/*globals console:true*/
(function (global) {

    "use strict";

    var loadedModules = {
            // some dependencies are always ready
            "require": "complete",
            "exports": "complete",
            "module": "complete"
        },
        dynamicModules = {},
        definedModules = [],
        execedModules = [],
        modules = {},
        localRequires = {},
        globalRequire,
        exportsRegistry = {},
        LOCAL_REQUIRE = "require",
        EXPORTS = "exports",
        MODULE = "module",
        anonyModuleCounter = 0,
        requireCounter = 0,
        ANONY_MODULE_ID_PREFIX = "__anony-module-",
        REQUIRE_ID_PREFIX = "__require-",
        loadingObjList = {},
        isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined",
        isWebWorker = !isBrowser && typeof importScripts !== "undefined",
        head = isWebWorker ? null : document.getElementsByTagName("head")[0],
        checkProgressInterval = 100,
        jsSuffixRegExp = /\.js$/,
        externalRegExp = /^(\/\/)|([^:]+:\/\/)/,
        docRootRegExp = /^\/[^\/]+/,
        readyRegExp = navigator.platform === "PLAYSTATION 3" ? /^complete$/ : /^(complete|loaded)$/,
        // utils stuff
        op = Object.prototype,
        hasOwn = op.hasOwnProperty,
        ostring = op.toString,
        ap = Array.prototype,
        binder = {},
        // configs
        _config = {},
        baseUrl = "./",
        paths = {},
        pathsKeys = [],
        waitInterval = 10000;

    /**
     * Method to pass configuration to AMD module loader.
     * Any existing path will be overridden by new setting.
     * @method
     * @memberof module:amd
     * @param {Object} opts the config object
     * @param {String} [opts.baseUrl] The default base url to load scripts. All scripts will be loaded relative
     * @param {Number} [opts.waitSeconds] The number of seconds to wait before giving up on loading a script. The default is 10.
     * @param {Object} [opts.paths] Path mappings for module names not found directly under baseUrl.
     */
    function config(opts) {
        var key;

        opts = opts || {};
        extendObj(_config, opts, true);

        baseUrl = opts.baseUrl || baseUrl;
        if (!endsWith(baseUrl, "/")) {
            baseUrl += "/";
        }

        // paths = opts.paths || paths;
        if (opts.paths) {
            extendObj(paths, opts.paths, true);

            pathsKeys = [];
            for (key in paths) {
                pathsKeys.push(key);
            }
            pathsKeys.sort().reverse();
        }

        waitInterval = (opts.waitSeconds || 10) * 1000;
    }

    function startsWith(string, prefix) {
        return string.indexOf(prefix) === 0;
    }

    function endsWith(string, suffix) {
        return string.indexOf(suffix, string.length - suffix.length) !== -1;
    }

    /**
     * Check if an object/array contains the specific item.
     * @method
     * @private
     * @param {Object|Array} collection the collection to search
     * @param {Mixed} item the item to search for
     * @returns {Boolean} true if the collection contains the item, false otherwise
     * @memberof module:amd
     */

    function contains(collection, item) {
        if (isArray(collection)) {
            return collection.indexOf(item) !== -1;
        }
        return hasOwn.call(collection, item);
    }

    function isFunction(it) {
        return ostring.call(it) === "[object Function]";
    }

    function isArray(it) {
        return ostring.call(it) === "[object Array]";
    }

    function isObject(it) {
        return ostring.call(it) === "[object Object]";
    }

    function isString(it) {
        return typeof it === "string";
    }

    /**
     * Bind a function (func) to a context.
     * If used directly on the function and extending function is allowed, first argument can be omited.
     * @method
     * @private
     * @param {Function} func to extend (if function extending allowed, this is to be omited)
     * @param {Object} context The context to bind to
     * @param {Object} third or extra arguments will be passed as an input parameter to the Function func binded.
     * @return {Function} Wraped function where execution is guaranteed in the given context
     * @memberof module:amd~binder
     */
    binder.bind = function (func, context) {
        var __method = func,
            args = Array.prototype.slice.call(arguments, 2);
        return function () {
            var a = args.concat(arguments);
            return __method.apply(context, a);
        };
    };

    /**
     * Extends the dest object with the properties in src object.
     * For each property in src, it will be copied to dest if dest has no such property.
     * If dest or src is not an object, then do nothing.
     * @method
     * @private
     * @param {Object} dest the object to extend
     * @param {Object} src the object to extend from
     * @param {Boolean} [force] enforce the copy operation even if the dest has the corresponding property
     * @memberof module:amd
     */
    function extendObj(dest, src, force) {
        if (!isObject(dest) || !isObject(src)) {
            return;
        }

        var prop;
        for (prop in src) {
            if (isObject(src[prop])) {
                dest[prop] = extendObj(dest[prop] || {}, src[prop], force);
            } else if (force || !contains(dest, prop)) {
                dest[prop] = src[prop];
            }
        }

        return dest;
    }

    /**
     * Resolve the module id with the paths given in the configuration by substitution.
     * If the module id matches the paths' value, the match will be replaced by the corresponding path key.
     * @method
     * @private
     * @param {String} moduleId the module id
     * @returns {String} the resolved module id
     * @memberof module:amd
     */

    function lookupModuleId(moduleId) {
        var subKey, subPath = "",
            pathKey;
        for (pathKey in paths) {
            if (startsWith(moduleId, paths[pathKey]) && paths[pathKey].length > subPath.length) {
                subKey = pathKey;
                subPath = paths[pathKey];
            }
        }

        if (subPath !== "") {
            moduleId = moduleId.replace(subPath, subKey);
        }

        return moduleId;
    }

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @method
     * @private
     * @param {Array} array the array of path segments
     * @memberof module:amd
     * @example
     *     trimDots([".", "this", "..", "is", ".", "a", "path"]); // becomes ["is", "a", "path"]
     *     trimDots(["..", "this", "..", "is", ".", "another", "path"]); // becomes ["..", "is", "another", "path"]
     */

    function trimDots(array) {
        var i, part, length = array.length;
        for (i = 0; i < length; i++) {
            part = array[i];
            if (part === ".") {
                array.splice(i, 1);
                i -= 1;
            } else if (part === "..") {
                if (i === 1 && (array[2] === ".." || array[0] === "..")) {
                    // end of the line.
                    // Keep at least one non-dot path segment at the front so it can be mapped correctly to disk. 
                    // Otherwise, there is likely no path mapping for a path starting with '..'.
                    // This can still fail, but catches the most reasonable uses of ..
                    break;
                } else if (i > 0) {
                    array.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    /**
     * @ignore
     */

    function getLoadObjsByDependency(moduleId) {
        var deps, i, loadObjId, loadObjs = [];
        for (loadObjId in loadingObjList) {
            if (loadingObjList.hasOwnProperty(loadObjId)) {
                // anonymous module should only be referenced by the function created it
                if (isAnonymous(loadObjId)) {
                    continue;
                }

                deps = loadingObjList[loadObjId].dependencies;
                i = deps.length;

                while (i--) {
                    if (deps[i] === moduleId) {
                        loadObjs.push(loadingObjList[loadObjId]);
                        break;
                    }
                }
            }
        }

        return loadObjs;
    }

    /**
     * Get the anonymous id for a module loading.
     *
     * @method
     * @private
     * @returns {String} the id
     * @memberof module:amd
     */
    function getAnonyId() {
        // this is a dummy id to reference while the dependencies are loaded
        return ANONY_MODULE_ID_PREFIX + anonyModuleCounter++;
    }

    /**
     * Get an id for a require().
     *
     * @method
     * @private
     * @returns {String} the id
     * @memberof module:amd
     */
    function getRequireId() {
        // this is a dummy id to reference while the dependencies are loaded
        return REQUIRE_ID_PREFIX + requireCounter++;
    }

    /**
     * Checks if a module is anonymous using its id.
     *
     * @method
     * @private
     * @param {String} moduleId The id of the module
     * @returns {Boolean} True if the module is anonymous, false otherwise
     * @memberof module:amd
     */
    function isAnonymous(moduleId) {
        return moduleId.indexOf(ANONY_MODULE_ID_PREFIX) === 0;
    }

    /**
     * Check if the moduleId is specified as CommonJS component.
     * NOTE: This function will modify the _depModules_
     *
     * @method
     * @private
     * @param {String} moduleId the module id
     * @memberof module:amd
     */
    function isCommonJSComponents(moduleId) {
        return moduleId === LOCAL_REQUIRE || moduleId === EXPORTS || moduleId === MODULE;
    }

    /**
     * Import the objects specified by CommonJS spec to the dependent (if applicable).
     * NOTE: This function will modify _loadingObj.depModules_
     *
     * @method
     * @private
     * @param {String} moduleId the module id
     * @param {String} dep the id of the dependency
     * @param {Object} loadingObj The loading object of a module
     * @returns {Boolean} True if component is added, false otherwise
     * @memberof module:amd
     */
    function importCommonJSComponents(moduleId, dep, loadingObj) {
        var depModule;

        if (dep === LOCAL_REQUIRE) {
            // if the loading module is anonymous (not from define()), provide the global require
            if (isAnonymous(moduleId)) {
                depModule = globalRequire;
            } else {
                depModule = localRequires[moduleId];
            }
        } else if (dep === EXPORTS) {
            depModule = getExports(moduleId);
        } else if (dep === MODULE) {
            depModule = {
                id: moduleId
            };
        } else {
            return false;
        }

        loadingObj.depModules[loadingObj.dependencies.indexOf(dep)] = depModule;
        return true;
    }

    /**
     * Checks if the loading of a module has timed out.
     *
     * @method
     * @private
     * @param {Object} loadingObj The loading object
     * @returns {Boolean} True if timed out, false otherwise
     * @memberof module:amd
     */
    function hasLoadingTimedOut(loadingObj) {
        return new Date().getTime() > loadingObj.timeLimit;
    }

    /**
     * Checks the scrip download progress.
     * This method invokes the factory of the module loading when the module is loaded.
     * Similarly, the onFailure will be invoked (or an error will be thrown) when the module loading time out.
     *
     * This method will periodcally repeat itself until the module is either loaded or the loading time out.
     *
     * @method
     * @private
     * @param {String} moduleId The id of the module to check
     * @memberof module:amd
     */
    function checkLoadingProgress(moduleId) {
        var loadingObj = loadingObjList[moduleId],
            deps, i, dep;

        if (!loadingObjList[moduleId]) {
            // module is not loading
            return;
        }

        deps = loadingObj.dependencies;

        if (contains(modules, moduleId)) {
            // module is already loaded
            return;
        }

        if (hasLoadingTimedOut(loadingObj)) {
            if (isFunction(loadingObj.onFailure)) {
                loadingObj.onFailure(new Error("Required dependencies cannot be loaded for module " + moduleId +
                    " wait timeout reached!"));
                return;
            } else {
                var timedOutModules = [];
                i = deps.length;
                while (i--) {
                    dep = deps[i];

                    if (!jsSuffixRegExp.test(dep) && loadedModules[dep] === "complete" && !contains(modules, dep)) {
                        timedOutModules.push(dep);
                    } else if (jsSuffixRegExp.test(dep) && loadedModules[dep] !== "complete") {
                        timedOutModules.push(dep);
                    }
                }
                throw new Error("Required dependencies cannot be loaded for module " + moduleId +
                    " wait timeout reached! Possibliy one of the following: " + timedOutModules.join(","));
            }
        }

        var checkAgainLater = function () {
            setTimeout(function () {
                checkLoadingProgress(moduleId);
            }, checkProgressInterval);
        };

        i = deps.length;
        while (i--) {
            dep = deps[i];

            //if it is error, it will notify when onScriptError and no need to check Progress. So stop and do nothing
            if (loadedModules[dep] === "error") {
                delete loadingObjList[moduleId];
                return;
            }

            if (jsSuffixRegExp.test(dep)) { // JS files
                if (loadedModules[dep] !== "complete") { // not ready
                    checkAgainLater();
                    return;
                }
                continue; // it is ready
            }

            // dependency module not ready
            if (!contains(modules, dep)) {
                // import the CommonJS components (require, exports, module) if any is required
                if (importCommonJSComponents(moduleId, dep, loadingObj)) {
                    continue;
                }

                checkAgainLater();
                return;
            }

            // module was not loaded at last check
            if (loadingObj.depModules[i] === undefined) {
                // loaded plugin resource will be injected by loadResourceUsingPlugin()
                if (dep.indexOf("!") >= 0) {
                    // reaching here means the resource is not loaded yet,  cannot proceed
                    checkAgainLater();
                    return;
                }

                // inject non-plugin resource
                loadingObj.depModules[i] = modules[dep];
            }
        }

        loadingObj.onSuccess(loadingObj.depModules);
        notifyReady(moduleId);
    }

    /**
     * Method to handle when script is loaded
     * @method completeLoad
     * @memberof module:amd
     * @param {String} moduleId
     */
    function completeLoad(moduleId) {
        loadedModules[moduleId] = "complete";
        notifyReady(moduleId);
    }

    /**
     * Notifies that the module is ready, so that they can resume processing.
     * Ready here means all of its dependencies have been loaded, and the factory can be/ has been executed.
     *
     * @method
     * @private
     * @param {String} moduleId The id of the module
     * @memberof module:amd
     */
    function notifyReady(moduleId) {
        if (jsSuffixRegExp.test(moduleId)) {
            // this is just a js file, so nothing to do
            return;
        }

        var loadObjs = getLoadObjsByDependency(moduleId),
            j = loadObjs.length,
            loadObj, deps, dep, i, fullyLoaded;

        // get the absolute module id by looking up the paths config
        moduleId = lookupModuleId(moduleId);

        while (j--) {
            loadObj = loadObjs[j];

            // some modules may be waiting to start in different "thread"
            // don't process those modules to avoid duplicate execution
            if (!loadObj.started) {
                continue;
            }

            deps = loadObj.dependencies;
            i = deps.length;
            fullyLoaded = true;

            // check if all dependencies of the loadObj has loaded
            while (i--) {
                dep = deps[i];

                // ignore *.js file
                if (jsSuffixRegExp.test(dep)) {
                    continue;
                }

                if (loadedModules[dep] !== "complete") {
                    fullyLoaded = false;
                    break;
                }
            }

            if (fullyLoaded) {
                // force an update on the parent
                checkLoadingProgress(loadObj.moduleId);
            }
        }
    }

    function onScriptSuccess(moduleId) {
        // if definedModules does not contain the loaded script, then it is either an ordinary script or anonymous module
        if (!contains(definedModules, moduleId)) {
            var processed = false;
            var lastIndex = definedModules.length - 1;

            if (lastIndex >= 0 && isAnonymous(definedModules[lastIndex])) {
                var lastDefinedModuleId = definedModules[lastIndex];
                var loadingObj = loadingObjList[lastDefinedModuleId];

                // anonymous
                if (loadingObj) {
                    // create a reference for the real module
                    // the anonymous loading object isn't deleted as it is still referenced by other function
                    loadingObjList[moduleId] = loadingObj;
                    // replace the anonymous id with the real module id
                    loadingObj.moduleId = moduleId;
                    definedModules.pop();
                    definedModules.push(moduleId);
                    // update the base of the module
                    loadingObj.base = moduleId;

                    processed = true;
                }
            }

            // ordinary script
            if (!processed) {
                modules[moduleId] = {};
            }
        }

        completeLoad(moduleId);
    }

    function onScriptError(path, msg, url, line) {
        var errMsg, moduleId, loadObjs, loadObj, len;

        errMsg = "Error loading module or script \'" + path + "\": " + msg + ", at line:" + line + " URL:" + url;
        if (typeof (console) !== "undefined") {
            console.error(errMsg);
        }

        // get the absolute module id by looking up the paths config
        moduleId = lookupModuleId(path);

        loadedModules[moduleId] = "error";

        loadObjs = getLoadObjsByDependency(moduleId);
        len = loadObjs.length;

        while (len--) {
            loadObj = loadObjs[len];

            //to notify the onFailure directly
            if (isFunction(loadObj.onFailure)) {
                loadObj.onFailure(new Error("Required dependencies cannot be loaded for module " + moduleId + " wait timeout reached!"));
            }
        }
    }

    /**
     * Method to load the module
     * @method
     * @memberof module:amd
     * @param {String} moduleId the module id
     */
    function load(moduleId) {
        var actualPath = resolvePath(moduleId);

        if (isWebWorker) {
            try {
                /* global importScripts: true */
                importScripts(actualPath);
                /* global importScripts: false */
                onScriptSuccess(moduleId);
            } catch (ex) {
                var srcMatches = ex.stack.match(/(http:|https:).+\.\w+/gi);
                var lineMatches = ex.stack.match(/\d+:\d+/g);

                onScriptError(moduleId, ex.message, srcMatches[srcMatches.length - 1], lineMatches[lineMatches.length - 1]);
            }

            return;
        }

        /**
         * @ignore
         */
        var node = document.createElement("script");
        node.type = "text/javascript";
        node.charset = "utf-8";
        node.async = true;

        node.onreadystatechange = node.onload = function () {
            if (!node.readyState || readyRegExp.test(node.readyState)) {
                node.onload = node.onreadystatechange = null;
                node.onerror = null;

                onScriptSuccess(moduleId);
            }
        };

        node.onerror = function (msg, url, line) {
            node.onload = node.onreadystatechange = null;
            node.onerror = null;

            onScriptError(moduleId, msg, url, line);
        };

        node.src = actualPath;
        head.appendChild(node);
    }

    /**
     * Method to pass from the path into actual path
     * @method
     * @memberof module:amd
     * @param {String} path the module path
     * @param {String} return the resolved actual path of the js
     */

    function resolvePath(path) {
        var actualPath;
        if (jsSuffixRegExp.test(path)) { // simply load the js file as it is
            return path;
        }

        actualPath = resolveModulePath(path);

        return actualPath + ".js";
    }

    /**
     * Resolve the given module id to the actual path which relative to the base url.
     * Any external resource will be returned as is.
     * @method
     * @private
     * @param {String} moduleId a normalized module id
     * @returns {String} the actual path (relative to the base url) of the module refered by the given module id
     * @memberof module:amd
     */

    function resolveModulePath(moduleId) {
        // test if the module id represents an external resource
        if (externalRegExp.test(moduleId)) {
            // return the extenal module id as is
            return moduleId;
        }

        var actualPath = moduleId,
            i, key;

        for (i in pathsKeys) {
            key = pathsKeys[i];
            if (!startsWith(actualPath, key)) {
                continue;
            }

            actualPath = actualPath.replace(key, paths[key]);
            break;
        }

        // prepend baseUrl only if the actual path does not start from the document root
        if (!docRootRegExp.test(actualPath) && !externalRegExp.test(actualPath)) {
            actualPath = baseUrl + actualPath;
        }

        return actualPath;
    }

    /**
     * Parse the resource id to report any plugin requirement.
     * @method
     * @private
     * @param {String} resourceId The resource id
     * @returns {Object} the parsed object containing
     *  * {String} plugin The required plugin's id, or '' if none is required
     *  * {String} moduleId The actual required module's id (remain in relative if it was)
     * @memberof module:amd
     */

    function parsePlugin(resourceId) {
        var idIndex, pluginId = "",
            moduleId = resourceId;

        idIndex = resourceId.indexOf("!");

        if (idIndex > -1) {
            pluginId = resourceId.substring(0, idIndex);
            moduleId = resourceId.substring(idIndex + 1, resourceId.length);
        }

        return {
            plugin: pluginId,
            moduleId: moduleId
        };
    }

    /**
     * Check if module should is dynamic. i.e. reload every time
     * @method
     * @private
     * @param {String} pluginId The id of the required plugin
     * @param {String} resourceId The id of the required module
     * @param {Object} require The local require object for path normalization
     * @memberof module:amd
     */

    function isModuleDynamic(moduleId) {
        return dynamicModules[moduleId];
    }

    /**
     * Load a resource using a specific plugin.
     * @method
     * @private
     * @param {String} pluginId The id of the required plugin
     * @param {String} resourceId The id of the required module
     * @param {Object} require The local require object for path normalization
     * @param {Object} loadingObj The loading object of a module
     * @memberof module:amd
     */
    function loadResourceUsingPlugin(pluginId, resourceId, require, loadingObj) {
        var fullModuleId = pluginId + "!" + resourceId,
            plugin = getExecModule(pluginId);

        // load the module if it has not loaded yet
        if (plugin.dynamic || !loadedModules[resourceId]) {
            // mark the [pluginId]![resourceId] as loading
            loadedModules[fullModuleId] = "loading";

            if (plugin.dynamic) {
                dynamicModules[fullModuleId] = plugin.dynamic;
            }

            // load the module once the plugin is ready
            plugin.load(resourceId, require, function (resource) {
                modules[fullModuleId] = resource;
                loadingObj.depModules[loadingObj.dependencies.indexOf(fullModuleId)] = resource;
                completeLoad(fullModuleId);
            }, extendObj({
                onFailure: function () {
                    //the plugin file is fail to load and then simulate the onscript error once
                    if (loadedModules[fullModuleId] !== "error") {
                        onScriptError(fullModuleId, "Fail to load the resource " + fullModuleId);
                    }
                }
            }, _config));
        }
    }

    /**
     * Normalize a relative module id to a real module id that can be mapped to a path.
     * @method
     * @param {String} id the relative module id
     * @param {String} baseId a real module id that the id arg is relative to
     * @returns {String} normalized module id
     * @memberof module:amd
     */
    function normalize(id, baseId) {
        var baseParts = baseId && baseId.split("/"),
            normalizedBaseParts,
            idComps,
            lastIndex;

        // normalize only if the given id is a relative id
        if (id && id.charAt(0) === ".") {
            if (baseId) {
                // Convert baseId to array, and lop off the last part,
                // so that . matches that 'directory' and not id of the baseId's module. 
                // For instance, baseId of 'one/two/three', maps to 'one/two/three.js', 
                // but we want the directory, 'one/two' for this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                idComps = id.split("/");
                lastIndex = idComps.length - 1;

                // if wanting node ID compatibility, strip .js from end of IDs.
                if (config.nodeIdCompat && jsSuffixRegExp.test(idComps[lastIndex])) {
                    idComps[lastIndex] = idComps[lastIndex].replace(jsSuffixRegExp, "");
                }

                idComps = normalizedBaseParts.concat(idComps);
                trimDots(idComps);
                id = idComps.join("/");
            } else if (id.indexOf("./") === 0) {
                // no baseId, so the id is resolved relative to baseUrl
                // remove the leading dot
                id = id.substring(2);
            }
        }

        return id;
    }

    /**
     * Actual function to load modules, using the loading object created by other function.
     * This function executes asynchronously.
     * @method
     * @private
     * @param {Object} loadObj the loading object which stores the information about the loading request
     * @param {String} loadObj.moduleId the id of the module which invoke this loading operation
     * @param {String[]} loadObj.dependencies the modules to be loaded
     * @param {Function} loadObj.onSuccess success callback to be called when all dependencies are loaded
     * @param {Function} loadObj.onFailure failure callback to be called if some dependencies cannot be loaded
     */

    function loadModules(loadObj) {
        var moduleId = loadObj.moduleId,
            deps = loadObj.dependencies,
            dep, i, len, defined, hasWork, prop;

        loadObj.timeLimit = new Date().getTime() + waitInterval;

        len = deps.length;
        for (i = 0; i < len; i++) {
            dep = deps[i];
            defined = false;

            if (dep === LOCAL_REQUIRE) {
                loadObj.depModules[i] = localRequires[moduleId];
                continue;
            }

            // already loaded and is not a plugin resource
            if (contains(modules, dep) && dep.indexOf("!") < 0) {
                loadObj.depModules[i] = modules[dep];
                continue;
            }

            // (?) no need to wait until the loading module finished?
            for (prop in loadingObjList) {
                // if the dependency is already defined
                if (loadingObjList[prop].moduleId === dep) {
                    defined = true;
                    hasWork = true;
                    break;
                }
            }

            // skip calling load because it's already defined
            if (defined) {
                continue;
            }

            if (jsSuffixRegExp.test(dep) && loadedModules[dep] === "complete") {
                // js file already loaded
                continue;
            } else if (loadedModules[dep] === "loading" || loadedModules[dep] === "complete") {
                // there is dep loading, need to wait
                hasWork = true;
                continue;
            } else if (parsePlugin(dep).plugin) {
                hasWork = true;

                // the loader plugin will do the work, do not load the resource here
                continue;
            }

            hasWork = true;

            loadedModules[dep] = "loading";
            global.amd.load(dep);
        }

        if (hasWork) {
            checkLoadingProgress(moduleId);
        } else {
            loadObj.onSuccess(loadObj.depModules);
        }
    }

    /**
     * Execute a factory to retrieve the actual module.
     * This is used for the lazy loading mechanism of amd.
     * If the factory has already been executed before, it will be returned directly.
     *
     * @method
     * @private
     * @param {String} moduleId The module id
     * @param {Function|Object} factory The factory of a module under AMD spec.
     * @returns {Object} the actual module
     * @memberof module:amd
     */
    function executeFactoryIfNeeded(moduleId, factory) {
        var ret = factory;

        // run the factory if it's an internal wrapper
        if (isFunction(factory)) {
            // It is possible that a factory uses the local require in a synchronous way.
            // This would be problematic while circular dependency occurs.
            // The factory will be executed more than once in such condition, and it is not easy to catch.
            // See XDK-2538.
            if (factory.__isExecuting) {
                throw new Error("The module factory is executed while it is being executed. This is probably caused by circular dependency.");
            }

            if (factory.__isInternalWrapper) {
                // use the global amd function to allow extension
                ret = global.amd.executeFactory(moduleId, factory);
            }
        }

        return ret;
    }

    /**
     * Execute a factory function of an AMD module.
     * This could be a hooking point for project customization.
     *
     * @method
     * @param {String} moduleId The module id
     * @param {Function} factory The factory function
     * @returns {Object} The actual module
     * @memberof module:amd
     */
    function executeFactory(moduleId, factory) {
        return factory();
    }

    /**
     * Exec a defined module, to lazy trigger the factory method when the module had been required
     * @method
     * @param {String} moduleId The module id
     * @param {Function|Object} loadedModule The module or the factory of the module
     * @private
     */
    function getExecModule(moduleId, loadedModule) {
        var _module;

        if (isModuleDynamic(moduleId) || isCommonJSComponents(moduleId)) {
            _module = executeFactoryIfNeeded(moduleId, loadedModule);
            return _module;
        }


        if (contains(execedModules, moduleId)) {
            _module = modules[moduleId];
            // the module is executing because of the circular dependency
            if (_module.__isInternalWrapper) {
                return undefined;
            }

            return _module;
        }

        _module = loadedModule || modules[moduleId];

        // circular dependency issues
        // When trying to get ExecModule and it is undefined from the list or loadedModule, it will consider to be a cirucular dependency   
        // which it should not be executed and assigned to module list object.
        // If it is an export object or undefined which only export after getting all the executed modules.
        // Otherwise it will load an undefined into the object list and affect the other item in the cirular dependency.
        if (_module === undefined) {
            return undefined;
        }

        modules[moduleId] = executeFactoryIfNeeded(moduleId, _module);
        // declare the module(factory) has been executed
        execedModules.push(moduleId);

        return modules[moduleId];
    }

    /**
     * Exec the defined module, to lazy trigger the factory method when the module had been required
     * @method
     * @param {String[]} modulesIds moduleIds
     * @param {Function[]} loadedModules loaded and defined modules' factory methods from the call stack
     * @private
     */
    function getExecModules(moduleIds, loadedModules) {

        var i, len, _module, moduleId, ret = [];

        for (i = 0, len = moduleIds.length; i < len; i++) {

            moduleId = moduleIds[i];

            if (moduleId === LOCAL_REQUIRE || moduleId === EXPORTS) {
                _module = loadedModules[i];
            } else {
                _module = getExecModule(moduleId, loadedModules[i]);
            }

            ret.push(_module);
        }

        return ret;

    }

    /**
     * Build a self-contained factory function, such that it can be easily invoked by any function.
     * This could be a hooking point for extension.
     *
     * @method
     * @param {String} moduleId The module id
     * @param {Function|Object} factory The original factory defined
     * @param {String[]} [depIds] List of the id of the dependencies of the module
     * @param {Object[]} [depModules] The dependency modules for the factory
     * @returns {Function|Object} The processed factory, or the module itself if no factory is needed.
     * @memberof module:amd
     */
    function buildFactory(moduleId, factory, depIds, depModules) {
        // factory is not a function, but the module itself
        if (!isFunction(factory)) {
            return factory;
        }

        var factoryWrapper = function () {
            factoryWrapper.__isExecuting = true;
            var executedModules = getExecModules(depIds, depModules);
            var _module = factory.apply(global, executedModules);

            if (_module === undefined) {
                _module = getExports(moduleId);
            }

            return _module;
        };

        factoryWrapper.__isInternalWrapper = true;

        return factoryWrapper;
    }

    /**
     * Defines a module. Also accessible from global scope.
     * @method
     * @param {String} moduleId Module identifier
     * @param {Array} [dependencies] Array of dependencies, in strings
     * @param {Function} factory module factory function or module object.
     * @param {Function} [onFailure] failure callback when package loading is unsuccessful.
     * All dependencies will passed as arguements into this factory method.
     * @memberOf module:amd
     * @example
     * define("app/myModule", ["xdk-base/util"], function(util){
     *     var myModule = ...;
     *     ...
     *     util.each(...);
     *     ...
     *     return myModule;
     * });
     */

    function define() {
        var args = ap.slice.call(arguments),
            moduleId, deps, factory, onSuccess, onFailure;

        if (isString(args[0])) {
            moduleId = args.shift();

            //to avoid duplicate module load
            if (loadedModules[moduleId] === "complete") {
                //since some platform has no console
                if (typeof (console) !== "undefined") {
                    console.warn("### Unable to load the multiple module that module is loaded more than once: " + moduleId);
                }
                return;
            }

        } else {
            // apply a temporary id, which will be resolved after node.onload
            moduleId = getAnonyId();
        }

        if (isArray(args[0])) {
            deps = args.shift();
        } else {
            deps = [LOCAL_REQUIRE, EXPORTS, MODULE];
        }

        factory = args.shift();

        onFailure = args.shift();

        // define(moduleId, ..) has been called
        definedModules.push(moduleId);

        // Usually a module starts loading when it is required by another module.
        // But it may happen that the module is defined without `require` (e.g optimized module that has several `define` in a file).
        // In such cases if the module is required by another module, amd will try to load it using the `paths`.
        // This is not intended, and may cause problems.
        // Declare the module is loaded if it didn't go through the `require` process.
        if (!loadedModules[moduleId] && !isAnonymous(moduleId)) {
            loadedModules[moduleId] = "complete";
        }

        localRequires[moduleId] = generateRequire(moduleId);

        onSuccess = function (loadedDepModules, actualModuleId) {
            modules[actualModuleId] = global.amd.buildFactory(actualModuleId, factory, deps, loadedDepModules);
        };

        return requireModules(moduleId, deps, moduleId, onSuccess, onFailure);
    }

    /**
     * Removes a module from registery.
     * Please note that, the module will remain in memory if there is still reference to this module anywhere else.
     * @method
     * @param {String} moduleId the target module's ID
     * @memberOf module:amd
     */

    function undefine(moduleId) {
        if (!moduleId) {
            return;
        }

        delete modules[moduleId];
    }

    /**
     * Load a list of required modules asynchronously, then execute the success callback.
     * This function will try to resolve the dependencies based on the location _base_.
     * This works for actual id and relative id.
     * @method
     * @private
     * @param {String[]} deps a list of dependencies, could be actual or relative
     * @param {String} base the directory to reference while relative id is given
     * @param {Function} onSuccess the callback to execute when all dependencies are loaded
     * @param {Function} onFailure the callback to execute if some of the dependencies cannot be loaded (timeout)
     * @memberOf module:amd
     */
    function requireModules(moduleId, deps, base, onSuccess, onFailure) {
        var onSuccessWrapper, loadObj;
        var depModules = [];

        if (!isArray(deps)) {
            deps = [];
        }

        if (deps.length > 0) {
            depModules[deps.length - 1] = undefined;
        }

        onSuccessWrapper = function (deps) {
            var actualModuleId = loadingObjList[moduleId].moduleId;

            try {
                onSuccess(deps, actualModuleId);
            } catch (ex) {
                // error occurs while executing the factory
                loadedModules[actualModuleId] = "error";

                if (isFunction(_config.onError)) {
                    _config.onError(actualModuleId, ex);
                } else if (typeof (console) !== "undefined") {
                    if (ex.stack) {
                        console.error(ex.stack);
                    }
                    console.error("### Unable to prepare module " + actualModuleId + ".\n\tError: " + ex);
                }
            }

            // delete both the named and anonymous object (if any)
            delete loadingObjList[moduleId];
            delete loadingObjList[actualModuleId];
        };

        loadObj = {
            base: base,
            moduleId: moduleId,
            onSuccess: onSuccessWrapper,
            onFailure: onFailure,
            dependencies: deps,
            depModules: depModules
        };

        loadingObjList[moduleId] = loadObj;

        var doLoadModules = function () {
            localRequires[loadObj.moduleId] = generateRequire(loadObj.moduleId);
            loadObj.started = true;

            if (prepareContext(loadObj)) {
                loadModules(loadObj);
            }
        };

        if (isAnonymous(moduleId)) {
            // queue until node.onload update the module id in the loading object
            // the callback there will update the module id and the resolution base
            setTimeout(function () {
                doLoadModules();
            }, 1);
        } else {
            doLoadModules();
        }
    }

    /**
     * Prepares the context of the module loading object.
     * This method loads the plugin and plugin resource as well.
     *
     * @method
     * @private
     * @param {Object} loadingObj The loading object of the module
     * @returns {Boolean} True if the context is ready and can progress, false if the context cannot be prepared yet
     * @memberof module:amd
     */
    function prepareContext(loadingObj) {
        var base = loadingObj.base;
        var deps = loadingObj.dependencies;

        // check for existence of plugin dependencies
        for (var i = 0, len = deps.length; i < len; i++) {
            var dep = deps[i];
            var parts = parsePlugin(dep);

            if (parts.plugin) {
                // normalize the plugin id, then update the dep
                var absPluginId = lookupModuleId(normalize(parts.plugin, base));
                var req = getLocalRequire(base);

                // load resource if plugin has already loaded
                if (contains(modules, absPluginId)) {
                    var plugin = getExecModule(absPluginId);
                    var absModuleId, fullModuleId;

                    if (isFunction(plugin.normalize)) {
                        absModuleId = plugin.normalize(parts.moduleId, generateNormalize(base));
                    } else {
                        absModuleId = lookupModuleId(normalize(parts.moduleId, base));
                    }

                    fullModuleId = absPluginId + "!" + absModuleId;
                    deps[i] = dep = fullModuleId;

                    // only load resource if 
                    // 1. it is not loaded, or
                    // 2. resource caching is forbidden
                    if (!modules[fullModuleId] || plugin.dynamic) {
                        loadResourceUsingPlugin(absPluginId, absModuleId, req, loadingObj);
                    } else {
                        loadingObj.depModules[i] = modules[fullModuleId];
                    }
                } else {
                    // load the plugin first, then replay the request
                    req([absPluginId], binder.bind(requireModules, null, loadingObj.moduleId, deps, base, loadingObj.onSuccess, loadingObj.onFailure));
                    return false;
                }
            } else {
                // normalize the dependency (from relative to absolute) and lookup its path (match with paths)
                // (e.g. './lib/A' -> 'lib/A' -> 'A')
                deps[i] = lookupModuleId(normalize(dep, base));
            }
        }

        return true;
    }

    /**
     * Returns the local require of the module.
     * If the module id is not specified or is anonymous, then assume it is global.
     *
     * @method
     * @private
     * @param {String} moduleId The id of the module
     * @returns {Function} The local require function of the module
     * @memberof module:amd
     */
    function getLocalRequire(moduleId) {
        // a global require() call
        if (!moduleId || isAnonymous(moduleId)) {
            return globalRequire;
        }

        // an anonymous define() or require()
        if (!localRequires[moduleId]) {
            localRequires[moduleId] = generateRequire(moduleId);
        }

        return localRequires[moduleId];
    }

    /**
     * Resolves the relative module id (may contains plugin) to absolute id.
     *
     * @method
     * @private
     * @param {String} moduleId The id of the module
     * @returns {String} The absolute module id
     * @throws {Error} If the module cannot be resolved. This will happen if a plugin resource id is resolved before the plugin is loaded.
     * @memberof module:amd
     */
    function resolveModuleId(moduleId, base) {
        var parts = parsePlugin(moduleId);

        // no plugin is involved, resolve the id directly
        if (!parts.plugin) {
            return lookupModuleId(normalize(moduleId, base));
        }

        var absPluginId = lookupModuleId(normalize(parts.plugin, base));

        // resource id cannot be resolved if the plugin hasn't loaded
        if (!contains(modules, absPluginId)) {
            throw new Error("Cannot resolve resource id: plugin is not loaded.");
        }

        var plugin = getExecModule(absPluginId);
        var absModuleId;

        // normalize() is defined in the plugin, use it to resolve the resource id
        if (isFunction(plugin.normalize)) {
            absModuleId = plugin.normalize(parts.moduleId, generateNormalize(base));
        } else {
            absModuleId = lookupModuleId(normalize(parts.moduleId, base));
        }

        return absPluginId + "!" + absModuleId;
    }

    /**
     * Generate a require object according to the base path given.
     * If the base is defined, then this will be a local require. Otherwise, this will be a global require.
     * @method
     * @private
     * @param {String} [base] the base path to reference from
     * @returns {Object} a require object referenced to the corresponding path
     * @memberOf module:amd
     */

    function generateRequire(base) {
        /**
         * Loads several dependencies, then fire the onSuccess or onFailure parameter.
         * @method
         * @memberOf module:amd
         * @param {Object} deps the dependencies to load
         * @param {String} [factory] Success callback function, all dependencies will passed as arguments into this method.
         * @param {Object} [onFailure] Failure callback function.
         */
        var require = function (deps, factory, onFailure) {
            var strParams = [],
                len = arguments.length,
                onSuccess, i, absModuleId, _module;

            // require(String)
            // synchronously return the module represented by the module id
            if (isString(deps)) {
                absModuleId = resolveModuleId(deps, base);

                if (!contains(modules, absModuleId)) {
                    throw new Error("### Module \'" + deps + "\" is not yet loaded!");
                }

                var parts = parsePlugin(absModuleId);
                var plugin;
                if (parts.plugin) {
                    plugin = getExecModule(parts.plugin);

                    if (plugin.dynamic) {
                        throw new Error("require(String) cannot load dynamic resources.");
                    }
                }

                _module = getExecModule(absModuleId);

                if (typeof _module === "undefined") {
                    throw new Error("### Module \'" + deps + "\" is not yet loaded!");
                }

                return _module;
            }

            if (len === 1 && isFunction(deps)) { // assume function(require, exports, module)
                factory = deps;
                deps = [LOCAL_REQUIRE, EXPORTS, MODULE];
            }

            if (isArray(deps) && isFunction(factory)) {
                // require(Array, Function)
                // load the required modules
                onSuccess = function (loadedDepModules) {
                    //execDefinedModules if not defined yet
                    var execedDeps = getExecModules(deps, loadedDepModules);
                    factory.apply(global, execedDeps);
                };

                return requireModules(getRequireId(), deps, base, onSuccess, onFailure);
            } else if (typeof base === "undefined" && isObject(deps) && arguments.length === 1) {
                // require(Object)
                // config amd
                config(deps);
            } else {
                // undefined

                for (i = 0; i < len; i++) {
                    strParams[i] = typeof arguments[i];
                }

                throw new Error("The requested usage of require(" + strParams.join(", ") + ") is undefined");
            }
        };

        /**
         * Converts a String that is of the form [module ID] + '.extension' to an URL path.
         * require.toUrl resolves the module ID part of the string
         * using its normal module ID-to-path resolution rules,
         * except it does not resolve to a path with a ".js" extension.
         * Then, the '.extension' part is then added to that resolved path.
         * @method
         * @param {String} moduleIdWithExt the module id to be resolved
         * @memberOf module:amd
         */
        require.toUrl = function (moduleIdWithExt) {
            var extension,
                pureModuleId = moduleIdWithExt,
                index = moduleIdWithExt.lastIndexOf("."),
                firstSegment = moduleIdWithExt.split("/")[0],
                isRelative = firstSegment === "." || firstSegment === "..";

            // have a file extension alias, and it is not the dots from a relative path
            if (index !== -1 && (!isRelative || index > 1)) {
                extension = moduleIdWithExt.substring(index, moduleIdWithExt.length);
                pureModuleId = moduleIdWithExt.substring(0, index);
            }

            var url = resolveModulePath(normalize(pureModuleId, base)) + (extension || "");
            var comps = url.split("/");
            if (comps[0] === ".") {
                comps = comps.slice(1);
                trimDots(comps);
                comps.splice(0, 0, ".");
            } else {
                trimDots(comps);
            }

            return comps.join("/");
        };

        return require;
    }

    function generateNormalize(base) {
        /**
         * Normalize a relative module id to a real module id that can be mapped to a path.
         * @method
         * @name normalize
         * @param {String} id the relative module id
         * @param {String} [baseId] the base directory to relative to. Override the default if provided.
         * @returns {String} normalized module id
         * @memberof module:amd
         */
        return function (id, baseId) {
            var baseParts,
                normalizedBaseParts,
                lastIndex;

            baseId = baseId || base;

            // normalize only if the given id is a relative id
            if (id && id.charAt(0) === ".") {
                if (baseId) {
                    baseParts = baseId && baseId.split("/");
                    // Convert baseId to array, and lop off the last part,
                    // so that . matches that 'directory' and not id of the baseId's module. 
                    // For instance, baseId of 'one/two/three', maps to 'one/two/three.js', 
                    // but we want the directory, 'one/two' for this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    id = id.split("/");
                    lastIndex = id.length - 1;

                    // if wanting node ID compatibility, strip .js from end of IDs.
                    if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                        name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                    }

                    id = normalizedBaseParts.concat(id);
                    trimDots(id);
                    id = id.join("/");
                } else if (id.indexOf("./") === 0) {
                    // no baseId, so the id is resolved relative to baseUrl
                    // remove the leading dot
                    id = id.substring(2);
                }
            }

            return id;
        };
    }

    function getExports(moduleId) {
        if (!exportsRegistry[moduleId]) {
            exportsRegistry[moduleId] = {};
        }

        return exportsRegistry[moduleId];
    }

    // define a global require object
    globalRequire = generateRequire();


    // load config if already exists
    if (global.amd && global.amd.config) {
        config(global.amd.config);
    }

    define.amd = {}; // indicate we are AMD loader

    // put things out into global
    globalRequire.config = config;

    if (!global.define) {
        global.define = define;
    }

    if (!global.undefine) {
        global.undefine = undefine;
    }

    // put to global only if it was not defined
    if (!global.require) {
        global.require = globalRequire;
    }

    /**
     * The module that contains AMD API and other non standard APIs.
     * This is accessible from global scope.
     *
     * NOTE: Unit test of this module is done using amdjs-tests (<https://github.com/amdjs/amdjs-tests>).
     *
     * Following is a list of supported features of this AMD implementation:
     *
     *  * both global & local require objects
     *      * require(String)
     *      * require(Array, Function)
     *      * require.toUrl(String)
     *      * relative module id resolve
     *  * anonymous module
     *  * loader plugin
     *  * web worker
     *
     * Following is a list of features this AMD implementation hasn't support yet:
     *
     *  * common js compactibility
     *
     * Following is a list of additional features provided by this implementation:
     *
     *     * global onError callback. It will be called when a module cannot be defined properly due to internal failure.
     *
     * @name amd
     * @module
     * @see {@link https://github.com/amdjs/amdjs-api/wiki|AMD specification}
     * @example
     * <caption>Using global onError callback</caption>
     * require({
     *     onError: function(moduleId, ex) {
     *         // custom handling
     *         console.log("Error loading " + moduleId, ex);
     *     }
     * });
     *
     * @example
     * <caption>Using web worker</caption>
     * <caption>Main.js</caption>
     * // create a worker in the main thread
     * var worker = new Worker('Worker.js');
     *
     * // register the message callback
     * worker.onmessage = function (evt) {
     *     console.log("Get update from the worker: " + evt.data);
     * };
     *
     * <caption>Worker.js</caption>
     * // load the amd module in the worker thread
     * importScripts("dep/tv.accedo.xdk.base/js/ax/amd.js");
     *
     * // Set the baseUrl as the original one.
     * // However, this file may not sits under baseUrl.
     * // The baseUrl should be a relative path from this file to the original baseUrl.
     * require({
     *     baseUrl: "../js/"
     * });
     * 
     * require([
     *     "xdk-base/util",
     *     "demo/longRunningTask"
     * ], function (
     *     util,
     *     longRunningTask
     * ) {
     *     // start the heavy lifting
     *     longRunningTask.start(function (update) {
     *         if (util.isUndefined(update.progress)) {
     *             return;
     *         }
     *
     *         // notify the main thread
     *         postMessage(update.progress);
     *     });
     * });
     */

    if (!global.amd) {
        global.amd = {
            require: globalRequire,
            define: define,
            undefine: undefine,
            config: config,
            load: load,
            completeLoad: completeLoad,
            resolvePath: resolvePath,
            buildFactory: buildFactory,
            executeFactory: executeFactory
        };
    }

}(this));
define("xdk-base/amd", function(){});

// XDK notes: due to requirements, this modules is modified to become a global object
/**
 * A global function, that registers callbacks for DOM ready event.
 * @module domReady
 */
window.domReady = (function () {
    "use strict";

    var isReady = false,
        callbacks = [];


    // Sets the page as loaded.
    function pageLoaded() {
        if (!isReady) {
            isReady = true;

            var i;
            for (i = 0; i < callbacks.length; i += 1) {
                callbacks[i](document);
            }
        }
    }

    if (document.addEventListener) {
        document.addEventListener("DOMContentLoaded", pageLoaded, false);
        window.addEventListener("load", pageLoaded, false);
        window.addEventListener("show", pageLoaded, false);
        window.onShow = pageLoaded;
    } else if (window.attachEvent) {
        window.attachEvent("onload", pageLoaded);
    }

    if (document.readyState === "complete") {
        pageLoaded();
    }

    /**
     * Registers a callback for DOM ready. If DOM is already ready, the
     * callback is called immediately. Globally accessible.
     * @param {Function} callback the callback function to register
     * @method
     * @memberof domReady
     */
    function domReady(callback) {
        if (isReady) {
            callback(document);
        } else {
            callbacks.push(callback);
        }
        return domReady;
    }

    return domReady;
})();
define("xdk-base/domReady", function(){});

require({
  "paths": {
    "vdk-appGrid": "../dep/vdk-appGrid",
    "vdk-lib-moment": "../dep/vdk-lib-moment",
    "vdk-message": "../dep/vdk-message",
    "vdk-loading": "../dep/vdk-loading",
    "xdk-ax": "../dep/xdk-ax",
    "xdk-ext-device-lg": "../dep/xdk-ext-device-lg",
    "xdk-base": "../dep/xdk-base",
    "vdk-lib-base64": "../dep/vdk-lib-base64",
    "xdk-ext-device-samsung": "../dep/xdk-ext-device-samsung",
    "xdk-ext-device-tizen": "../dep/xdk-ext-device-tizen",
    "xdk-history": "../dep/xdk-history",
    "xdk-mouse": "../dep/xdk-mouse",
    "xdk-ui-grid": "../dep/xdk-ui-grid",
    "xdk-ui-basic": "../dep/xdk-ui-basic",
    "xdk-ui-animatedlabel": "../dep/xdk-ui-animatedlabel",
    "xdk-ui-input": "../dep/xdk-ui-input",
    "xdk-ext-device-playstation": "../dep/xdk-ext-device-playstation",
    "image": "../dep/xdk-base/loader/image",
    "json": "../dep/xdk-base/loader/json",
    "css": "../dep/xdk-base/loader/css"
  }
});
define("../dep/dep.config.js", function(){});

require({"image":{"map":{"../img":[]}}});
define("../dep/img.map.js", function(){});

require({
    "baseUrl": "js", 
    "paths": {
        "appmeasurement": "analytics/AppMeasurement",
        "appmeasurementMedia": "analytics/AppMeasurement_Module_Media",
        "cryptojs": "cryptojs/rollups",

        "tve/ext/ui/programguide": "storm/programguide",

        /**
        * Use modified promise files to solve memory leak issue.
        * @see https://accedobroadband.jira.com/browse/XDK-2900
        * @TODO Remove these (including the actual files) when using updated XDK where this is no longer needed
        */
        "xdk-base/promise": "./modules/promise/promise"

        // Use this to turn off logging completelly during memory debugging
        //"xdk-base/console": "./modules/console/console"
    },
    "waitSeconds": 60
});
define("amd.config.js", function(){});

/**
 * XDK framework "meta" information or capabilities
 * @module xdk-base/core
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-base/core", [], function () {
    "use strict";
    var core, guid = 1,
        CustomException = function (name, message) {
            this.name = name || "XDKCustomError";
            this.message = message || "";
        };

    core = {
        /**
         * Current XDK version number
         * @member version
         * @memberof module:xdk-base/core
         * @public
         */
        version: "2.6.3",
        /**
         * The build number of the current version
         * @name buildNumber
         * @memberof module:xdk-base/core
         * @public
         */
        buildNumber: "1462774903-66aafb6",
        /**
         * Context root of current Javascript runtime
         * @name root
         * @memberof module:xdk-base/core
         * @public
         */
        root: (function () {
            return (typeof window !== "undefined" ? window : null);
        })(),
        /**
         * Create a custom exception (i.e. a runtime error) with name and message, that can be thrown later
         * @method createException
         * @memberof module:xdk-base/core
         * @param {String} [name] exception name
         * @param {String} [message] exception message
         * @return {CustomException} exception the custom XDK exception
         * @public
         */
        createException: function (name, message) {
            CustomException.prototype = new Error(); // create error here to record the stack
            CustomException.prototype.constructor = CustomException;
            return new CustomException(name, message);
        },
        /**
         * Gets the next global unique
         * @method getGuid
         * @return {Number} guid a unique global ID
         * @public
         * @memberof module:xdk-base/core
         */
        getGuid: function () {
            return guid++;
        }
    };
    return core;
});
/**
 * The exception names referencing from JAVA Exception.
 * @see {@link http://www.tutorialspoint.com/java/java_builtin_exceptions.htm}
 * @see {@link http://rymden.nu/exceptions.html}
 * @module xdk-base/exception
 * @example
 * core.createException(exception.UNSUPPORTED_OPERATION, "Unsupported on this device.");
 */
define("xdk-base/exception", {
    /**
     * @typedef Exception
     * @type {String}
     * @desc Provide the exception name and will be used in {@link module:xdk-base/core.createException}
     * @memberof module:xdk-base/exception
     */
    /**
     * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
     * @typedef ILLEGAL_ARGUMENT
     * @type {Exception}
     * @memberof module:xdk-base/exception
     */
    ILLEGAL_ARGUMENT: "ax:exception:illegal-argument",
    /**
     * Thrown when a method has been invoked at an illegal or inappropriate time
     * @typedef ILLEGAL_STATE
     * @type {Exception}
     * @memberof module:xdk-base/exception
     */
    ILLEGAL_STATE: "ax:exception:illegal-state",
    /**
     * Thrown when a call to a library or RPC throws error.
     * @typedef INTERNAL
     * @type {Exception}
     * @memberof module:xdk-base/exception
     */
    INTERNAL: "ax:exception:internal",
    /**
     * Thrown when access to certain resource fails due to unsufficient privilege.
     * @typedef UNAUTHORIZED
     * @type {Exception}
     * @memberof module:xdk-base/exception
     */
    UNAUTHORIZED: "ax:exception:unauthorized",
    /**
     * Thrown to indicate that the requested operation is not supported.
     * @typedef UNSUPPORTED_OPERATION
     * @type {Exception}
     * @memberof module:xdk-base/exception
     */
    UNSUPPORTED_OPERATION: "ax:exception:unsupported-operation"
});
/**
 * Javascript globals module. Export standard ECMA built-in objects as dependencies
 * for AMD dependency injections.
 *
 * @module xdk-base/jsGlobals
 */
define('xdk-base/jsGlobals',["exports"], function(exports) {

    "use strict";

    exports.Array = Array;
    exports.Object = Object;
});
/**
 * Utilities module.
 *
 * @module xdk-base/util
 */
define("xdk-base/util", [
    "require",
    "xdk-base/core",
    "xdk-base/exception",
    "xdk-base/jsGlobals"
], function (
    require,
    core,
    exception,
    jsGlobals
) {

    "use strict";

    var util = {},
        Array = jsGlobals.Array,
        Object = jsGlobals.Object,
        getPromise = function () {
            return require("xdk-base/promise");
        };
    /**
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {Boolean} [isDeep=false] Specify a deep flatten.
     * @param {Boolean} [isStrict=false] Restrict flattening to arrays and `arguments` objects.
     * @param {Number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var arr = [1, [2], [3, [[4]]]];
     * baseFlatten(arr, true, false, 0)
     * // [1, 2, 3, 4]
     *
     * baseFlatten(arr, false, false, 0)
     * // [1, 2, [3, 4]]
     */
    function baseFlatten(array, isDeep, isStrict, fromIndex) {
        var index = (fromIndex || 0) - 1,
            length = array.length,
            resIndex = -1,
            result = [];

        while (++index < length) {
            var value = array[index];

            if (value && typeof value === "object" && typeof value.length === "number" &&
                (util.isArray(value) || util.isArguments(value))) {
                // recursively flatten arrays (susceptible to call stack limits)
                if (isDeep) {
                    value = baseFlatten(value, isDeep, isStrict);
                }
                var valIndex = -1,
                    valLength = value.length;

                result.length += valLength;
                while (++valIndex < valLength) {
                    result[++resIndex] = value[valIndex];
                }
            } else if (!isStrict) {
                result[++resIndex] = value;
            }
        }
        return result;
    }

    //Object Part
    (function () {
        /**
         * A reference to naitive toString function.
         * @name _toString
         * @private
         */
        var __toString,
            BOOLEAN_CLASS = "[object Boolean]",
            NUMBER_CLASS = "[object Number]",
            STRING_CLASS = "[object String]",
            ARRAY_CLASS = "[object Array]",
            DATE_CLASS = "[object Date]",
            FUNCTION_TYPE = "function";
        __toString = Object.prototype.toString;
        /**
         * Extends a dest with properties from src.
         * Possible deep copy/extending by setting deep = true.
         * @method extend
         * @memberof module:xdk-base/util
         * @param {Object} dest Destination object to be extended
         * @param {Object} src Source object with properties to extend with
         * @param {Boolean} [deep] Deep copy
         * @return {Object} extended object
         * @public
         */
        util.extend = function (dest, src, deep) {
            var objIsArray, orig, copy, clone, att;
            for (att in src) {

                orig = dest[att];
                copy = src[att];
                // Prevent never-ending loop
                if (dest === copy) {
                    continue;
                }

                objIsArray = this.isArray(copy);
                if (deep && copy && (objIsArray || this.isPlainObject(copy))) {
                    if (objIsArray) {
                        objIsArray = false;
                        clone = orig && this.isArray(orig) ? orig : [];
                    } else {
                        clone = orig && this.isPlainObject(src) ? orig : {};
                    }

                    // Never move original objects, clone them
                    dest[att] = this.extend(clone, copy, true);
                } else if (!this.isUndefined(copy)) {
                    dest[att] = copy;
                }
            }
            return dest;
        };
        /**
         * Clones an object.
         * @method clone
         * @memberof module:xdk-base/util
         * @param {Object|Array} obj Object to check
         * @param {Boolean} [deep] Deep copy
         * @return {Object} a copy of the object
         * @public
         */
        util.clone = function (obj, deep) {
            if (this.isArray(obj)) {
                return this.extend([], obj, deep);
            }
            return this.extend({}, obj, deep);
        };
        /**
         * Checks is object is undefined.
         * @method isUndefined
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is undefined, false otherwise
         * @public
         */
        util.isUndefined = function (obj) {
            return typeof obj === "undefined";
        };
        /**
         * Checks if the object is a plain object, created using {} or new Object().
         * @method isPlainObject
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to test.
         * @return {Boolean} true if parameter is an object, false otherwise
         * @public
         */
        util.isPlainObject = function (obj) {
            if (!obj || typeof obj !== "object" || obj.nodeType) {
                return false;
            }

            // Not own constructor property must be Object
            if (obj.constructor && !obj.hasOwnProperty("constructor") && !obj.constructor.prototype.hasOwnProperty("isPrototypeOf")) {
                return false;
            }

            //Loop through all properties to get access to the last one.
            var key;
            for (key in obj) {}

            //Own properties are iterated first, so it is enough to look at the last one.
            return (key === undefined || obj.hasOwnProperty(key));
        };
        /**
         * Checks if the object is an array.
         * @method isArray
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is an Array, false otherwise
         * @public
         */
        util.isArray = Array.isArray ? Array.isArray : function (obj) {

            //Information  on the best way to perform this type of check is taken from:
            // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
            return __toString.call(obj) === ARRAY_CLASS;
        };
        /**
         * Checks if the object is Function.
         * @method isFunction
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is a Function, false otherwise
         * @public
         */
        util.isFunction = function (obj) {
            return typeof obj === FUNCTION_TYPE || false;
        };
        /**
         * Checks if the object is a string.
         * @method isString
         * @memberof module:xdk-base/util
         * @function
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is a String, false otherwise
         * @public
         * @static
         */
        util.isString = function (obj) {
            return __toString.call(obj) === STRING_CLASS;
        };
        /**
         * Checks if the object is a number.
         * @method isNumber
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is a Number, false otherwise
         * @public
         */
        util.isNumber = function (obj) {
            return __toString.call(obj) === NUMBER_CLASS;
        };
        /**
         * Checks if the object is NaN
         * @method isNan
         * @memberof module:xdk-base/util
         * @param {object} obj Object to check
         * @return {Boolean} true if object is NaN, false otherwise
         */
        util.isNaN = function (obj) {
            return util.isNumber(obj) && obj !== +obj;
        };
        /**
         * Checks if the object is Finite
         * @method isFinite
         * @memberof module:xdk-base/util
         * @param {object} obj Object to check
         * @return {Boolean} true if object is Finite, false otherwise
         */
        util.isFinite = function (obj) {
            return isFinite(obj);
        };
        /**
         * Checks if the object is a boolean.
         * @method isBoolean
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is a Boolean, false otherwise
         * @public
         */
        util.isBoolean = function (obj) {
            return __toString.call(obj) === BOOLEAN_CLASS;
        };
        /**
         * Checks if the object is a date.
         * @method isDate
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is a Date, false otherwise
         * @public
         */
        util.isDate = function (obj) {
            return __toString.call(obj) === DATE_CLASS;
        };
        /**
         * Checks if the object is a DOM element.
         * @method isDOMElement
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is a DOM element, false otherwise
         * @public
         */
        util.isDOMElement = function (obj) {
            if (!obj) {
                return false;
            }
            //Browsers not supporting W3 DOM2 don't have HTMLElement and
            //an exception is thrown and we end up here. Testing some
            //properties that all elements have. (works on IE7)
            return (typeof obj === "object") && (obj.nodeType === 1) && (typeof obj.style === "object") && (typeof obj.ownerDocument === "object") && (typeof obj.nodeName === "string");
        };
        /**
         * Tests whether an object is empty or not (an empty object is {})
         * @method isEmpty
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is empty, false otherwise
         * @public
         */
        util.isEmpty = function (obj) {
            //other than plainobject return false
            if (!this.isPlainObject(obj)) {
                return false;
            }
            var prop;
            for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }

            return true;
        };
        /**
         * Tests whether an object is null
         * @method isNull
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is empty, false otherwise
         * @public
         */
        util.isNull = function (obj) {
            return obj === null;
        };
        /**
         * To check if it is object. It is different from plainObject which suppose has no contructor
         * @method isObject
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object, false otherwise
         * @public
         */
        util.isObject = function (obj) {
            return obj === Object(obj);
        };
        /**
         * To check if it is an argument object
         * @method isArgument
         * @memberof module:xdk-base/util
         * @param {Object} obj Object to check
         * @return {Boolean} true if object is argument, false otherwise
         */
        util.isArguments = function (obj) {
            return util.has(obj, "callee");
        };

        /**
         * Checks if the 2 specified plain objects are equal.
         * 2 objects are considered equal iff all of the corresponding properties are equal (recursively).
         * `deepness` could be provided to control the deepness of checking. The properties under the specified depth are ignored.
         *
         * @method
         * @param {Object} original Original plain object
         * @param {Object} target Plain object to check against
         * @param {Number} [deepness] The depth limit (>= 1) of the check. If not specified (or < 1), a complete check will be performed among all properties (recursively).
         * @returns {Boolean} True if the objects are equal before the specific depth, false otherwise.
         * @memberof module:xdk-base/util
         */
        util.areObjectsEqual = function (original, target, deepness) {
            if (!util.isPlainObject(original) || !util.isPlainObject(target)) {
                return false;
            }

            var key;
            var keyMap = {};
            var lastLevel = false;

            // in the recursive case, if deepness is not defined, deepness - 1 will be NaN
            // NaN is essentially having the same effect as undefined, which leads to full check
            if (deepness === 1) {
                lastLevel = true;
            }

            for (key in original) {
                var prop1 = original[key];
                var prop2 = target[key];

                if (util.isPlainObject(prop1) && util.isPlainObject(prop2)) {
                    if (!lastLevel && !util.areObjectsEqual(prop1, prop2, deepness - 1)) {
                        return false;
                    }
                } else if (util.isArray(prop1) && util.isArray(prop2)) {
                    if (!lastLevel && !util.areArraysEqual(prop1, prop2, deepness - 1)) {
                        return false;
                    }
                } else if (prop1 !== prop2) {
                    return false;
                }

                keyMap[key] = true;
            }

            // any property not in `original` => not equal
            for (key in target) {
                if (!keyMap[key]) {
                    return false;
                }
            }

            return true;
        };

        /**
         * Checks if the 2 specified arrays are equal.
         * 2 arrays are considered equal iff all of the elements exist in both arrays and are in same order.
         * Array or object element inside the array will be checked recursively.
         * `deepness` could be provided to control the deepness of checking. The elements under the specified depth are ignored.
         *
         * @method
         * @param {Array} original Original array
         * @param {Array} target Array to check against
         * @param {Number} [deepness] The depth limit (>= 1) of the check. If not specified (or < 1), a complete check will be performed among all elements (recursively).
         * @returns {Boolean} True if the arrays are equal, false otherwise.
         * @memberof module:xdk-base/util
         */
        util.areArraysEqual = function (original, target, deepness) {
            if (!util.isArray(original) || !util.isArray(target)) {
                return false;
            }

            var len1 = original.length;
            var len2 = target.length;
            var lastLevel = false;

            if (len1 !== len2) {
                return false;
            }

            // in the recursive case, if deepness is not defined, deepness - 1 will be NaN
            // NaN is essentially having the same effect as undefined, which leads to full check
            if (deepness === 1) {
                lastLevel = true;
            }

            for (var i = 0; i < len1; i++) {
                if (util.isPlainObject(original[i]) && util.isPlainObject(target[i])) {
                    if (!lastLevel && !util.areObjectsEqual(original[i], target[i], deepness - 1)) {
                        return false;
                    }
                } else if (util.isArray(original[i]) && util.isArray(target[i])) {
                    if (!lastLevel && !util.areArraysEqual(original[i], target[i], deepness - 1)) {
                        return false;
                    }
                } else if (original[i] !== target[i]) {
                    return false;
                }
            }

            return true;
        };

        /**
         * Merge sort implementation 
         * Divide and Conquer! :)
         * http://en.wikipedia.org/wiki/Merge_sort
         * 
         * @example
         * //Sorting by default comparator using merge sorting.
         * util.sort(array);
         * //specify a comparator:
         * var sortOrder = -1;
         * util.sort(array,function(a,b) { return ((a < b) ? -1 : (a > b) ? 1 : 0) * sortOrder; });
         * 
         * @param  {Array} arr       
         * @param  {Function} comparator 
         * @return {Array}    
         * @memberof module:xdk-base/util
         */
        util.sort = function (arr, comparator) {

            if (!util.isArray(arr)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "arr parameter must be array");
            }

            var mid, left, right;

            if (arr.length < 2) {
                return arr;
            }

            if (!comparator || !util.isFunction(comparator)) {
                comparator = defaultComparator;
            }

            function defaultComparator(a, b) {
                return a < b ? -1 : (a > b ? 1 : 0);
            }

            function merge(left, right, comparator) {
                var result = [];

                while (left.length && right.length) {
                    if (comparator(left[0], right[0]) <= 0) {
                        // if 0 it should preserve same order (stable)
                        result.push(left.shift());
                    } else {
                        result.push(right.shift());
                    }
                }

                if (left.length) {
                    result.push.apply(result, left);
                }

                if (right.length) {
                    result.push.apply(result, right);
                }

                return result;
            }

            mid = Math.round(arr.length / 2);
            left = util.sort(arr.slice(0, mid), comparator);
            right = util.sort(arr.slice(mid, arr.length), comparator);

            return merge(left, right, comparator);
        };

        /**
         * Shuffle 
         * Knuth shuffle method
         * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
         * 
         * @example
         * //returns a shuffle array
         * var arr = ["a","b","c","d"];
         * util.suffle(arr);
         * 
         * @param  {Array} arr       
         * @return {Array}    
         * @memberof module:xdk-base/util
         */
        util.shuffle = function (arr) {

            if (!util.isArray(arr)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "arr parameter must be array");
            }

            var currentIndex = arr.length,
                temporaryValue, randomIndex;

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {

                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                // And swap it with the current element.
                temporaryValue = arr[currentIndex];
                arr[currentIndex] = arr[randomIndex];
                arr[randomIndex] = temporaryValue;
            }

            return arr;
        };

        /**
         * sortByField allows the caller to sort an object array by one of its properties.
         * The default comparator will order items in ascending order. 
         * If a minus sign is placed at the beginning of the 'field' argument, 
         * the array will be sorted in descending order.
         * Optionally, a custom comparator function can be passed as an argument for this function.
         * Optionally, a custom property wrapper function can be passed as an argument, which will convert the property value before comparison is performed.
         * 
         * @example 
         * //returns the array ordered by Age property descending.
         * array = util.sortBy(array,"-Age");
         * //return the array ordered by firstName ascending.
         * util.sortByField(array,"FirstName");
         * //return the array ordered by firstName lenghts.
         * util.sortByField(array,"FirstName",function(val) { return val.length; });
         * //parseInt as the wrapper for Age attribute comparission.
         * util.sortByField(array,"Age", parseInt);
         * //specify a custom wrapper
         * util.sortByField(array,"Age", function(val) { return yourFn(val) });
         * //return the results in inverse order
         * util.sortByField(array,"-Age", function(val) { return yourFn(val) });
         * 
         * @param  {Array}    arr        object array to be sorted
         * @param  {String}   field      field string
         * @param  {Function} wrapper    optional function to convert the property value before performing the comparission.
         * @return {Array}     
         * @memberof module:xdk-base/util       
         */
        util.sortByField = function (array, field, wrapper) {


            var reverse = 1,
                key;

            if (!util.isArray(array)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "arr parameter must be array");
            }

            if (wrapper && !util.isFunction(wrapper)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "If wrapper is provided, must be a function");
            }

            if (field[0] === "-") {
                reverse = -1;
                field = field.substr(1);
            }

            if (wrapper && util.isFunction(wrapper)) {
                key = function (x) {

                    if (!x.hasOwnProperty(field)) {
                        throw core.createException(exception.ILLEGAL_STATE, "Unable to sort, as " + field + " is not a property in the comparable array item");
                    }

                    return wrapper(x[field]);
                };
            } else {
                key = function (x) {

                    if (!x.hasOwnProperty(field)) {
                        throw core.createException(exception.ILLEGAL_STATE, "Unable to sort, as " + field + " is not a property in the comparable array item");
                    }

                    return x[field];
                };
            }

            var comparator = function (a, b) {

                a = key(a);
                b = key(b);

                return reverse * ((a > b) - (b > a));

            };

            return util.sort(array, comparator);

        };

        /**
         * sortByFields Allows the caller to sort an array by multiple fields
         * 
         * @example 
         * //returns the sorted array by Age property, 
         * //prior to applying a parseInt on Age property before performing the comparission. 
         * //and sort in descending order (reversed).
         * sortByFields(arr,["-Age"],parseInt);
         * //return the array ordered by age, and then for Firstname in inverse order. 
         * util.sortByFields(array,["Age","-FirstName"]);
         * //return the array ordered by Firstname Z-A and then for Lastname A-Z
         * util.sortByFields(array,["-Firstname","LastName"]);
         * //add a wrapper to order the results by the length of the FirstName, then the length of the LastName
         * util.sortByFields(array,["-Firstname","LastName"],function(val) {  return val.length; });
         * 
         * @param  {Array}    array      Array to be sorted
         * @param  {Array}    fields     field list to be sorted e.g: ["FirstName","-Age"]
         * @param  {Function} wrapper    optional wrapper function, if you need to convert the property value before performing the comparission. note: apply for all fields.
         * @return {Array}
         * @memberof module:xdk-base/util            
         */
        util.sortByFields = function (array, fields, wrapper) {

            if (!util.isArray(array)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "array parameter must be a array");
            }

            if (!util.isArray(fields)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "Fields parameter must be a array");
            }

            if (wrapper && !util.isFunction(wrapper)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "If wrapper is provided, must be a function");
            }

            function _sortByAttr(attr) {

                var sortOrder = 1;
                if (attr[0] === "-") {
                    sortOrder = -1;
                    attr = attr.substr(1);
                }

                return function (a, b) {

                    if (!a.hasOwnProperty(attr) || !b.hasOwnProperty(attr)) {
                        throw core.createException(exception.ILLEGAL_STATE, "Unable to sort, as " + attr + " is not a property in the comparable array item");
                    }

                    var _a = a[attr],
                        _b = b[attr];

                    if (wrapper && util.isFunction(wrapper)) {
                        _a = wrapper(a[attr]);
                        _b = wrapper(b[attr]);
                    }

                    return ((_a < _b) ? -1 : (_a > _b) ? 1 : 0) * sortOrder;

                };

            }

            function _getSortFunc() {

                return function (a, b) {
                    var result, i;
                    for (i = 0, result = 0; result === 0 && i < fields.length; i++) {
                        result = _sortByAttr(fields[i])(a, b);
                    }
                    return result;
                };
            }

            return util.sort(array, _getSortFunc.apply(null, fields));

        };

    })();


    //fn Part
    (function () {
        var update, merge;
        /**
         * Updates an array (of arguments) with values arguments list (args).
         * This function modifies the "array".
         * @method update
         * @param {Array} array Array to update
         * @param {Object} args Arguments list
         * @return Updated array of arguments
         * @memberof module:xdk-base/util
         * @private
         */
        update = function (array, args) {
            var arrayLength = array.length,
                length = args.length;
            while (length--) {
                array[arrayLength + length] = args[length];
            }
            return array;
        };

        /**
         * Copies array and updates it with arguments.
         * Same as _update but does not modify the original array
         * @method merge
         * @param {Array} array Array to update (Not modified)
         * @param {Object} args Arguments list
         * @return Updated array of arguments
         * @memberof module:xdk-base/util
         * @private
         */
        merge = function (array, args) {
            array = Array.prototype.slice.call(array, 0);
            return update(array, args);
        };
        /**
         * Bind a function (func) to a context.
         * If used directly on the function and extending function is allowed, first argument can be omited.
         * @method bind
         * @memberof module:xdk-base/util
         * @param {Function} func to extend (if function extending allowed, this is to be omited)
         * @param {Object} context The context to bind to
         * @param {Object} third or extra arguments will be passed as an input parameter to the Function func binded.
         * @return {Function} Wraped function where execution is guaranteed in the given context
         * @public
         */
        util.bind = function (func, context) {

            if (util.isFunction(Function.prototype.bind)) {
                return Function.prototype.bind.apply(func, Array.prototype.slice.call(arguments, 1));
            }

            if (arguments.length < 2 && util.isUndefined(arguments[0])) {
                return func;
            }

            var __method = func,
                args = Array.prototype.slice.call(arguments, 2);
            return function () {
                var a = merge(args, arguments);
                return __method.apply(context, a);
            };
        };
        /**
         * Return a list of argument names for a function.
         * @method argumentNames
         * @memberof module:xdk-base/util
         * @param {Function} func to return a list of arguments for
         * @return {Array} An array of strings (argument names)
         * @public
         */
        util.argumentNames = function (func) {
            var names = func.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, "").replace(/\s+/g, "").split(",");
            return names.length === 1 && !names[0] ? [] : names;
        };


        /**
         * Promise timeout functions
         * @private
         **/
        (function () {

            var delayRefs = {};

            /**
             * Keep reference a request by is
             * @name refDelay
             * @module
             * @memberof module:xdk-base/util~
             * @private
             */

            function refDelay(id, delay) {

                if (!id || !delay) {
                    return;
                }

                if (delayRefs[id]) {
                    throw core.createException("Repeated id for deferred creation");
                }

                delayRefs[id] = delay;

                return delayRefs[id];

            }

            /**
             * Get the reference of a request by id
             * @name getDelay
             * @module
             * @memberof module:xdk-base/util~
             * @private
             */

            function getDelay(id) {
                return delayRefs[id];
            }


            /**
             * Get the reference of a request by id
             * @name unrefDelay
             * @module
             * @memberof module:xdk-base/util~
             * @private
             */

            function unrefDelay(id) {
                delayRefs[id] = undefined;
            }

            /**
             * Delays execution of function "func" for a time specified in seconds by "timeout".
             *
             * @method delay
             * @memberof module:xdk-base/util
             * @param {Number} timeout Delay time in seconds
             * @param {Number|String} [id] unqiue id for the delay
             * @return {module:xdk-base/promise~Promise}
             * @public
             * @example
             *
             * var id = core.getGuid();
             * // delay 1 second
             * util.delay(1, id).then(function(){
             *     ...do something
             * });
             *
             * // clear the delay, note that id not required if there's no need to clear the delay
             * util.clearDelay(id);
             *
             */
            util.delay = function (timeout, id) {

                var deferred = getPromise().defer(),
                    handle;

                handle = core.root.setTimeout(function () {

                    if (id) {
                        unrefDelay(id);
                    }

                    return deferred.resolve();

                }, timeout * 1000);

                if (id) {
                    refDelay(id, {
                        handle: handle,
                        deferred: deferred
                    });
                }

                return deferred.promise;
            };

            /**
             * Defers execution of the function until the processor is ready.
             * This is essencialy the same as setting timeout to 1ms.
             * @method defer
             * @param {Number|String} [id] unqiue id for the delay
             * @see module:xdk-base/util.delay
             * @memberof module:xdk-base/util
             * @return {module:xdk-base/util~Promise}
             * @public
             */
            util.defer = function (id) {
                return util.delay(0.01, id);
            };


            /**
             * Cancel the promise requested
             *
             * @method clearDelay
             * @memberof module:xdk-base/util
             * @param {module:xdk-base/util~CancellablePromise} timeout Delay time in seconds
             * @public
             */
            util.clearDelay = function (id) {

                if (!id) {
                    return;
                }

                var delay = getDelay(id);

                if (!delay) {
                    return;
                }

                clearTimeout(delay.handle);

                delay.deferred.reject("delay aborted");

                unrefDelay(id);
            };

        })();

        /**
         * Returns a function "wrapped" around the original function.
         * This function lets you easily build on existing functions by specifying before and after behavior,
         * transforming the return value, or even preventing the original function from being called.
         *
         *  The wraper function is called with this signature:
         *      function wrapper(callOriginal[, args...])
         *
         * "callOriginal" is a function that can be used to call the original (wrapped) function (or not, as appropriate).
         * It is not a direct reference to the original function, there's a layer of indirection in-between that sets up
         * the proper context for it.
         *
         * @method wrap
         * @memberof module:xdk-base/util
         * @param {Function} target  to wrap
         * @param {Function} wrapper to wrap with
         * @return Wrapped function with correct references
         * @public
         */
        util.wrap = function (target, wrapper) {
            return function () {
                var a = update([util.bind(target, this)], arguments);
                return wrapper.apply(this, a);
            };
        };
        /**
         * Wraps the function inside another function that, when called, pushes 'this' to the original function
         * as the first argument (with any further arguments following it).
         * This method transforms the original function that has an explicit first argument to a function that
         * passes `this` (the current context) as an implicit first argument at call time.
         * It is useful when wanted to transform a function that takes an object to a method of that object or
         * its prototype, shortening its signature by one argument.
         * @method methodize
         * @memberof module:xdk-base/util
         * @param {Function} target to transform.
         * @return {Function} wrapped function
         * @public
         */
        util.methodize = function (target) {
            /**
             * @ignore
             */
            if (target._methodized) {
                return target._methodized;
            }

            var __method = target;
            /**
             * @ignore
             */
            target._methodized = function () {
                var a = update([this], arguments);
                return __method.apply(null, a);
            };
            return target._methodized;
        };
    }());

    //string Part
    (function () {
        /**
         * Insert a string to a given position
         * @method insert
         * @memberof  module:xdk-base/util
         * @param {String} str String to work with
         * @param {Number} position Number of position to insert (Default last).
         * if number is smaller than 0 or larger the string position, it will insert at the end.
         * @param {String} phrase A phrase to inserted (Default "")
         * @return {String|Boolean} Inserted string. it will return false when it is not string
         * @public
         * @example <caption> To insert the string at position 2</caption>
         * util.insert("testing", 2, "@@");
         */
        util.insert = function (str, position, phrase) {
            if (!util.isString(str)) {
                str = "" + str;
            }

            if (util.isUndefined(position) || position < 0 || position > str.length) {
                position = str.length;
            }
            phrase = util.isUndefined(phrase) ? "" : phrase;

            return str.slice(0, position) + phrase + str.slice(position, str.length);
        };
        /**
         * Truncates a string to a given length, with optional truncation
         * @method truncate
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String to work with
         * @param {Number} length Number of characters to strip at (Default 30). If it is smaller than 0, it will be 0.
         * @param {String} truncation A truncation(ending) string. (Default "...")
         * @return {String|Boolean} Truncated string.it will return false when it is not string
         * @example <caption> To truncate the string</caption>
         * util.truncate("testing", 4, "...");
         */
        util.truncate = function (str, length, truncation) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            length = util.isNumber(length) ? length : 30;
            truncation = util.isUndefined(truncation) ? "..." : truncation;
            var resultLen = length < 0 ? 0 : length;
            return str.length > length ? str.slice(0, resultLen) + truncation : String(str);
        };
        /**
         * Strips all leading and trailing whitespaces from a string.
         * @method strip
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String to work with
         * @return {String|Boolean} String with striped whitespaces.it will return false when it is not string
         * @example <caption> To strip the string</caption>
         * util.strip("     testing");
         */
        util.strip = function (str) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            return str.replace(/^\s+/, "").replace(/\s+$/, "");
        };
        /**
         * Converts a string separated by dashes into a camelCase equivalent. For
         * instance, `"foo-bar"` would be converted to `"fooBar"`.
         * @method camelize
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String to work with.
         * @return {String|Boolean} Camelized string.it will return false when it is not string
         * @example <caption> To camelize the string from foo-bar to fooBar</caption>
         * util.camelize("foo-bar");
         */
        util.camelize = function (str) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            return str.replace(/-+(.)?/g, function (match, chr) {
                return chr ? chr.toUpperCase() : "";
            });
        };
        /**
         * Converts a string from camelCase to decamelized equivalent. For
         * instance, `"fooBar"` would be converted to `"foo-bar"`.
         * @method decamelize
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String to work with.
         * @param {String} separator String to separate the words. (Default is "-")
         * @return {String|Boolean} Decamelized string.it will return false when it is not string
         * @example <caption> To decamelize the string of fooBar to foo-bar</caption>
         * util.decamelize("fooBar");
         */
        util.decamelize = function (str, separator) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            separator = separator || "-";
            return str.replace(/([a-z])([A-Z])/g, "$1" + separator + "$2").toLowerCase();
        };
        /**
         * Checks if the string is empty or only contains whitespaces.
         * @method empty
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String to work with
         * @return {Boolean} true if string is empty, false otherwise.
         * @example <caption> To check if the type is empty</caption>
         * util.empty(" ");
         */
        util.empty = function (str) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            return (/^\s*$/).test(str);
        };
        /**
         * Checks if a string starts by the same characters than another specified string
         * @method startsWith
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String inside which we search for a starting substring
         * @param {String} startStr Starting substring to search for
         * @return {Boolean} true if str starts with startStr.it will return false when it is not string
         * @example <caption> To check if the string start with specific string "a"</caption>
         * util.startsWith("accedo","a");
         */
        util.startsWith = function (str, startStr) {
            //is either undefined, return false;
            if (util.isUndefined(str) || util.isUndefined(startStr)) {
                return false;
            }
            if (!util.isString(str)) {
                str = "" + str;
            }
            if (!util.isString(startStr)) {
                startStr = "" + startStr;
            }
            return str.substr(0, startStr.length) === startStr;
        };
        /**
         * encode the character like & to "&amp;"
         * @method encodeHTML
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String inside which we need to encode
         * @return {String} s String which is encoded
         * @example <caption> To encode the string from "acc>do" to "acc&g t;do"</caption>
         * util.encodeHTML("acc>do");
         */
        util.encodeHTML = function (str) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            var s = "";
            if (str.length === 0) {
                return "";
            }
            s = str.replace(/&/g, "&amp;");
            s = s.replace(/</g, "&lt;");
            s = s.replace(/>/g, "&gt;");
            s = s.replace(/ /g, "&nbsp;");
            s = s.replace(/\'/g, "'");
            s = s.replace(/\"/g, "&quot;");
            s = s.replace(/\n/g, "<br>");
            return s;
        };
        /**
         * decode the character like &amp; to &
         * @method decodeHTML
         * @memberof module:xdk-base/util
         * @public
         * @param {String} str String which we need to decode
         * @return {String} s String which is decoded
         * @example <caption> To decode the string from "acc&g t;do" to "accedo"</caption>
         * util.decodeHTML("acc&g t;do");
         */
        util.decodeHTML = function (str) {
            if (!util.isString(str)) {
                str = "" + str;
            }
            var s = "";
            if (str.length === 0) {
                return "";
            }
            s = str.replace(/&amp;/g, "&");
            s = s.replace(/&lt;/g, "<");
            s = s.replace(/&gt;/g, ">");
            s = s.replace(/&nbsp;/g, " ");
            s = s.replace(/'/g, "\'");
            s = s.replace(/&quot;/g, "\"");
            s = s.replace(/<br>/g, "\n");
            return s;
        };
    }());


    // JSON Part
    // create and return a valid JSON module
    var root = core.root,
        nullRegex = /^\s*null(\s)*$/,
        jsonModule = {
            /**
             * Parse the JSON string into the object
             * @method parse
             * @memberof module:xdk-base/util
             * @param {String} str the string to be parsed
             * @returns {Object} If the input string is correct format, it will return the JSON object.
             * @public
             * @example <caption> To change the json string into object</caption>
             * util.parse("{"a": 1, "b": 2, "c": 3}");
             */
            parse: function (str) {
                // use the native parse function if available
                if (root.JSON && root.JSON.parse) {
                    return root.JSON.parse(str);
                }

                if (util.isString(str) || util.isNumber(str)) {
                    if (nullRegex.test(str)) {
                        return null;
                    }

                    try {
                        /*jshint -W054 */
                        return (new Function("var input = " + str + "; if (input === undefined || input === null) throw \"Unexpected token\"; return input;"))();
                    } catch (ex) {
                        throw core.createException("JSONParseError", "JSON parse Error");
                    }
                }
                throw core.createException("JSONParseError", "JSON parse Error");
            },
            /**
             * Stringify the object
             * @method  stringify
             * @memberof module:xdk-base/util
             * @param {Object} obj Object to be stringified
             * @returns {String} the JSON string
             * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} if the object is not a valid JSON object
             * @public
             * @see the MDN {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify|JSON.stringify} documentation
             * @example <caption> To get the string format of the object</caption>
             * util.stringify({a: 1, b: "boy", c: 3});
             */
            stringify: function (obj) {
                // use the native stringify function if available
                if (root.JSON && root.JSON.stringify) {
                    return root.JSON.stringify(obj);
                }

                var results = [],
                    len, value, property, i;

                if (util.isDOMElement(obj)) {
                    throw core.createException(exception.ILLEGAL_ARGUMENT, "Coverting DOM element to JSON");
                }

                if (obj === null) {
                    return "null";
                }

                if (obj === undefined) {
                    return undefined;
                }

                if (util.isFunction(obj.toJSON)) {
                    return obj.toJSON();
                }

                if (util.isBoolean(obj) || util.isNumber(obj)) {
                    return obj.toString();
                }

                if (util.isString(obj)) {
                    return "\"" + obj.replace(/"/g, "\"") + "\"";
                }

                if (util.isArray(obj)) {
                    var arrayString = "[";

                    len = obj.length;

                    for (i = 0; i < len; i++) {
                        value = this.stringify(obj[i]);
                        arrayString += (util.isUndefined(value) ? null : value) + ",";
                    }

                    return arrayString.substring(0, arrayString.length - 1) + "]";
                }

                if (util.isPlainObject(obj)) {
                    for (property in obj) {
                        value = this.stringify(obj[property]);
                        if (!util.isUndefined(value)) {
                            results.push("\"" + property.toString() + "\":" + value);
                        }
                    }
                    return "{" + results.join(",") + "}";
                }

                return undefined;
            }
        };

    // set the JSON methods under util namespace
    util.parse = jsonModule.parse;
    util.stringify = jsonModule.stringify;

    //breaker will be used in the array and plainObject to break the loop in the each function
    util.breaker = {};

    //Array Part
    (function () {
        /**
         * Returns the first element of the array.
         * @method first
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to fetch element of
         * @return first element of the array. If it is not array or length is 0. null will be returned.
         * @public
         * @example  <caption> get the first item in the array</caption>
         * var arr = [1,3,5];
         * console.log(util.first(arr));
         * //log 1
         */
        util.first = function (arr) {
            if (!util.isArray(arr)) {
                throw core.createException("ArrayFirstError", "Type is not an array");
            }
            return arr[0];
        };
        /**
         * Returns the first index at which a given element can be found in the array, or -1 if it is not present.
         * IndexOf implementation for JS < 1.6.
         * @method indexOf
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to search in
         * @param {Object} item Item to search for
         * @param {Number} [i] Index to search from
         * @return {Number} first index at which element is found int he array or -1 if not present
         * @public
         * @example  <caption>get the item index from the array</caption>
         * var arr = [1,3,5];
         * console.log(util.indexOf(arr,3);
         * //log 1
         */
        util.indexOf = function (arr, item, i) {
            if (!util.isArray(arr)) {
                throw core.createException("ArrayIndexOfError", "Type is not an array");
            }

            //to use the default indexOf
            if (util.isFunction(Array.prototype.indexOf)) {
                return arr.indexOf(item, i);
            }

            if (!i) {
                i = 0;
            }
            var len = arr.length;
            if (i < 0) {
                i = len + i;
            }

            for (; i < len; i++) {
                if (arr[i] === item) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * Returns the last element of the array.
         * @method last
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to fetch element of
         * @return {Object} last element of the array or null when the length is 0 or it is not an array
         * @public
         * @example  <caption>get the item index from the array</caption>
         * var arr = [1,3,5];
         * console.log(util.last(arr);
         * //log 5
         */
        util.last = function (arr) {
            if (!util.isArray(arr)) {
                throw core.createException("ArrayLastError", "Type is not an array");
            }
            return arr[arr.length - 1];
        };
        /**
         * Returns the position of the last occurrence of "item" within the array or -1 if "item" doesn't exist in the array.
         * @method lastIndexOf
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to search in
         * @param {Object} item Item to search for
         * @param {Number} [i] Index to start searching from
         * @return {Number} last index of the item in the array or -1 if item does not exist
         * @public
         * @example <caption>Get the last index of 5</caption>
         * var ret = util.lastIndexOf([1, 3, 5, 7], 5);
         * //log 2
         * console.log(ret);
         */
        util.lastIndexOf = function (arr, item, i) {

            if (!util.isArray(arr)) {
                throw core.createException("ArrayLastError", "Type is not an array");
            }

            //use the browser default function
            if (util.isFunction(Array.prototype.lastIndexOf)) {
                if (util.isUndefined(i)) {
                    return arr.lastIndexOf(item);
                }
                return arr.lastIndexOf(item, i);
            }

            i = !util.isNumber(i) ? arr.length : (i < 0 ? arr.length + i : i) + 1;
            var n = this.indexOf(arr.slice(0, i).reverse(), item);
            return (n < 0) ? n : i - n - 1;
        };

        /**
         * Flatten out an array, either recursively (by default), or just one level.
         * @method flatten
         * @memberof module:xdk-base/util
         * @param {Array} arr An array to flatten
         * @param {Boolean} isDeep Flatten nested array or not
         * @return {Array} flatten array
         * @example
         *
         * util.flatten([1, 2, [3, [4]]])
         * // [1, 2, 3, [4]]
         *
         * util.flatten([1, 2, [3, [4]]], true)
         * // [1, 2, 3, 4]
         */
        util.flatten = function (arr, isDeep) {
            return baseFlatten(arr, isDeep, false);
        };

        /**
         * Returns the length of array. This is the same as calling arr.length
         * @method size
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to get size of
         * @return {Number} length of the array. -1 when it is not array
         * @public
         * @example <caption>get the size of the array</caption>
         * var ret = [1,3,5];
         * console.log(util.size(ret));
         * //log 3
         **/
        util.size = function (arr) {
            if (!util.isArray(arr)) {
                throw core.createException("ArraySizeError", "Type is not an array");
            }
            return arr.length;
        };
        /**
         * Removes all items of an Array from an index to another
         * /!\ Your array will be modified, not a copy of it
         * @method remove
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to work on
         * @param {Number} from Index from which we remove elements
         * @param {Number} [to] Index up to which we remove elements
         * @returns {Number} the resulting Array's length
         * @public
         * @example <caption>Remove the second item from the array [1,2,3] and array will become [1,3]</caption>
         * util.remove([1,2,3],1);
         * <caption>Remove the second-to-last item from the array [1,2,3,4] and array will become [1,2,4]</caption>
         * util.remove([1,2,3,4],-2);
         * <caption>Remove the second and third items  from the array [1,2,3,4,5] and array will become [1,4,5]</caption>
         *  util.remove([1,2,3,4,5],1,2);
         * <caption> Remove the last and second-to-last items from the array [1,2,3,4,5] and array will become [1,2,5]</caption>
         *  util.remove([1,2,3,4,5],-3,-2);
         */
        util.remove = function (arr, from, to) {
            if (!util.isArray(arr)) {
                throw core.createException("ArrayRemoveError", "Type is not an array");
            }
            if (from >= arr.length || (to && to >= arr.length)) {
                throw core.createException("ArrayRemoveError", "Range is out of the array length");
            }
            var rest = arr.slice((to || from) + 1 || arr.length);
            arr.length = from < 0 ? arr.length + from : from;
            return arr.push.apply(arr, rest);
        };

        /**
         * Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
         * @method reduce
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to work on
         * @param {Function} iter Iterator function
         * @param {Object} [initialValue] the first argument to the first call of the callback.
         * @public
         * @example <caption>To sum up all the value from left to right</caption>
         * util.reduce([0,1,2,3,4],
         *     function(previousValue, currentValue, index, array){
         *         return previousValue + currentValue;
         *     }
         * );
         */
        util.reduce = function (arr, iter, initialValue) {

            if (!util.isArray(arr)) {
                throw core.createException("ArrayReduceError", "Type is not an array");
            }

            iter = iter || function (x) {
                return x;
            };

            if (arr.length === 0) {
                return initialValue;
            }

            //to use the default some
            if (util.isFunction(Array.prototype.reduce)) {
                if (util.isUndefined(initialValue)) {
                    return arr.reduce(iter);
                }
                return arr.reduce(iter, initialValue);
            }

            if (!util.isFunction(iter)) {
                throw core.createException("ArrayReduceError", "iter is not a function");
            }

            var index = 0,
                length = arr.length,
                value, isValueSet = false;
            if (!util.isUndefined(initialValue)) {
                value = initialValue;
                isValueSet = true;
            }
            for (; length > index; ++index) {
                if (!arr.hasOwnProperty(index)) {
                    continue;
                }
                if (isValueSet) {
                    value = iter(value, arr[index], index, arr);
                } else {
                    value = arr[index];
                    isValueSet = true;
                }
            }
            return value;
        };
        /**
         * Apply a function against an accumulator and each value of the array (from right to left) as to reduce it to a single value.
         * @method reduceRight
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to work on
         * @param {Function} iter Iterator function
         * @param {Object} [initialValue] initialValue the first argument to the first call of the callback.
         * @public
         * @example <caption>To concate all the value from right to left</caption>
         * var ret = util.reduceRight(["a", "c", "c", "e", "d", "o"],
         *    function(previousValue, currentValue, index, array) {
         *        return previousValue + currentValue;
         *   }
         * );
         * console.log(ret);
         * //log "odecca"
         */
        util.reduceRight = function (arr, iter, initialValue) {

            if (!util.isArray(arr)) {
                throw core.createException("ArrayReduceRightError", "Type is not an array");
            }

            iter = iter || function (x) {
                return x;
            };

            //to use the default some
            if (util.isFunction(Array.prototype.reduceRight)) {
                if (util.isUndefined(initialValue)) {
                    return arr.reduceRight(iter);
                }
                return arr.reduceRight(iter, initialValue);
            }

            if (!util.isFunction(iter)) {
                throw core.createException("ArrayReduceRightError", "iter is not a function");
            }

            var length = arr.length,
                index = length - 1,
                value, isValueSet = false;
            if (!util.isUndefined(initialValue)) {
                value = initialValue;
                isValueSet = true;
            }
            for (; - 1 < index; --index) {
                if (!arr.hasOwnProperty(index)) {
                    continue;
                }
                if (isValueSet) {
                    value = iter(value, arr[index], index, arr);
                } else {
                    value = arr[index];
                    isValueSet = true;
                }
            }
            return value;
        };
        /**
         * Creates a new array with the results of calling a provided iterator function on every element in this array.
         * @method map
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to work on
         * @param {Function} iter Iterator function to call on every object
         * @param {Object} context Scope to bind everything to
         * @return {Array} New array with modified values
         * @public
         * @example <caption>Get the last index of 5</caption>
         * var ret = [1,3,5];
         * var newArray = util.map(ret,function(i){return i+2;});
         * console.log(newArray);
         * //[2,5,7];
         */
        util.map = function (arr, iter, context) {

            if (!util.isArray(arr)) {
                throw core.createException("ArrayMapError", "Type is not an array");
            }

            iter = iter || function (x) {
                return x;
            };

            //to use the default indexOf
            if (util.isFunction(Array.prototype.map)) {
                return arr.map(iter, context);
            }

            if (!util.isFunction(iter)) {
                throw core.createException("ArrayMapError", "iter is not a function");
            }

            var results = [];

            this.each(arr, function (value, index) {
                results.push(iter.call(context, value, index));
            });

            return results;
        };
        /**
         * Creates a new array with all elements that pass the test implemented by the provided iterator function.
         * For compatibility with JS 1.6 this also passes while array to iterator as 3rd argument
         * @method filter
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to search in
         * @param {Function} iter Iterator function to use for testing (returns true for pass, false for fail)
         * @param {Object} context Scope of the iterator
         * @return {Array} Elements that passed the test
         * @public
         * @example <caption> To iterate the function for every item in the array and
         * filter the items that satisfy the condition (is Number)</caption>
         * var arr = [1,2,"a",3];
         * var count = 0;
         * var ret = util.filter(arr, function(i){
         *  if(typeof i === "number"){
         *      return true;
         *  }
         *  return false;
         * });
         * //ret will be [1,2,3];
         * console.log(ret);
         */
        util.filter = function (arr, iter, context) {

            if (!util.isArray(arr)) {
                throw core.createException("ArrayFilterError", "Type is not an array");
            }

            iter = iter || function (x) {
                return x;

            };

            //to use the browser default
            if (util.isFunction(Array.prototype.filter)) {
                return arr.filter(iter, context);
            }

            if (!util.isFunction(iter)) {
                throw core.createException("ArrayFilterError", "iter is not a function");
            }

            var results = [];
            this.each(arr, function (value, index) {
                if (iter.call(context, value, index, arr)) {
                    results.push(value);
                }
            });

            return results;
        };
        /**
         * iterate over the array and return the first element that callback function returns turthy
         * @method findIndex
         * @memberof module:xdk-base/util
         * @param {Array} arr Array to search in
         * @param {Function} iter Iterator function to use for testing (returns true for pass, false for fail)
         * @param {Object} context Scope of the iterator
         * @return {Number} index of first found element
         * @example
         *
         * var characters = [
         *   { 'name': 'barney',  'age': 36, 'blocked': false },
         *   { 'name': 'fred',    'age': 40, 'blocked': true },
         *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
         * ];
         *
         * util.findIndex(characters, function(chr) {
         *   return chr.age < 20;
         * });
         * // 2
         */
        util.findIndex = function (arr, iter, context) {
            var index = -1,
                length = arr ? arr.length : 0;

            iter = iter || function (x) {
                return x;
            };

            while (++index < length) {
                if (iter.call(context, arr[index], index, arr)) {
                    return index;
                }
            }
            return -1;
        };
        /*
         * iterate over the array and return the first element that callback function returns turthy
         * @method find
         * @memberof module:xdk-base/util
         * @param {Array} arr Array to search in
         * @param {Function} iter Iterator function to use for testing (returns true for pass, false for fail)
         * @param {Object} context Scope of the iterator
         * @return {Number} first found element
         * @example
         *
         * var characters = [
         *   { 'name': 'barney',  'age': 36, 'blocked': false },
         *   { 'name': 'fred',    'age': 40, 'blocked': true },
         *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
         * ];
         *
         * util.find(characters, function(chr) {
         *   return chr.age < 20;
         * });
         * // { 'name': 'pebbles', 'age': 1,  'blocked': false }
         */
        util.find = function (arr, iter, context) {
            var index = util.findIndex(arr, iter, context);
            return index > -1 ? arr[index] : undefined;
        };
        /**
         * Tests whether some element in the array passes the test implemented by the provided iterator function.
         * @method some
         * @memberof  module:xdk-base/util
         * @param {Array} arr Array to work on
         * @param {Function} iter Iterator function to test with
         * @param {Object} context Scope to bind everything to
         * @return {Boolean} true if at least one object passes iterator test, false otherwise
         * @public
         * @example <caption>To check if the array contain any number</caption>
         * var arr = ["a","b","c",1];
         * var ret = util.some(arr,function(i){
         *      if(typeof i === "number"){
         *          return true;
         *      }
         *     return false;
         * });
         * console.log(ret);
         * //log: true
         */
        util.some = function (arr, iter, context) {

            if (!util.isArray(arr)) {
                throw core.createException("ArraySomeError", "Type is not an array");
            }

            iter = iter || function (x) {
                return x;
            };
            //to use the default some
            if (util.isFunction(Array.prototype.some)) {
                return arr.some(iter, context);
            }

            if (!util.isFunction(iter)) {
                throw core.createException("ArraySomeError", "iter is not a function");
            }

            var result = false;
            this.each(arr, function (value, index) {
                result = iter.call(context, value, index);
                if (result) {
                    return util.breaker;
                }
            }, this);
            return result;
        };
        /*
         * Retrieves the value of a specified property from all elements in the collection.
         * @method pluck
         * @memberof module:xdk-base/util
         * @param {Array.<Object>} arr collection of object
         * @param {String} propertyName The name of the property to pluck.
         * @return {Array} Array of property values
         * @example
         *
         * var characters = [
         *     { 'name': 'barney', 'age': 36 },
         *     { 'name': 'fred',   'age': 40 }
         * ];
         *
         * util.pluck(characters, 'name');
         * // ['barney', 'fred']
         */
        util.pluck = function (arr, propertyName) {
            var mapper = function (obj) {
                return (propertyName === null) ? undefined : obj[propertyName];
            };
            return util.map(arr, mapper);
        };
        /*
         * Return a copy of the object only containing the whitelisted properties.
         * @method pick
         * @memberof module:xdk-base/util
         * @param {Object} obj An plain object
         * @param {Function|...String|String[]} iter Iteratee or property keys
         * @param {Object} context The this binding of iter function
         * @return {Object} a copy of the object only containing the whitelisted properties.
         * @example
         *
         * util.pick({ "name": "fred", "_userid": "fred" }, "name");
         * // { "name": "fred" }
         *
         * util.pick({ "name": "fred", "_userid": "fred" }, "name", "_userid");
         * // { "name": "fred", "_userid": "fred" }
         *
         * util.pick({ "name": "fred", "_userid": "fred" }, ["name", "_userid"]);
         * // { "name": "fred", "_userid": "fred" }
         *
         * util.pick({ "name": "fred", "_userid": "fred1" }, function(value, key) {
         *     return key.charAt(0) != "_";
         * })
         */
        util.pick = function (obj, iter, context) {
            var result = {},
                key;
            if (obj === null) {
                return result;
            }
            if (util.isFunction(iter)) {
                for (key in obj) {
                    var value = obj[key];
                    if (iter.call(context, value, key, obj)) {
                        result[key] = value;
                    }
                }
            } else {
                var keys = baseFlatten(arguments, false, false, 1);
                obj = new Object(obj);
                for (var i = 0, length = keys.length; i < length; i++) {
                    key = keys[i];
                    if (key in obj) {
                        result[key] = obj[key];
                    }
                }
            }
            return result;
        };
    }());

    //plainObject part
    (function () {
        /**
         * Returns an array of keys.
         * @method keys
         * @memberof module:xdk-base/util
         * @param {Object} object Object to check
         * @return {Array} an array contain all keys
         * @public
         * @example <caption> To return the keys of the object</caption>
         * util.keys({"1": "studing", "studied": "false", "hong": "kong"});
         * It will return ["1", "studied", "hong"];
         */
        util.keys = function (object) {
            var results = [],
                property;

            // use native keys function
            if (util.isFunction(Object.keys)) {
                return Object.keys(object);
            }

            for (property in object) {
                if (object.hasOwnProperty(property)) {
                    results.push(property);
                }
            }
            return results;
        };

        /**
         * Returns the debug-oriented string representation of the object
         * @method inspect
         * @memberof module:xdk-base/util
         * @param {Object} object object need to be inspected
         * @return {String} string representation of the object
         * @public
         * @example <caption>To get all the information about the object object </caption>
         * var obj = {"mon":"13/5","tue":14,"wed":15,"thurs":"diecisiete","fri":"eighteen"};
         * console.log(util.inspect(obj));
         * //log "#<object:{mon:13/5, tue:14, wed:15, thurs:diecisiete, fri:eighteen}>"
         * empty object will be "#<object:{}"
         */
        util.inspect = function (object) {
            var result, keys = this.keys(object),
                values = this.values(object),
                i, length = keys.length;
            result = "#<object:{";
            if (length === 0) {
                return result + "}>";
            }
            for (i = 0; i < length; i++) {
                result = result + keys[i] + ":" + values[i] + ", ";
            }
            result = result.substr(0, result.length - 2) + "}>";
            return result;
        };

        /**
         * Returns an array of values.
         * Note: Key order is depending on JS implementation
         * @method values
         * @memberof module:xdk-base/util
         * @param {Object} object Object to get the values
         * @return {Array} Values of this object
         * @public
         * @example <caption> To get the values of the obejct </caption>
         * util.values({a:1, b:2, c:3}); -> [1,2,3]
         */
        util.values = function (object) {
            var v = [],
                key;
            for (key in object) {
                v.push(object[key]);
            }
            return v;
        };
        /**
         * Returns a URL-encoded string containing the object's contents as query parameters.
         * @method toQueryString
         * @memberof module:xdk-base/util
         * @param {Object} object object Object to querystring
         * @return {String} key-value pairs represented as a querystring
         * @public
         * @example <caption>To change into the query string and usually for the ajax</caption>
         *  util.toQueryString({action: "ship",
         *      order_id: 123,
         *      fees: ["f1", "f2"]
         *  })-> "action=ship&order_id=123&fees=f1&fees=f2"
         *
         *  util.toQueryString({comment: "",
         *      "key with spaces": true,
         *      related_order: undefined,
         *      contents: null,
         *      "label": "a demo"
         *  }); // -> "comment=&key%20with%20spaces=true&related_order&contents=&label=a%20demo"
         *
         *  // an empty object is an empty query string:
         *  util.toQueryString(); // -> ""
         */
        util.toQueryString = function (object) {
            var results = [],
                __toQueryPair;
            /**
             * Converts a key/value pair to a query pair in the form of "key=value"
             * @param {String} key the key
             * @param {Object} value the value
             * @private
             */
            __toQueryPair = function (key, value) {
                if (util.isUndefined(value)) {
                    return key;
                }
                return (key + "=" + encodeURIComponent((value === null) ? "" : String(value)));
            };
            util.each(object, function (pair) {
                var key = encodeURIComponent(pair.key),
                    values = pair.value,
                    i, len, value, queryValues;
                if (values && typeof values === "object") {
                    if (util.isArray(values)) {
                        i = 0;
                        len = values.length;
                        queryValues = [];
                        for (; i < len; i++) {
                            value = values[i];
                            queryValues.push(__toQueryPair(key, value));
                        }
                        results = results.concat(queryValues);
                    }
                } else {
                    results.push(__toQueryPair(key, values));
                }

            }, this);
            return results.join("&");
        };

        /*
         * Check if an object has a given property directly
         * @method has
         * @memberof module:xdk-base/util
         * @param {Object} obj An plain object
         * @param {String} key Property name
         * @return {Boolean} whether object has the property
         * @public
         * @example
         * util.has({"a":1,"b":2},"a");
         * //true
         */
        util.has = function (obj, key) {
            return obj !== null && hasOwnProperty.call(obj, key);
        };
    }());

    //Share part between array and plainObject
    (function () {
        var checkType = function () {
            if (util.isArray(arguments[0])) {
                return true;
            }
            if (util.isPlainObject(arguments[0])) {
                return false;
            }

            throw core.createException("Exception", "No such related function of the type" + typeof arguments[0]);
        };
        /**
         * Clears the array/object (makes it empty) and returns the array/object reference.
         * @method clear
         * @memberof  module:xdk-base/util
         * @param {Array|Object} target Targeted object or array want to clear
         * @return {Array|Object} array/object reference.
         * @public
         * @example <caption> To clear up the array and return the array e</caption>
         * var arr = [1,3,5];
         * util.clear(arr);
         * console.log(arr);
         * //[]
         *
         * var obj = {a:1,b:2,c:3};
         * util.clear(obj);
         * console.log(obj);
         * //{}
         */
        util.clear = function (target) {
            var obj, i, arr, len, keys;
            //array
            if (checkType(target)) {
                arr = target;
                arr.length = 0;
                return arr;
            }
            //object
            obj = target;
            i = 0;
            keys = util.keys(obj);
            len = keys.length;
            for (; i < len; i++) {
                delete obj[keys[i]];
            }
            return obj;
        };
        /**
         * Iterates array/object and for each item calls iterator function, with given context.
         * To break the loop, throw {@link xdk-base/util.breaker}
         * @method each
         * @memberof  module:xdk-base/util
         * @param {Array|Object} target Array/Object to iterate
         * @param {Function} iter Iterator function
         * @param {Object} context A context to bind iterator to
         * @public
         * @example <caption> To iterate the function for each item in the array</caption>
         * //array
         * var arr = [1,2,3];
         * var arr1 = util.each(arr, function(i){console.log(i);});
         *
         * //object
         *  var string = "";
         * var count = 0;
         * util.each({a:1,b:2,c:3},function(pair){
         *  string += pair.key;
         *  count += pair.value;
         * });
         * <caption>To stop when reach "b", we return util.breaker to end the each function </caption>
         * util.each({a:1,b:2,c:3},function(pair){
         *     if(pair.key === "b"){
         *         return util.breaker;
         *     }
         * });
         */
        util.each = function (target, iter, context) {
            var arr, i, len, key, value, pair, object;
            iter = iter || function (x) {
                return x;
            };
            if (!util.isFunction(iter)) {
                throw core.createException("EachError", "iter is not a function");
            }
            if (checkType(target)) {
                arr = target;

                // it is not possible to break a forEach natively, so we use some function instead
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
                if (util.isFunction(Array.prototype.some)) {
                    arr.some(function () {
                        // workaround, check if util.breaker is returned from iter function
                        return (iter.apply(context, arguments) === util.breaker);
                    }, context);
                    return;
                }

                i = 0;
                len = arr.length;
                for (; i < len; i++) {
                    if (iter.call(context, arr[i], i, arr) === util.breaker) {
                        return;
                    }
                }
                return;
            }
            object = target;
            for (key in object) {
                value = object[key];
                pair = [key, value];
                pair.key = key;
                pair.value = value;
                if (iter.call(context, pair) === util.breaker) {
                    return;
                }
            }

        };
        /**
         * Tests whether all elements in the array/object pass the test implemented by the provided iterator function
         * @method every
         * @memberof  module:xdk-base/util
         * @param {Array|Object} target Array to loop through
         * @param {Function} iter Iterator function
         * @param {Object} context A context to bind iterator to
         * @return {Boolean} true if every element passes the test, false otherwise
         * @public
         * @example <caption> To iterate the function for every item in the array and check if all the items are number</caption>
         * var arr = [1,2,"a",3];
         * var obj = {"a":1, b:"a", "c": 5, "d":"b"};
         * var typeCheck = function(i){
         *  if(typeof i === "number"){
         *      return true;
         *  }
         *  return false;
         * }
         *
         * //array
         * var ret = util.every(arr, typeCheck);
         * //ret will be false as not all the number is number
         * console.log(ret);
         *
         * //object
         * var ret = util.every(obj, typeCheck);
         * //false since not all the values are number
         *
         */
        util.every = function (target, iter, context) {
            var arr, result,
                isArray = false;

            iter = iter || function (x) {
                return x;
            };

            if (checkType(target)) {
                isArray = true;
                //array case

                //to use the browser default
                if (util.isFunction(target.every)) {
                    return target.every(iter, context);
                }
            }

            result = true;

            //plain object case and array without array.every function
            this.each(target, function (value, index) {

                if (!isArray) {
                    value = value.value;
                }

                result = result && !!iter.call(context, value, index, arr);
                //Stop execution and break directly in the each function
                if (!result) {
                    return util.breaker;
                }
            }, this);
            return result;
        };
        /**
         * Determine if the array or object contains a given value (using `===`).
         * @method contains
         * @memberof module:xdk-base/util
         * @param {Array|Object} arr Collection
         * @param {String|Number|Object} target Value
         * @return {Boolean} contain the value or not
         * @example
         *
         * util.contains([1, 2, 3], 1);
         * // true
         
         * util.contains({"a":1,"b":2, "c":3}, 1);
         * // true
         */
        util.contains = function (arr, target) {
            if (arr === null) {
                return false;
            }
            if (arr.length !== +arr.length) {
                arr = util.values(arr);
            }
            return util.indexOf(arr, target) >= 0;
        };

    }());
    return util;
});
/**
 * Interface emulation for javascript. Provider a helper funciton to create Interface as well as a
 * ensure function to do implementation check.
 *
 * *NOTE* The constructor is a private. Use {@link xdk-base/Interface.create}.
 *
 * @class xdk-base/Interface
 * @param {String} name Name of the interface
 * @param {xdk-base/Interface[]} exts List of extended interfaces
 * @param {Object} methods Map of methods declared
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-base/Interface", ["xdk-base/util", "xdk-base/core"], function (util, core) {
    "use strict";
    var __creating = false;

    function Interface(name, exts, methods) {
        if (!__creating) {
            throw core.createException("PrivateConstructor", "Use Interface.create instead");
        }
        this.name = name;
        this.exts = exts || [];
        this.methods = methods || {};
    }

    Interface.prototype.toString = function () {

        var fnName,
            ret = "Interface " + this.name + " : { ";
        for (fnName in this.methods) {
            ret += this.printFn(fnName);
        }
        ret += " }";

        return ret;
    };

    Interface.prototype.printFn = function (fnName) {
        return fnName + "(" + this.methods[fnName].join() + ")";
    };

    /**
     * @ignore
     */
    function isInterface(intf) {
        return (intf instanceof Interface);
    }

    /**
     * Create an Interface
     * @name create
     * @param {String} name Name for the new Interface. Usually the module id of the AMD.
     * @param {xdk-base/Interface[]} [exts] Extended interfaces
     * @param {Object} methods List of methods to be declared
     * @function
     * @public
     * @memberof xdk-base/Interface
     */
    function create() {

        if (arguments.length < 2) {
            throw core.createException("InvalidArgument", "intf.create called with " + arguments.length + "arguments, but expected at least 2.");
        }

        var args = Array.prototype.slice.call(arguments),
            name,
            exts,
            methods,
            ret,
            i, len, fnName;

        name = args.shift();
        if (!util.isString(name)) {
            throw core.createException("InvalidArgument", "intf.create: expects the first argument to be String");
        }


        // First arguments to be extended Interfaces
        if (args.length > 1) {
            exts = args.shift();

            if (!exts || !util.isArray(exts)) {
                throw core.createException("InvalidArgument", "intf.create: expects the second argument of three provided as an array");
            }

            for (i = 0, len = exts.length; i < len; i++) {
                if (!isInterface(exts[i])) {
                    throw core.createException("InvalidArgument", "intf.create: expects the first argument array contains only interfaces");
                }
            }
        }

        methods = args.shift();

        if (!methods || !util.isPlainObject(methods)) {
            throw core.createException("InvalidArgument", "intf.create: expects an Object for the last argument");
        }

        util.each(methods, function (pair) {

            fnName = pair.key;

            if (!util.isArray(pair.value)) {
                throw core.createException("InvalidArgument", "intf.create: expects method param list to be passed in as an array.");
            }

            for (i = 0, len = pair.value.length; i < len; i++) {
                if (!util.isString(pair.value[i])) {
                    throw core.createException("InvalidArgument", "intf.create: expects method param to be passed in as a string.");
                }
            }
        });

        __creating = true;
        ret = new Interface(name, exts, methods);
        __creating = false;

        // create an interface
        return ret;
    }

    /**
     * Ensure an Class implements an Interface. Class should implement the same function name with equal or larger number of arguments in order to fulfil the interface.
     * @name ensureImpl
     * @param {xdk-base/Class} klass The Class to check
     * @param {xdk-base/Interface} intf the Interface to ensure
     * @function
     * @public
     * @memberof xdk-base/Interface
     **/
    function ensureImpl(klass, intf) {

        var i, len, params, fnExist, fn, prototype, fnName;

        //Check extended interfaces
        if (intf.exts) {

            for (i = 0, len = intf.exts.length; i < len; i++) {
                ensureImpl(klass, intf.exts[i]);
            }

        }

        //check this interface
        util.each(intf.methods, function (pair) {
            fnName = pair.key;
            params = pair.value;
            prototype = klass.prototype;
            fnExist = false;


            while (!fnExist && prototype) {

                if (prototype[fnName] && util.isFunction(prototype[fnName])) {

                    //get the orig function if it's been super injected
                    fn = prototype[fnName].isSuperWrapper ? prototype[fnName].orig : prototype[fnName];

                    // Check arguments length
                    if (fn.length >= intf.methods[fnName].length) {
                        fnExist = true;
                    }
                }

                prototype = prototype.prototype;
            }

            if (!fnExist) {
                throw core.createException("InterfaceViolation", "intf.ensureImpl: object does not implement the " + intf.name + " interface. Method " + intf.printFn(fnName) + " was not found.");
            }

        });

    }

    Interface.create = create;
    Interface.ensureImpl = ensureImpl;

    return Interface;
});
/**
 * Simulate class inheritance using javascript's prototypical inheritance
 * @module xdk-base/class
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-base/class", ["xdk-base/util", "xdk-base/core", "xdk-base/Interface", "require"], function (util, core, Interface, require) {
    "use strict";
    var classModule, IS_DONTENUM_BUGGY = true,
        p,
        inheriting = false,
        // Internal extend utility function
        extendFn = function(destination, source) {
            var k, value;
            for (k in source) {
                value = source[k];
                // if is a plain object or array, do not share the reference, use a clone instead
                if (util.isArray(value)) {
                    destination[k] = value.slice();
                    continue;
                }
                if (util.isPlainObject(value)) {
                    destination[k] = util.clone(value, true);
                    continue;
                }
                destination[k] = value;
            }
        },
        // Utility function to only copy over objects and arrays
        copyObjectFn = function(destination, source) {
            var k, value;
            for (k in source) {
                value = source[k];
                // if is a plain object or an array, do not share the reference, use a clone instead
                if (util.isArray(value)) {
                    destination[k] = value.slice();
                    continue;
                }
                if (util.isPlainObject(value)) {
                    destination[k] = util.clone(value, true);
                    continue;
                }
            }
        },
        emptyFn = function() {},

        create, addMethods, addStaticMethods, createAbstract, isAbstract,
        /**
         * Reference function for absract function declaration
         * @memberof module:xdk-base/class
         * @method abstractFn
         * @public
         */
        abstractFn = function() {
            var console = require("xdk-base/console"),
                core = require("xdk-base/core");
            console.error("Abstract function called!");
            throw core.createException("AbstractMethodInvoked",
                "Abstract method called! This method must be implemented in subclass!");
        };

    for (p in {
        toString: 1
    }) {
        if (p === "toString") {
            IS_DONTENUM_BUGGY = false;
        }
    }

    /**
     * Add/Overload class members
     * @memberof module:xdk-base/class
     * @deprecated
     * @function addMethods
     * @param {Object} source Members to be added to current class
     * @param {Boolean} isStatic Whether the members are static or instance memebers
     * @return {Class}
     */
    addMethods = function(klass, source, isStatic) {
        var ancestor = isStatic ? klass._superclass : klass._superclass && klass._superclass.prototype,
            i, length, property, value, origMethod, injectSuper, properties = util.keys(source);

        if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
                properties.push("toString");
            }
            if (source.valueOf !== Object.prototype.valueOf) {
                properties.push("valueOf");
            }
        }
        injectSuper = function(name, fn) {
            var _injected = function() {
                var ret, temp = this._super;
                // Add a new ._super() method that is the same method
                // but on the super-class
                this._super = ancestor[name];

                // fail-over incase ancestor has no such method
                if (!util.isFunction(this._super)) {
                    this._super = emptyFn;
                }

                // The method only need to be bound temporarily, so we
                // remove it when we're done executing
                ret = fn.apply(this, arguments);
                if (temp) {
                    this._super = temp;
                } else {
                    delete this._super;
                }

                return ret;
            };

            // add introspection for interface impl. checking
            _injected.isSuperWrapper = true;
            _injected.orig = fn;

            return _injected;
        };
        for (i = 0, length = properties.length; i < length; i++) {
            property = properties[i];
            value = source[property];

            if (ancestor && util.isFunction(value)) {
                origMethod = value;
                value = injectSuper(property, origMethod);
                value.valueOf = util.bind(origMethod.valueOf, origMethod);
                value.toString = util.bind(origMethod.toString, origMethod);
            }

            if (isStatic) {
                klass[property] = value;
            } else {
                klass.prototype[property] = value;
            }
        }
        return klass;
    };

    /**
     * Add/Override static members
     * @memberof module:xdk-base/class
     * @deprecated
     * @function addStaticMethods
     * @param {Object} source Static members to be added to current class
     * @returns {Class}
     */
    addStaticMethods = function(klass, source) {
        return addMethods(klass, source, true);
    };


    function classCreate() {
        var Parent = null,
            args = Array.prototype.slice.call(arguments),
            intfs = [],
            statics = null,
            members = null,
            console;

        if (util.isFunction(args[0])) {
            Parent = args.shift();
        }

        // get the interfaces declaration
        if (util.isArray(args[0])) {
            intfs = args.shift();
        }

        // get static members declaration
        statics = args.shift();

        if (!util.isPlainObject(statics) && !util.isFunction(statics)) {
            console = require("xdk-base/console");
            console.error("Static members parameter must be an object or a function!");
            throw core.createException("IncorrectParam",
                "Static members parameter must be an object or a function!");
        }

        // get instance members declaration
        members = args.shift();

        function klass() {
            /*jshint validthis:true */
            if (!(this instanceof klass)) {
                var console = require("xdk-base/console");
                console.error(
                    "Please use \'new\' operator! This is a class constructor function, it cannot be called directly!"
                );
                throw core.createException("IncorrectInvocation",
                    "Please use \'new\' operator! This is a class constructor function, it cannot be called directly!"
                );
            }

            if (!inheriting) {
                copyObjectFn(this, klass.__defaults);
                this.init.apply(this, arguments);
            }
        }

        if (Parent) {
            extendFn(klass, Parent); // inherit parent's static members
            inheriting = true;
            klass.prototype = new Parent();
            inheriting = false;
            // not to reference the same object for different classes
            copyObjectFn(klass.prototype, Parent.prototype);
        } else {
            extendFn(klass, classModule.methods); // bring in basic static memebers
        }

        klass._superclass = Parent;

        //add statics methods
        if (util.isFunction(statics)) {
            statics = statics.apply(null);
        }
        addStaticMethods(klass, statics);

        //Add memebers
        if (util.isFunction(members)) {
            members = members.apply(null);
        }

        if (members) {
            addMethods(klass, members);
            // save up instance default values of objects and arrays
            klass.__defaults = {};
            copyObjectFn(klass.__defaults, klass.prototype); // inherited defaults
            copyObjectFn(klass.__defaults, members); // overriden defaults
        }
        if (!members) {
            throw core.createException("IncorrectParam", "Instance memebers are not provided!");
        }

        if (!klass.prototype.init) {
            klass.prototype.init = emptyFn;
        }

        klass.prototype.constructor = klass;

        if (util.isFunction(klass.prototype.deinit)) {
            klass.prototype.destructor = klass.prototype.deinit;
        }

        //add the interface
        klass.intfs = intfs;

        if (util.isFunction(klass.main)) {
            klass.main();
        } else if (!klass.main) {
            klass.main = emptyFn;
        }

        //add the parent interface
        if (Parent && Parent.intfs && Parent.intfs.length > 0) {
            klass.intfs = klass.intfs.concat(Parent.intfs);
        }

        return klass;
    }
    /**
     * Creates a class and returns a constructor function for instances
     * of the class. Calling the constructor function (typically as part of a new
     * statement) will invoke the class's init method.
     *
     * If a subclass overrides an instance method declared in a superclass, the
     * subclass's method can still access the original method. To do so, call
     * this._super which is available within the overrided method.
     *
     *
     * To extend a class after it has been defined, use {@link module:xdk-base/class.addMethods}.
     *
     * @name create
     * @memberof module:xdk-base/class
     * @function create
     * @param {Class} [parentClass] Parent class to inherit from.
     * @param {xdk-base/Interface[]} {interfaces} Interfaces to implement.
     * @param {Object} staticMember Static members of the class. For function, it will be executed and
     *  the returned object will be used.
     * @param {Object} [instanceMember] Instance members of the class. For function, it will be executed and
     *  the returned object will be used.
     * @return {Class} the created class' constructor
     * @example
     * klass.create(ParentClass, [
     *        "MyInterface1",
     *        "MyInterface2"
     * ],
     * {
     * // Static declarations
     *      ...
     * },{
     * // Member declarations
     *
     *      //constructor method
     *      init:function(opts) {
     *
     *          this._super(opts); //calling super class method
     *      }
     * });
     */
    /**
     * Stop NetBeans from complaining
     * @ignore
     */
    create = function() {
        var klass, i, parent;

        //normal class create
        klass = classCreate.apply(this, arguments);

        parent = klass._superclass;

        //ensure interface implmentation
        if (klass.intfs) {
            for (i = 0; i < klass.intfs.length; i++) {
                Interface.ensureImpl(klass, klass.intfs[i]);
            }
        }

        klass.__abstract = false;

        return klass;
    };
    /**    
     * create an abstract class. The different between create and createAbstract is abstract class won't check if any abstract function
     * or interface that not implement. The class inherit from abstract class need to implement all the abstractFn from the abstract class.
     * Otherwise, error will be thrown.
     * @name createAbstract
     * @memberof module:xdk-base/class
     * @function
     * @param {Class} [parentClass] Parent class to inherit from.
     * @param {xdk-base/Interface[]} {interfaces} Interfaces to implement.
     * @param {Object} staticMember Static members of the class. For function, it will be executed and
     *  the returned object will be used.
     * @param {Object} [instanceMember] Instance members of the class. For function, it will be executed and
     *  the returned object will be used.
     * @return {Class} the created class' constructor
     * @example
     * klass.createAbstract(ParentClass, [
     *        "MyInterface1",
     *        "MyInterface2"
     * ],
     * {
     * // Static declarations
     *      ...
     * },{
     * // Member declarations
     *
     *      //constructor method
     *      init:function(opts) {
     *
     *          this._super(opts); //calling super class method
     *      }
     * });
     */
    createAbstract = function() {
        var klass = classCreate.apply(this, arguments);

        klass.__abstract = true;

        return klass;
    };
    /**    
     * check if current class is abstract
     * @name isAbstract
     * @method
     * @param {xdk-base/Class} klass the Class to check
     * @returns {Boolean} True if it is abstract class
     * @memberof xdk-base/Class
     */
    isAbstract = function(klass) {
        return klass.__abstract;
    };
    /**    
     * Check if a Class has implemented an Interface
     * @name hasImpl
     * @method
     * @param {xdk-base/Class} klass the Class to check
     * @param {xdk-base/Interface} intf the Interface to look for
     * @memberof xdk-base/Class
     */
    function hasImpl(klass, intf) {

        /**
         * @ignore
         */
        function checkIntfs(implIntfs) {

            var ret = false;

            util.each(implIntfs, function(implIntf) {

                if (implIntf === intf) {
                    ret = true;
                    return util.breaker;
                }

                if (checkIntfs(implIntf.exts)) {
                    ret = true;
                    return util.breaker;
                }

            });

            return ret;

        }

        var anctrKlass = klass,
            hasIntf = false;

        while (anctrKlass) {
            if (checkIntfs(anctrKlass.intfs, intf)) {
                hasIntf = true;
                break;
            } else {
                anctrKlass = anctrKlass._superclass;
            }
        }

        return hasIntf;

    }

    classModule = {
        create: create,
        addMethods: addMethods,
        addStaticMethods: addStaticMethods,
        abstractFn: abstractFn,
        hasImpl: hasImpl,
        createAbstract: createAbstract,
        isAbstract: isAbstract
    };

    return classModule;
});
/**
 * Utility class on the query strings of current URL.  
 *
 * @class xdk-base/QueryString
 * @since 2.1
 * @author Marco Fan <marco.fan@accedo.tv>
 * @param {String} [url=window.location.href] The url used to parse the query string. Query string with leading "?" sign are also accepted.
 * @example
 * var queryString = new QueryString("http://127.0.0.1/queryStringExample?a=1");
 * var anotherQueryString = new QueryString("?a=1");
 */
define("xdk-base/QueryString", ["xdk-base/class", "xdk-base/util"], function (klass, util) {
    "use strict";    
    return klass.create({
        /**
         * Extracts the parameters from the specified query string to a key-value paired object.  
         * 
         * @function parse
         * @static
         * @memberof xdk-base/QueryString
         * @param {String} queryString The query string to be processed
         * @returns {Object} An string-string key-value paired object
         * @example
         * var queryString = new QueryString("http://127.0.0.1/queryStringExample?a=1&b=2"),
         *     strQueryString = queryString.getQueryString(); // "a=1&b=2"
         * 
         * QueryString.parse(strQueryString); // {"a": "1", "b": "2"}
         */
        parse : function(queryString) {
            if (!queryString || !util.isString(queryString)) {
                return {};
            }

            var pairs,
                matches,
                params = {},
                i,
                length;

            // each pair falls into the set {"_key_", "_key_=", "_key_=_value_"}
            pairs = queryString.split("&");

            for (i = 0, length = pairs.length; i < length; i++) {
                matches = pairs[i].match(/^([^=]+)=?(.*)$/);

                if (matches) {
                    params[matches[1]] = matches[2];
                }
            }

            return params;
        }
    }, {
        /**
         * The parameters extracted from the uri.
         * @prop __parameters
         * @private
         * @memberof xdk-base/QueryString#
         */
        __parameters: [],

        /**
         * The query string in string format.
         * @prop __queryString
         * @private
         * @memberof xdk-base/QueryString#
         */
        __queryString: "",

        /* Constructor of QueryString, which initiate the query string instance. */
        init: function(url) {
            if (!url) {
                url = window.location.href;
            }

            var matches;

            // extract the query string from the url
            matches = url.match(/^([^?]*)\?(.*)$/);
            if (!matches) {
                this.__queryString = "";
            } else {
                this.__queryString = matches[2];
            }

            this.__parameters = this.constructor.parse(this.__queryString);
        },

        /**
         * Retrieves the value of a parameter in the query string using a specified key.  
         * 
         * @function getValue
         * @public
         * @memberof xdk-base/QueryString#
         * @param {String} key The key of the parameter to ask for
         * @returns {String} Mapped value of the key, or null if none exists
         * @example
         * var queryString = new QueryString("http://127.0.0.1/queryStringExample?a=1&b=2");
         * 
         * queryString.getValue("a"); // "1"
         * queryString.getValue("c"); // null
         */
        getValue : function(key) {
            // every parameter should be a string-string key-value pair
            if (util.isString(this.__parameters[key])) {
                return this.__parameters[key];
            }

            return null;
        },

        /**
         * Retrieves the query string, where the result is processed by the options.  
         * The result can be altered to exclude some parameters, and/or be overrided. 
         * Whenever they have conflict, exclusion dominates overriding.  
         * Note:  
         * - the sequence of the parameters may not be preserved  
         * - the query string is not url encoded, if the input was not
         * 
         * @function getQueryString
         * @public
         * @memberof xdk-base/QueryString#
         * @param {Object} [options] An option object
         * @param {Object} [options.exclude] An array that specified a list of parameters to exclude from the result
         * @param {Object} [options.extendFrom] An object that extends the final result should extend from. Eventally this will overrides some parameters.
         * @returns {String} The constructed query string without the leading "?" sign
         * @example
         * var queryString = new QueryString("http://127.0.0.1/queryStringExample?a=1&b=2");
         * 
         * queryString.getQueryString(); // "a=1&b=2"
         * // exclude __a__
         * queryString.getQueryString({"exclude": ["a"]}); // "b=2"
         * // override __a__
         * queryString.getQueryString({"extendFrom": {"a": "lower_a"}}); // "a=lower_a&b=2"
         * // exclude __a__ & override __c__
         * queryString.getQueryString({"exclude": ["a"], "extendFrom": {"c": "lower_c"}}); // "b=2&c=lower_c"
         */
        getQueryString: function(options) {
            if (!util.isObject(options)) {
                // don't have to modifying anything, return the orignal query string
                return this.__queryString;
            }

            var params,
                queryString = "",
                key,
                exclude;

            // create a clone to prevent modication from the original copy
            params = util.clone(this.__parameters);

            // extend the resultant parameters from the _extendFrom_ option
            if (util.isObject(options.extendFrom)) {
                params = util.extend(params, options.extendFrom);
            }

            // exclude the parameters
            if (util.isArray(options.exclude)) {
                exclude = options.exclude;

                for (key in params) {
                    // if key exists in _exclude_, remove it from _params_
                    if (util.indexOf(exclude, key) !== -1) {
                        if (params.hasOwnProperty(key)) {
                            delete params[key];
                        }
                    }
                }
            }

            // make a query string from the parameters
            for (key in params) {
                queryString += key + "=" + params[key] + "&";
            }

            // remove the trailing "&"
            if (queryString.length > 0) {
                queryString = queryString.substring(0, queryString.length - 1);
            }

            return queryString;
        },

        /**
         * Extracts the parameters from this query string to a key-value paired object.  
         * 
         * @function toObject
         * @memberof xdk-base/QueryString#
         * @returns {Object} An string-string key-value paired object
         * @example
         * var queryString = new QueryString("http://127.0.0.1/queryStringExample?a=1&b=2");
         * 
         * queryString.toObject(); // {"a": "1", "b": "2"}
         */
        toObject: function() {
            return this.__parameters;
        }
    });
});
/* global readFile: true */
/**
 * A JSON loader plugin that is responsible to load JSON files.
 * Parameters can be specified in the definition separated using pipe character (|) to control the load. Configurable behaviors include failover and timeout.
 * To enable failover, specify failover=true. To define a timeout period other than the default (8 seconds), use waitSeconds=[number-of-seconds].
 * @module json
 * @example
 * // load a local json file
 * require(["json!app/config.json"], function (config) {
 *     // utilize the config
 *     console.log(config.ovpApi);
 * });
 *
 * // load an external json file
 * // amd.config.js
 * require({
 *     baseUrl: "js/",
 *     paths: {
 *         remote: "http://xdk.demo.accedo.tv/test"
 *     }
 * });
 *
 * // in app
 * // the location will be resolved as http://xdk.demo.accedo.tv/test/config.json
 * require(["json!remote/config.json"], function (config) {
 *     // utilize the config
 *     console.log(config.ovpApi);
 * });
 *
 *
 * // allowing failover (return empty object instead of throw exception)
 * require(["json!failover=true|remote/config.json"], function (config) {
 *     // give us {} if remote/config.json does not exist
 *     console.log(config); // {}
 * });
 *
 * // allowing failover (return empty object instead of throw exception)
 * require(["json!waitSeconds=4|remote/config.json"], function (config) {
 *     // will be invoked if can be loaded
 * }, function (reason) {
 *     // will be invoked after 4 seconds timeout
 * });
 *
 * // multiple parameters, in a format of query string
 * require(["json!failover=true&waitSeconds=4|remote/config.json"], function (config) {
 *     // give us {} if remote/config.json does not exist
 * }, function (reason) {
 *     // will be invoked after 4 seconds timeout
 * });
 */
define("json", ["xdk-base/util", "xdk-base/QueryString"], function (util, QueryString) {

    "use strict";

    var exports = {
            /**
             * If the plugin has a dynamic property set to true, then it means
             * the loader MUST NOT cache the value of a normalized plugin dependency,
             * instead call the plugin's load method for each instance of a plugin dependency.
             * @property {Boolean} dynamic
             * @memberof module:json
             */
            dynamic: false
        },

        // regex for string representing network resource
        REGEX_IS_EXTERNAL = /^(\/\/)|([^:]+:\/\/)/,

        // delimiter for loader parameter
        PARAM_DELIMITER = "|",

        // dummy function
        DUMMY_FUNCTION = function () {},

        // timeout period
        waitSeconds = 8,

        // template for module definition
        MODULE_ID_PLACEHOLDER = "%MODULE_ID%",
        MODULE_CONTENT_PLACEHOLDER = "%MODULE_CONTENT%",
        DEFINE_TEMPLATE = "define('" + MODULE_ID_PLACEHOLDER + "'," + MODULE_CONTENT_PLACEHOLDER + ")",

        // build config
        configuration = {},

        // loaded json
        jsonContent = {};


    /**
     * Get a valid transport object for ajax request.
     * @method
     * @private
     * @returns {Object} The transport object
     * @memberof module:json
     */
    function getTransport() {
        return new XMLHttpRequest();
    }

    /**
     * Read file content, and store it in a map.
     * This function assumes the running environment is Rhino.
     * @method
     * @private
     * @param {String} path The file path
     * @memberof module:json
     */
    function readFileContent(path) {
        // for rhino
        return readFile(path);
    }

    /**
     * Get a valid transport object for ajax request.
     * @method
     * @private
     * @param {String} responseText The response text from the XmlHttpRequest
     * @returns {Object} The transport object
     * @memberof module:json
     */
    function parseResponse(responseText) {
        // util.parse is always available after loading ax/util
        return util.parse(responseText);
    }

    /**
     * Check if the resource url should be skipped from optimization.
     * @method
     * @private
     * @param {Object} obj The object to test
     * @returns {Boolean} True if the object is a function, false otherwise
     * @memberof module:json
     */
    function shouldResourceSkipped(resourceUrl) {
        // the path is mapped to an empty file OR is an external resource
        return resourceUrl.indexOf("empty:") === 0 || REGEX_IS_EXTERNAL.test(resourceUrl);
    }

    /**
     * Execute the onFailure function if it is a valid function.
     * @method
     * @private
     * @param {Object} onSuccess The onSuccess callback
     * @param {Object} onFailure The onFailure object
     * @param {Object} arg The argument for the onFailure function
     * @param {Object} loadOption The loading option
     * @memberof module:json
     */
    function handleFailure(onSuccess, onFailure, arg, loadOption) {
        loadOption = loadOption || {};

        if (loadOption.failover) {
            onSuccess({});
            return;
        }

        onFailure(arg);
    }

    /**
     * Handle the response text from XmlHttpRequest.
     * @method
     * @private
     * @param {String} responseText The response text from the XmlHttpRequest
     * @param {Function} onSuccess The callback for success case
     * @param {Function} onFailure The callback for failure case
     * @param {Object} loadOption The loading option
     * @returns {Object} The transport object
     * @memberof module:json
     */
    function handleResponse(responseText, onSuccess, onFailure, loadOption) {
        try {
            onSuccess(parseResponse(responseText));
        } catch (e) {
            // response is not a valid JSON
            handleFailure(onSuccess, onFailure, e, loadOption);
        }
    }

    /**
     * Resolve resource id to a url that can be loaded directly.
     * Only non-external resource should be resolved using require.toUrl.
     * .json extension will be added after resolve (if necessary).
     * @method
     * @private
     * @param {String} resourceId The resource id
     * @param {Object} require The require object from the amd core
     * @returns {String} The resource url after resolve
     * @memberof module:json
     */
    function resolveResourceUrl(resourceId, require) {
        // only resolve non-external resource
        if (REGEX_IS_EXTERNAL.test(resourceId)) {
            return resourceId;
        }

        return require.toUrl(resourceId);
    }

    /**
     * Parse the "resource id", get the failover config and the real resource id from it.
     * @method
     * @private
     * @param {String} resourceId The resource id
     * @returns {Object} The parsed object, containing the resource id and the parameters
     * @memberof module:json
     */
    function parseResourceId(resourceId) {
        var tokens = resourceId.split(PARAM_DELIMITER),
            param;

        // no delimiter in the resource id, no more process
        if (tokens.length === 1) {
            return {
                id: resourceId,
                failover: false,
                waitSeconds: waitSeconds
            };
        }

        param = parseLoadingOption(tokens[0]);

        return util.extend({
            id: tokens[1]
        }, param);
    }

    /**
     * Parse the loading option.
     * @method
     * @private
     * @param {String} queryString The parameter list in the loader dependency
     * @returns {Object} The parsed object, containing 2 properties: failover (Boolean) and waitSeconds (Number)
     * @memberof module:json
     */
    function parseLoadingOption(queryString) {
        var param = QueryString.parse(queryString);

        param.failover = param.failover === "true";

        // parse waitSeconds
        param.waitSeconds = parseInt(param.waitSeconds, 10);
        if (isNaN(param.waitSeconds)) {
            param.waitSeconds = waitSeconds;
        }

        return param;
    }

    /**
     * Load the required JSON file.
     * The onSuccess callback will be executed after the file is successfully loaded.
     * The onFailure callback will be executed if the file cannot be loaded.
     * @method
     * @private
     * @param {String} path The file path
     * @param {Function} onSuccess The callback for success case
     * @param {Function} onFailure The callback for failure case
     * @param {Object} loadOption The loading option
     * @memberof module:json
     */
    function loadJsonFile(path, onSuccess, onFailure, loadOption) {
        var xhr = getTransport();

        xhr.onload = xhr.onreadystatechange = function () {
            if (xhr.readyState !== 4) {
                return;
            }

            xhr.onload = xhr.onreadystatechange = null;

            var statusCode = xhr.status;

            if (statusCode === 0 || (statusCode >= 200 && statusCode < 300) || statusCode === 304) {
                handleResponse(xhr.responseText, onSuccess, onFailure, loadOption);
            } else {
                handleFailure(onSuccess, onFailure, xhr, loadOption);
            }
        };

        // set up a timeout
        xhr.timeout = (loadOption.waitSeconds || waitSeconds) * 1000;
        xhr.ontimeout = function () {
            handleFailure(onSuccess, onFailure, "Loading " + path + " timeout.", loadOption);
        };

        // send AJAX request to get the JSON
        xhr.open("GET", path);
        xhr.send();
    }

    /**
     * A function to normalize the passed-in resource ID.
     * Normalization of an module ID normally means converting relative paths, like './some/path' or '../another/path' to be non-relative, absolute IDs.
     * This is useful in providing optimal caching and optimization, but it only needs to be implemented if:
     * - the resource IDs have complex normalization
     * - only needed if the resource name is not a module name.
     * If the plugin does not implement normalize then the loader will assume it is something like a regular module ID and try to normalize it.
     * @method
     * @param {String} resourceId The resource ID that the plugin should load.
     * @param {Function} normalize A normalization function that accepts a string ID to normalize using the standard relative module normalization rules using the loader's current configuration.
     * @returns {String} The normalized resource id
     * @memberof module:json
     */
    exports.normalize = function (resourceId, normalize) {
        var tokens = resourceId.split(PARAM_DELIMITER);

        // no delimiter in the resource id, no more process
        if (tokens.length === 1) {
            return normalize(resourceId);
        }

        return tokens[0] + PARAM_DELIMITER + normalize(tokens[1]);
    };

    /**
     * Load resource for build process.
     * @method
     * @private
     * @param {String} resourceId The resource ID that the plugin should load.
     * @param {Function} require A local require function to use to load other modules. This require function has some utilities on it:
     *  * require.toUrl("moduleId+extension"). See the require.toUrl API notes for more information.
     * @param {Function} onLoad A function to call once the value of the resource ID has been determined. This tells the loader that the plugin is done loading the resource.
     * @param {Object} [config] A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. An optimization tool may set an isBuild property in the config to true if this plugin (or pluginBuilder (TODOC)) is being called as part of an optimizer build.
     * @memberof module:json
     */
    function loadForBuild(resourceId, require, onLoad, config) {
        var loadOption = parseResourceId(resourceId),
            resourceUrl = resolveResourceUrl(loadOption.id, require);

        if (shouldResourceSkipped(resourceId) || shouldResourceSkipped(resourceUrl)) {
            onLoad();
            return;
        }

        // store the config for later use (namespace, dir, etc.)
        configuration = config;

        // load file
        jsonContent[resourceId] = readFileContent(resourceUrl);
        onLoad(jsonContent);
    }

    /**
     * Load resource for application run time.
     * @method
     * @private
     * @param {String} resourceId The resource ID that the plugin should load.
     * @param {Function} require A local require function to use to load other modules. This require function has some utilities on it:
     *  * require.toUrl("moduleId+extension"). See the require.toUrl API notes for more information.
     * @param {Function} onLoad A function to call once the value of the resource ID has been determined. This tells the loader that the plugin is done loading the resource.
     * @param {Object} [config] A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. An optimization tool may set an isBuild property in the config to true if this plugin (or pluginBuilder (TODOC)) is being called as part of an optimizer build.
     * @memberof module:json
     */
    function loadForApp(resourceId, require, onLoad, config) {
        var onFailure = config ? (util.isFunction(config.onFailure) ? config.onFailure : DUMMY_FUNCTION) : DUMMY_FUNCTION,
            loadOption = parseResourceId(resourceId);

        // load the JSON file
        loadJsonFile(resolveResourceUrl(loadOption.id, require), onLoad, onFailure, loadOption);
    }

    /**
     * Load a resource.
     * Assuming the resource IDs do not need special ID normalization.
     * @method
     * @param {String} resourceId The resource ID that the plugin should load.
     * @param {Function} require A local require function to use to load other modules. This require function has some utilities on it:
     *  * require.toUrl("moduleId+extension"). See the require.toUrl API notes for more information.
     * @param {Function} onLoad A function to call once the value of the resource ID has been determined. This tells the loader that the plugin is done loading the resource.
     * @param {Object} [config] A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. An optimization tool may set an isBuild property in the config to true if this plugin (or pluginBuilder (TODOC)) is being called as part of an optimizer build.
     * @memberof module:json
     */
    exports.load = function (resourceId, require, onLoad, config) {
        if (config.isBuild) {
            loadForBuild(resourceId, require, onLoad, config);
        } else {
            loadForApp(resourceId, require, onLoad, config);
        }
    };

    /**
     * Function being called by r.js when a module is parsed.
     * In this implementation a __json!name__ module is inserted into the output file.
     * By this, the amd module will not request these json modules in runtime.
     * @see {@link http://requirejs.org/docs/plugins.html#apiwrite}
     * @param {String} pluginName The plugin name
     * @param {String} name The module name
     * @param {Function} write A function to write to the output file
     * @memberof module:json
     */
    exports.write = function (pluginName, name, write) {
        if (shouldResourceSkipped(name) || !jsonContent[name]) {
            return;
        }

        var moduleName = pluginName + "!" + name,
            definePrefix = configuration.namespace ? (configuration.namespace + ".") : "",
            moduleDefinition;

        moduleDefinition = DEFINE_TEMPLATE.replace(MODULE_ID_PLACEHOLDER, moduleName)
            .replace(MODULE_CONTENT_PLACEHOLDER, jsonContent[name]);

        write.asModule(moduleName, definePrefix + moduleDefinition);
    };


    return exports;

});

define('json!failover=true|xdk.config.json',{
    "device.multiAudioTrackStgy": {
        "tvedemo/ext/device/samsung/SefPlayer": "xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy",
        "tvedemo/ext/device/playstation/PSPlayer": "tvedemo/ext/device/playstation/PSPlayerMultiAudioTracksStgy",
        "tvedemo/ext/device/tizen/AVPlayer": "tvedemo/ext/device/tizen/AVPlayerMultiAudioTracksStgy"
    },
    "device.packages": [
        "tvedemo/ext/device/lg",
        "xdk-base/device/workstation",
        "tvedemo/ext/device/samsung",
        "xdk-ext-device-playstation",
        "xdk-ext-device-tizen"
    ],
    "device.players": {
        "lg": [
            "tvedemo/ext/device/lg/LgPlayer"
        ],
        "workstation": [
            "xdk-base/device/shared/Html5Player"
        ],
        "samsung": [
            "tvedemo/ext/device/samsung/SefPlayer"
        ],
        "playstation": [
            "tvedemo/ext/device/playstation/PSPlayer"
        ],
        "tizen": [
            "tvedemo/ext/device/tizen/AVPlayer"
        ]
    },
    "device.tracking": {
        "playstation": {
            "convivaPlayerName": "st",
            "convivaLibraryURL": "js/analytics/ConvivaLivePass_PlayStation_WebMAF_2_86_0_22221.js",
            "convivaEnableTouchstoneDebugging": false
        }
    },
    "tve.appgrid": {
        "api": "http://appgrid-api.cloud.accedo.tv",
        "appKey": "55f2b0bee4b0ba9c58ce5d11"
    },
    "tve.ovp": {
        "api": "http://share.tve.demo.accedo.tv/ovp/api/1.1"
    },
    "approuter": {
        "base": "tvedemo/ctrl",
        "paths": {
            "Blank": "storm/ctrl/Blank"
        }
    },
    "analytics.platform": "omniture",
    "analytics.debug": false,
    "dev.proxy": false,
    "dev.proxyPath": "http://192.168.2.224/proxy.php?url=",
    "dev.proxyHosts": [
        "storm-tst3.sky.de",
        "test-skyonline.sky.de",
        "skyonline.sky.de",
        "ipad-live-1.sky.de"
    ],
    "dev.replaceHost": false,
    "dev.findHosts": [
        "://skyonline.sky.de"
    ],
    "dev.replaceHosts": [
        "://test-skyonline.sky.de"
    ],
    "app.name": "SkyOnline",
    "version": "2.0.11",
    "displayVersion": false,
    "environment": "production",
    "WARNING": "Environment that we're working in / connecting to - 'production', or 'test' keys into data returned from AppGrid (so, data you can't see in this code repository; be cautious!)",
    "dialogTimeLimit": {
        "alert": 10,
        "confirm": 30,
        "task": 60
    }
}
);
/**
 * Configuration module. Allow developer to specify application configuration through a json file.
 * This module depends on the configuration file `xdk.config.json` as the base.
 * Developer should define the path to this file in `amd.config.js`.
 *
 * After loaded up, get and set functions are available.
 *
 * #### Usages
 * The usage of the configuration should be specified in module's/class's API documentation:
 *
 * __NOTE__ that XDK has reserved some configuration for internal use already.
 * __Static__ - Only configuration in the configuration will be effective. e.g.
 * __Dynamic__ - Configurations set in the runtime will also be effective immediately. e.g. {@link module:xdk-base/device/shared/InternetPoller|device:internet-poller:url}
 *
 * @module xdk-base/config
 * @author Thomas Lee <thomas.lee@accedo.tv>
 * @example
 * // define the mapping in amd.config.js
 * // note that the actual location depends on the overall baseUrl setting
 * paths: {
 *     "xdk.config": "../xdk.config"
 * }
 *
 */
define("xdk-base/config", ["json!failover=true|xdk.config.json"], function (xdkConfig) {

    "use strict";

    var configModule, _configs = xdkConfig;

    configModule = {
        /**
         * Get configuration value if exist, otherwise return default value
         * @method get
         * @memberof module:xdk-base/config
         * @param {String} key configuration entry key
         * @param {Object} defaultValue default value to return if the configuration entry does not exist
         * @returns {Object} If the key and value both exist, it will return the value.
         *  If the key has no value, it will return the default Value.
         *  If the key is undefined, it will return the entire config object.
         * @public
         * @function
         * @example <caption> To get the focus trail setting</caption>
         * config.get("ui.focus.enableTrail",false)
         */
        get: function (key, defaultValue) {
            if (typeof key === "undefined" || key === null) {
                return _configs;
            }
            if (_configs.hasOwnProperty(key)) {
                return _configs[key];
            }
            return defaultValue;
        },
        /**
         * Set configuration value
         * @method set
         * @memberof module:xdk-base/config
         * @param {String} key configuration entry key
         * @param {Object} value value of the key. If value is undefined, it will remove the specific config
         * @returns {Boolean} true when successfully set but false when key or value is undefined and key is null.
         * @public
         * @function
         * @example <caption> To disable the focus trail</caption>
         * config.set("ui.focus.enableTrail",false)
         */
        set: function (key, value) {
            if (key === null || typeof key === "undefined") {
                return 0;
            }

            if (typeof value === "undefined") {
                delete _configs[key];
                return 1;
            }
            _configs[key] = value;
            return 1;
        }
    };

    return configModule;
});
/**
 * The logger base, can be used as a starting point of building any logger.
 *
 * @class xdk-base/logger/loggerBase
 */
define("xdk-base/logger/loggerBase", ["xdk-base/config"], function (config) {
    "use strict";
    return {
        /**
         * Log level debug
         * @member LV_DEBUG
         * @memberof module:xdk-base/logger/loggerBase
         * @public
         */
        LV_DEBUG: 0,
        /**
         * Log level info
         * @member LV_INFO
         * @memberof module:xdk-base/logger/loggerBase
         * @public
         */
        LV_INFO: 1,
        /**
         * Log level log
         * @member LV_LOG
         * @memberof module:xdk-base/logger/loggerBase
         * @public
         */
        LV_LOG: 2,
        /**
         * Log level warning
         * @member LV_WARNING
         * @memberof module:xdk-base/logger/loggerBase
         * @public
         */
        LV_WARNING: 3,
        /**
         * Log level error
         * @member LV_ERROR
         * @memberof module:xdk-base/logger/loggerBase
         * @public
         */
        LV_ERROR: 4,
        /**
         * Current log level
         * @member level
         * @memberof module:xdk-base/logger/loggerBase
         * @public
         */
        level: config.get("console.lv", 2),
        /**
         * Send a log message
         * @method log
         * @memberof xdk-base/logger/loggerBase
         * @public
         * @param {Mixed} string 1st log message
         * @param {Mixed} [...] nth log message
         */
        log: function () {
            if (this.level > this.LV_LOG) {
                return;
            }
            var args = Array.prototype.slice.call(arguments);
            this._log(args.join(" "));
        },
        /**
         * Send a debug message
         * @method debug
         * @public
         * @memberof xdk-base/logger/loggerBase
         * @param {Mixed} string 1st log message
         * @param {Mixed} [...] nth log message
         */
        debug: function () {
            if (this.level > this.LV_DEBUG) {
                return;
            }
            var args = Array.prototype.slice.call(arguments);
            this._log("[DEBUG]: " + args.join(" "));
        },
        /**
         * Send a info message
         * @method info
         * @public
         * @memberof xdk-base/logger/loggerBase
         * @param {Mixed} string 1st log message
         * @param {Mixed} [...] nth log message
         */
        info: function () {
            if (this.level > this.LV_INFO) {
                return;
            }
            var args = Array.prototype.slice.call(arguments);
            this._log("[INFO]: " + args.join(" "));
        },
        /**
         * Send a warn message
         * @method warn
         * @public
         * @memberof xdk-base/logger/loggerBase
         * @param {Mixed} string 1st log message
         * @param {Mixed} [...] nth log message
         */
        warn: function () {
            if (this.level > this.LV_WARNING) {
                return;
            }
            var args = Array.prototype.slice.call(arguments);
            this._log("[WARN]: " + args.join(" "));
        },
        /**
         * Send a error message
         * @method error
         * @public
         * @memberof xdk-base/logger/loggerBase
         * @param {Mixed} string 1st log message
         * @param {Mixed} [...] nth log message
         */
        error: function () {
            if (this.level > this.LV_ERROR) {
                return;
            }
            var args = Array.prototype.slice.call(arguments);
            this._log("[ERROR]: " + args.join(" "));
        },
        /**
         * Log a message
         * @method _log
         * @memberof xdk-base/logger/loggerBase
         * @param {Mixed} string 1st log message
         * @param {Mixed} [...] nth log message
         * @protected
         * @abstract
         */
        _log: null
    };
});
/**
 * A logger module that mimics some of the behaviour of console object found on
 * desktop browsers.
 *
 * First, the module will test whether it is running on Samsung Orsay platform
 * by checking if the userAgent string contains the word "maple". If found,
 * window.alert will be used to output the message to the console. Such
 * behaviour is needed to ensure smooth operation on Orsay platform.
 *
 * Second, the module will check if the native console object can be found, if
 * so the native console object will be used.
 *
 * If none of the above check can be satisfied, all 5 console functions will
 * be defaulted to empty function.
 *
 * @module xdk-base/logger/nativeLogger
 * @extends ax/logger/loggerBase
 */
define("xdk-base/logger/nativeLogger", [
    "xdk-base/logger/loggerBase",
    "xdk-base/core"
], function (
    loggerBase,
    core
) {
    "use strict";

    var EMPTY_FUNCTION = function () {},
        // Reference to the window object.
        root      = core.root,
        userAgent = root.navigator && root.navigator.userAgent;

    if (userAgent.toLowerCase().indexOf("maple") > -1) {
        //override the loggerBase _log function
        loggerBase._log = function () {
            var args = Array.prototype.slice.call(arguments),
                msg = args.join(", ");

            /* global alert */
            if (alert) {
                alert(msg);
            }
        };

        return loggerBase;
    }

    if (root.console) {
        return root.console;
    }

    return {
        log   : EMPTY_FUNCTION,
        error : EMPTY_FUNCTION,
        debug : EMPTY_FUNCTION,
        info  : EMPTY_FUNCTION,
        warn  : EMPTY_FUNCTION
    };
});

/**
 * On-screen logger extend from loggerBase so it shows the log messages on the screen
 *
 * ####Config Params
 * Attribute | Value
 * --------- | ---------
 * Key      | onscreenlogger.maxline
 * Type     | Number
 * Usage    | {@link module:xdk-base/config}
 * Desc     | Maximum number of lines that can be printed onto screen. {@link module:xdk-base/logger/onScreenLogger.maxLine}
 * Default  | 14
 * -------------------------------------------
 * Attribute | Value
 * --------- | ---------
 * Key      | onscreenlogger.bgcolor
 * Type     | String
 * Usage    | {@link module:xdk-base/config}
 * Desc     | Color code or name for styling the log area's background color. {@link module:xdk-base/logger/onScreenLogger.bgColor}
 * Default  | green
 * -----------------------------------------
 *  Attribute | Value
 * --------- | ---------
 * Key      | onscreenlogger.key
 * Type     | String
 * Usage    | {@link module:xdk-base/config}
 * Desc     | The key to toggle the display of onScreen whether show or hide {@link module:xdk-base/logger/onScreenLogger.triggerKey}
 * Default  | "KEY_1"
 * -------------------------------------------
 *  Attribute | Value
 * --------- | ---------
 * Key      |onscreenlogger.dimension
 * Type     | Object
 * Usage    | {@link module:xdk-base/config}
 * Desc     | Dimension of the log area, in the format of {Object}, stating top, left, width and height. {@link module:xdk-base/logger/onScreenLogger.dimension}
 * Default  |
 *     {
 *         "top": 480,
 *         "left": 0,
 *         "width": 1280,
 *         "height": 240
 *     }
 *
 * @module xdk-base/logger/onScreenLogger
 * @extends ax/logger/loggerBase
 */
define("xdk-base/logger/onScreenLogger", ["xdk-base/config", "xdk-base/logger/loggerBase", "require"], function (config, loggerBase,
    require) {
    "use strict";
    var inited = false,
        logArea, onScreenLogger, item;

    onScreenLogger = {

        messages: [],
        messageEle: null,

        /**
         * Maximum number of lines that can be printed onto screen.
         * Gets from config **onscreenlogger.maxline**, with default value of 14.
         * @member maxLine
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        maxLine: config.get("onscreenlogger.maxline", 14),
        /**
         * Color code or name for styling the log area's background color.
         * Gets from config **onscreenlogger.bgcolor**, with default value of "green".
         * @member bgColor
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        bgColor: config.get("onscreenlogger.bgcolor", "green"),
        /**
         * The key to toggle the display of onScreen whether show or hide
         * Gets from config **onscreenlogger.key**, with default value of "KEY_1".
         * @member triggerKey
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        triggerKey: config.get("onscreenlogger.key", "KEY_1"),
        /**
         * Dimension of the log area, in the format of {Object}, stating top, left, width and height.
         * Gets from config **onscreenlogger.dimension**, with default value of 240px in height.
         * @member dimension
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        dimension: config.get("onscreenlogger.dimension", {
            "top": 480,
            "left": 0,
            "width": 1280,
            "height": 240
        }),
        /**
         * Initializes and create the on-screen logger when the first log
         * @method __init
         * @memberof module:xdk-base/logger/onScreenLogger
         * @priavate
         */
        __init: function () {
            if (inited) {
                return;
            }
            inited = true;

            logArea = document.createElement("div");

            logArea.setAttribute("id", "logArea");
            logArea.style.position = "absolute";
            logArea.style.left = this.dimension.left + "px";
            logArea.style.top = this.dimension.top + "px";
            logArea.style.width = this.dimension.width + "px";
            logArea.style.height = this.dimension.height + "px";
            logArea.style.backgroundColor = this.bgColor;
            logArea.style.zIndex = "99";
            logArea.style.opacity = "0.5";
            logArea.style.overflow = "hidden";

            this.messageEle = document.createElement("pre");
            this.messageEle.style.margin = "0 0 0 10px";
            logArea.appendChild(this.messageEle);
            domReady(function () {
                document.body.appendChild(logArea);
            });

            this.show();
            this.__setKey();
        },
        /**
         * To set the key which toggle the display of onscreen logger when the env is ready
         * @method __setKey
         * @memberof module:xdk-base/logger/onScreenLogger
         * @private
         */
        __setKey: function () {
            try {
                var sEnv = require("xdk-base/Env").singleton(),
                    vKey = require("xdk-base/device/vKey");

                if (sEnv) {
                    sEnv.addEventListener(sEnv.EVT_ONKEY, function (key) {
                        switch (key.id) {
                        case vKey[onScreenLogger.triggerKey].id:
                            if (logArea.style.display === "none") {
                                onScreenLogger.show();
                            } else {
                                onScreenLogger.hide();
                            }
                            break;
                        }
                        return false;
                    });
                }
            } catch (ex) {
                //keep trying until the env is ready
                setTimeout(this.__setKey, 500);
            }
        },
        /**
         * Log a message
         * @method _log
         * @memberof module:xdk-base/logger/onScreenLogger
         * @param {String} msg log message
         * @protected
         */
        _log: function (msg) {
            this.__init();
            this.messages.unshift(msg);
            if (this.messages.length > this.maxLine) {
                this.messages.pop();
            }
            this.messageEle.innerHTML = this.messages.join("\n");
        },
        /**
         * Hide the on-screen log
         * @method hide
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        hide: function () {
            logArea.style.display = "none";
        },
        /**
         * Show the on-screen log
         * @method show
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        show: function () {
            logArea.style.display = "block";
        },
        /**
         * Clear the on-screen log
         * @method clear
         * @memberof module:xdk-base/logger/onScreenLogger
         * @public
         */
        clear: function () {
            this.messages.length = 0;
            this.messageEle.innerHTML = "";
        }
    };

    for (item in loggerBase) {
        if (!onScreenLogger[item]) {
            onScreenLogger[item] = loggerBase[item];
        }
    }

    return onScreenLogger;
});
/**
 *
 * Remote logger implemetation of ILogger interface.
 * To use the remote logging, developers need to set the url of the console.php ("remotelogger.url" in config). It will automatically
 * generate an xdkLog.txt file in the same directoy.
 *
 * ### Config Params
 *
 *  Attribute | Value
 * --------- | ---------
 * Key      | remotelogger.url
 * Type     | String
 * Usage    | {@link module:xdk-base/config}
 * Desc     | To receive and display the log message {@link module:xdk-base/logger/remoteLogger.url}
 * Default  | ""
 * -------------------------------------------
 *   Attribute | Value
 * --------- | ---------
 * Key      | remotelogger.logInterval
 * Type     | Number
 * Usage    | {@link module:xdk-base/config}
 * Desc     | The Interval(sec) of checking log. If there are awaiting logs, it will send out.{@link module:xdk-base/logger/remoteLogger.logInterval}
 * Default  | 10
 * -------------------------------------------
 *    Attribute | Value
 * --------- | ---------
 * Key      | remotelogger.logFilePath
 * Type     | String
 * Usage    | {@link module:xdk-base/config}
 * Desc     | the path to save the log file {@link module:xdk-base/logger/remoteLogger.logFilePath}
 * Default  | xdkLog.txt
 * -------------------------------------------
 *   Attribute | Value
 * --------- | ---------
 * Key      | remotelogger.async
 * Type     | Boolean
 * Usage    | {@link module:xdk-base/config}
 * Desc     | The async of the ajax send to the php file. Default is false {@link module:xdk-base/logger/remoteLogger.async}
 * Default  | false
 *
 * @module xdk-base/logger/remoteLogger
 * @extends ax/logger/loggerBase
 * @author Thomas Lee <thomas.lee@accedo.tv>
 */
define("xdk-base/logger/remoteLogger", ["xdk-base/config", "xdk-base/logger/loggerBase"], function (config, loggerBase) {
    "use strict";
    var messages = [],
        remoteLogger, item, request;
    request = function (url, opts) {
        var req = new XMLHttpRequest();
        req.open("post", url, opts.async);
        req.send(opts.parameters);
    };
    remoteLogger = {
        /**
         * To receive and display the log message
         * Gets from config **remotelogger.urL**, with default value of "".
         * To get the logger php,please go to jira wiki page
         * @member url
         * @memberof module:xdk-base/logger/remoteLogger
         * @public
         */
        url: config.get("remotelogger.url", ""),
        /**
         * The Interval of checking log. If there are awaiting logs, it will send out.
         * Gets from config **remotelogger.logInterval**, with default value of "10s"
         * @member logInterval
         * @memberof module:xdk-base/logger/remoteLogger
         * @public
         */
        logInterval: config.get("remotelogger.logInterval", 10),
        /**
         * The async of the ajax send to the php file. Default is false
         * @member async
         * @memberof module:xdk-base/logger/remoteLogger
         * @public
         */
        async: config.get("remotelogger.async", false),
        /**
         * the path to save the log file
         * Gets from config **remotelogger.logFilePath**, with default value of "xdkLog.txt" in the same folder with the php
         * @member logFilePath
         * @memberof module:xdk-base/logger/remoteLogger
         * @public
         */
        logFilePath: config.get("remotelogger.logFilePath", "xdkLog.txt"),
        /**
         * To store the time out before sending the log out.
         * @member _timeInterval
         * @memberof module:xdk-base/logger/remoteLogger
         * @private
         */
        _timeInterval: null,
        /**
         * To send the log using ajax
         * @method __sendLog
         * @memberof module:xdk-base/logger/remoteLogger
         * @private
         */
        __sendLog: function () {
            //if no url or no msg, then did nth
            if (!remoteLogger.url || messages.length < 1) {
                return;
            }

            var data = {
                msg: messages,
                logPath: remoteLogger.logFilePath
            },
                sendMsg;
            //send the message out
            if (!JSON || !JSON.stringify) {
                sendMsg = remoteLogger.__stringify(data);
            } else {
                sendMsg = JSON.stringify(data);
            }
            request(remoteLogger.url, {
                parameters: sendMsg,
                async: remoteLogger.async
            });
            //remove the message
            messages = messages.slice(messages.length);
        },
        /**
         * To stringify the obejct as some platform may not have the JSON.stringify function and this logger is independent of the util and util json part
         * @method  __stringify
         * @param {object} obj object to stringify
         * @memberof module:xdk-base/logger/remoteLogger
         * @private
         */
        __stringify: function (obj) {
            var results = [],
                len, value, property, i = 0;
            if (obj === null) {
                return "null";
            }

            if (obj.toJSON && typeof obj.toJSON === "function") {
                return obj.toJSON();
            }

            if (typeof obj === "boolean" || typeof obj === "number") {
                return obj.toString();
            }

            if (typeof obj === "string") {
                return "\"" + obj.replace(/"/g, "\\\"") + "\"";
            }

            if (Object.prototype.toString.call(obj) === "[object Array]") {
                len = obj.length;

                for (; i < len; i++) {
                    value = remoteLogger.__stringify(obj[i]);
                    if (typeof obj !== "undefined") {
                        results.push(value);
                    }
                }
                return "[" + results.join(",") + "]";
            }

            if (obj) {
                for (property in obj) {
                    value = remoteLogger.__stringify(obj[property]);
                    if (typeof obj !== "undefined") {
                        results.push("\"" + property.toString() + "\":" + value);
                    }
                }
                return "{" + results.join(",") + "}";
            }

            return false;
        },
        /**
         * Log a message
         * @method _log
         * @memberof module:xdk-base/logger/remoteLogger
         * @param {String} msg log message
         * @protected
         */
        _log: function (msg) {
            //if the awaiting message size is larger than 500, just keep the latest 500 messages
            if (messages.length >= 500) {
                messages = messages.slice(1);
            }
            messages.push(msg);
            if (!this._timeInterval) {
                this._timeInterval = setInterval(this.__sendLog, this.logInterval * 1000);
            }
        }
    };

    for (item in loggerBase) {
        if (!remoteLogger[item]) {
            remoteLogger[item] = loggerBase[item];
        }
    }

    return remoteLogger;
});
/*jshint unused:false*/
/**
 * To output the console, the main purpose of this module is to distinguish which logger to use.
 * Default will use the native logger.e.g in samsung, it will use alert. workstation will use the native console.log
 * Developers can set the config __console.logger__ to be the path of the logger.
 *
 * Available logger
 *
 * 1.  {@link module:xdk-base/logger/onScreenLogger} - to show the log on the screen
 * 2.  {@link module:xdk-base/logger/remoteLogger} - to remote the log message through the php
 *
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * --------- | ---------
 * Key:    | console.logger
 * Desc    | Set the console logger to be used. Choices are {@link module:xdk-base/logger/onScreenLogger} and {@link module:xdk-base/logger/remoteLogger}
 * Type    |String
 * Default  | "xdk-base/logger/nativeLogger"
 * Usage | {@link module:xdk-base/config}
 * --------------------------------------
 *  Attribute | Value
 * --------- | ---------
 * Key     |console.lv
 * Desc    |the level of the show message. It will skip the message that smaller than this level. Default will be 2. So that info and debug message will be excluded. If it is 0, all the messages will be displayed.
 * Type    |Number
 * Default | 2
 * Usage   |{@link module:xdk-base/config}
 *--------------------------------
 * There are 5 levels of log
 *
 * 0:  LV_DEBUG
 * 1:  LV_INFO
 * 2:  LV_LOG
 * 3:  LV_WARNING
 * 4:  LV_ERROR
 *
 * @module xdk-base/console
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-base/console", ["xdk-base/config", "xdk-base/logger/nativeLogger", "xdk-base/logger/onScreenLogger", "xdk-base/logger/remoteLogger",
    "require"
], function (config, NativeLogger, OnScreenLogger, RemoteLogger) {
    "use strict";
    var console, setLogger;
    /**
     * Sets the logger to use.
     * @method setLogger
     * @memberof module:xdk-base/console
     * @param {xdk-base/logger/ILogger} logger the logger to use
     * @private
     */
    setLogger = function (logger) {
        if (logger) {
            try {
                logger = require(logger);
                console = logger;
                return;
            } catch (ex) {
                //unable to load the console and automatically fallback to console
                console = NativeLogger;
            }
        }
        console = NativeLogger;
    };

    setLogger(config.get("console.logger", null));

    return console;
});
/**
 * An event dispatcher, implementing the Observer design pattern.
 * @class xdk-base/EventDispatcher
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-base/EventDispatcher", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-base/core"
], function (
    klass,
    util,
    console,
    core
) {

    "use strict";

    return klass.create({}, {
        /**
         * Registery for all event handlers
         * @member __eventCallbacks
         * @memberof xdk-base/EventDispatcher#
         * @private
         */
        __eventCallbacks: {},
        /**
         * Get the event handlers by given type
         * @method __getEventHandlers
         * @param {String} type event type
         * @return {Array} event handlers of given type
         * @private
         * @memberof xdk-base/EventDispatcher#
         */
        __getEventHandlers: function (type) {
            var handlers = this.__eventCallbacks[type];
            if (!handlers && !util.isArray(handlers)) {
                handlers = [];
            }

            return handlers;
        },
        /**
         * Dispatches an event with additional data.
         * @method dispatchEvent
         * @param {String} type event type to dispatch
         * @param {Object} data the event data object
         * @param {Boolean} handleError catch the errors on thrown in listener and handle gracefully. Default is false.
         * @return {Boolean} result dispatch success for true
         * @public
         * @memberof xdk-base/EventDispatcher#
         */
        dispatchEvent: function (type, data, handleError) {
            if (!type) {
                throw core.createException("IncorrectParam", "Failed to dispatch event due to no event type!");
            }

            /**
             * @TODO still keep this onDispatchEvent() thing?
             */
            if (this.onDispatchEvent && !this.onDispatchEvent(type, data)) {
                console.log("Event blocked for type=" + type + " data=" + data);
                return false;
            }

            var onces = [],
                obj, i, handlers = this.__getEventHandlers(type),
                result = true,
                curResult;


            if (util.isUndefined(data)) {
                data = {};
            }

            for (i = 0; i < handlers.length; i++) {
                obj = handlers[i];

                if (util.isFunction(obj.handler)) {

                    if (handleError===true) {
                        try {
                            curResult = obj.handler.call(this, data);
                        }
                        catch (e) {
                            //errors caught should be logged properly, dispatcher shouldn'
                            console.error(e.name + ":" + e.message);
                            if (e.stack) {
                                console.error(e.stack);
                            }
                        }
                    }
                    else {
                        curResult = obj.handler.call(this, data);
                    }
                }

                //Remove handlers that is listen for once only
                if (obj.once) {
                    onces.push(obj);
                }

                if (curResult === false) {
                    result = false;
                }
            }

            for (i = 0; i < onces.length; i++) {
                this.removeEventListener(type, onces[i].handler);
            }

            return result;
        },
        /**
         * Registers an event listener for a certain type.
         * @method addEventListener
         * @param {String} type event type
         * @param {Function} handler event listener function
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @public
         * @memberof xdk-base/EventDispatcher#
         */
        addEventListener: function (type, handler, once) {
            if (!type || !handler) {
                throw core.createException("IncorrectParam", "Failed to add event listener due to no event type or listener!");
            }

            if (!once) {
                once = false;
            }

            var i, handlers = this.__eventCallbacks[type],
                obj;
            if (!handlers || !util.isArray(handlers)) {
                handlers = [];
                this.__eventCallbacks[type] = handlers;
            }

            obj = {
                handler: handler,
                once: once
            };

            //Do not add handler if it is already registred
            for (i = 0; i < handlers.length; i++) {
                if (handlers[i].handler === handler) {
                    return this;
                }
            }

            handlers.push(obj);

            return this;
        },
        /**
         * Removes one or more event listeners.
         * @method removeEventListener
         * @param {xdk-ax/evt|String} type Event type
         * @param {Function} [handler] event listener function.  If not provided, all listeners will be removed for the specific type.
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @public
         * @memberof xdk-base/EventDispatcher#
         */
        removeEventListener: function (type, handler) {
            var handlers = this.__eventCallbacks[type],
                i;

            if (!handlers) {
                return this;
            }
            if (!handlers.length) {
                delete this.__eventCallbacks[type];
                return this;
            }

            if (!handler) { // should remove handlers regardless of handler function
                for (i in handlers) {
                    this.removeEventListener(type, handlers[i].handler);
                }
                delete this.__eventCallbacks[type];
                return this;
            }

            // find the exact handler
            for (i = 0; i < handlers.length; i++) {
                if (handlers[i].handler === handler) {
                    break;
                }
            }

            if (i < handlers.length) {
                handlers.splice(i, 1);
            }

            return this;
        },
        /**
         * Removes all event listeners.
         * @see ax/EventDispatcher#removeEventListener
         * @method removeAllListeners
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @public
         * @memberof xdk-base/EventDispatcher#
         */
        removeAllListeners: function () {
            var type;
            for (type in this.__eventCallbacks) {
                this.removeEventListener(type);
            }
            return this;
        },
        /**
         * Deinitialize this event dispatcher
         * @method deinit
         * @protected
         * @memberof xdk-base/EventDispatcher#
         */
        deinit: function () {
            this.removeAllListeners();
        }
    });
});
/**
 * Contain definition for abstracted virtual keys in XDK.
 *
 * **Note** that device specific keys (e.g. Samsung SmartHub Key) are defined within Samsung package.
 *
 *
 * @module xdk-base/device/vKey
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @example
 * // Handling the key event dispatched from Env
 * sEnv.addEventListener(sEnv.EVT_ONKEY, function(keyEvt) {
 *
 *      switch (keyEvt.id) {
 *
 *          // compare to see if it"s a virtual key
 *          case vKey.KEY_0.id:
 *
 *          // custom key events emitted by specific device
 *          case "vkey:samsung:smart-hub":
 *             ...
 *          break;
 *
 *      }
 * }
 */
define("xdk-base/device/vKey", [], function () {
    "use strict";
    return {
        /**
         * @name KEY_0
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:0"
         * @property {String} text Text value of the Virtual Key. "0"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_0: {
            id: "device:vkey:0",
            text: "0"
        },
        /**
         * @name KEY_1
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:1"
         * @property {String} text Text value of the Virtual Key. "1"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_1: {
            id: "device:vkey:1",
            text: "1"
        },
        /**
         * @name KEY_2
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:2"
         * @property {String} text Text value of the Virtual Key. "2"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_2: {
            id: "device:vkey:2",
            text: "2"
        },
        /**
         * @name KEY_3
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:3"
         * @property {String} text Text value of the Virtual Key. "3"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_3: {
            id: "device:vkey:3",
            text: "3"
        },
        /**
         * @name KEY_4
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:4"
         * @property {String} text Text value of the Virtual Key. "4"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_4: {
            id: "device:vkey:4",
            text: "4"
        },
        /**
         * @name KEY_5
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:5"
         * @property {String} text Text value of the Virtual Key. "5"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_5: {
            id: "device:vkey:5",
            text: "5"
        },
        /**
         * @name KEY_6
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:6"
         * @property {String} text Text value of the Virtual Key. "6"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_6: {
            id: "device:vkey:6",
            text: "6"
        },
        /**
         * @name KEY_7
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:7"
         * @property {String} text Text value of the Virtual Key. "7"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_7: {
            id: "device:vkey:7",
            text: "7"
        },
        /**
         * @name KEY_8
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:8"
         * @property {String} text Text value of the Virtual Key. "8"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_8: {
            id: "device:vkey:8",
            text: "8"
        },
        /**
         * @name KEY_9
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:9"
         * @property {String} text Text value of the Virtual Key. "9"
         * @memberof module:xdk-base/device/vKey
         */
        KEY_9: {
            id: "device:vkey:9",
            text: "9"
        },
        /**
         * @name OK
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:ok"
         * @memberof module:xdk-base/device/vKey
         */
        OK: {
            id: "device:vkey:ok"
        },
        /**
         * @name UP
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:up"
         * @memberof module:xdk-base/device/vKey
         */
        UP: {
            id: "device:vkey:up"
        },
        /**
         * @name DOWN
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:down"
         * @memberof module:xdk-base/device/vKey
         */
        DOWN: {
            id: "device:vkey:down"
        },
        /**
         * @name LEFT
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:left"
         * @memberof module:xdk-base/device/vKey
         */
        LEFT: {
            id: "device:vkey:left"
        },
        /**
         * @name RIGHT
         * @property {String} id Virtual Key ID. "device:vkey:right"
         * @memberof module:xdk-base/device/vKey
         */
        RIGHT: {
            id: "device:vkey:right"
        },
        /**
         * @name EXIT
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:left"
         * @memberof module:xdk-base/device/vKey
         */
        EXIT: {
            id: "device:vkey:exit"
        },
        /**
         * @name BACK
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:back"
         * @memberof module:xdk-base/device/vKey
         */
        BACK: {
            id: "device:vkey:back"
        },
        /**
         * @name RED
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:green"
         * @memberof module:xdk-base/device/vKey
         */
        RED: {
            id: "device:vkey:red"
        },
        /**
         * @name GREEN
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:green"
         * @memberof module:xdk-base/device/vKey
         */
        GREEN: {
            id: "device:vkey:green"
        },
        /**
         * @name YELLOW
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:yellow"
         * @memberof module:xdk-base/device/vKey
         */
        YELLOW: {
            id: "device:vkey:yellow"
        },
        /**
         * @name BLUE
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:blue"
         * @memberof module:xdk-base/device/vKey
         */
        BLUE: {
            id: "device:vkey:blue"
        },
        /**
         * @name PLAY
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:play"
         * @property {String} text Text value of the Virtual Key. "play"
         * @memberof module:xdk-base/device/vKey
         */
        PLAY: {
            id: "device:vkey:play"
        },
        /**
         * @name PLAY_PAUSE
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:play-pause"
         * @memberof module:xdk-base/device/vKey
         */
        PLAY_PAUSE: {
            id: "device:vkey:playPause"
        },
        /**
         * @name PAUSE
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:pause"
         * @memberof module:xdk-base/device/vKey
         */
        PAUSE: {
            id: "device:vkey:pause"
        },
        /**
         * @name STOP
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:stop"
         * @memberof module:xdk-base/device/vKey
         */
        STOP: {
            id: "device:vkey:stop"
        },
        /**
         * @name FF
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:ff"
         * @memberof module:xdk-base/device/vKey
         */
        FF: {
            id: "device:vkey:ff"
        },
        /**
         * @name RW
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:rw"
         * @memberof module:xdk-base/device/vKey
         */
        RW: {
            id: "device:vkey:rw"
        },
        /**
         * @name NEXT
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:next"
         * @memberof module:xdk-base/device/vKey
         */
        NEXT: {
            id: "device:vkey:next"
        },
        /**
         * @name PREV
         * @type {object}
         * @property {String} id Virtual Key ID. "device:vkey:prev"
         * @memberof module:xdk-base/device/vKey
         */
        PREV: {
            id: "device:vkey:prev"
        }

    };
});
/**
 * Media player registery, registers media players along with their capabilities.
 * During preparation of playback, this registry will be consulted for the appropriate player.
 * @module xdk-base/device/playerRegistry
 */
define("xdk-base/device/playerRegistry", ["xdk-base/util", "require"], function (util, require) {
    "use strict";    
    var mediaRegistry = [];
    return {
        /**
         * Register a player implementation
         * @method
         * @param {xdk-base/device/interface/Player} playerObj the player implementation to register
         * @param {string} id - the identifier for the player instance at runtime
         * @memberof module:xdk-base/device/playerRegistry
         */
        register: function (playerObj, id) {
            var cap = playerObj.getCapabilities(),
                types = cap.type || ["*"],
                drms = cap.drms || [],
                type, drm, i, object = {
                    type: {},
                    drm: {},
                    player: null
                };

            if (!util.isArray(types)) {
                types = [types];
            }

            if (!util.isArray(drms)) {
                drms = [drms];
            }

            for (i in types) {
                type = types[i];
                if (type) {
                    object.type[type] = true;
                }
            }

            for (i in drms) {
                drm = drms[i];
                if (drm) {
                    object.drm[drm] = true;
                }
            }

            playerObj.setId(id);
            object.id = id;
            object.player = playerObj;

            mediaRegistry.push(object);
        },
        /**
         * Unregister a player implementation
         * @method
         * @param {xdk-base/device/interface/Player} playerObj the player implementation to unregister
         * @memberof module:xdk-base/device/playerRegistry
         */
        unregister: function (playerObj) {
            util.each(mediaRegistry, function (obj, i) {
                if (obj.player === playerObj) {
                    playerObj.reset();
                    mediaRegistry.splice(i, 1);
                    return util.breaker;
                }
            });
        },
        /**
         * deinit the playerRegistry and deinit and unregister all the player
         * @method deinit
         * @memberof module:xdk-base/device/playerRegistry
         */
        deinit: function () {
            util.each(mediaRegistry, util.bind(function (obj) {
                this.unregister(obj.player);
                obj.player.deinit();
            }, this));
        },
        /**
         * Get the registered player instance by Player
         * @method getPlayerByClass
         * @param {String} klass The name of the player class. e.g. "xdk-base/device/shared/Html5Player".
         * @return {ax/device/interface/Player|Null} player instance. Null if not found
         * @memberOf module:xdk-base/device/playerRegistry
         */
        getPlayerByClass: function (klass) {

            var playerClass = require(klass),
                player = null;
            util.each(mediaRegistry, function (item) {
                if (item.player.constructor === playerClass) {
                    player = item.player;
                    return util.breaker;
                }
            });

            return player;

        },
        /**
         * Find the first registered matched player by the type and drm. Uses
         * {@link module:xdk-base/device/playerRegistry.getPlayers|getPlayers}.
         * @method getPlayer
         * @param {Object} [opts]
         * @param {String} [opts.type] media type
         * @param {String} [opts.drm] drm type
         * @return {Object|Null} first registered matched player is returned.
         * @memberof module:xdk-base/device/playerRegistry
         */
        getPlayer: function (opts) {
            var players = this.getPlayers(opts);

            if (players.length === 0) {
                return null;
            }
            return players[0];
        },
        /**
         * Find the players by the media type and drm. For list of supported
         * media types, please see device player API documentation. e.g.
         * {@link module:xdk-base/device/workstation/DevicePackage|workstation/DevicePackage}
         *
         * @method getPlayers
         * @param {object} [opts]
         * @param {String} [opts.type] media type
         * @param {String} [opts.drm] drm type
         * @return {Array} list of available player with id as key and player object as value.
         * @memberof module:xdk-base/device/playerRegistry
         * @exmaple playerRegistry.getPlayers({ type: "hls", drm: "AES-128"});
         *
         */
        getPlayers: function (opts) {

            var resultArr = [],
                type = opts.type,
                drm = opts.drm;

            if (!type && !drm) {
                util.each(mediaRegistry, function (item) {
                    resultArr.push(item.player);
                });
                return resultArr;
            }



            util.each(mediaRegistry, function (item) {
                if (type && item.type[type] || type === "*") {
                    if ((drm && item.drm[drm]) || !drm) {
                        resultArr.push(item.player);
                    }
                }

                if (!type && drm && item.drm[drm]) {
                    resultArr.push(item.player);
                }
            });

            return resultArr;
        }

    };
});
/**
 * The media player interface
 * Implement this interfaces and register to {@link xdk-base/device/playerRegistry|Player Registry}.
 * @class xdk-base/device/interface/Player
 * @author Mike Leung <mike.leung@accedo.tv>
 */

define("xdk-base/device/interface/Player", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    /**
     * @typedef PlayerCapabilites
     * @inner
     * @desc the player's capabilities
     * @type {object}
     * @property {Array} drms Player supported DRM
     * @property {Array} type Player'supported container format. e.g. ["mp4","hls"]
     * @inner
     * @memberof xdk-base/device/interface/Player
     * @example
     * {
     *      "drms" : ["aes128", "widevine"],
     *      "type" : ["hls", "mp4"]
     * }
     */

    /**
     * @typedef MediaBitrates
     * @inner
     * @desc the media's bitrates
     * @type {object}
     * @property {Array} [currentBitrate] current playback bitrate
     * @property {Array} [availableBitrates] available playback bitrates
     * @inner
     * @memberof xdk-base/device/interface/Player
     *
     */

    var IPlayer = Interface.create("Player", {
        /**
         * Gets the player's capabilities
         * @method
         * @abstract
         * @return {ax/device/interface/Player~PlayerCapabilites} the player's capabilities
         * @memberof xdk-base/device/interface/Player
         */
        getCapabilities: [],
        /**
         * Prepare the player, should be called before using
         * @method
         * @abstract
         * @param {string} type The media type to be played
         * @param {string} [codec] The media codec
         * @param {string} [drm] DRM to be used
         * @memberof xdk-base/device/interface/Player
         */
        prepare: ["opts"],
        /**
         * Reset the player, should be called when it is to replaced by other player
         * @method
         * @abstract
         * @memberof xdk-base/device/interface/Player
         */
        reset: [],
        /**
         * Loads the specified media
         * @method
         * @abstract
         * @param {String} url the URL address of the media
         * @param {Object} [opts] the options for loading this media
         * @param {string} [opts.codec] the media codec
         * @param {string} [opts.type] explicitly specify the media type
         * @param {string} [opts.drm] DRM to be used
         * @memberof xdk-base/device/interface/Player
         */
        load: ["mediaUrl", "opts"],
        /**
         * Start the playback
         * @method
         * @abstract
         * @param {Object} [opts] the options for starting playback
         * @param {Number} [opts.sec] the playback start time
         * @memberof xdk-base/device/interface/Player
         */
        play: ["opts"],
        /**
         * Stop the playback
         * @method
         * @abstract
         * @memberof xdk-base/device/interface/Player
         */
        stop: [],
        /**
         * Pause the playback
         * @method
         * @abstract
         * @memberof xdk-base/device/interface/Player
         */
        pause: [],
        /**
         * Resume the playback
         * @method
         * @abstract
         * @memberof xdk-base/device/interface/Player
         */
        resume: [],
        /**
         * Seek to specifiy position of the video
         * @method
         * @abstract
         * @param {Number} sec the position to seek to in seconds
         * @memberof xdk-base/device/interface/Player
         */
        seek: ["sec"],
        /**
         * Skip the playback forward/backward for certain seconds
         * @method
         * @abstract
         * @param {Number} sec number of seconds to skip (10 by default)
         * @memberof xdk-base/device/interface/Player
         */
        skip: ["sec"],
        /**
         * Speed up/down the media playback
         * @method
         * @abstract
         * @param {Number} speed the playback speed to set
         * @memberof xdk-base/device/interface/Player
         */
        speed: ["speed"],
        /**
         * Get the playback speed
         * @method
         * @abstract
         * @return {Number} the playback speed
         * @memberof xdk-base/device/interface/Player
         */
        getPlaybackSpeed: [],
        /**
         * Sets video window size
         * @method
         * @abstract
         * @param {Object} param window size parameter
         * @param {Integer} param.top window top
         * @param {Integer} param.left window left
         * @param {Integer} param.width window width
         * @param {Integer} param.height window height
         * @memberof xdk-base/device/interface/Player
         */
        setWindowSize: ["param"],
        /**
         * Sets video window size to be fullscreen
         * @method
         * @abstract
         * @memberof xdk-base/device/interface/Player
         */
        setFullscreen: [],
        /**
         * Get the media bitrates
         * @method
         * @abstract
         * @return {ax/device/interface/Player~MediaBitrates} current bitrate and available bitrates
         * @memberof xdk-base/device/interface/Player
         */
        getBitrates: [],
        /**
         * Get the current playback time
         * @method
         * @abstract
         * @return {Number} the current playback time
         * @memberof xdk-base/device/interface/Player
         */
        getCurTime: [],
        /**
         * Get the total playback time
         * @method
         * @abstract
         * @return {Number} the total playback time
         * @memberof xdk-base/device/interface/Player
         */
        getDuration: [],
        /**
         * Get back the path
         * @method
         * @public
         * @return {String} the path of the player
         * @memberof xdk-base/device/interface/Player
         */
        getId: [],
        /**
         * set the id of the player
         * @method
         * @public
         * @param {String} id the path of the player
         * @memberof xdk-base/device/interface/Player
         */
        setId: ["id"]
    });


    /**
     * The playback states of the player.
     * @enum {String}
     * @memberof xdk-base/device/interface/Player
     */
    IPlayer.PLAYBACK_STATE = {
        /**
         * The playback is playing, this also includes skipping, speeding, bufferring.
         */
        PLAYING: "playing",
        /**
         * The playback is paused, this also includes bufferring.
         */
        PAUSED: "paused",
        /**
         * The playback is stopped, or not started yet.
         */
        STOPPED: "stopped"
    };

    var PLAYBACK_ERRORS_GROUPS = {
        RENDER: "onRenderError",
        NETWORK: "onConnectionError",
        DRM: "onDRMError",
        GENERIC: "onUnknownError"
    };
    /**
     * Default player errors.
     * @enum {Object}
     * @memberof xdk-base/device/interface/Player
     */
    IPlayer.PLAYBACK_ERRORS = {

        RENDER: {
            //general
            FAILED: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1001,
                id: "player.error.render.failed",
                desc: "Stream Playback Generic Error"
            },
            ABORTED: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1002,
                id: "player.error.render.aborted",
                desc: "You aborted the video playback"
            },
            DECODE: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1003,
                id: "player.error.render.decode",
                desc: "Decoding error, The video playback was aborted due to a corruption problem or because the video used features your browser did not support."
            },
            CORRUPTED: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1004,
                id: "player.error.render.corrupted",
                desc: "Corrupted Stream Error"
            },
            UNSUPPORTED: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1005,
                id: "player.error.render.unsupported",
                desc: "Unsupported Video Format, The media resource indicated by the src attribute or assigned media provider object was not suitable."
            },
            //specific
            DEVICE: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1006,
                id: "player.error.render.device",
                desc: "Device system Error, out of memory or other reason."
            },
            PLAYLIST: {
                evt: PLAYBACK_ERRORS_GROUPS.RENDER,
                code: 1007,
                id: "player.error.render.playlist",
                desc: "Unrecognized play list or Play list is empty"
            }
        },

        NETWORK: {
            //general
            FAILED: {
                evt: PLAYBACK_ERRORS_GROUPS.NETWORK,
                code: 2001,
                id: "player.error.network.failed",
                desc: "A network error caused the video download to fail part-way"
            },
            FILE: {
                evt: PLAYBACK_ERRORS_GROUPS.NETWORK,
                code: 2002,
                id: "player.error.network.file",
                desc: "File is not found or network error while trying to load the file"
            },
            //specific
            TIMEOUT: {
                evt: PLAYBACK_ERRORS_GROUPS.NETWORK,
                code: 2003,
                id: "player.error.network.timeout",
                desc: "Network Timeout"
            },
            DISCONNECTED: {
                evt: PLAYBACK_ERRORS_GROUPS.NETWORK,
                code: 2004,
                id: "player.error.network.disconnected",
                desc: "Network Disconnected"
            },
            PROTOCOL: {
                evt: PLAYBACK_ERRORS_GROUPS.NETWORK,
                code: 2005,
                id: "player.error.network.protocol",
                desc: "Invalid Protocol"
            }
        },

        DRM: {
            //general
            FAILED: {
                evt: PLAYBACK_ERRORS_GROUPS.DRM,
                code: 3001,
                id: "player.error.drm.failed",
                desc: "Authentication Failed, general message"
            },
            //specific
            NOLICENCE: {
                evt: PLAYBACK_ERRORS_GROUPS.DRM,
                code: 3002,
                id: "player.error.drm.nolicense",
                desc: "No License"
            },
            INVALID: {
                evt: PLAYBACK_ERRORS_GROUPS.DRM,
                code: 3003,
                id: "player.error.drm.invalid",
                desc: "Invalid license"
            }
        },

        GENERIC: {
            //general
            UNKNOWN: {
                evt: PLAYBACK_ERRORS_GROUPS.GENERIC,
                code: 4001,
                id: "player.error.generic.unknown",
                desc: "Unidentified Error on Playback"
            },
            LOAD: {
                evt: PLAYBACK_ERRORS_GROUPS.GENERIC,
                code: 4002,
                id: "player.error.generic.load",
                desc: "Exception caught when trying to load the media"
            }
        }
    };


    return IPlayer;


});
/**
 * Thennable is a helper module for promise to handle `thenable` type of methods. Please
 * refer to promise-a-plus specification 2.3.3 for more details
 * </p>
 *
 * @class xdk-base/Thennable
 */

define("xdk-base/Thennable", [
    "require",
    "xdk-base/util"
], function (
    require,
    util
) {
    "use strict";

    var getPromise = function () {
        return require("./promise");
    };

    /**
     * Constructor method
     */
    function Thennable(obj, then) {
        this.pending = true;
        this.obj = obj;
        this.then = then;
    }

    /**
     * Reject the thennable instance
     * @param  {T} reason Reason to reject the thennable
     * @private
     */
    Thennable.prototype.reject = function (reason) {
        if (!this.pending) {
            return;
        }
        this.pending = false;
        this.rejecter(reason);
    };

    /**
     * Fulfil the thennable instance
     * @param  {T} value Value resolving the thennable
     * @private
     */
    Thennable.prototype.fulfil = function (value) {

        if (!this.pending) {
            return;
        }

        this.pending = false;

        if (getPromise().isPromise(value)) {
            value.then(this.resolver, this.rejecter);
            return;
        }

        try {
            if (!Thennable.handle(value, this.resolver, this.rejecter)) {
                this.resolver(value);
            }
        } catch (e) {
            this.rejecter(e);
        }
    };

    /**
     * Run the thennable
     * @param  {Function} resolver callback when thennable fulfilled
     * @param  {Function} rejecter callback when thennable rejected
     * @method run
     * @memberof xdk-base/Thennable#
     */
    Thennable.prototype.run = function (resolver, rejecter) {

        var obj = this.obj,
            then = this.then;

        this.resolver = resolver;
        this.rejecter = rejecter;

        try {
            then.call(obj, util.bind(this.fulfil, this), util.bind(this.reject, this));
        } catch (e) {
            this.reject(e);
        }
    };

    /**
     * Try to handle a value as Thennable
     * @param  {T} value    The value that maybe a Thennable
     * @param  {Method} resolver Callback on Thennable fulfilled
     * @param  {Method} rejecter Callback on Thennable rejected
     * @return {Boolean}          True if value has then handled as Thennable
     * @method handle
     * @memberof xdk-base/Thennable
     */
    Thennable.handle = function (value, resolver, rejecter) {

        if (!value) {
            return false;
        }

        if (getPromise().isPromise(value)) {
            return false;
        }

        if (!util.isFunction(value) && !util.isPlainObject(value)) {
            return false;
        }

        // Avoid calling ES5 getter twice. See https://promisesaplus.com/#point-75
        var then = value.then;

        if (!util.isFunction(then)) {
            return false;
        }

        var thennable = new Thennable(value, then);
        thennable.run(resolver, rejecter);

        return true;
    };

    return Thennable;
});
/**
 * Promise represents the eventual value returned from the single completion of an operation.<br/>
 * There are three states: pending, fulfilled and rejected cases.
 * With promise, developer can handle and control the deferred and asynchronous computations.
 * <p>
 * A general error handling function can be set on the promise module, i.e. promise.onerror.<br/>
 * If this is set, any unhandled rejection reaching the end of the promise chain (.done()) or exception thrown in onProgress callback will go through that function.
 * Otherwise, the default action will be an exception thrown to the global space directly, leading to an unhandle-able exception.
 * </p>
 *
 * @module ax/promise
 */
define("xdk-base/promise", [
    "xdk-base/core",
    "require",
    "exports",
    "xdk-base/Thennable",
    "xdk-base/util",
    "xdk-base/exception",
    "xdk-base/console"
], function(
    core,
    require,
    exports,
    Thennable,
    util,
    exception,
    console
) {
    "use strict";

    var nextTick;

    /**
     * It is a task-scheduling queue which handles the tasks one by one.<br/>
     * It will return the function to process the next Tick until no more items in the queue.
     *
     * @returns {Function} A function to perform the next task
     * @method nextTick
     * @memberof module:ax/promise
     */
    exports.nextTick = (function() {
        var head, tail, flushing, requestTick;
        //handle the list of tasks
        head = {
            task: undefined,
            next: null
        };
        tail = head;
        flushing = false;

        function flush() {
            while (head.next) {
                head = head.next;
                var task = head.task;
                head.task = undefined;

                try {
                    task();
                } catch (e) {
                    throw e;
                }
            }

            flushing = false;
        }

        nextTick = function(task) {
            tail = tail.next = {
                task: task,
                next: null
            };

            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };

        requestTick = function() {
            setTimeout(flush, 0);
        };


        return nextTick;
    })();

    /**
     * A PromiseDefer object contains a promise, which will be fulfilled/rejected according to the defer object.<br/>
     * To fulfill the promise, invoke {@link module:ax/promise~PromiseDefer#resolve}.
     * To reject, invoke {@link module:ax/promise~PromiseDefer#reject}.
     *
     * @class PromiseDefer
     * @property {module:ax/promise~Promise} promise The promise contained in the defer object, which is sensitive to the defer object's state.
     * @property {Function} resolve resolve the deferred promise with a value,
     * without wrapping the value with a Promise if it's promise.
     * @property {Function} fulfil fulfil the deferred promise with a value.
     * @property {Function} reject reject the deferred promise with a reason.
     * @property {Function} onCancel delegate to be triggered upon
     * associated promise being cancelled.
     * @memberof module:ax/promise~
     * @example
     *
     * var deferred = promise.defer();
     *
     * deferred.promise.then(function(succeed) {
     *    console.log(succeed);
     * }, function(fail) {
     *    console.log(fail);
     * }, function(notify) {
     *    console.log(notify);
     * });
     *
     * @example
     * // The state of the contained promise can be controlled through the methods of the defer object.
     * // resolve/fulfil/reject can only be called once while in pending state.
     * // It is forbidden to call the methods while the promise is not in pending state.
     * deferred.resolve("pass");
     * deferred.fulfil("pass");
     * deferred.reject("fail");
     * deferred.notify("processing");
     *
     * @example
     * //Cancellation
     *
     * deferred.onCancel =function(message) {
     *     //reject the promise with message upon cancel request
     *     deferred.reject(message);
     * };
     *
     * deferred.promise.cancel();
     *
     * @example
     * // To inspect the state of the defer
     * var stateObj = deferred.inspect();
     *
     * @example
     * // typical usage
     * function doSomething() {
     *     var deferred = promise.defer();
     *
     *     // an asynchronous task
     *     setTimeout(function() {
     *         deferred.resolve("done");
     *     }, 20000);
     *
     *     return deferred.promise;
     * }
     *
     * // somewhere
     * doSomething().then(function() {
     *     // this will be executed when the defer is resolved
     * }).done();
     *
     **/

    /**
     * @typedef {Object} module:ax/promise~PromiseState
     * @property {String} state The state of the defer/promise object
     * @property {T} value The value of the fulfilled promise
     * @property {T} reason The reason of the rejected promise
     * @memberof module:ax/promise
     */

    var STATE = {
        PENDING: "pending",
        FULFILLED: "fulfilled",
        REJECTED: "rejected",
        CANCELLED: "cancelled"
    };

    var EVT = {
        PROGRESSED: "progressed",
        FULFILLED: "fulfilled",
        REJECTED: "rejected",
        CANCELLED: "cancelled"
    };

    var Event = {

        init: function() {
            this._listeners = {};
        },

        on: function(evt, clientId, listener) {
            this._listeners[evt] = this._listeners[evt] || {};
            this._listeners[evt][clientId] = this._listeners[evt][clientId] || [];
            this._listeners[evt][clientId].push(listener);
        },

        off: function(evt, clientId) {
            if (clientId && this._listeners[evt]) {
                delete this._listeners[evt][clientId];
                return;
            }

            delete this._listeners[evt];
        },

        fire: function(evt, value) {
            var clients = this._listeners[evt];
            if (!clients) {
                return;
            }

            util.each(clients, function(pair) {
                var listeners = pair.value;
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i](value);
                }
            });
        }
    };

    function cleanUp() {
        /*jshint validthis: true */
        Event.off.call(this, EVT.FULFILLED);
        Event.off.call(this, EVT.REJECTED);
        Event.off.call(this, EVT.PROGRESSED);
        Event.off.call(this, EVT.CANCELLED);
        this._onCancel = null;
    }

    /**
     * The Promise object
     *
     * @class Promise
     * @memberof module:ax/promise~
     * @protected
     * @example
     * <caption>General Usage</caption>
     * var defer = promise.defer();
     * defer.promise.then(function(succeed){
     *    console.log(succeed);
     * },function(fail){
     *    console.log(fail);
     * },function(notify){
     *    console.log(notify);
     * });
     *
     **/

    function Promise(task, onCancel) {

        if (!util.isFunction(task)) {
            throw core.createException(exception.ILLEGAL_ARGUMENT, "task is not a Function");
        }

        this._id = core.getGuid();

        this._status = {
            state: STATE.PENDING
        };

        this._activeThens = [];

        Event.init.apply(this);

        var resolver = util.bind(fulfill, this),
            rejecter = util.bind(reject, this),
            progresser = util.bind(progress, this);

        try {
            task.call(this, resolver, rejecter, progresser);
        } catch (e) {
            rejecter(e);
        }

        if (util.isFunction(onCancel)) {
            this._onCancel = util.bind(onCancel, this);
        }

        function fulfill(value) {
            /*jshint validthis: true */
            if (!this.isPending()) {
                return;
            }

            this._status.state = STATE.FULFILLED;
            this._status.value = value;

            nextTick(util.bind(function() {
                Event.fire.call(this, EVT.FULFILLED, value);
                cleanUp.call(this);
            }, this));
        }

        function reject(reason) {
            /*jshint validthis: true */
            if (!this.isPending()) {
                return;
            }

            this._status.state = STATE.REJECTED;
            this._status.reason = reason;

            nextTick(util.bind(function() {
                Event.fire.call(this, EVT.REJECTED, reason);
                cleanUp.call(this);
            }, this));
        }

        function progress(update) {
            /*jshint validthis: true */
            if (!this.isPending()) {
                return;
            }
            nextTick(util.bind(function() {
                Event.fire.call(this, EVT.PROGRESSED, update);
            }, this));
        }
    }


    /**
     * Guid of the promise instance
     *
     * @method getId
     * @returns {Number} Identified in integer
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.getId = function() {
        return this._id;
    };

    /**
     * To handle the cases when fulfill(success), reject(fail) or notify(progress)
     *
     * @method then
     * @param {module:ax/promise~Promise#onFulfill} fulfilled  Callback function when the promise is fulfilled
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @param {module:ax/promise~Promise#onProgress} progressed  Callback function when the promise is processing
     * @returns {module:ax/promise~Promise} Promise is returned
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.then = function(onFulfill, onReject, onProgress, onCancel) {

        var p = (function(waited) {

            function thenResolver(resolve, reject, notify) {
                /*jshint validthis: true */

                function handler(thenHandler, propagator, valueOrReason) {
                    /*jshint validthis: true */


                    if (!util.isFunction(thenHandler)) {
                        propagator(valueOrReason);
                        return;
                    }

                    try {
                        var ret = thenHandler(valueOrReason);
                        if (ret === this) {
                            reject(new TypeError("promise's handler cannot return itself (same promise instance)"));
                            return;
                        }
                        if (isPromise(ret)) {
                            // wait on the returned Promise rather than parent
                            waited = ret.then(resolve, reject);
                            return;
                        }
                        //thennable, no progress support
                        if (!Thennable.handle(ret, resolve, reject)) {
                            resolve(ret);
                        }
                    } catch (e) {
                        reject(e);
                    }
                }

                function handleProgress(progress) {
                    if (!util.isFunction(onProgress)) {
                        notify(progress);
                        return;
                    }

                    try {
                        var ret = onProgress(progress);
                        notify(ret);
                    } catch (e) {
                        reject(e);
                    }
                }

                if (waited.isPending()) {
                    Event.on.call(waited, EVT.FULFILLED, this.getId(), util.bind(handler, this, onFulfill, resolve));
                    Event.on.call(waited, EVT.REJECTED, this.getId(), util.bind(handler, this, onReject, reject));
                    Event.on.call(waited, EVT.PROGRESSED, this.getId(), handleProgress);
                    return;
                }

                if (waited.isFulfilled()) {
                    nextTick(util.bind(handler, this, onFulfill, resolve, waited.inspect()
                        .value));
                    return;
                }

                if (waited.isRejected()) {
                    nextTick(util.bind(handler, this, onReject, reject, waited.inspect()
                        .reason));
                    return;
                }

            }

            function thenOnCancel(message) {
                /*jshint validthis: true */

                waited.cancel(message, this.getId());
            }

            var child = new Promise(thenResolver, thenOnCancel);

            function handleCancel() {

                //cancel decesdant promise
                child.cancel();

                if (util.isFunction(onCancel)) {
                    nextTick(onCancel);
                }
            }

            if (waited.isPending()) {
                Event.on.call(waited, EVT.CANCELLED, child.getId(), handleCancel);
            }

            return child;

        }(this));

        this._activeThens.push(p.getId());

        return p;
    };

    /**
     * Returns the current status of the Promise
     *
     * @method inspect
     * @returns {Object} see example
     * @memberof module:ax/promise~Promise#
     * @example
     *
     * promise.resolve('value').inspect(); // { status: 'fulfilled', value: 'value' };
     * promise.rejected('reason').inspect(); // { status: 'rejected', reason: 'reason' };
     * promise.defer().promise.inspect(); // { status: 'pending' };
     */
    Promise.prototype.inspect = function() {
        return this._status;
    };

    /**
     * Check if promise is in pending state
     *
     * @method isPending
     * @returns {Boolean} true if pending
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.isPending = function() {
        return this._status.state === STATE.PENDING;
    };

    /**
     * Check if promise is in fulfilled state
     *
     * @method isFulfilled
     * @returns {Boolean} true if fulfilled
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.isFulfilled = function() {
        return this._status.state === STATE.FULFILLED;
    };

    /**
     * Check if promise is in rejected state
     *
     * @method isRejected
     * @returns {Boolean} true if rejected
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.isRejected = function() {
        return this._status.state === STATE.REJECTED;
    };

    /**
     * Check if promise is in cancelled state
     *
     * @method isCancelled
     * @returns {Boolean} true if cancelled
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.isCancelled = function() {
        return this._status.state === STATE.CANCELLED;
    };

    /**
     * To pass a cancel request to the Producer of the promise. Behavior depends on
     * specific cancellation case.
     *
     * @method cancel
     * @param {T} [message] Message to pass
     * @memberof module:ax/promise~Promise#
     */
    function cancel(message, from) {
        /*jshint validthis: true */

        if (!this.isPending()) {
            return;
        }


        if (from) {
            // Implicit cancellations through then will be ignored if 
            // there are still active thens waited, suppose originate then
            // has been cancelled already
            var fromIdx = this._activeThens.indexOf(from);
            if (fromIdx > -1) {
                this._activeThens.splice(fromIdx, 1);
            }

            Event.off.call(this, EVT.FULFILLED, from);
            Event.off.call(this, EVT.REJECTED, from);
            Event.off.call(this, EVT.PROGRESSED, from);

            if (this._activeThens.length > 0) {
                return;
            }
        }

        this._status.state = STATE.CANCELLED;

        this._onCancel(message);

        Event.fire.call(this, EVT.CANCELLED);

        cleanUp.call(this);
    }

    Promise.prototype.cancel = cancel;

    exports.Promise = Promise;

    exports.promise = function(resolver) {
        return new Promise(resolver);
    };

    /**
     * To check if the given promise is still pending.
     * @method isPending
     * @memberof module:ax/promise
     * @param {object} object The target promise object
     * @returns {Boolean} True if it is still pending, false otherwise
     */
    function isPending(obj) {
        return isPromise(obj) && obj.isPending();
    }
    exports.isPending = isPending;

    /**
     * To check if the given Promise has fulfilled.
     * @method isFulfilled
     * @memberof module:ax/promise
     * @param {object} object The target promise object
     * @returns {Boolean} True if it is fulfilled or non promise, false otherwise
     */
    function isFulfilled(obj) {
        return !isPromise(obj) || obj.isFulfilled();
    }
    exports.isFulfilled = isFulfilled;

    /**
     * To check if the given Promise has rejected.
     * @method isRejected
     * @memberof module:ax/promise
     * @param {object} object The target promise object
     * @returns {Boolean} True if it is rejected or non promise, false otherwise
     */
    function isRejected(obj) {
        return isPromise(obj) && obj.isRejected();
    }
    exports.isRejected = isRejected;

    /**
     * To indicate whether the given object is a promise or not.
     * @method isPromise
     * @memberof module:ax/promise
     * @param {Object} object The target object
     * @returns {Boolean} True if it is promise, false otherwise
     */
    function isPromise(value) {
        return value instanceof Promise;
    }
    exports.isPromise = isPromise;

    /**
     * To create a fulfilled promise with the value specified.
     * @method fulfill
     * @memberof module:ax/promise
     * @param {T} value The value when fulfill
     * @returns {module:ax/promise~Promise.<T>} A fulfilled promise with the value specified
     */
    function fulfill(value) {
        return new Promise(function(resolve, reject) {
            resolve(value);
        });
    }
    exports.fulfill = fulfill;


    /**
     * To create a rejected promise with the reason specified.
     *
     * @method reject
     * @memberof module:ax/promise
     * @param {T} reason the reson to reject
     * @returns {module:ax/promise~Promise.<T>} A rejected promise with the reason specified
     */
    function reject(reason) {
        return new Promise(function(resolve, reject) {
            reject(reason);
        });
    }
    exports.reject = reject;
    /**
     * To create a promise, which has fulfilled with the given value.
     *
     * @method resolve
     * @memberof module:ax/promise
     * @param {T} value The value when resolve
     * @returns {module:ax/promise~Promise.<T>} A fulfilled promise with the value specified
     */
    function resolve(value) {
        if (isPromise(value)) {
            return value;
        }
        return fulfill(value);
    }
    exports.resolve = resolve;

    /**
     * Create a PromiseDefer object.
     *
     *
     *
     * @method defer
     * @memberof module:ax/promise
     * @returns {module:ax/promise~PromiseDefer} Return the deferred object
     * @example
     * var deferred = promise.defer();
     */
    function defer() {
        var ret = {};

        ret.promise = new Promise(function(resolve, reject, progress) {
            ret.fulfill = resolve; //deprecated, keep for backward-compatibility
            ret.resolve = resolve;
            ret.reject = reject;
            ret.notify = progress;
        }, function(message) {
            var onCancel = ret.onCancel;
            if (util.isFunction(onCancel)) {
                onCancel(message);
            }
            ret.onCancel = null;
        });

        return ret;
    }
    exports.defer = defer;



    /**
     * To handle the failure case of the promise.
     *
     * @param {module:ax/promise~Promise} promise targed promise
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @returns {module:ax/promise~Promise} Promise is returned
     * @method fail
     * @memberof module:ax/promise
     * @private
     */
    function fail(promise, rejected) {
        return when(promise, undefined, rejected);
    }
    exports.fail = fail;
    /**
     * To handle the failure case of the promise.
     *
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @returns {module:ax/promise~Promise} Promise is returned
     * @method fail
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.fail = function(rejected) {
        return fail(this, rejected);
    };

    /**
     * To handle the progress case of the promise.
     *
     * @param {module:ax/promise~Promise} promise targed promise
     * @param {module:ax/promise~Promise#onProgress} progressed  Callback function when the promise is processing
     * @returns {module:ax/promise~Promise} Promise is returned
     * @method progress
     * @memberof module:ax/promise
     * @private
     */
    function progress(promise, progressed) {
        return when(promise, undefined, undefined, progressed);
    }
    exports.progress = progress;

    /**
     * To handle the progress case of the promise.
     *
     * @param {module:ax/promise~Promise#onProgress} progressed  Callback function when the promise is processing
     * @returns {module:ax/promise~Promise} Promise is returned
     * @method progress
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.progress = function(progressed) {
        return progress(this, progressed);
    };

    /**
     * To create a fulfilled promise when it fulfill the value.
     * @method when
     * @memberof module:ax/promise
     * @param {Object} value  promise or immediate reference to observe
     * @param {module:ax/promise~Promise#onFulfill} fulfilled  Callback function when the promise is fulfilled
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @param {module:ax/promise~Promise#onProgress} progressed  Callback function when the promise is processing
     * @param {module:ax/promise~Promise#onCancel} cancelled  Callback function when the promise is cancelled
     * @returns {module:ax/promise~Promise} Promise is returned
     */
    function when(value, fulfilled, rejected, progressed, cancelled) {
        return resolve(value)
            .then(fulfilled, rejected, progressed, cancelled);
    }
    exports.when = when;


    /**
     * To handle the promise after it has either fulfilled or rejected.<br/>
     * This method is used to handle any common logic regardless of the attached promise result.
     * The value of the attached promise will not be passed into the onComplete callback, but be cascaded to the promise chain.
     *
     * @param {module:ax/promise~Promise} promise targed promise
     * @param {module:ax/promise~Promise#onComplete.<T>} callback  Callback function when the promise completes
     * @returns {module:ax/promise~Promise.<T>} A promise value cascaded from the attached promise
     * @method complete
     * @memberof module:ax/promise
     * @private
     */
    function complete(promise, callback) {
        return when(promise, function(value) {
            return when(callback(),
                function() {
                    return value;
                }
            );
        }, function(exception) {
            return when(callback(),
                function() {
                    return reject(exception);
                }
            );
        }, null, function() {
            callback();
        });
    }

    /**
     * To handle the promise after it has either fulfilled or rejected.<br/>
     * The value of the attached promise will be cascaded. This method is usually used for resource clean up.
     *
     * @param {module:ax/promise~Promise#onComplete.<T>} callback  Callback function when the promise completes
     * @returns {module:ax/promise~Promise.<T>} A promise value cascaded from the attached promise
     * @method complete
     * @memberof module:ax/promise~Promise#
     * @example
     * var fs = FileSystem.init();
     * var file = fs.open(fileName);
     *
     * // assume writeToFile(String, String) is a function writing content to the specified file
     * // this function return a fulfilled promise when success, or a rejected promise when fail
     * file.writeToFile(fileName, content)
     *   .complete(function() {
     *       file.close();
     *   }).then(function(value) {
     *       // continue the logic
     *   }, function(reason) {
     *       // show failure popup
     *   }).done();
     */

    Promise.prototype.complete = function(callback) {
        return complete(this, callback);
    };
    exports.complete = complete;

    /**
     * Terminates a chain of promises, forcing unhandled rejection to be thrown as exceptions.
     *
     * @param {module:ax/promise~Promise} promise targed promise
     * @param {module:ax/promise~Promise#onFulfill} fulfilled  Callback function when the promise is fulfilled
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @param {module:ax/promise~Promise#onProgress} progressed  Callback function when the promise is processing
     * @param {module:ax/promise~Promise#onProgress} cancelled  Callback function when the promise is cancelled
     * @returns {module:ax/promise~Promise} Promise is returned
     * @method done
     * @memberof module:ax/promise
     * @private
     */
    function done(promise, fulfilled, rejected, progress, cancelled) {
        var promiseToHandle, onUnhandledError;
        onUnhandledError = function(error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            nextTick(function() {

                if (exports.onerror) {
                    exports.onerror(error);
                } else if (error instanceof Error) {
                    throw error;
                } else {
                    console.warn(error);
                }
            });
        };

        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        promiseToHandle = fulfilled || rejected || progress || cancelled ? when(promise, fulfilled, rejected, progress, cancelled) :
            promise;

        fail(promiseToHandle, onUnhandledError);
    }
    exports.done = done;
    /**
     * Terminates a chain of promises, forcing unhandled rejection to be thrown as exceptions.
     *
     * @param {module:ax/promise~Promise#onFulfill} fulfilled  Callback function when the promise is fulfilled
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @param {module:ax/promise~Promise#onProgress} progressed  Callback function when the promise is processing
     * @returns {module:ax/promise~Promise} Promise is returned
     * @method done
     * @memberof module:ax/promise~Promise#
     */
    Promise.prototype.done = function(fulfilled, rejected, progress, cancelled) {
        return done(this, fulfilled, rejected, progress, cancelled);
    };



    /**
     * Turns an array of promises into a promise for an array.<br/>
     * The promise will get fulfilled when all given promises fulfill.
     * If any of the given promises gets rejected, the whole array is rejected immediately.
     * Cancelling a all would imply a cancel to all subsequence pending promises.
     *
     * @method all
     * @memberof module:ax/promise~Promise
     * @param {Array} promises an array (or promise for an array) of values (or promises for values)
     * @returns {module:ax/promise~Promise.<Array>} a promise for an array of the corresponding values
     * @throws {module:ax/promise~Promise.<Error|Object>} the value of the rejected promise
     */
    function all(promises) {

        return (function() {

            var countDown = 0,
                pendingIds = {},
                resolve,
                reject,
                notify;

            function waitFor(promise, index) {

                var p = promise.then(
                    function(value) {
                        promises[index] = value;
                        delete pendingIds[promise.getId()];

                        //resolved when all promises resolved
                        if (--countDown === 0) {
                            resolve(promises);
                            util.clear(pendingIds);
                        }
                    },
                    function(reason) {
                        reject(reason);
                        util.clear(pendingIds);
                    },
                    function(progress) {
                        notify({
                            index: index,
                            value: progress
                        });
                    });

                pendingIds[promise.getId()] = p.getId();
            }

            function allResolver(_resolve, _reject, _notify) {

                resolve = _resolve;
                reject = _reject;
                notify = _notify;

                util.each(promises, function(promise, index) {

                    if (!isPromise(promise)) {
                        return;
                    }

                    if (isRejected(promise)) {
                        reject(promise.inspect()
                            .reason);
                    }

                    if (isFulfilled(promise)) {
                        promises[index] = promise.inspect()
                            .value;

                        return;
                    }

                    ++countDown;

                    waitFor(promise, index);
                });

                if (countDown === 0) {
                    resolve(promises);
                }
            }

            function allOnCancel(message) {

                util.each(promises, function(promise, index) {

                    if (!isPromise(promise)) {
                        return;
                    }

                    if (promise.isPending()) {
                        promise.cancel(message, pendingIds[promise.getId()]);
                        delete pendingIds[promise.getId()];
                    }
                });

            }

            return new Promise(allResolver, allOnCancel);
        }());

    }
    exports.all = all;

    /**
     * Turns an array of promises into a promise for an array.<br/>
     * The promise will get fulfilled when all given promises are fulfilled or rejected.
     * Cancelling a spread would imply a cancel to all subsequence pending promises
     *
     * @method allSettled
     * @memberof module:ax/promise~Promise
     * @param {Array} promises an array (or promise for an array) of values (or promises for values)
     * @returns {module:ax/promise~Promise.<Array>} a promise for an array of the corresponding inspect object
     * @example
     *
     * var all = promise.allSettled([
     *         promise.resolve(1),
     *         promise.reject(2)
     *     ]);
     *
     * all.then(function (results) {
     *     // results[0] - { state: "fulfilled", value: 1 }
     *     // results[1] - { state: "rejected", reason: 2 }
     * });
     */
    function allSettled(promises) {
        return all(util.map(promises, function(promise) {
            if (!isPromise(promise)) {
                promise = resolve(promise);
            }

            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    }
    exports.allSettled = allSettled;

    /**
     * Turns an array of promises into a promise for an array.<br/>
     * a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.
     * Cancelling a race would imply cancelling to all subsequence pending promises.
     *
     * @method race
     * @memberof module:ax/promise~Promise
     * @param {Array} promises an array (or promise for an array) of values (or promises for values)
     * @returns {module:ax/promise~Promise.<Object>} corresponding value of the fastest promise
     * @throws {module:ax/promise~Promise.<Error|Object>} the reason of the fastest promise
     * @example
     *
     * var a = promise.defer(),
     *     b = promise.defer();
     *
     * promise.race([
     *     a.promise,
     *     b.promise
     * ]).then(function(value) {
     *     // value - "a"
     * }, null);
     *
     * a.resolve("a");
     */
    function race(promises) {
        var deferred = defer(),
            pendingPromises = [];

        when(promises, function(promises) {
            util
                .each(promises, function(promise, index) {

                    if (!isPromise(promise)) {
                        promise = resolve(promise);
                    }
                    var p = when(promise, deferred.resolve, deferred.reject);
                    pendingPromises.push(p);
                });
        });


        deferred.onCancel = function(message) {

            util.each(pendingPromises, function(promise, index) {
                promise.cancel(message);
            });

        };

        return deferred.promise;
    }
    exports.race = race;

    /**
     * Spreads the values of a promised array into fulfill callback.
     * The fulfill callback will then be invoked with a list of arguments,
     * each of them corresponds to the element inside the promise array.
     *
     * @method spread
     * @private
     * @memberof module:ax/promise
     * @param {module:ax/promise~Promise} promise to observe
     * @param {module:ax/promise~Promise#onFulfill} fulfilled  Callback function when the promise is fulfilled
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @returns {module:ax/promise~Promise} Promise is returned
     */
    function spread(promise, fulfilled, rejected) {
        return when(promise, function(valuesOrPromises) {
            return all(valuesOrPromises)
                .then(function(values) {
                    return fulfilled.apply(undefined, values);
                }, rejected);
        }, rejected);

    }

    /**
     * Spreads the values of the attached promised array into fulfill callback.
     * The fulfill callback will then be invoked with a list of arguments,
     * each of them corresponds to the element inside the promise array.
     * This is usually used together with {@link module:ax/promise.all}.
     * Cancelling a spread would imply a cancel to all subsequence pending promises.
     *
     * @method spread
     * @memberof module:ax/promise~Promise#
     * @param {module:ax/promise~Promise#onFulfill} fulfilled  Callback function when the promise is fulfilled
     * @param {module:ax/promise~Promise#onReject} rejected  Callback function when the promise is rejected
     * @returns {module:ax/promise~Promise} Promise is returned
     * @example
     * promise.all([
     *   promise.resolve(1),
     *   promise.resolve(2)
     * ]).spread(function(a, b) {
     *   console.log(a + b);
     * }).done();
     * // output
     * // 3
     *
     * promise.all([
     *   promise.resolve(1),
     *   promise.reject(2)
     * ]).spread(function(a, b) {
     *   console.log(a + b);
     * }, function(reason) {
     *   console.error(reason);
     * }).done();
     * // output
     * // 2
     */
    Promise.prototype.spread = function(fulfilled, rejected) {
        return spread(this, fulfilled, rejected);
    };

    exports.spread = spread;



});
/**
 *
 * @class xdk-base/device/interface/DevicePackage
 */
define("xdk-base/device/interface/DevicePackage", [
    "xdk-base/Interface"
], function (
    Interface
) {
    "use strict";
    var DevicePackage = Interface.create("DevicePackage", {
        /**
         * set up the Device Package
         * @name setup
         * @function
         * @memberof xdk-base/device/interface/DevicePackage
         * @param {Function} onDeviceLoaded callback when the device is loaded.
         * @public
         */
        setup: ["onDeviceLoaded"],
        /**
         * get the id of the device package
         * @name init
         * @function
         * @memberof xdk-base/device/interface/DevicePackage
         * @returns {String} the id of the device package
         * @public
         */
        getId: [],
        /**
         * get the default player when no players provided
         * @name getDefaultPlayer
         * @function
         * @memberof xdk-base/device/interface/DevicePackage
         * @returns {String[]} Array of the player
         * @public
         */
        getDefaultPlayer: []
    });

    return DevicePackage;
});
/**
 * The abstract Device Package, can be used as a starting point of building any device package.
 * @class xdk-base/device/AbstractDevicePackage
 */
define("xdk-base/device/AbstractDevicePackage", [
    "xdk-base/class",
    "xdk-base/core",
    "xdk-base/console",
    "xdk-base/device/playerRegistry",
    "xdk-base/device/interface/Player",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/promise",
    "require",
    "xdk-base/device/interface/DevicePackage"
], function (
    klass,
    core,
    console,
    playerRegistry,
    IPlayer,
    util,
    config,
    promise,
    require,
    IDevicePackage) {
    "use strict";
    var PACKAGE_ENUM = {
            STORAGE: "Storage",
            STORAGE_HANDLE: "storage",
            MEDIA_PLAYER: "Media",
            MEDIA_PLAYER_HANDLE: "media",
            TV_KEY: "TvKey",
            TV_KEY_HANDLE: "tvkey",
            ID: "Id",
            ID_HANDLE: "id",
            CONSOLE: "Console",
            CONSOLE_HANDLE: "console",
            SYSTEM: "System",
            SYSTEM_HANDLE: "system"
        },
        devicePackage = klass.createAbstract([IDevicePackage], {
            /**
             * Name for Storage interface
             * @constant
             * @name STORAGE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            STORAGE: PACKAGE_ENUM.STORAGE,
            /**
             * Name for Storage Handle
             * @constant
             * @name STORAGE_HANDLE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            STORAGE_HANDLE: PACKAGE_ENUM.STORAGE_HANDLE,
            /**
             * Name for Media interface
             * @constant
             * @name MEDIA_PLAYER
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            MEDIA_PLAYER: PACKAGE_ENUM.MEDIA_PLAYER,
            /**
             * Name for Media Handle
             * @constant
             * @name MEDIA_PLAYER_HANDLE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            MEDIA_PLAYER_HANDLE: PACKAGE_ENUM.MEDIA_PLAYER_HANDLE,
            /**
             * Name for TV KEY interface
             * @constant
             * @name TV_KEY
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            TV_KEY: PACKAGE_ENUM.TV_KEY,
            /**
             * Name for TV KEY HANDLE
             * @constant
             * @name TV_KEY_HANDLE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            TV_KEY_HANDLE: PACKAGE_ENUM.TV_KEY_HANDLE,
            /**
             * Name for ID interface
             * @constant
             * @name ID
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            ID: PACKAGE_ENUM.ID,
            /**
             * Name for ID handle
             * @constant
             * @name ID_HANDLE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            ID_HANDLE: PACKAGE_ENUM.ID_HANDLE,
            /**
             * Name for Console interface
             * @constant
             * @name CONSOLE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            CONSOLE: PACKAGE_ENUM.CONSOLE,
            /**
             * Name for Console handle
             * @constant
             * @name CONSOLE_HANDLE
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            CONSOLE_HANDLE: PACKAGE_ENUM.CONSOLE_HANDLE,
            /**
             * Name for System interface
             * @constant
             * @name SYSTEM
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            SYSTEM: PACKAGE_ENUM.SYSTEM,
            /**
             * Name for System interface
             * @constant
             * @name SYSTEM
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            SYSTEM_HANDLE: PACKAGE_ENUM.SYSTEM_HANDLE,
            /**
             * Basic interfaces for a proper device package
             * @constant
             * @name BASIC_INTERFACES
             * @memberof xdk-base/device/AbstractDevicePackage
             */
            BASIC_INTERFACES: [{
                name: PACKAGE_ENUM.STORAGE,
                handle: PACKAGE_ENUM.STORAGE_HANDLE
            }, {
                name: PACKAGE_ENUM.MEDIA_PLAYER,
                handle: PACKAGE_ENUM.MEDIA_PLAYER_HANDLE
            }, {
                name: PACKAGE_ENUM.TV_KEY,
                handle: PACKAGE_ENUM.TV_KEY_HANDLE
            }, {
                name: PACKAGE_ENUM.ID,
                handle: PACKAGE_ENUM.ID_HANDLE
            }, {
                name: PACKAGE_ENUM.SYSTEM,
                handle: PACKAGE_ENUM.SYSTEM_HANDLE
            }],
            /**
             * [Backward Compatible only] To be called when the device package is loaded
             * @deprecated
             * @method _onDeviceReady
             * @memberof xdk-base/device/AbstractDevicePackage
             * @protected
             */
            _onDeviceReady: null,
            /**
             * [Backward Compatible only] To be true when device package version >= 2.3
             * @property {Boolean} Should this setup method in AbstractDevicePackage run
             * @name _shouldSetup
             * @memberof xdk-base/device/AbstractDevicePackage
             * @protected
             */
            _shouldSetup: false,
            /**
             * [Backward Compatible only] To set the callback before init the device package instead of set in the constructor to avoid being overrided.
            
             * @method prepare
             * @param {Function} callback Device ready callback
             * @returns {ax/device/AbstractDevicePackage} abstract device package itself
             * @deprecated
             * @memberof xdk-base/device/AbstractDevicePackage
             * @public
             */
            prepare: function (callback) {
                devicePackage._onDeviceReady = callback;
            }
        }, {
            /**
             * To be called when the device package is loaded
             * @since 2.1 to replace static onDeviceReady variable
             * @name __onDeviceReady
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @private
             */
            __onDeviceReady: null,
            /**
             * To store the interface information like the handle and obj
             * @name __interfaceTypes
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @private
             */
            __interfaceTypes: {},
            /**
             * To store the reference which will be then append to the device
             * @name __device
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @private
             */
            __device: {},
            /**
             * [Backward Compatible only] To set the callback
             * @method init
             * @deprecated constructor should not pass the callback. callback should pass in the set up function.
             * @param {Function} callback Device ready callback
             * @returns {ax/device/AbstractDevicePackage} abstract device package itself
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            init: function (onDeviceLoaded) {
                this.__onDeviceReady = onDeviceLoaded;
                console.info("init of abstractDevicePackage");
                return this;
            },
            /**
             * setup the device package
             * @method setup
             * @param {Function} onDeviceLoaded callback when the device is loaded.
             * @returns {ax/device/AbstractDevicePackage} abstract device package itself
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            setup: function(onDeviceLoaded) {
                if (!this._shouldSetup) {
                    return;
                }

                this.__onDeviceReady = onDeviceLoaded;
                console.info("set up abstractDevicePackage");
                core.root.onunload = this.deinit;

                return this;
            },
            /**
             * To add the interface into the abstraction which later will be appended into the device
             *
             * @method addInterfaceType
             * @param {String} type Interface type
             * @param {Function} handle Interface handle
             * @param {Object} interfaceObj Interface Object
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            addInterfaceType: function (type, handle, interfaceObj) {
                this.__interfaceTypes[type] = {
                    handle: handle,
                    interfaceObj: interfaceObj
                };

                this.__device[handle] = interfaceObj;
            },
            /**
             * Get the interface by type
             * @method getInterface
             * @param {String} type Interface type
             * @return {Object|Null} interfaceObj Interface Object
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            getInterface: function (type) {
                if (this.__interfaceTypes[type]) {
                    return this.__interfaceTypes[type].interfaceObj;
                }
                return null;
            },
            /**
             * To get the unique indicator for each device package
             * @return {String} the id name e.g workstation
             *
             * @method getId
             * @abstract
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            getId: klass.abstractFn,
            /**
             * To go through the checking and ensure the device module is attached to the device
             *
             * @method ready
             * @param {Object} [launchData] hold launch data if any
             * @param {Boolean} [launchData.isPaused=false] whether the device load again from pause state
             * @param {Object} [launchData.deeplinkData=null] the deep link data from platform if any
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            ready: function (launchData) {
                launchData = launchData || {};

                if (this.__onDeviceReady && util.isFunction(this.__onDeviceReady)) {
                    this.__onDeviceReady(this.__device, launchData);
                    return;
                }

                // backward compatible only
                devicePackage._onDeviceReady(this.__device, launchData);
            },
            /**
             * To load the player from the playlist set in the config
             * @method _preparePlayerList
             * @param {Function} cb callback function to be called after prepared playlist
             * @deprecated it will perform playlist handling when the device package is ready inside the device
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @protected
             */
            _preparePlayerList: function (cb) {
                cb();
            },
            /**
             * To get the default player. Default will be [] array.
             * @method getDefaultPlayer
             * @returns {String[]} Array of the player list
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @public
             */
            getDefaultPlayer: function () {
                return [];
            },
            /**
             * To get the default player. Default will be [] array.
             * @method _getDefaultPlayer
             * @returns {String[]} Array of the player list
             * @deprecated replaced with {@link xdk-base/device/AbstractDevicePackage#getDefaultPlayer}
             * @memberof xdk-base/device/AbstractDevicePackage#
             * @protected
             */
            _getDefaultPlayer: function () {
                return [];
            },
            /**
             * To unlod the playerRegistry and deinit all the player
             *
             * @method deinit
             * @memberof xdk-base/device/AbstractDevicePackage#
             */
            deinit: function () {
                var device = require("xdk-base/device");

                console.info("[XDK] DOM Unloaded");

                playerRegistry.deinit();

                //deinit device module
                device.deinit();
            }
        });
    return devicePackage;
});
/**
 * The device handler interface to resolve the state of the application when the platform is detected and application is loaded, paused, resumed or unloaded.
 *
 * @class xdk-base/interface/DeviceHandler
 */
define("xdk-base/interface/DeviceHandler", ["xdk-base/Interface"], function (Interface) {
    "use strict";

    return Interface.create("DeviceHandler", {
        /**
         * when the platform is detected before loading the device package
         * @name onDeviceDetect
         * @function
         * @param {String} platform the id of the platform
         * @memberof xdk-base/interface/DeviceHandler
         * @public
         */
        onDeviceDetect: ["platform"],
        /**
         * when the device package is loaded and application is ready to load
         * @name onDeviceLoad
         * @function
         * @param {Object} [launchData] hold launch data if any
         * @param {Boolean} [launchData.isPaused=false] whether the device load again from pause state
         * @param {Object} [launchData.deeplinkData=null] the deep link data from platform if any
         * @memberof xdk-base/interface/DeviceHandler
         * @public
         */
        onDeviceLoad: ["launchData"],
        /**
         * when the application pause
         * @name onDevicePause
         * @function
         * @memberof xdk-base/interface/DeviceHandler
         * @public
         */
        onDevicePause: [],
        /**
         * when the application resume
         * @name onDeviceResume
         * @function
         * @memberof xdk-base/interface/DeviceHandler
         * @public
         */
        onDeviceResume: [],
        /**
         * when the application unloads
         * @name onDeviceUnload
         * @function
         * @memberof xdk-base/interface/DeviceHandler
         * @public
         */
        onDeviceUnload: [],
        /**
         * Handle the onKey from the device package, it will then dispatch the onKey event to the appliation.
         * @name onDeviceKey
         * @function
         * @memberof xdk-base/interface/DeviceHandler
         * @param {Object} tvKey the key object of {@link module:xdk-base/device/shared/keyboardVKey} or {@link module:xdk-base/device/VKey}
         * @param {String} source the source of the key event. Default will be "device"
         * @public
         */
        onDeviceKey: []
    });
});
/**
 * The device's module type constants.
 * @module xdk-base/device/basicInterfaces
 * @author Marcus Yip <marcus.yip@accedo.tv>
 */
define("xdk-base/device/basicInterfaces", [],function() {
    "use strict";

    return {
        STORAGE: "storage",
        MEDIA_PLAYER: "media",
        TV_KEY: "tvkey",
        ID: "id",
        SYSTEM: "system"
    };
});

/**
 * @module xdk-base/device
 * @description
 *
 * Device module handles device detection and platform module loading. Every device abstraction package should provide a detection module, providing the API to check if itself is the correct package to use. The order of  package detection is determined from config **device.packages**
 *
 * ###Config Params
 *
 *  Attribute | Value
 * --------- | ---------
 * Key      | device.initTimeout
 * Type     | Number
 * Desc     |  Timeout for loading device packages in milliseconds.
 * Default  | 10000
 * Usage    | {@link module:xdk-base/config}
 * -----------------------------------------------------
 * Attribute | Value
 * --------- | ---------
 * Key      | device.target-platform
 * Type     |  String
 * Desc     | The target platform when loading the platform. No detection will be checked and directly load. The priority of device.target-platform will be higher than the device.packages
 * Default  | null
 * Usage    | {@link module:xdk-base/config}
 * Example  | "xdk-ext-device-lg"
 * -----------------------------------------
 * Attribute | Value
 * --------- | ---------
 * Key      | device.packages
 * Type     | Array
 * Desc     | The list of device package to be added for detection
 * Default  | ["xdk-base/device/workstation"]
 * Usage    | {@link module:xdk-base/config}
 * Example  |  ["xdk-ext-device-samsung", "xdk-ext-device-lg", "xdk-base/device/workstation"]
 * ----------------------------------------------------------------------------------
 * Attribute | Value
 * --------- | ---------
 * Key      | device.players
 * Type     | Object
 * Usage    | {@link module:xdk-base/config}
 * Desc     | The list of players added into that platform
 * Default  | Error occur if it is empty
 * Example  |
 *{
 *    "ps3": [ "xdk-ext-device-ps3/PSPlayer"],
 *    "playstation": [ "xdk-ext-device-playstation/PSPlayer"],
 *    "opera": ["xdk-base/device/shared/FlashPlayer"],
 *    "workstation": ["xdk-base/device/shared/Html5Player", "xdk-base/device/shared/FlashPlayer"],
 *    "samsung": ["xdk-ext-device-samsung/SefPlayer", "xdk-base/device/shared/FlashPlayer", "xdk-ext-device-samsung/InfolinkPlayer"]
 *}
 *
 * ### Abstracted Device Interfaces
 *
 * Device module abstracted a set of abstracted device interfaces. They unify functionality and interface across different platforms. These APIs can be directly accessible through Device module. e.g.**device.id**
 *
 * * {@link xdk-base/device/AbstractId|device.id}
 * * {@link xdk-base/device/AbstractStorage|device.storage}
 * * {@link xdk-base/device/AbstractSystem|device.system}
 * * {@link xdk-base/device/AbstractTvKey|device.tvkey}
 * * {@link xdk-base/device/Media|device.media}
 *
 * @author Thomas Lee <thomas.lee@accedo.tv>
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-base/device", [
    "xdk-base/config",
    "xdk-base/console",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/device/AbstractDevicePackage",
    "xdk-base/device/vKey",
    "require",
    "xdk-base/class",
    "xdk-base/interface/DeviceHandler",
    "xdk-base/exception",
    "xdk-base/device/interface/Player",
    "xdk-base/promise",
    "xdk-base/device/playerRegistry",
    "xdk-base/device/basicInterfaces"
], function (
    config,
    console,
    core,
    util,
    abstrDevicePackage,
    _vKey,
    require,
    klass,
    IDeviceHandler,
    exception,
    IPlayer,
    promise,
    playerRegistry,
    basicInterfaces
) {
    "use strict";
    /**
     * To store the device detect from the deviceHandler
     * @name onDeviceDetect
     * @memberof module:xdk-base/device
     * @private
     */
    var onDeviceDetect,
        /**
         * To store the device loaded from the deviceHandler
         * @name onDeviceLoad
         * @memberof module:xdk-base/device
         * @private
         */
        onDeviceLoad,
        /**
         * To store the device package
         * @name devicePackage
         * @memberof module:xdk-base/device
         * @private
         */
        devicePackage,
        /**
         * The timeout handle for loading package
         * @name packageTimeoutHandle
         * @memberof module:xdk-base/device
         * @private
         */
        packageTimeoutHandle,
        /**
         * whether the dom is ready
         * @name ready
         * @memberof module:xdk-base/device
         * @private
         */
        ready = false,
        /**
         * whether the device is inited
         * @name inited
         * @memberof module:xdk-base/device
         * @private
         */
        inited = false,
        /**
         * whether detected
         * @name  detected
         * @memberof module:xdk-base/device
         * @private
         */
        detected = false,
        /**
         * detectedPackage
         * @name detectedPackage
         * @memberof module:xdk-base/device
         * @private
         */
        detectedPackage = null,
        /**
         * the device handler
         * @name deviceHandler
         * @memberof module:xdk-base/device
         * @private
         */
        deviceHandler,
        /**
         * The callback when the desired device package is loaded and fallback to the device module.
         * @method onInitedSuccess
         * @param {Object} devicePackageDef the devicePackage when finsih inited
         * @param {Object} launchData hold launch data if any
         * @param {Boolean} [launchData.isPaused=false] whether the device load again from pause state
         * @param {Object} [launchData.deeplinkData=null] the deep link data from platform if any
         * @throws {Exception.<exception.ILLEGAL_ARGUMENT>} when the target player doesn't implement interface Player or fail to load the multi audio track strategy
         * @memberof module:xdk-base/device
         * @private
         */
        onInitedSuccess = function (devicePackageDef, launchData) {
            var playerList, intf, handleName;

            inited = true;

            //to ensure thing are attached to device package
            util.each(basicInterfaces, function (pair) {
                handleName = pair.value;
                intf = devicePackageDef[handleName];

                if (!intf) {
                    console.error("Basic interface not implemented in device package:name=" + handleName);
                }

                //put the device back to device level
                deviceModule[handleName] = intf;
            });

            clearTimeout(packageTimeoutHandle);

            //init key handling
            //the callback function is for backward compatability
            deviceModule.tvkey.initKeyHandling(function () {
                return false;
            });

            //to config the player list
            playerList = config.get("device.players", false);

            if (playerList && playerList[devicePackage.getId()]) {
                //grab the predefined player list
                playerList = playerList[devicePackage.getId()];
            } else {

                //apply the new player list
                if (devicePackage.getDefaultPlayer) {
                    //get the default player list
                    playerList = devicePackage.getDefaultPlayer();
                }

                //backward compatible only, apply when the playerlist is empty(which is not set in the getDefaultPlayer) and _getDefaultPlayer function exists
                if (playerList.length === 0 && devicePackage._getDefaultPlayer) {
                    playerList = devicePackage._getDefaultPlayer();
                }
            }

            if (playerList.length > 0) {
                //to load the player list file
                require(playerList, function () {

                    var playerStgyPromiseArr = [],
                        playerHandler;

                    playerHandler = function (Player, i) {
                        if (!klass.hasImpl(Player, IPlayer)) {
                            throw core.createException(exception.ILLEGAL_ARGUMENT, "Player does not implement ax/device/interface/Player: " + playerId);
                        }
                        var playerInstance, multiAudioTrackList, playerId, subtitleList, stgyArr = [],
                            playerSubtitle, playerStgyDefer;

                        playerId = playerList[i];

                        try {
                            playerInstance = new Player(devicePackage);
                        } catch (e) {
                            console.warn("[XDK] Fail to load the player : " + playerId + " : " + e.name);
                            return;
                        }

                        //register the player
                        playerRegistry.register(playerInstance, playerId);

                        //player strategy loading
                        //multiple audio track
                        multiAudioTrackList = config.get("device.multiAudioTrackStgy", null);

                        //to get the default multi audio track config
                        if (multiAudioTrackList && multiAudioTrackList[playerId]) {
                            stgyArr.push(multiAudioTrackList[playerId]);
                            console.info("[XDK] Multi Audio Track exist " + multiAudioTrackList + " for " + playerId);
                        }

                        //subtitle
                        subtitleList = config.get("device.subtitleStgy", null);

                        //to get the subtitle config
                        if (subtitleList && subtitleList[playerId]) {
                            
                            playerSubtitle = subtitleList[playerId];

                            //load the internal player subtitle stgy
                            if (playerSubtitle.internal) {
                                console.info("[XDK] Loading the internal player strategy " + playerSubtitle.internal);
                                stgyArr.push(playerSubtitle.internal);
                            }

                            if (playerSubtitle.external) {
                                console.info("[XDK] Loading the external player strategy " + playerSubtitle.external);
                                stgyArr.push(playerSubtitle.external);
                            }

                        }

                        //no need to load external strategy
                        if (stgyArr.length === 0) {
                            return;
                        }

                        playerStgyDefer = promise.defer();

                        playerStgyPromiseArr.push(playerStgyDefer.promise);

                        //to load the strategies for that player
                        require(stgyArr, function () {
                            console.info("[XDK] Loading the player strategies");
                            playerStgyDefer.resolve();
                        }, function () {
                            throw core.createException(exception.ILLEGAL_ARGUMENT, "Unable to load the player related strategies. Please check the paths.");
                        });
                    };

                    util.each(Array.prototype.slice.call(arguments), playerHandler);

                    //continue devie initialization in a new thread
                    promise.all(playerStgyPromiseArr).then(util.bind(onDeviceLoad, this, launchData)).done();
                }, function () {
                    throw core.createException(exception.UNSUPPORTED_OPERATION, "Unable to load the player list. Please check the paths.");
                });

                return;
            }

            onDeviceLoad(launchData);
        },
        /**
         * To handle the device package loading failure
         * @method onInitFailure
         * @throws {Exception.<exception.UNSUPPORTED_OPERATION>} when fail to initialize the device package
         * @memberof module:xdk-base/device
         * @private
         */
        onInitFailure = function () {
            clearTimeout(packageTimeoutHandle);
            console.error("Initialize device package timeout!");
            throw core.createException(exception.UNSUPPORTED_OPERATION, "Initialize device package timeout!");
        },
        /**
         * After loaded the desired platform js file, it will then init the platofrm.
         * @method onLoadSuccess
         * @param {Object} devicePackageDef the device packages
         * @memberof module:xdk-base/device
         * @private
         */
        onLoadSuccess = function (DevicePackageDef) {
            var deferOnDevicePackageInited,
                /**
                 * time out for loading the device
                 * @name DEVICE_INIT_TIMEOUT
                 * @memberof module:xdk-base/device
                 * @private
                 */
                DEVICE_INIT_TIMEOUT = config.get("device.initTimeout", 10 * 1000);

            packageTimeoutHandle = setTimeout(onInitFailure, DEVICE_INIT_TIMEOUT);

            if (!DevicePackageDef) {
                onLoadFailure("Device package reference not found.");
                return;
            }

            // backward compatible setting only
            if (DevicePackageDef.prepare) {
                DevicePackageDef.prepare(onInitedSuccess);
            }

            deferOnDevicePackageInited = util.wrap(onInitedSuccess, function (origin, arg) {
                //to create another thread so that the devicePackage is created before the package is inited and access its public function
                util.delay().then(util.bind(origin, deviceModule, arg));
            });

            //@deprecated to pass the onInitedSuccess in the constructor, the new device package should use setup function.
            devicePackage = new DevicePackageDef(deferOnDevicePackageInited);

            devicePackage.setup(function () {
                //add the platform id into the device
                deviceModule.platform = devicePackage.getId();

                onInitedSuccess.apply(null, arguments);
            });
        },

        /**
         * To handle the device package failure
         * @method onLoadFailure
         * @throws {Exception.<exception.UNSUPPORTED_OPERATION>} when device package fails to load
         * @memberof module:xdk-base/device
         * @private
         */
        onLoadFailure = function (err) {
            console.error("Device package is unable to load due to: " + err.message);
            throw core.createException(exception.UNSUPPORTED_OPERATION, "Device package is unable to load due to: " + err.message);
        },

        /**
         * To load the package
         * @method loadPackage
         * @memberof module:xdk-base/device
         * @private
         */
        loadPackage = function () {

            if (detected) {
                return;
            }
            //default is workstation
            if (!detectedPackage) {
                detectedPackage = "xdk-base/device/workstation";
            }

            detected = true;

            onDeviceDetect(detectedPackage);

            require([detectedPackage + "/DevicePackage"], onLoadSuccess, onLoadFailure);

        },
        /**
         * loading the device package
         * @method loadDevicePackage
         * @throws {Exception.<exception.ILLEGAL_ARGUMENT>} when no available target device package(s)
         * @throws {Exception.<exception.UNSUPPORTED_OPERATION>} when fail to load the list of target device packages
         * @memberof module:xdk-base/device
         * @private
         */
        loadDevicePackage = function () {

            /**
             * the target device platform
             * @name targetPlatform
             * @memberof module:xdk-base/device
             * @private
             */
            var targetPlatform = config.get("device.target-platform", null),
                /**
                 * target device package
                 * @name targetPackages
                 * @memberof module:xdk-base/device
                 * @private
                 */
                targetPackages = config.get("device.packages", ["xdk-base/device/workstation"]),
                /**
                 * the detection list
                 * @name detectionList
                 * @memberof module:xdk-base/device
                 * @private
                 */
                detectionList = [];

            if (inited) {
                if (util.isFunction(onDeviceLoad)) {
                    onDeviceLoad();
                }
                return;
            }

            //if there is targetPlatform, load it without any detection checking
            if (targetPlatform) {

                detectedPackage = targetPlatform;

                //continue load package in a new thread
                util.defer().then(loadPackage).done();

                return;
            }

            //check target packages format
            if (!util.isArray(targetPackages) || targetPackages.length === 0) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "device.packages should be an array:" +
                    targetPackages + " and should not be empty");
            }

            util.each(targetPackages, function (obj) {
                detectionList.push(obj + "/detection");
            });

            require(detectionList, function () {
                util.each(Array.prototype.slice.call(arguments), util.bind(function (obj, i) {
                    if (obj) {
                        detectedPackage = targetPackages[i];
                        return util.breaker;
                    }
                }));

                //continue load package in a new thread
                util.defer().then(loadPackage).done();
            }, function (e) {
                throw core.createException(exception.UNSUPPORTED_OPERATION, "Unable to load detection from the provided packages list: " + targetPackages.toString(), ". Please check your detection file. Stack: " + e.stack);
            });
        },

        /**
         * Default window onload handler.
         * @method onLoad
         * @memberof module:xdk-base/device
         * @private
         */
        onLoad = function () {
            if (ready) {
                return;
            }

            ready = true;

            console.info("[XDK] DOM loaded");
            deviceModule.bootstrap();
        },
        /**
         * the device module
         * @name deviceModule
         * @memberof module:xdk-base/device
         * @private
         */
        deviceModule = {
            //Reserved properties for linking to the device
            id: null,
            system: null,
            media: null,
            tvkey: null,
            storage: null,
            vKey: _vKey,
            /**
             * init the the device module
             * @method init
             * @param {xdk-base/interface/DeviceHandler} targetDeviceHandler the device handler
             * @memberof module:xdk-base/device
             * @throws {Exception.<exception.ILLEGAL_ARGUMENT>} when no valid device handler
             * @public
             */
            init: function (targetDeviceHandler) {
                //set the handler

                //device handler
                if (!klass.hasImpl(targetDeviceHandler.constructor, IDeviceHandler)) {
                    throw core.createException(exception.ILLEGAL_ARGUMENT, "[XDK] Not a valid device handler.");
                }

                deviceHandler = targetDeviceHandler;

                domReady(onLoad);
            },
            /**
             * The bootstrap of the device package. First it will undergo the platform detection and then load the desired platform files.
             * @method _bootstrap
             * @deprecated replaced with {@link module:xdk-base/device.bootstrap}
             * @param {Object} callbackObj Object of function to call when it is initied or detected
             * @param {Function} callbackObj.platformDetectedCb the function to be called when the platform detected.
             * @param {Function} callbackObj.inited the function to be called when the device package is ready
             * @param {Function} failureCb Failure function to be called when fail in loading interfaces
             * @memberof module:xdk-base/device
             * @protected
             */
            _bootstrap: function (callbackObj, failureCb) {

                //to inform back that platform detected, after that device package of that platform will be loaded
                onDeviceDetect = callbackObj.platformDetecetedCb || function (platform) {
                    console.log("platform detected" + platform);
                };

                onDeviceLoad = callbackObj.inited;

                if (util.isFunction(failureCb)) {
                    onLoadFailure = failureCb;
                }

                loadDevicePackage();
            },
            /**
             * The bootstrap of the device which loads the device package.
             * @method bootstrap
             * @memberof module:xdk-base/device
             * @public
             */
            bootstrap: function () {
                var DeviceHandler = this.getDeviceHandler();

                //to inform back that platform detected, after that device package of that platform will be loaded
                onDeviceDetect = util.bind(DeviceHandler.onDeviceDetect, DeviceHandler);

                onDeviceLoad = util.bind(DeviceHandler.onDeviceLoad, DeviceHandler);

                loadDevicePackage();

            },
            /**
             * get the device handler
             * @method getDeviceHandler
             * @returns {ax/interface/DeviceHandler} the device handler
             * @memberof module:xdk-base/device
             * @public
             */
            getDeviceHandler: function () {
                return deviceHandler;
            },
            /**
             * Override to be protected as it should only be called by {@link xdk-base/Env|Env}
             * @method deinit
             * @param {Function} callback Callback function to be called when deinit
             * @memberof  module:xdk-base/device
             * @protected
             */
            deinit: function (callback) {
                //@deprecated
                if (util.isFunction(callback)) {
                    callback();
                }

                //to notify the env is unloaded
                this.getDeviceHandler().onDeviceUnload();
            }
        };

    return deviceModule;
});
/**
 * Cross-browser enviroment abstraction module.
 *
 * This class is designed as a singleton, developer should use {@link xdk-base/Env.singleton|singleton} to obtain the instance.
 * Creating instance using the _new_ keyword is prohibited.
 *
 * @class xdk-base/Env
 * @augments ax/EventDispatcher
 * @fires ax/Env#EVT_ON_PLATFORM_DETECTED
 * @fires ax/Env#EVT_ONDETECT
 * @fires ax/Env#EVT_ONUNLOAD
 * @fires ax/Env#EVT_ONLOAD
 * @fires ax/Env#EVT_ONKEY
 * @fires ax/Env#EVT_ONPAUSE
 * @fires ax/Env#EVT_ONRESUME
 * @fires ax/Env#EVT_ON_MOUSE_WHEEL
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-base/Env", [
    "xdk-base/class", "xdk-base/EventDispatcher", "xdk-base/console", "xdk-base/device/vKey", "xdk-base/util",
    "xdk-base/device", "xdk-base/core", "xdk-base/interface/DeviceHandler"
], function (klass, EventDispatcher, console, vKey, util,
    device, core, IDeviceHandler) {
    "use strict";
    var Env, instance, EVT_ONDETECT = "env:device:ondetect";

    Env = klass.create(EventDispatcher, [IDeviceHandler], {
        /**
         * Get the singleton instance of this class.
         * @method
         * @static
         * @returns {ax/Env} The singleton
         * @memberof xdk-base/Env
         */
        singleton: function () {
            if (!instance) {
                instance = new Env();
            }

            return instance;
        }
    }, {
        /**
         * Fired when the current platform is detected. i.e. device.platform
         * should be available. Delivering device.platform value as the data.
         * @event EVT_ONDETECT
         * @type {String}
         * @memberof xdk-base/Env#
         */
        EVT_ONDETECT: EVT_ONDETECT,
        /**
         * Fired when the current platform is detected. i.e. device.platform
         * should be available. Delivering device.platform value as the data.
         *
         * @deprecated replaced with {@link xdk-base/Env.EVT_ONDETECT}
         * @event EVT_ON_PLATFORM_DETECTED
         * @type {String}
         * @memberof xdk-base/Env#
         */
        EVT_ON_PLATFORM_DETECTED: EVT_ONDETECT,
        /**
         * Event: onload
         *
         * @event EVT_ONLOAD
         * @memberof xdk-base/Env#
         */
        EVT_ONLOAD: "env:onload",
        /**
         * Event: onunload
         *
         * @event EVT_ONUNLOAD
         * @memberof xdk-base/Env#
         */
        EVT_ONUNLOAD: "env:onunload",
        /**
         * Event: onkey
         *
         * @event EVT_ONKEY
         * @type {object}
         * @property {string} id Virtual key id. e.g. "device:vkey:a"
         * @property {string} value Virtual Key value e.g. "a"
         * @property {string} source Source of the key event e.g. "soft-keyboard"
         * @memberof xdk-base/Env#
         */
        EVT_ONKEY: "env:onkey",
        /**
         * Event: mousewheel
         *
         * @event EVT_ON_MOUSE_WHEEL
         * @type {Object}
         * @property {Number} deltaY The vertical amount of units the wheel has scrolled. Postive number indicates scrolling away from the user, negative means scrolling toward the user.
         * @property {xdk-ax/Component} target The component that is pointed by the mouse pointer when the wheel event took place
         * @memberof xdk-base/Env#
         */
        EVT_ON_MOUSE_WHEEL: "env:onmousewheel",
        /**
         * Event: onpause
         *
         * @event EVT_ONPAUSE
         * @type {String}
         * @memberof xdk-base/Env#
         */
        EVT_ONPAUSE: "env:onpause",
        /**
         * Event: onresume
         *
         * @event EVT_ONRESUME
         * @type {String}
         * @memberof xdk-base/Env#
         */
        EVT_ONRESUME: "env:onresume",
        /**
         * Whether the env is ready.
         * @memberof xdk-base/Env#
         * @private
         */
        __ready: false,
        /**
         * Whether the deivce is ready.
         * @memberof xdk-base/Env#
         * @protected
         */
        __deviceReady: false,
        /**
         * The screen resolution (will be assigned upon device initialization).
         * @name resolution
         * @deprecated should use device.system.getDisplayResolution
         * @memberof xdk-base/Env#
         * @public
         */
        resolution: null,
        /**
         * Object for storing notBlocked keys
         * @private
         * @memberof xdk-base/Env#
         */
        __notBlockedKeysList: {},
        /**
         * Is currently blocking keys
         * @private
         * @memberof xdk-base/Env#
         */
        __isBlockingKeys: false,
        /**
         * Is currently blocking keys
         * @private
         * @memberof xdk-base/Env#
         */
        __hasMouse: false,
        /**
         * Is currently blocking Mouse
         * @private
         * @memberof xdk-base/Env#
         */
        __isBlockingMouse: false,
        /**
         * the launch data when env load
         * @private
         * @memberof xdk-base/Env#
         */
        __launchData: null,
        /**
         * To see if the environment is ready or not. Environment is ready when device platform is finished loading
         * @method isLoaded
         * @return {Boolean} True if the env is ready.
         * @public
         * @memberof xdk-base/Env#
         */
        isLoaded: function () {
            return this.__deviceReady;
        },
        /**
         * Start blocking mouse events
         * @method blockMouse
         * @public
         * @memberof xdk-base/Env#
         */
        blockMouse: function () {
            this.__isBlockingMouse = true;
        },
        /**
         * Stop blocking mouse events.
         * @method unblockMouse
         * @public
         * @memberof xdk-base/Env#
         */
        unblockMouse: function () {
            this.__isBlockingMouse = false;
        },
        /**
         * Whether mouse events are blocked
         * @method isBlockingMouse
         * @public
         * @return {Boolean} Whether mouse events are blocked
         * @memberof xdk-base/Env#
         */
        isBlockingMouse: function () {
            return this.__isBlockingMouse;
        },
        /**
         * Start blocking key events. By default, power, exit, home, stop keys are whitelisted.
         * @method blockKeys
         * @public
         * @memberof xdk-base/Env#
         */
        blockKeys: function () {
            this.__isBlockingKeys = true;
        },
        /**
         * Stop blocking key events
         * @name unblockKeys
         * @public
         * @memberof xdk-base/Env#
         * @function
         */
        unblockKeys: function () {
            this.__isBlockingKeys = false;
        },
        /**
         * Is blocking key events
         * @method isBlockingKeys
         * @public
         * @memberof xdk-base/Env#
         * @return {Boolean} Is blocking key events
         */
        isBlockingKeys: function () {
            return this.__isBlockingKeys;
        },
        /**
         * Adds key(s) to be whitelisted when key event blocking is turned on.
         * By default, power, exit, home, stop keys are whitelisted.
         * @name addNotBlockedKey
         * @param {String|Array} key keys(s) to be whitelisted. If you want to block key from the vKey, parameter should be the id of that key
         * @function
         * @public
         * @example
         * sEnv.addNotBlockedKey([vKey.KEY_0.id]);
         * @memberof xdk-base/Env#
         */
        addNotBlockedKey: function (key) {
            var i;
            if (util.isString(key)) {
                this.__notBlockedKeysList[key] = true;
            } else {
                for (i in key) {
                    this.__notBlockedKeysList[key[i]] = true;
                }
            }
        },
        /**
         * Set all the key that exists in an object's members to be key whitelisted (existing settings will get over-written).
         * @name setWhitelist
         * @param {Object} whitelist keys to be whitelisted, in a plain object map
         * @function
         * @public
         * @memberof xdk-base/Env#
         */
        setWhitelist: function (whitelist) {
            this.__notBlockedKeysList = whitelist;
        },
        /**
         * Removes key to be whitelisted when key blocking is turned on.
         * @name removeWhitelistedKey
         * @param {String} key key to be removed from whitelist
         * @function
         * @public
         * @memberof xdk-base/Env#
         */
        removeWhitelistedKey: function (key) {
            delete this.__notBlockedKeysList[key];
        },
        /**
         * Overrides parent method to block key events.
         * @method dispatchEvent
         * @public
         * @memberof xdk-base/Env#
         */
        dispatchEvent: function (type, data) {
            // key event blocking
            if (this.__isBlockingKeys && type === this.EVT_ONKEY && !this.__notBlockedKeysList[data.id]) {
                console.debug("Key blocked by env.");
                return false;
            }
            return this._super(type, data);
        },
        /**
         * Overrides parent method
         * @method addEventListener
         * @param {String} type event type
         * @param {Function} handler event listener function
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {ax/Env} current event dispatcher, for easier chain Env.EVT_ONKEYing
         * @public
         * @memberof xdk-base/Env#
         */
        addEventListener: function (type, handler, once) {

            // if EVT_ONLOAD is already fired, just run the handler
            if (type === this.EVT_ONLOAD && this.__deviceReady) {
                handler(this.__launchData);
                return this;
            }

            return this._super(type, handler, once);
        },
        /**
         * Returns whether the current platform supports mouse or not.
         * @method hasMouse
         * @memberof xdk-base/Env#
         * @returns {Boolean} whether device has mouse
         * @public
         */
        hasMouse: function () {
            return device.system.hasMouse();
        },
        /**
         * Initializes enviroment
         * @method init
         * @memberof xdk-base/Env#
         * @protected
         */
        init: function () {
            this.addNotBlockedKey([vKey.EXIT.id, vKey.STOP.id]);

            //need to set the handlers at the beginning.
            device.init(this);

            this._super();
        },
        /**
         * Default device initialize callback.
         * @method _onDeviceInited
         * @memberof xdk-base/Env#
         * @private
         */
        _onDeviceInited: function () {
            this.__deviceReady = true;

            //@deprecated init resolution
            this.resolution = device.system.getDisplayResolution();

            console.info("[XDK] env ready");
            //call onload when everything is ready
            this.dispatchEvent(this.EVT_ONLOAD);
        },
        /**
         * Default device initialize callback.
         * @method onDeviceLoad
         * @param {Object} [launchData] hold launch data if any
         * @param {Boolean} [launchData.isPaused=false] whether the device load again from pause state
         * @param {Object} [launchData.deeplinkData=null] the deep link data from platform if any
         * @memberof xdk-base/Env#
         * @public
         */
        onDeviceLoad: function (launchData) {
            launchData = launchData || {};
            launchData.isPaused = launchData.isPaused || false;
            launchData.deeplinkData = launchData.deeplinkData || null;

            this.__deviceReady = true;
            this.__launchData = launchData;

            //@deprecated init resolution
            this.resolution = device.system.getDisplayResolution();

            console.info("[XDK] env ready from " + launchData.isPaused);
            console.info("[XDK] deeplink data: " + launchData.deeplinkData);

            //call onload when everything is ready
            this.dispatchEvent(this.EVT_ONLOAD, launchData);
        },
        /**
         * The callback when dispatching key event
         * @param {Object} tvKey the key object of {@link module:xdk-base/device/shared/keyboardVKey} or {@link module:xdk-base/device/VKey}
         * @param {String} source the source of the key event. Default will be "device"
         * @method onDeviceKey
         * @memberof xdk-base/Env#
         * @public
         */
        onDeviceKey: function (tvKey, source) {
            var env = Env.singleton();
            source = source || "device";

            if (tvKey) {
                env.dispatchEvent(env.EVT_ONKEY, util.extend({
                    source: source
                }, tvKey));
            }
        },
        /**
         * Default window onload handler.
         * @method _onload
         * @memberof xdk-base/Env#
         * @private
         */
        _onload: function () {
            if (this.__ready) {
                return;
            }

            console.info("[XDK] DOM loaded");

            this.__ready = true;

            if (device._bootstrap) {
                device._bootstrap({
                    inited: util.bind(this._onDeviceInited, this),
                    platformDetecetedCb: util.bind(this._onPlatformDetected, this)
                });
            }
        },
        /**
         * when the application unloads
         * @method onDeviceUnload
         * @memberof xdk-base/Env#
         * @public
         */
        onDeviceUnload: function () {
            console.info("[XDK] Application unload");
            this.__launchData = null;
            this._onunload();
        },
        /**
         * Default window onunload handler.
         * @method _onunload
         * @memberof xdk-base/Env#
         * @private
         */
        _onunload: function () {
            this.__ready = false;
            this.__deviceReady = false;
            this.dispatchEvent(this.EVT_ONUNLOAD);
        },
        /**
         * To dispatch event the platform is detected
         * @method onDeviceDetect
         * @param {String} platform the string of platform
         * @memberof xdk-base/Env#
         * @public
         */
        onDeviceDetect: function (platform) {
            console.info("[XDK] device detected  " + platform);
            this.dispatchEvent(this.EVT_ONDETECT, platform);
        },
        /**
         * To dispatch event the platform is detected
         * @method _onPlatformDetected
         * @param {String} platform the string of platform
         * @memberof xdk-base/Env#
         * @private
         */
        _onPlatformDetected: function (platform) {
            this.onDeviceDetect(platform);
        },
        /**
         * To dispatch event the application pauses
         * @method onPause
         * @memberof xdk-base/Env#
         * @public
         */
        onDevicePause: function () {
            console.info("[XDK] Application pause");
            this.dispatchEvent(this.EVT_ONPAUSE);
        },
        /**
         * To dispatch event the application resume
         * @method onDeviceResume
         * @memberof xdk-base/Env#
         * @public
         */
        onDeviceResume: function () {
            console.info("[XDK] Application resume");
            this.dispatchEvent(this.EVT_ONRESUME);
        }
    });

    // enforce the instance creation before returning, preventing 2 instances being created
    // (2 executions may go into the creation at the same time...)
    Env.singleton();

    return Env;

});
/**
 * An event dispatcher, that can dispatch events in capturing and bubbling phases.
 * @extends ax/EventDispatcher
 * @class xdk-ax/evt/DualEventDispatcher
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/evt/DualEventDispatcher", ["xdk-base/class", "xdk-base/EventDispatcher"], function (klass, EventDispatcher) {
    "use strict";
    return klass.create(EventDispatcher, {}, {
        /**
         * Event callbacks for capturing phase
         * @memberof xdk-ax/evt/DualEventDispatcher#
         * @private
         */
        __capturingCallbacks: {},
        /**
         * Event callbacks for bubbling phase
         * @memberof xdk-ax/evt/DualEventDispatcher#
         * @private
         */
        __bubblingCallbacks: {},
        /**
         * Switch between capturing and bubbling mode.
         * @method __switchMode
         * @param {Booleab} isCapture is for capturing phase
         * @public
         * @memberof xdk-ax/evt/DualEventDispatcher#
         */
        __switchMode: function (isCapture) {
            if (isCapture) {
                this.__eventCallbacks = this.__capturingCallbacks;
            } else {
                this.__eventCallbacks = this.__bubblingCallbacks;
            }
        },
        /**
         * Dispatches an event with additional data.
         * @method dispatchEvent
         * @param {xdk-ax/evt|String} type event type to dispatch
         * @param {Object} data the event data object
         * @param {Boolean} isCapture whether is capturing phase currently
         * @public
         * @memberof xdk-ax/evt/DualEventDispatcher#
         */
        dispatchEvent: function (type, data, isCapture) {
            isCapture = !! isCapture;
            this.__switchMode(isCapture);
            return this._super(type, data);
        },
        /**
         * Registers an event listener for a certain type.
         * @method addEventListener
         * @param {xdk-ax/evt|String} type event type
         * @param {Function} handler event listener function
         * @param {Boolean} [useCapture] whether listener is registered to capturing phase, false by default
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {xdk-ax/evt/DualEventDispatcher} current event dispatcher, for easier chaining
         * @public
         * @memberof xdk-ax/evt/DualEventDispatcher#
         */
        addEventListener: function (type, handler, useCapture, once) {
            useCapture = !! useCapture;
            this.__switchMode(useCapture);
            return this._super(type, handler, once);
        },
        /**
         * Removes one or more event listeners.
         * @method removeEventListener
         * @param {module:xdk-ax/evt/type|String} type Event type
         * @param {Function} [handler] event listener function.  If not provided, all listeners will be removed for the specific type.
         * @param {Boolean} [useCapture] whether listener is registered to capturing phase. If not provided, it **defaults to false.**
         * @public
         * @memberof xdk-ax/evt/DualEventDispatcher#
         */
        removeEventListener: function (type, handler, useCapture) {
            useCapture = !! useCapture;
            this.__switchMode(useCapture);
            return this._super(type, handler);
        },
        /**
         * Removes all event listeners.
         * @method removeAllListeners
         * @public
         * @memberof xdk-ax/evt/DualEventDispatcher#
         */
        removeAllListeners: function () {
            this.__switchMode(false);
            this._super();
            this.__switchMode(true);
            this._super();
            return this;
        }
    });
});
/**
 * The event object, holding information of an event.
 * @class xdk-ax/evt/Event
 * @param {module:xdk-ax/evt/type} type event type
 * @param {xdk-ax/Component} target the target component
 * @param {Object} [data] a plain ojbect data to be carried along with event object when dispatching
 * @param {Function} defaultAction the default action to be carried out, if no event listener raises objection. Takes current event object as parameter.
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/evt/Event", ["xdk-base/class", "xdk-base/util", "xdk-base/console"], function (klass, util, console) {
    "use strict";
    return klass.create({}, {
        _isPropagationStopped: false,
        _isDefaultPrevented: false,
        _defaultAction: null,
        target: null,
        type: "",
        init: function (type, target, data, defaultAction) {
            var i;
            this.type = type;
            this.target = target;
            this._defaultAction = defaultAction;

            // inject data stuff into current event object
            // e.g. keyCode
            for (i in data) {
                if (!util.isUndefined(this[i])) {
                    console.warn("Data parameter have collision with some event class members! They will be ignored!");
                }
                this[i] = data[i];
            }
        },
        /**
         * Sets and overrides the default action.
         * @method
         * @param {Function} defaultAction the default action function
         * @protected
         * @memberof xdk-ax/evt/eventManager#
         */
        _setDefaultAction: function (defaultAction) {
            this._defaultAction = defaultAction;
        },
        /**
         * Prevents default action to be carried out.
         * @method
         * @public
         * @memberof xdk-ax/evt/eventManager#
         */
        preventDefault: function () {
            this._isDefaultPrevented = true;
        },
        /**
         * If default action is prevented to be carried out.
         * @method
         * @return {Boolean} If default action is prevented to be carried out.
         * @public
         * @memberof xdk-ax/evt/eventManager#
         */
        isDefaultPrevented: function () {
            return this._isDefaultPrevented;
        },
        /**
         * Prevents the current event from futher propagating.
         * @method
         * @public
         * @memberof xdk-ax/evt/eventManager#
         */
        stopPropagation: function () {
            this._isPropagationStopped = true;
        },
        /**
         * If the current event is prevented from futher propagating.
         * @method
         * @return {Boolean} If the current event is prevented from futher propagating.
         * @public
         * @memberof xdk-ax/evt/eventManager#
         */
        isPropagationStopped: function () {
            return this._isPropagationStopped;
        },
        /**
         * Performs the default action. Will be call upon propagation complete and no event listener has objection.
         * @method
         * @public
         * @memberof xdk-ax/evt/eventManager#
         */
        performDefaultAction: function () {
            if (this._defaultAction) {
                this._defaultAction(this);
            }
        }
    });

});
/**
 * The event type constants.
 * @module xdk-ax/evt/type
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/evt/type", {
    /**
     * Dispatched when component shown
     * @event
     * @type {Object}
     * @property {Boolean} hidden True if component is hidden.
     * @memberof module:xdk-ax/evt/type
     */
    SHOWN: "ui:evt:shown",
    /**
     * Dispatched when component hidden
     * @event
     * @type {Object}
     * @property {Boolean} hidden True if component is hidden.
     * @memberof module:xdk-ax/evt/type
     */
    HIDDEN: "ui:evt:hidden",
    /**
     * Dispatched when component detach
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    DETACH: "ui:evt:detach",
    /**
     * Dispatched when component detached from DOM
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    DETACHED_FROM_DOM: "ui:evt:detachDOM",
    /**
     * Dispatched when component attach
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    ATTACH: "ui:evt:attach",
    /**
     * Dispatched when component attacted to DOM
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    ATTACHED_TO_DOM: "ui:evt:attachDOM",
    /**
     * Dispatched when component attached to Controller
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    ATTACHED_TO_CONTROLLER: "ui:evt:attach-controller",
    /**
     * Dispatched when component detached from Controller
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    DETACHED_FROM_CONTROLLER: "ui:evt:detach-controller",
    /**
     * Dispatched when component focus
     * @event
     * @type {object}
     * @property {xdk-ax/Component} relatedTarget The component who just lost focus due to this event.
     * @memberof module:xdk-ax/evt/type
     */
    FOCUS: "ui:evt:focus",
    /**
     * Dispatched when component blur
     * @event
     * @type {object}
     * @property {xdk-ax/Component} relatedTarget The component who just gain focus due to this event.
     * @memberof module:xdk-ax/evt/type
     */
    BLUR: "ui:evt:blur",
    /**
     * Dispatched when component receive key
     * @event
     * @type {object}
     * @property {String} source from software or hardware keyboard
     * @property {String} id key ID
     * @property {String} text key text, if any
     * @memberof module:xdk-ax/evt/type
     */
    KEY: "ui:evt:key",
    /**
     * Dispatched when widget open
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    OPEN: "ui:evt:open",
    /**
     * Dispatched when widget close
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    CLOSE: "ui:evt:close",
    /**
     * Dispatched when component receive click
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    CLICK: "ui:evt:click",
    /**
     * Dispatched when component receive mouseover
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    MOUSEOVER: "ui:evt:mouseover",
    /**
     * Dispatched when widget cancel
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    CANCEL: "ui:evt:cancel",
    /**
     * Dispatched when widget confirm
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    CONFIRM: "ui:evt:confirm",
    /**
     * Dispatched when widget scroll
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    SCROLL: "ui:evt:scroll",
    /**
     * Dispatched when widget selection changed
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    SELECTION_CHANGED: "ui:evt:selection-changed",
    /**
     * Dispatched when widget text changed
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    TEXT_CHANGED: "ui:evt:text-changed",
    /**
     * Dispatched when value changed
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    VALUE_CHANGED: "ui:evt:value-changed",
    /**
     * Dispatched when widget moved
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    MOVED: "ui:evt:moved",
    /**
     * Dispatched when scrollable label scroll to the top ,previously was SCROLL_TO_TOP
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    SCROLLED_TO_TOP: "ui:evt:scroll-to-top",
    /**
     * Dispatched when scrollable label scroll to the bottom,previously was SCROLL_TO_BOTTOM
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    SCROLLED_TO_BOTTOM: "ui:evt:scroll-to-bottom",
    /**
     * Dispatched when a component becomes active
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    ACTIVED: "ui:evt:actived",
    /**
     * Dispatched: when a component becomes inactive
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    INACTIVED: "ui:evt:inactived",
    /**
     * Dispatched when a draggable object is moving
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    DRAG_MOVING: "ui:evt:drag-moving",
    /**
     * Dispatched when a draggable object is released
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    DRAG_RELEASE: "ui:evt:drag-release",
    /**
     * Dispatched when a indicator is updated and send signal to the mediator and then to the scrollable
     * @deprecated since the indicator now only receive event from scrollable, it won't dispatch update event to the scrollable.
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    INDICATOR_UPDATED: "ui:evt:indicator-updated",
    /**
     * Dispatched when a scrollable object is scrolled by indicator info (start, length, total), it will send signal to the mediator and then to the indicator
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    SCROLLED_INDICATOR: "ui:evt:scrolled-indicator",
    /**
     * Dispatched when a scrollable object is scrolled by percentage, it will send signal to the mediator and then to the indicator
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    SCROLLED_PERCENTAGE: "ui:evt:scrolled-percentage",
    /**
     * DEPRECATED. Dispatched when the tv channel changed
     * @deprecated
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    CHANNEL_CHANGED: "device:evt:channel-changed",
    /**
     * Dispatched when animated label iteration end
     * @event
     * @memberof module:xdk-ax/evt/type
     */
    ANIM_ITERATION_ENDED: "ui:evt:anim-iteration-ended"
});

/**
 * Interface for iterators.
 * @class xdk-ax/iterator/interface/Iterator
 */
define("xdk-ax/iterator/interface/Iterator", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    return Interface.create("Iterator", {
        /**
         * Returns the next element in the iteration.
         * @method
         * @return {Mixed} the next element, throws exception if iteration has no more elements.
         * @memberof xdk-ax/iterator/interface/Iterator
         * @public
         */
        next: [],
        /**
         * Returns true if the iteration has more elements.
         * @method
         * @return {Boolean} true if the iterator has more elements.
         * @memberof xdk-ax/iterator/interface/Iterator
         * @public
         */
        hasNext: []
    });
});
/**
 * {@link xdk-ax/Component|Component} bubbling iterator.
 * @class xdk-ax/iterator/BubblingCompIt
 * @extends xdk-ax/iterator/interface/Iterator
 * @param {xdk-ax/Component} targetComp bubbling starting component
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/iterator/BubblingCompIt", [
    "xdk-base/class",
    "xdk-ax/iterator/interface/Iterator",
    "xdk-base/core"
], function (
    klass,
    IIterator,
    core
) {
    "use strict";

    return klass.create([IIterator], {}, {
        /**
         * current component reference
         * @private
         */
        __curComp: null,
        init: function (targetComp) {
            this.__curComp = targetComp;
        },
        next: function () {
            if (!this.__curComp) {
                core.createException("NoSuchElement", "No more element is available for current iteraion!");
            }
            var result = this.__curComp;
            this.__curComp = this.__curComp.getParent();
            return result;
        },
        hasNext: function () {
            return !!this.__curComp;
        }
    });
});
/**
 * {@link xdk-ax/Component|Component} capturing iterator.
 * @class xdk-ax/iterator/CapturingCompIt
 * @extends xdk-ax/iterator/interface/Iterator
 * @param {xdk-ax/Component} targetComp capturing target component
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/iterator/CapturingCompIt", [
    "xdk-base/class",
    "xdk-ax/iterator/interface/Iterator",
    "xdk-base/core"
], function (
    klass,
    IIterator,
    core
) {
    "use strict";

    return klass.create([IIterator], {}, {
        /**
         * internal component array
         * @private
         */
        __compArr: [],
        init: function (targetComp) {
            var curComp = targetComp;
            while (curComp) {
                this.__compArr.push(curComp);
                curComp = curComp.getParent();
            }
        },
        next: function () {
            if (!this.__compArr.length) {
                core.createException("NoSuchElement", "No more element is available for current iteraion!");
            }
            return this.__compArr.pop();
        },
        hasNext: function () {
            return !!this.__compArr.length;
        }
    });
});
/**
 * depth first search iterator.
 * @class xdk-ax/iterator/DFSCompIt
 * @extends xdk-ax/iterator/interface/Iterator
 * @param {xdk-ax/Component} targetComp capturing target component
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/iterator/DFSCompIt", ["xdk-base/class", "xdk-ax/iterator/interface/Iterator", "xdk-base/core"], function (klass, IIterator, core) {
    "use strict";
    return klass.create([IIterator], {}, {
        /**
         * internal component array
         * @private
         */
        __compArr: [],
        init: function (targetComp) {
            this._include(targetComp);
        },
        _include: function (comp) {
            if (comp.isLeaf()) {
                this.__compArr.unshift(comp);
                return;
            }
            var i, children = comp.getChildren();
            for (i in children) {
                this._include(children[i]);
            }

            this.__compArr.unshift(comp);
        },
        next: function () {
            if (!this.__compArr.length) {
                core.createException("NoSuchElement", "No more element is available for current iteraion!");
            }
            return this.__compArr.pop();
        },
        hasNext: function () {
            return !!this.__compArr.length;
        }
    });
});
/**
 * Triggers events on a tree of {@link xdk-ax/Component|Component}, and make sure it propagates on that tree.
 * @module xdk-ax/evt/eventManager
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/evt/eventManager", ["xdk-ax/evt/Event", "xdk-ax/evt/type", "xdk-ax/iterator/BubblingCompIt", "xdk-ax/iterator/CapturingCompIt", "xdk-ax/iterator/DFSCompIt"], function (Event, evtType, BubblingCompIt, CapturingCompIt, DFSCompIt) {
    "use strict";
    var evtMgrModule, itConfig = {};

    // iterator config for special events
    /**
     * @TODO include other event types
     */

    itConfig[evtType.ATTACH] = {
        bubblingIt: DFSCompIt
    };
    itConfig[evtType.ATTACHED_TO_DOM] = {
        bubblingIt: DFSCompIt
    };
    itConfig[evtType.DETACH] = {
        bubblingIt: DFSCompIt
    };
    itConfig[evtType.DETACHED_FROM_DOM] = {
        bubblingIt: DFSCompIt
    };

    evtMgrModule = {
        /**
         * Triggers an event on a specified target.
         * @method
         * @param {module:xdk-ax/evt/type} eventType event type
         * @param {xdk-ax/Component} target the target component
         * @param {Object} [data] a plain ojbect data to be carried along with event object when dispatching
         * @param {Object} [data.defaultAction] the default action to be carried out when event finished propagation
         * @public
         * @memberof module:xdk-ax/evt/eventManager
         */
        trigger: function (eventType, target, data) {
            data = data || {};

            var capturingIt, bubblingIt, evt, curComp;

            // check if has special iterator config
            if (itConfig[eventType]) {
                capturingIt = itConfig[eventType].capturingIt;
                bubblingIt = itConfig[eventType].bubblingIt;
                /* jshint newcap:false*/
                capturingIt = capturingIt ? new capturingIt(target) : null;
                bubblingIt = bubblingIt ? new bubblingIt(target) : null;
                /* jshint newcap:true*/
            } else { // use default iterators
                capturingIt = new CapturingCompIt(target);
                bubblingIt = new BubblingCompIt(target);
            }

            evt = new Event(eventType, target, data, data.defaultAction);

            // event capturing phase
            if (capturingIt) {
                while (!evt.isPropagationStopped() && capturingIt.hasNext()) {
                    curComp = capturingIt.next();
                    if (false === curComp.dispatchEvent(eventType, evt, true)) {
                        evt.stopPropagation();
                        evt.preventDefault();
                    }
                }
            }

            // event bubbling phase
            if (bubblingIt) {
                while (!evt.isPropagationStopped() && bubblingIt.hasNext()) {
                    curComp = bubblingIt.next();
                    if (false === curComp.dispatchEvent(eventType, evt, false)) {
                        evt.stopPropagation();
                        evt.preventDefault();
                    }
                }
            }

            if (!evt.isDefaultPrevented()) {
                evt.performDefaultAction();
            }
        }
    };

    return evtMgrModule;
});
/**
 * Element wrapper class. Provides element manipulation and event functionalities.
 * @class xdk-base/Element
 * @param {String|DOMElement} type DOM element tag name, or just DOM element instance to wrap
 * @param {Object} [attributes] attributes to assigned to DOM element
 * @param {Object} [attributes.style] CSS styles to assigned to DOM element
 * @param {xdk-base/Element|DOMElement} [parent] parent element to append to
 * @author Thomas Lee <thomas.lee@accedo.tv>
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-base/Element", ["xdk-base/class", "xdk-base/core", "xdk-base/console", "xdk-base/util", "xdk-base/device"], function (klass, core, console, util, device) {
    "use strict";
    var ElementClass, isOldMaple = (function () {
            var ua = navigator.userAgent.toLowerCase();
            if (ua.indexOf("maple") !== -1 && ua.indexOf("5.1") !== -1) {
                return true;
            }
            return false;
        }()),
        /**
         * Whether the platform supports "DOMElement.classList" property
         * @method supportsClassList
         * @private
         * @memberof xdk-base/Element
         * @static
         */
        supportsClassList = (function () {
            // document.body is not available now, go for the one that must exist: a script element
            var scriptEle = document.getElementsByTagName("script")[0];
            return !!(scriptEle.classList && scriptEle.classList.add);
        }()),
        /**
         * Handler method for cancelling the event default action.
         * @name preventDefault
         * @private
         * @memberof xdk-base/Element
         * @static
         */
        preventDefault = function () {
            this.returnValue = false;
        },
        /**
         * Handler method for stopping event propagation.
         * @name stopPropagation
         * @private
         * @memberof xdk-base/Element
         * @static
         */
        stopPropagation = function () {
            this.cancelBubble = true;
        },
        /**
         * Fix up an event so that can use W3C standard methods to cancel the event and stop event propagation.
         * Brought in a lot of ideas from Dean Edwards' addEvent()
         * @name fixEvent
         * @param {Event} evt
         * @returns {Event}  the updated native event object
         * @private
         * @memberof xdk-base/Element
         * @static
         */
        fixEvent = function (evt) {
            // add W3C standard event methods
            if (!evt.preventDefault) {
                evt.preventDefault = preventDefault;
            }
            if (evt.stopPropagation) {
                evt.stopPropagation = stopPropagation;
            }
            return evt;
        },
        /**
         * Map from pseudo events to real attachable event types.
         * @name pseudoEvents
         * @private
         * @memberof xdk-base/Element
         * @static
         */
        pseudoEvents = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        },
        /**
         * Wraps a pseudo event listener, makes it possible to be attached onto a browser event.
         * @name wrapPseudoEventListener
         * @param type the pseudo event type
         * @param listener the pseudo event listener function
         * @returns {Function} the wrapped listener function, which is ready to be attached to a browser event
         * @private
         * @memberof xdk-base/Element
         * @static
         */
        wrapPseudoEventListener = function (type, listener) {
            if (!pseudoEvents[type]) { // no such pseudo event
                return null;
            }

            return function (evt) {
                var related = evt.relatedTarget,
                    origType = evt.type;
                while (related && related !== this._dom) { // search up DOM tree from related target
                    try {
                        related = related.parentNode;
                    } catch (e) {
                        break;
                    }
                }
                if (related !== this._dom) { // a real entrance/leave
                    evt.type = type;
                    listener.apply(this, arguments);
                    evt.type = origType;
                }
            };
        };

    ElementClass = klass.create({
            /**
             * Gets the element by ID and returns a corresponding wrapper or null of element does not exist.
             * @method getById
             * @memberof xdk-base/Element
             * @param {String} id String ID of the element in the DOM
             * @return {ax/Element} Element wrapper
             * @static
             */
            getById: function (id) {
                var _dom = document.getElementById(id);
                if (_dom && util.isDOMElement(_dom)) {
                    return new ElementClass(_dom);
                }
                return null;
            }
        },
        /** @lends ax/Element.prototype */
        {
            /**
             * The underlying HTML DOM element.
             * @member _dom
             * @protected
             * @memberof xdk-base/Element#
             */
            _dom: null,
            /**
             * The container for event listeners.
             * @member __event
             * @private
             * @memberof xdk-base/Element#
             */
            __events: null,
            /**
             * Store the style display of the element for hide/show purpose
             * @member __origDisplayStyle
             * @private
             * @memberof xdk-base/Element#
             */
            __origDisplayStyle: "",
            /**
             * constructs ax/Element
             */
            init: function (type, attributes, parent) {
                if (util.isDOMElement(type)) {
                    this._dom = type;
                } else {
                    this._dom = document.createElement(type);
                }

                //Parse and set attributes as requested
                if (util.isPlainObject(attributes)) {
                    this.attr(attributes);
                }


                //Append child to parent if possible
                if (parent) {
                    //if the parent is DOMElement and then we create and then append
                    if (parent && util.isDOMElement(parent)) {
                        parent = new ElementClass(parent);
                    }
                    parent.append(this._dom);
                }
            },
            /**
             * Returns the actual HTML Element.
             * @method getHTMLElement
             * @returns {Element} the actual HTML Element
             * @public
             * @memberof xdk-base/Element#
             */
            getHTMLElement: function () {
                return this._dom;
            },
            /**
             * Gets parent element wrapped in DOM util.
             * @method getParent
             * @returns {Element} the parent HTML Element
             * @public
             * @memberof xdk-base/Element#
             */
            getParent: function () {
                var parent = this._dom.parentNode;
                if (parent) {
                    return new ElementClass(parent);
                }

                return null;
            },
            /**
             * Detach element from the DOM tree.
             * @method detach
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            detach: function () {
                //no dom object since it is already detached or hasn't attached to dom yet
                if (!this._dom) {
                    return this;
                }
                var parent = this._dom.parentNode,
                    child;
                if (parent) {
                    //Prevent memory leaks in Samsung devices using a left-hand operand
                    child = parent.removeChild(this._dom);
                }

                child = null;
                parent = null;
                return this;
            },
            /**
             * Sets the element as depending on its parent (so it shows it, if its parent is not hidden itself)
             * @method show
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            show: function () {
                var originalDisplay = this._dom.style.display;
                if (originalDisplay !== "none") {
                    this.__origDisplayStyle = originalDisplay;
                    return this;
                }
                this._dom.style.display = this.__origDisplayStyle;
                return this;
            },
            /**
             * Hides element
             * @method hide
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            hide: function () {
                var originalDisplay = this._dom.style.display;
                if (originalDisplay !== "none") {
                    this.__origDisplayStyle = originalDisplay;
                }
                this._dom.style.display = "none";
                return this;
            },
            /**
             * Hides or shows the element (if its display is none, sets it to inherit, otherwise set it to none.
             * It means you'll lose the current value by toggling twice, if display was "inline" or "block" for instance)
             * @method toggle
             * @public
             * @memberof xdk-base/Element#
             * @return {boolean} false if the element is hidden after toggling, true otherwise
             */
            toggle: function () {
                if (this._dom.style.display === "none") {
                    this.show();
                    return true;
                }
                this.hide();
                return false;
            },
            /**
             * Add event listener to the DOM element.
             * The listener function will have "this" pointing to current element. Also added "mouseenter" and "mouseleave" as pseudo events.
             * @see {@link http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#event-type-mouseenter}
             * @see {@link http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#event-type-mouseleave}
             * @method addEventListener
             * @param {String} type Event type
             * @param {Function} listener Function to call back on event fire
             * @param {Boolean} useCapture Use capture?
             * @return {Element} The element itself, for chaining
             * @public
             * @example
             * myElement.addEventListener("mouseenter",
             *     function(evt){
             *         console.log(this.getInnerText());
             *         },
             *     true);
             * @memberof xdk-base/Element#
             */
            addEventListener: function (type, listener, useCapture) {
                var element = this._dom,
                    events = this.__events,
                    pseudoType = type,
                    origListener = listener,
                    listeners, listenerEntry;

                useCapture = !!useCapture;

                // wrap up pseudo-event listners such as "mouseenter" and "mouseleave"
                if (pseudoEvents[pseudoType]) {
                    type = pseudoEvents[pseudoType];
                    listener = wrapPseudoEventListener(pseudoType, listener);
                }
                listener = util.bind(listener, this);

                // assign each event handler a unique ID
                // so that they can be removed later to prevent memory leaks on some devices
                if (!origListener.$$guid) {
                    origListener.$$guid = core.getGuid();
                }

                // create a hash table of event types for the element
                if (!events) {
                    this.__events = events = {};
                }
                // create a hash table of event handlers for each element/event pair
                listeners = events[pseudoType];
                if (!listeners) {
                    listeners = events[pseudoType] = {};
                    // if not handling pseudo event currently, store the existing event handler (if there is one)
                    if (pseudoType === type && element["on" + type]) {
                        listeners[0] = {};
                        // not using capture for onXXX event
                        listeners[0][false] = [element["on" + type]];
                    }
                }

                // store the event handler in the hash table
                listeners[origListener.$$guid] = listeners[origListener.$$guid] || {};
                listenerEntry = listeners[origListener.$$guid];
                listenerEntry[useCapture] = listenerEntry[useCapture] || [];
                listenerEntry[useCapture].push(listener);

                if (element.addEventListener) {
                    element.addEventListener(type, listener, useCapture);
                } else { // use home-baked handler that calls all registered handlers
                    element["on" + type] = util.bind(this._handleEvent, this);
                }
                return this;
            },
            /**
             * Handles an event in case native addEventListener is not supported.
             * @method _handleEvent
             * @returns {boolean} false if any of the handlers returned false
             * @private
             * @memberof xdk-base/Element#
             */
            _handleEvent: function (evt) {
                var returnValue = true,
                    type = evt.type,
                    handlers, entry, i, j;
                // grab the event object (IE uses a global event object)
                evt = evt || fixEvent(window.event);
                // get a reference to the hash table of event handlers
                handlers = this.__events[type];
                if (pseudoEvents[type]) { // also check pseudo events
                    handlers = handlers.concat(this.__events[pseudoEvents[type]]);
                }
                // execute each event handler
                for (i in handlers) {
                    // not using capture for onXXX event
                    entry = handlers[i][false.toString()];
                    for (j in entry) {
                        this.$$handleEvent = entry[j];
                        if (this.$$handleEvent(evt) === false) {
                            returnValue = false;
                        }
                    }
                }
                return returnValue;
            },
            /**
             * Removes event listener from the DOM util.
             * @method removeEventListener
             * @param {String} [type] Event type, removes all event listeners if not provided
             * @param {Function} [listener] Function to call back on event fire, removes all event listeners of the specified type if not provided
             * @param {Boolean} [useCapture] Use capture or not
             * @return {ax/Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            removeEventListener: function (type, listener, useCapture) {
                var element = this._dom,
                    events = this.__events,
                    wrappedListeners = null,
                    attachedListener = listener,
                    attachedType = type,
                    listeners, curType, curGuid, curCapture;



                if (!type) { // remove all listeners
                    if (!events) {
                        return this;
                    }
                    for (curType in events) {
                        this.removeEventListener(curType);
                    }
                    this.__events = null; // remove all listeners
                    return this;
                }

                if (!listener) { // remove all listeners of certain type
                    if (!events) {
                        return this;
                    }
                    listeners = events[type];
                    for (curGuid in listeners) {
                        for (curCapture in listeners[curGuid]) {
                            // actually, for second param, all we need is the guid
                            while (listeners[curGuid] && listeners[curGuid][curCapture] && listeners[curGuid][curCapture].length) {
                                this.removeEventListener(type, {
                                    $$guid: curGuid
                                }, curCapture === true.toString());
                            }
                        }
                    }
                    delete events[type]; // remove whole type
                    return this;
                }

                // just remove one specific listener
                useCapture = !!useCapture;
                if (events && events[type] && events[type][listener.$$guid] && events[type][listener.$$guid][useCapture]) {

                    wrappedListeners = events[type][listener.$$guid][useCapture];
                    attachedListener = wrappedListeners.pop();
                    attachedType = pseudoEvents[type] || type;

                    if (wrappedListeners.length === 0) {
                        // delete current specific entry, if no more listeners in there
                        delete events[type][listener.$$guid][useCapture];
                        // delete whole Guid entry, if no more listeners in there
                        if (!events[type][listener.$$guid][!useCapture] || events[type][listener.$$guid][!useCapture].length === 0) {
                            delete events[type][listener.$$guid];
                        }
                    }

                }
                if (element.removeEventListener) {
                    element.removeEventListener(attachedType, attachedListener, useCapture);
                }
                return this;
            },
            /**
             * Removes all event listeners from the DOM util.
             * @method removeAllListeners
             * @return {Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            removeAllListeners: function () {
                if (!this.__events) { // for better performance
                    return this;
                }
                this.removeEventListener();
                return this;
            },
            /**
             * This function removes a child node from a parent node.
             * @method removeChild
             * @param {Element} child The child node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            removeChild: function (child) {
                if (!util.isDOMElement(child)) {
                    child = child.getHTMLElement();
                }

                //to ensure the it is child of its parent
                if (child.parentNode !== this._dom) {
                    console.warn("unable to remove the non children node");
                    return this;
                }

                if (util.isFunction(this._dom.removeChild)) {
                    this._dom.removeChild(child);
                } else {
                    util.each(
                        Array.prototype.slice.call(this._dom.childNodes, 0), function (_child) {
                            if (_child === child) {
                                //Prevent memory leaks in Samsung devices using a left-hand operand
                                var myChild = this._dom.removeChild(_child);
                                myChild = null;
                            }
                        }, this);
                }
                return this;
            },
            /**
             * This function removes all child nodes from a parent node.
             * @method removeAll
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            removeAll: function () {

                var child = this._dom.childNodes[0];
                while (child) {
                    this.removeChild(child);
                    child = this._dom.childNodes[0];
                }
                return this;
            },
            /**
             * This function appends a child node to a parent node.
             * @method append
             * @param {Element | ax/Element} child The child node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            append: function (child) {
                if (util.isDOMElement(child)) {
                    this._dom.appendChild(child);
                } else {
                    this._dom.appendChild(child.getHTMLElement());
                }
                return this;
            },
            /**
             * Append to a parent
             * @method appendTo
             * @param {Element | ax/Element} parent the parent node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            appendTo: function (parent) {
                if (util.isDOMElement(parent)) {
                    parent.appendChild(this._dom);
                } else {
                    parent.append(this);
                }
                return this;
            },
            /**
             * Inserts a new child node to this element, before one of its children.
             * @method insertBefore
             * @param {Element | ax/Element} existingChild The existing child node
             * @param {Element | ax/Element} newChild The new child node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            insertBefore: function (existingChild, newChild) {
                var existingC, newC;
                existingC = util.isDOMElement(existingChild) ? existingChild : existingChild.getHTMLElement();
                newC = util.isDOMElement(newChild) ? newChild : newChild.getHTMLElement();
                this._dom.insertBefore(newC, existingC);
                return this;
            },
            /**
             * Inserts a new child node to this element, after one of its children.
             *
             * @method insertAfter
             * @param {Element | ax/Element} existingChild The existing child node
             * @param {Element | ax/Element} newChild The new child node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            insertAfter: function (existingChild, newChild) {
                var existingC, newC;
                existingC = util.isDOMElement(existingChild) ? existingChild : existingChild.getHTMLElement();
                newC = util.isDOMElement(newChild) ? newChild : newChild.getHTMLElement();
                if (this._dom.lastChild === existingC) {
                    this._dom.appendChild(newC);
                } else {
                    this._dom.insertBefore(newC, existingC.nextSibling);
                }
                return this;
            },
            /**
             * This function attach a new child node to a parent node, replacing one of its children.
             * @method replaceChild
             * @param {Element | ax/Element} existingChild The existing child node
             * @param {Element | ax/Element} newChild The new child node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            replaceChild: function (existingChild, newChild) {
                var existingC, newC, sibling;
                existingC = util.isDOMElement(existingChild) ? existingChild : existingChild.getHTMLElement();
                newC = util.isDOMElement(newChild) ? newChild : newChild.getHTMLElement();
                if (this._dom.lastChild === existingC) {
                    this._dom.removeChild(existingC);
                    this._dom.appendChild(newC);
                } else {
                    sibling = existingC.nextSibling;
                    this._dom.removeChild(existingC);
                    this._dom.insertBefore(newC, sibling);
                }
                return this;
            },
            /**
             * This function appends a new child node to a parent node, before the first child.
             * @method prepend
             * @param {Element | ax/Element} newChild The new child node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            prepend: function (newChild) {
                if (util.isDOMElement(newChild)) {
                    this._dom.insertBefore(newChild, this._dom.firstChild);
                } else {
                    this._dom.insertBefore(newChild.getHTMLElement(), this._dom.firstChild);
                }
                return this;
            },
            /**
             * Prepend itself to the begining of the taret
             * @method prependTo
             * @param {Element | ax/Element} parent the parent node
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            prependTo: function (parent) {
                if (util.isDOMElement(parent)) {
                    parent.insertBefore(this._dom, parent.childNodes[0]);
                } else {
                    parent.prepend(this);
                }
                return this;
            },
            /**
             * This function finds out whether this node is attached to a parent or not.
             * @method isAttached
             * @public
             * @memberof xdk-base/Element#
             * @returns {Boolean} True when it is attached. Otherwise return false
             */
            isAttached: function () {
                return this.getHTMLElement().parentNode !== null;
            },
            /**
             * This function removes an attribute from an DOM element.
             * @method removeAttr
             * @param {String} attribute The attribute
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            removeAttr: function (attribute) {
                if (this.hasAttr(attribute)) {
                    this._dom.removeAttribute(attribute);
                }
                return this;
            },
            /**
             * This function removes a style definition from an DOM element.
             * @method removeStyle
             * @param {String} styleName The style name
             * @return {ax/Element} the Element itself
             * @public
             * @memberof xdk-base/Element#
             */
            removeStyle: function (styleName) {
                if (this.css(styleName)) {
                    this._dom.style[styleName] = "";
                    //it is unable to delete the style e.g style["display"]
                    delete this._dom.style[styleName];
                }
                return this;
            },
            /**
             * This function checks if an element has a certain attribute defined or not.
             * @method hasAttr
             * @param {String} attribute The attribute
             * @return {Boolean} True if it contains certain attribute.
             * @public
             * @memberof xdk-base/Element#
             */
            hasAttr: function (attribute) {
                if (this._dom.hasAttribute) {
                    return this._dom.hasAttribute(attribute);
                }
                return !util.isUndefined(this._dom[attribute]);
            },
            /**
             * Gets the style text of the element
             * @method __getStyleText
             * @return {String} the style text of the element
             * @memberof xdk-base/Element#
             * @private
             */
            __getStyleText: function () {
                if (!util.isUndefined(this._dom.style.cssText)) {
                    return this._dom.style.cssText;
                } else {
                    return this._dom.getAttribute("style");
                }
            },
            /**
             * Sets the style text of the element, will overwrites the original text
             * @method __setStyleText
             * @function
             * @param {String} styleText the style text to set into the element
             * @memberof xdk-base/Element#
             * @private
             */
            __setStyleText: function (styleText) {
                if (!util.isUndefined(this._dom.style.cssText)) {
                    this._dom.style.cssText = styleText;
                } else {
                    this._dom.setAttribute("style", styleText);
                }
            },
            /**
             * This function sets style attributes.
             * @method __setStyle
             * @param {Object} styles A object containing CSS name/value pairs
             * @return {Element} The element itself, for chaining
             * @private
             * @memberof xdk-base/Element#
             */
            __setStyle: function (styles) {
                var style, curStyleStr, curCSS = this.__getStyleText() || "",
                    newCSS = curCSS,
                    isCurCSSEmpty = !curCSS,
                    overrideArr = [],
                    key;
                // set style text way does not work at all on Samsung 2010
                if (isOldMaple) {
                    for (style in styles) {
                        if (styles.hasOwnProperty(style)) {
                            this._dom.style[style] = styles[style];
                        }
                    }
                    return this;
                }

                for (style in styles) {
                    if (styles.hasOwnProperty(style)) {
                        style = util.camelize(style);
                        curStyleStr = util.decamelize(style, "-") + ":" + styles[style] + ";";
                        if (isCurCSSEmpty) {
                            newCSS += curStyleStr;
                        } else if (!util.isNull(this._dom.style[style]) && !util.isUndefined(this._dom.style[style]) && this._dom.style[style] !== "") { // existing style
                            overrideArr.push(style);
                        } else { // non-existing style
                            newCSS = curStyleStr + newCSS;
                        }
                    }
                }
                this.__setStyleText(newCSS); // set new css in batch
                for (key in overrideArr) { // override old ones one by one
                    style = overrideArr[key];
                    this._dom.style[style] = styles[style];
                }
                return this;
            },
            /**
             * Gets a given style for the DOM element.
             * @method __getStyle
             * @memberof xdk-base/Element#
             * @param {String} style Style name to get.
             * @private
             * @return style value or null
             */
            __getStyle: function (style) {
                style = style === "float" ? "cssFloat" : util.camelize(style);
                var value = null;
                if (this._dom.currentStyle) {
                    value = this._dom.currentStyle[style];
                }
                //in opera currentStyle exist but it fails to get the style so it needs to ensure by checking style.
                if (!value) {
                    value = this._dom.style[style];
                }
                if (style === "opacity") {
                    return value ? parseFloat(value) : 1.0;
                }
                return value === "auto" ? null : value;
            },
            /**
             * Gets Cumulative offset for element.
             * Returned data is an object with x and y properties.
             * @method cumulativeOffset
             * @public
             * @memberof xdk-base/Element#
             * @return {Object} Offset object with x and y properties
             */
            cumulativeOffset: function () {
                var valueT = 0,
                    valueL = 0,
                    element = this._dom;
                if (element.parentNode) {
                    do {
                        valueT += element.offsetTop || 0;
                        valueL += element.offsetLeft || 0;
                        element = element.offsetParent;
                    } while (element);
                }
                return {
                    x: valueL,
                    y: valueT
                };
            },
            /**
             * This function adds one or more CSS classes to the given element.
             * @method addClass
             * @param {String | Array} className Either an array of CSS classname or a single CSS classname
             * @return {Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            addClass: function (className) {
                if (util.isArray(className)) {
                    util.each(className, function (def) {
                        this.addClass(def);
                    }, this);
                } else if (util.isString(className)) {
                    //Remove extra space to avoid DOM exception
                    className = className.replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                    if (className.indexOf(" ") >= 0) { // className contains space and multiple classes, need to chop them up
                        util.each(className.split(" "), function (def) {
                            this.addClass(def);
                        }, this);
                    } else if (supportsClassList) { // platform supports classList feature, so just use it
                        this._dom.classList.add(className);
                    } else if (!this.hasClass(className)) { // do it the old fashioned way
                        //Either add space or do not add space before appending className
                        this._dom.className += (this._dom.className ? " " : "") + className;
                    }
                }

                return this;
            },
            /**
             * Checks if the element has a CSS Class name assigned.
             * @method hasClass
             * @function
             * @public
             * @memberof xdk-base/Element#
             * @param {String} className CSS Class name to look for.
             * @return {Boolean} true if element has class name, false otherwise
             */
            hasClass: function (className) {
                if (supportsClassList) { // platform supports classList feature, so just use it
                    return this._dom.classList.contains(className);
                }

                var elemClass = this._dom.className;
                return (elemClass.length > 0 && (elemClass === className || new RegExp("(^|\\s)" + className + "(\\s|$)").test(elemClass)));
            },
            /**
             * Removes a given CSS class name from the element.
             * @method removeClass
             * @function
             * @public
             * @memberof xdk-base/Element#
             * @param {String} className CSS Class name to remove from the element.
             * @return {Element} The element itself, for chaining
             */
            removeClass: function (className) {
                if (supportsClassList) { // platform supports classList feature, so just use it
                    this._dom.classList.remove(className);

                    return this;
                }

                var cname = this._dom.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ");
                cname = util.strip(cname);
                this._dom.className = cname;

                return this;
            },
            /**
             * Replaces the current CSS class(es) with given the given className
             * @method setClass
             * @function
             * @param {String} className CSS Classname
             * @return {Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            setClass: function (className) {
                this._dom.className = util.strip(className);
                return this;
            },
            /**
             * This function sets the textual content of a DOM element. HTML code should be used setInnerHTML instead of.
             * @method setInnerText
             * @param {String} content The text content to set
             * @return {Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            setInnerText: function (content) {
                if (!util.isUndefined(this._dom.innerText)) {
                    this._dom.innerText = content;
                } else if (!util.isUndefined(this._dom.textContent)) {
                    // firefox is unable to set InnerText and textContent only available
                    this._dom.textContent = content;
                } else {
                    console.warn("fail to set Text" + content);
                }

                if (device.system) {
                    device.system.redraw(this._dom);
                }
                return this;
            },
            /**
             * This function sets the innerHTML of the element
             * @method setInnerHTML
             * @param {String} html content The text content to set
             * @return {Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            setInnerHTML: function (html) {
                this._dom.innerHTML = html;
                if (device.system) {
                    device.system.redraw(this._dom);
                }
                return this;
            },
            /**
             * This function returns the textual content of a DOM element.
             * @method getInnerText
             * @returns {String} the text content of the element
             * @public
             * @memberof xdk-base/Element#
             */
            getInnerText: function () {
                if (!util.isUndefined(this._dom.innerText)) {
                    return this._dom.innerText;
                }

                //firefox is unable to set InnerText and textContent only available
                if (!util.isUndefined(this._dom.textContent)) {
                    return this._dom.textContent;
                }
                console.warn("Fail to get innerText!");
                return undefined;
            },
            /**
             * This function returns the innerHTML of a DOM element.
             * @method getInnerHTML
             * @returns {String} the innerHTML of the element
             * @public
             * @memberof xdk-base/Element#
             */
            getInnerHTML: function () {
                return this._dom.innerHTML;
            },
            /**
             * Get the farthest-back ancestor of our node
             * @method _findUltimateAncestor
             * @return {Element} the farthest-back ancestor
             * @private
             * @memberof xdk-base/Element#
             */
            _findUltimateAncestor: function () {
                var ancestor = this._dom;
                while (ancestor.parentNode) {
                    ancestor = ancestor.parentNode;
                }
                return ancestor;
            },
            /**
             * If the current element is in DOM tree.
             * @method isInDOMTree
             * @return {Boolean} True if it is inside the DOM tree
             * @public
             * @memberof xdk-base/Element#
             */
            isInDOMTree: function () {
                return this._findUltimateAncestor().body === core.root.document.body;
            },
            /**
             * To delete, remove all the event listeners and detach from DOM.
             * @method discard
             * @public
             * @memberof xdk-base/Element#
             */
            discard: function () {
                this.detach();
                this.removeAllListeners();
                this._dom = null;
            },
            /**
             * This function signals this element will not be used any more, and should collect memory to prevent any memory leaks.
             * @method deinit
             * @public
             * @memberof xdk-base/Element#
             */
            deinit: function () {
                this.discard();
            },
            /**
             * To set or get the attribute of the element
             * @method attr
             * @param {Object|String} name Object to set a set of attributes to the element, or the attribute name to set/get
             * @param {String} [value] To set the string/number of the attribute
             * @return {Element|String} Return element when setAttribute while return string or null when getAttribute
             * @example <caption>To get the attribtue </caption>
             * element.attr("id");
             * //return the id of the element
             * <caption>To set the attribute using plainObject</caption>
             * element.attr({"alt":"desc","testing":123"});
             * //return itself and set successfully
             * <caption>To set the attribute</caption>
             * element.attr("alt","testing");
             * //return itself and set successfully
             * @public
             * @memberof xdk-base/Element#
             */
            attr: function (name, value) {
                var i;
                //if attribute name is undefined
                if (util.isUndefined(name)) {
                    throw core.createException("elementAttrError", "Undefined attribute name");
                }

                //if it is plain object, then set attributes
                if (util.isPlainObject(name)) {
                    for (i in name) {
                        this.attr(i, name[i]);
                    }
                    return this;
                }

                //to determine whether it is get/set. If the value is undefined, then it is get attr function
                if (util.isUndefined(value)) {
                    //use the default get attribute
                    if (util.isFunction(this._dom.getAttribute)) {
                        return this._dom.getAttribute(name);
                    }

                    //if no getAttribute and fail to retrieve the attribute value, it will return null
                    return null;
                }

                //set Attribute of string/value
                if (util.isString(value) || util.isNumber(value)) {
                    this._dom.setAttribute(name, value);
                    return this;
                }
                if (name === "style" && util.isPlainObject(value)) {
                    this.css(value);
                }

                return this;
            },
            /**
             * To set and get the css of the element
             * @method css
             * @param {Object} name Object to set a set of css attributes to the element, or the css attribute to set/get
             * @param {String} [value] To set the string/number of the attribute
             * @return {Element|String} Return element when set css while return string or null when get css
             * @example <caption>To get the css attribtue </caption>
             * element.css("background");
             * //return the bg color of the element
             * <caption>To set the css attribute using plainObject</caption>
             * element.css({"background":"green","display":inline-block"});
             * //return itself and set successfully
             * <caption>To set the css attribute</caption>
             * element.css("background","yellow");
             * //return itself and set successfully
             * @public
             * @memberof xdk-base/Element#
             */
            css: function (name, value) {
                //if attribute name is undefined
                if (util.isUndefined(name)) {
                    throw core.createException("elementCssError", "Undefined css name");
                }

                //if it is plain object, then set attributes
                if (util.isPlainObject(name)) {
                    if (name.display) {
                        if (name.display === "none") {
                            this.__origDisplayStyle = this._dom.style.display;
                        } else {
                            this.__origDisplayStyle = value;
                        }
                    }
                    this.__setStyle(name);
                    return this;
                }

                //to determine whether it is get/set. If the value is undefined, then it is get css function
                if (util.isUndefined(value)) {
                    //use the default get attribute
                    return this.__getStyle(name);
                }

                if (name === "display") {
                    if (value === "none") {
                        this.hide();
                    } else {
                        this.__origDisplayStyle = value;
                        this._dom.style.display = this.__origDisplayStyle;
                    }
                }

                //set Attribute of string/number value
                if (util.isString(value) || util.isNumber(value)) {
                    var styleObj = {};
                    styleObj[name] = value;
                    this.__setStyle(styleObj);
                    return this;
                }

                return this;
            },
            /**
             * Toogle the css class of the element.
             * The class will be added if it doesn't exist, or removed if it exists already.
             *
             * @method toggleClass
             * @param {String} className The css class name to toggle
             * @return {Element} The element itself, for chaining
             * @public
             * @memberof xdk-base/Element#
             */
            toggleClass: function (className) {
                return (this.hasClass(className)) ? this.removeClass(className) : this.addClass(className);
            }
        });

    return ElementClass;
});
/**
 * A basic model impelementation class.
 * For any attribute changes, events will be fired with name of: "change" or "change:[attr name]".
 *
 * The handler function will receive data with:
 *
 *  Attribute | Value
 *  ----------|------
 *  data.attr | the attribute name
 *  data.type | the event type
 *  data.oldValue | the old value
 *  data.newValue | the new value
 * @class xdk-ax/mvc/Model
 * @example
 * var User, alice, bob;
 * User = klass.create(Model,
 *    defaults:{
 *       gender: "m", // default value
 *       name: "Unnamed" // default value
 *   }, {});
 * alice = new User({
 *       name: "Alice",
 *       gender: "f"
 *   });
 * bob = new User({
 *       name: "Bob",
 *       gender: "m"
 *   })
 */
define("xdk-ax/mvc/Model", ["xdk-base/class", "xdk-base/EventDispatcher", "xdk-base/util"], function (klass, EventDispatcher, util) {
    "use strict";
    var Model = klass.create(EventDispatcher, {
        /**
         * Default attribute value to start with for a new instance
         * @public
         * @static
         * @memberof xdk-ax/mvc/Model#
         */
        defaults: {}
    }, {
        /**
         * Internal attribute storage
         * @protected
         * @memberof xdk-ax/mvc/Model#
         */
        _attrs: {},
        /**
         * Internal changed attributes marker
         * @protected
         * @memberof xdk-ax/mvc/Model#
         */
        _changed: {},
        /**
         * overrides init function
         * @param {type} attrs attributes to assign into a model instance
         * @param {type} opts options
         * @protected
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        /*jshint unused:false*/
        init: function (attrs, opts) {
            this._attrs = util.clone(this.constructor.defaults, true);
            util.extend(this._attrs, attrs);
            this._super();
        },
        /*jshint unused:true*/
        /**
         * Get all the changed attributes since this model has been created.
         * @return {Object} the changed attributes with their values
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        changedAttrs: function () {
            var res = {},
                self = this;
            util.each(this._changed, function (pair) {
                res[pair.key] = self._attrs[pair.key];
            });
            return res;
        },
        /**
         * Get a attribute for this model.
         * @param {String} attr the attribute name
         * @return {Mixed} the attribute value
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        get: function (attr) {
            return this._attrs[attr];
        },
        /**
         * Set one or multiple attributes for this model.
         * @param {String|Object} attr the attribute name,
         *     or the multiple attributes stored in an object
         * @param {Mixed} [value] the attribute value to set to
         * @return {xdk-ax/mvc/model} the current model for chaining
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        set: function (attr, value) {
            var self = this;
            if (util.isPlainObject(attr)) {
                util.each(attr, function (pair) {
                    self.set(pair.key, pair.value);
                });
                return this;
            }

            this.__updateAttr(attr, value);
            return this;
        },
        /**
         * Unset one an attribute for this model.
         * @param {String} attr the attribute name
         * @return {xdk-ax/mvc/model} the current model for chaining
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        unset: function (attr) {
            if (!this.has(attr)) {
                return this;
            }
            this.set(attr); // set value to undefined
            return this;
        },
        /**
         * Check if an attribute exists for this model.
         * @param {String} attr the attribute name
         * @param {Mixed} [value] the attribute value to set to
         * @return {Boolean} if the attribute value exist
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        has: function (attr) {
            return this._attrs.hasOwnProperty(attr);
        },
        /**
         * Clears all attributes exists for this model.
         * @return xdk-ax/mvc/model} the current model for chaining
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        clear: function () {
            var self = this;
            util.each(this._attrs, function (pair) {
                self.unset(pair.key, pair.value);
            });
            return this;
        },
        /**
         * Get the internal attributes storate from this model.
         * Please do not modify the return of this function, you can use set() to do so.
         * @return {Object} the attributes of this model
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        attributes: function () {
            return this._attrs;
        },
        /**
         * Alias to {@link xdk-base/EventDispatcher#addEventListener}.
         * Refer to class description for details.
         * @param {String} evtType event type
         * @param {Function} handler event listener function
         * @returns {xdk-ax/mvc/model} current model, for easier chaining
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        on: function (evtType, handler) {
            this.addEventListener(evtType, handler, false);
        },
        /**
         * Alias to {@link xdk-base/EventDispatcher#addEventListener}, with once set to true.
         * Refer to class description for details.
         * @param {String} evtType event type
         * @param {Function} handler event listener function
         * @returns {xdk-ax/mvc/model} current model, for easier chaining
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        once: function (evtType, handler) {
            this.addEventListener(evtType, handler, true);
        },
        /**
         * Alias to {@link xdk-base/EventDispatcher#removeEventListener}, with once set to true
         * @param {String} evtType Event type
         * @param {Function} [handler] event listener function.  If not provided, all listeners will be removed for the specific type.
         * @returns {xdk-ax/mvc/model} current model, for easier chaining
         * @public
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        off: function (evtType, handler) {
            this.removeEventListener(evtType, handler);
        },
        /**
         * Internal method to update an attribute
         * @param {String} attr the attribute name
         * @param {Mixed} value the attribute value to set to
         * @private
         * @method
         * @memberof xdk-ax/mvc/Model#
         */
        __updateAttr: function (attr, value) {
            var oldValue = this._attrs[attr],
                evtType, evtData;
            if (value === oldValue) {
                return;
            }

            if (util.isUndefined(value)) {
                delete this._attrs[attr];
            } else {
                this._attrs[attr] = value;
            }


            this._changed[attr] = true;
            evtType = "change:" + attr;
            evtData = {
                attr: attr,
                type: "change",
                oldVal: oldValue,
                newVal: value
            };

            this.dispatchEvent(evtType, evtData);
            this.dispatchEvent("change", evtData);
        }
    });

    return Model;
});
/**
 * A reference pointing to a model's attribute.
 * This class is normally consumed by widgets, so widgets can data-bind display elements with model data.
 * @class xdk-ax/mvc/ModelRef
 * @param {xdk-ax/mvc/Model} model the model instance
 * @param {String} attr the attribute name
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/mvc/ModelRef", ["xdk-base/class", "xdk-ax/mvc/Model", "xdk-base/core"], function (klass, Model, core) {
    "use strict";
    return klass.create({}, {
        /**
         * Model instance
         * @protected
         * @memberof xdk-ax/mvc/ModelRef#
         */
        _model: null,
        /**
         * Attribute name
         * @protected
         * @memberof xdk-ax/mvc/ModelRef#
         */
        _attr: null,
        /**
         * overrides parent init() method
         * @protected
         * @method
         * @memberof xdk-ax/mvc/ModelRef#
         */
        init: function (model, attr) {
            if (!(model instanceof Model) || !attr) {
                throw core.createException("IncorrectParam", "Incorrect parameter when trying to create a ModelRef instance!");
            }
            this._model = model;
            this._attr = attr;
        },
        /**
         * Gets the model instance we are referring
         * @public
         * @return {xdk-ax/mvc/Model} the model instance
         * @method
         * @memberof xdk-ax/mvc/ModelRef#
         */
        getModel: function () {
            return this._model;
        },
        /**
         * Gets the attribute name we are referring
         * @public
         * @return {String} attribute name
         * @method
         * @memberof xdk-ax/mvc/ModelRef#
         */
        getAttr: function () {
            return this._attr;
        },
        /**
         * Gets the attribute value we are referring
         * @public
         * @return {Mixed} attribute value of the model
         * @method
         * @memberof xdk-ax/mvc/ModelRef#
         */
        getVal: function () {
            return this._model.get(this._attr);
        }
    });
});
/**
 * Abstract component used as a base for all UI components.
 * This is the abstract component function that all UI object, it can be containers or components, inherrits from.
 * Inherits from {@link xdk-ax/evt/DualEventDispatcher}
 * @class xdk-ax/Component
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @param {Object} opts Options
 * @param {xdk-base/Element} opts.root The DOM root element (the container for this component)
 * @param {xdk-ax/Component} [opts.parent] The DOM parent element
 * @param {xdk-ax/Component.PLACE_BEFORE | xdk-ax/Component.PLACE_AFTER | xdk-ax/Component.PLACE_APPEND | xdk-ax/Component.PLACE_PREPEND} [opts.placement] - position the child should be placed. By default {@link xdk-ax/Component.PLACE_APPEND}.
 * @param {xdk-ax/Component} [opts.marker] - must be a child of current container when using PLACE_AFTER/PLACE_BEFORE, the placement of child will be in relative to this marker.
 * @param {Boolean} opts.clickable Whether this component is clickable
 * @param {Boolean} opts.focusable Whether this component is focusable
 * @param {Boolean} opts.mouseFocusableOnly To set this component is only focusable by mouse
 * @param {String | xdk-ax/Component} opts.forwardOnMouseOff the focus will be redirect to.If there is no setting, it will redirect to the last non mouse focus when it is mouseFocusableOnly.
 * @param {Boolean} opts.enterAsClick Whether to treat enter keys as clicks for this component
 * @param {String} opts.id The ID of this component
 * @param {Boolean|xdk-ax/mvc/ModelRef} [opts.visible] the visibility of the component
 *
 * @fires module:xdk-ax/evt/type.SHOWN
 * @fires module:xdk-ax/evt/type.HIDDEN
 * @fires module:xdk-ax/evt/type.ACTIVED
 * @fires module:xdk-ax/evt/type.INACTIVED
 * @fires module:xdk-ax/evt/type.DETACH
 * @fires module:xdk-ax/evt/type.DETACHED_FROM_DOM
 * @fires module:xdk-ax/evt/type.ATTACH
 * @fires module:xdk-ax/evt/type.ATTACHED_TO_DOM
 * @fires module:xdk-ax/evt/type.ATTACHED_TO_CONTROLLER
 * @fires module:xdk-ax/evt/type.DETACHED_FROM_CONTROLLER
 * @fires module:xdk-ax/evt/type.FOCUS
 * @fires module:xdk-ax/evt/type.BLUR
 * @fires module:xdk-ax/evt/type.KEY
 * @fires module:xdk-ax/evt/type.CLICK
 * @fires module:xdk-ax/evt/type.MOUSEOVER
 */
define("xdk-ax/Component", [
    "xdk-base/class",
    "xdk-ax/evt/DualEventDispatcher",
    "xdk-ax/evt/eventManager",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/evt/Event",
    "xdk-base/core",
    "xdk-base/Element",
    "xdk-base/device",
    "xdk-ax/mvc/ModelRef",
    "xdk-base/exception",
    "xdk-base/console"
], function (
    klass,
    EventDispatcher,
    evtMgr,
    util,
    evtType,
    Event,
    core,
    Element,
    device,
    ModelRef,
    exception,
    console
) {
    "use strict";
    return klass.create(EventDispatcher, {
        /**
         * Placement: before another sibling
         * @constant
         * @name PLACE_BEFORE
         * @memberof xdk-ax/Component
         *
         */
        PLACE_BEFORE: "before",
        /**
         * Placement: after another sibling
         * @constant
         * @name PLACE_AFTER
         * @memberof xdk-ax/Component
         */
        PLACE_AFTER: "after",
        /**
         * Placement: append
         * @constant
         * @name PLACE_APPEND
         * @memberof xdk-ax/Component
         */
        PLACE_APPEND: "append",
        /**
         * Placement: prepend
         * @constant
         * @name PLACE_PREPEND
         * @memberof xdk-ax/Component
         */
        PLACE_PREPEND: "prepend"
    }, {
        /**
         * Currrently disabled
         * @protected
         * @memberof xdk-ax/Component
         */
        _disabled: false,
        /**
         * Currrently hidden
         * @protected
         * @memberof xdk-ax/Component
         */
        _hidden: false,
        /**
         * One of the ancestors is currrently hidden
         * @protected
         * @memberof xdk-ax/Component
         */
        _ancestorHidden: false,
        /**
         * Currrently in DOM tree
         * @protected
         * @memberof xdk-ax/Component
         */
        _inDOMTree: false,
        /**
         * Parent component.
         * @protected
         * @memberof xdk-ax/Component
         */
        _parent: null,
        /**
         * Root element.
         * @protected
         * @memberof xdk-ax/Component
         */
        _root: null,
        /**
         * Attached controller.
         * @protected
         * @memberof xdk-ax/Component
         */
        _controller: null,
        /**
         * Options object.
         * @protected
         * @memberof xdk-ax/Component
         */
        _opts: null,
        /**
         * The registery for wrapped listeners
         * @private
         * @memberof xdk-ax/Component
         */
        __wrappedListeners: {},
        /**
         * The visibility model reference
         * @private
         * @memberof xdk-ax/Component
         */
        __visibilityModelRef: null,
        /**
         * The visibility listener
         * @private
         * @memberof xdk-ax/Component
         */
        __visibilityListener: null,
        /**
         * This function initiates a component using the options given in the constructor.
         * @method
         * @protected
         * @memberof xdk-ax/Component#
         */
        init: function (opts) {
            var placement, marker;

            opts = opts || {};

            opts.root = opts.root || new Element("div");

            this._super(opts);

            this._root = opts.root;
            if (this._root) {
                this._root.getHTMLElement().__comp = this;
            }

            this._parent = opts.parent;

            this._opts = util.clone(opts, true);

            if (this._root && this._parent) {
                placement = (opts.placement) ? opts.placement : this.PLACE_APPEND;
                marker = (opts.marker) ? opts.marker : undefined;
                this._parent.attach(this, placement, marker);
            }

            if (opts.id) {
                this.setId(opts.id);
            }

            if (opts.css) {
                this._root.addClass(opts.css);
            }

            if (!util.isUndefined(opts.visible)) {
                this.setVisibility(opts.visible);
            }

            this.postInit();
        },
        /**
         * To do after the initialization, when all children are readily included
         * @method
         * @memberof xdk-ax/Component#
         * @protected
         */
        postInit: function () {
            var style = this._opts.style;
            if (style && style.display && style.display.toLowerCase() === "none") {
                this.hide();
            }
        },
        /**
         * This function signals this component will not be further used, and should do clean up to prevent any memory leaks.
         * @method
         * @protected
         * @memberof xdk-ax/Component#
         */
        deinit: function () {
            this.detach();

            this._super();

            delete this._root.getHTMLElement().__comp;
            this._root.deinit(); // remove listeners that are attached to DOM element
            this._root = null;
        },
        /**
         * Returns true if component is clickable, false otherwise.
         * @method
         * @public
         * @return {Boolean}
         * @memberof xdk-ax/Component#
         */
        isClickable: function () {
            return this.getOption("clickable", false);
        },
        /**
         * Checks if component is disabled.
         * @method
         * @public
         * @return {Boolean} true if disabled, false otherwise.
         * @memberof xdk-ax/Component#
         */
        isDisabled: function () {
            return this._disabled;
        },
        /**
         * Sets disabled state to true. Also adds CSS class "disabled".
         * @method
         * @public
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Component#
         */
        disable: function () {
            this._disabled = true;
            this._root.addClass("disabled");
            return this;
        },
        /**
         * Sets disabled state to true. Also adds CSS class "disabled".
         * @method
         * @public
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Component#
         */
        enable: function () {
            this._disabled = false;
            this._root.removeClass("disabled");
            return this;
        },
        /**
         * This function returns whether this component is hidden or not
         * @name isHidden
         * @function
         * @public
         * @memberof xdk-ax/Component#
         */
        isHidden: function () {
            return this._hidden;
        },
        /**
         * This function returns whether this component's ancestor is hidden or not
         * @name isAncestorHidden
         * @function
         * @public
         * @memberof xdk-ax/Component#
         */
        isAncestorHidden: function () {
            return this._ancestorHidden;
        },
        /**
         * Updates the internal _ancestorHidden field for current and child components
         * @memberof xdk-ax/Component#
         * @method
         * @protected
         */
        _updateAncestorHidden: function () {
            var parent = this.getParent();
            if (!parent) {
                this._ancestorHidden = false;
                return;
            }
            this._ancestorHidden = parent.isAncestorHidden() || parent.isHidden();
        },
        /**
         * Updates the internal _inDOMTree field for current and child components
         * @memberof xdk-ax/Component#
         * @method
         * @protected
         */
        _updateInDOMTree: function (isAttached) {
            this._inDOMTree = isAttached;
        },
        /**
         * This function shows this component. Dispatches a "show" event.
         * It will set the visibility to be true and remove the model reference assigned via setVisibility.
         * As a result, only the latest visibilitity is set and control the show/hide.
         * @method
         * @public
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Component#
         * @fires module:xdk-ax/evt/type.SHOWN
         */
        show: function () {
            return this.setVisibility(true);
        },
        /**
         * To set the visibility of the component to be false and hide the component. Dispatches a "hide" event.
         * It will set the visibility to be false and remove the model reference assigned via setVisibility.
         * @method
         * @return {xdk-ax/Component} The component itself, for chaining
         * @public
         * @memberof xdk-ax/Component#
         * @fires module:xdk-ax/evt/type.HIDDEN
         */
        hide: function () {
            return this.setVisibility(false);
        },
        /**
         * This function toggle this component's display state.
         * It will toggle the visibility and remove the model reference assigned via setVisibility.
         * @return {xdk-ax/Component} The component itself, for chaining
         * @public
         * @memberof xdk-ax/Component#
         */
        toggle: function () {
            if (this.isHidden()) {
                return this.setVisibility(true);
            }
            return this.setVisibility(false);
        },
        /**
         * Add a CSS class name to this component.
         * @method
         * @public
         * @param {String} className the name of the class
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Component#
         */
        addClass: function (className) {
            if (!this._root) {
                return this;
            }
            this._root.addClass(className);
            return this;
        },
        /**
         * Remove a CSS class name frin this component.
         * @method
         * @param {String} className the name of the class
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Component#
         */
        removeClass: function (className) {
            if (!this._root) {
                return this;
            }
            this._root.removeClass(className);
            return this;
        },
        /**
         * Set this component's id
         * @method
         * @public
         * @param {String} id component's id
         * @memberof xdk-ax/Component#
         */
        setId: function (id) {
            //When opts.id starts with "#", we also put the ID into DOM element
            if (util.startsWith(id, "#")) {
                if (id.length > 1) {
                    this._root.id = id.substr(1);
                    this._root.attr("id", this._root.id);
                }
            } else {
                this._root.id = id;
            }
        },
        /**
         * Returns this component's id
         * @method
         * @public
         * @returns {String|null} component's id
         * @memberof xdk-ax/Component#
         */
        getId: function () {
            return this._root.id || null;
        },
        /**
         * This function returns itself if the supplied id matches its own id,
         * otherwise it null is returned
         * @method
         * @public
         * @param {String} id the ID of desired component
         * @memberof xdk-ax/Component#
         * @returns {xdk-ax/Component | null}
         */
        find: function (id) {
            return (this.getId() === id) ? this : null;
        },
        /**
         * Check if the current component is the ancestor of specified component.
         * @method
         * @public
         * @param {xdk-ax/Component} comp The component to check.
         * @memberof xdk-ax/Component#
         * @returns {boolean}
         */
        isAncestorOf: function (comp) {
            return comp.isDescendantOf(this);
        },
        /**
         * Check if the current component is a descendatn of the specified container.
         * @method
         * @public
         * @param {xdk-ax/Component} container The component to check.
         * @memberof xdk-ax/Component#
         * @returns {boolean}
         */
        isDescendantOf: function (container) {
            if (!this._parent) {
                return false;
            }
            if (this._parent === container) {
                return true;
            }
            return this._parent.isDescendantOf(container);
        },
        /**
         * This function returns the specified option and falls back to the supplied
         * default value if this option has not been defined for this component.
         * @method
         * @public
         * @memberof xdk-ax/Component#
         * @param {String} name The option name
         * @param {String} [defaultValue] The fallback value
         */
        getOption: function (name, defaultValue) {
            var ret = this._opts[name];
            if (util.isUndefined(ret)) {
                ret = defaultValue;
            }
            return ret;
        },
        /**
         * Sets an option for this component.
         * @method
         * @public
         * @memberof xdk-ax/Component#
         * @param {String} name The option name
         * @param {String} value The value of the option
         * @return {xdk-ax/Component} The component itself, for chaining
         */
        setOption: function (name, value) {
            this._opts[name] = value;
            return this;
        },
        /**
         * This function returns the root element of this component.
         * @method
         * @return {ax/Element} The root element
         * @public
         * @memberof xdk-ax/Component#
         */
        getRoot: function () {
            return this._root;
        },
        /**
         * This function returns the parent componet of this component.
         * @method
         * @return {xdk-ax/Component} The parent componet
         * @public
         * @memberof xdk-ax/Component#
         */
        getParent: function () {
            return this._parent;
        },
        /**
         * This function attach a controller to this component.
         * @method
         * @param {xdk-ax/mvc/Controller} controller the controller to attach
         * @return {ax/Element} The parent element
         * @public
         * @memberof xdk-ax/Component#
         */
        attachController: function (controller) {
            this._controller = controller;
        },
        /**
         * This function detaches a controller from this component.
         * @method
         * @public
         * @memberof xdk-ax/Component#
         */
        detachController: function () {
            this._controller = null;
        },
        /**
         * This function returns the attached controller of this component.
         * @method
         * @return {xdk-ax/Controller} The attached controller
         * @public
         * @memberof xdk-ax/Component#
         */
        getAttachedController: function () {
            return this._controller;
        },
        /**
         * This function returns the immediate controller of this component.
         * @method
         * @return {xdk-ax/Controller} The immediate controller
         * @public
         * @memberof xdk-ax/Component#
         */
        getController: function () {
            if (!this._controller) {
                var parent = this.getParent();
                if (!parent) {
                    return null;
                }
                return parent.getController();
            }
            return this._controller;
        },
        /**
         * Get root controller
         * @method
         * @return {xdk-ax/ui/Controller} The root level controller
         * @public
         * @memberof xdk-ax/Component#
         **/
        getRootController: function () {
            var parents = [],
                parent = this.getParent();

            while (parent) {
                parents.push(parent);
                parent = parent.getParent();
            }

            while (parents.length) {
                parent = parents.shift();
                if (parent.getAttachedController()) {
                    return parent.getAttachedController();
                }
            }

            return null;
        },
        /**
         * This function detaches this component from its current parent.
         * Dispatches a "detach" event.
         * @name detach
         * @function
         * @return {xdk-ax/Component} The component itself, for chaining
         * @public
         * @memberof xdk-ax/Component#
         * @fires module:xdk-ax/evt/type.DETACH
         * @fires module:xdk-ax/evt/type.DETACHED_FROM_DOM
         * @fires module:xdk-ax/evt/type.DETACHED_FROM_CONTROLLER
         */
        detach: function () {
            if (!this._parent) {
                return this;
            }

            this._parent.detach(this);

            return this;
        },
        /**
         * Set as the active widget from the container
         * @name setActive
         * @param {Boolean | xdk-ax/Component } [noTrailActive] - Optional.If it is boolean, true will only apply to the current component while false will setActive till the root.If it is abstract component, it will set active trail until the input abstractComponent(including).If the abstractComponent is not found,it will set active until the top of the tree and act like the false case. Default is False
         * the entire trail. False to skip.
         * active.
         * @function
         * @memberof xdk-ax/Component#
         * @public
         */
        setActive: function (noTrailActive) {
            var parent = this.getParent();

            if (!parent) {
                return;
            }

            parent.setActiveChild(this);

            if (noTrailActive === true) {
                return;
            }

            if (parent === noTrailActive) {
                return;
            }

            parent.setActive(noTrailActive);
        },
        /**
         * Returns true if itself is active
         * @method
         * @param {Boolean} [noTrail] Default False to activate
         * the entire trail. True to skip.
         * @return {Boolean} True if current is active
         * @memberof xdk-ax/Component#
         * @function
         * @public
         */
        isActive: function (noTrail) {
            var parent = this.getParent();

            if (!parent || (!noTrail && parent && !parent.isActive())) {
                return false;
            }

            return parent.isChildActive(this);
        },
        /**
         * Returns true if itself is leaf component
         * @method
         * @return {Boolean} True if itself is leaf component
         * @memberof xdk-ax/Component#
         * @public
         */
        isLeaf: function () {
            return true;
        },
        /**
         * Get hee mapped DOM event from a XDK event
         * @method
         * @param {module:xdk-ax/evt/type} type The XDK event type
         * @return {String} the DOM event name
         * @memberof xdk-ax/Component#
         * @private
         */
        __getMappedDOMEvent: function (type) {
            switch (type) {
                /**
                 * @TODO add more events if necessary
                 */
            case evtType.CLICK:
                //block the mouse click on the tv display only since there are both mouse click and key press A together.
                if (device.platform === "wiiu" && nwf) {
                    var displayMgr = nwf.display.DisplayManager.getInstance();
                    if (window === displayMgr.getTVDisplay().window) {
                        return false;
                    }
                }
                return "click";
            case evtType.MOUSEOVER:
                return "mouseover";
            }
            return false;
        },
        /**
         * Overrides parent's method {@link xdk-ax/evt/DualEventDispatcher#addEventListener|addEventListener}.
         * Note this function is not full compatible with parent's version.
         * @param {xdk-ax/evt|String} type event type
         * @param {Function} handler event listener function, by default this function is bind to current component
         * @param {Boolean} [useCapture] whether listener is registered to capturing phase, false by default
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {xdk-ax/evt/DualEventDispatcher} current event dispatcher, for easier chaining
         * @method
         * @public
         * @memberof xdk-ax/Component#
         */
        addEventListener: function (type, handler, useCapture, once) {
            var domEvtType = this.__getMappedDOMEvent(type),
                wrappedHandler, newEvt;

            if (!domEvtType) {
                return this._super(type, handler, useCapture, once);
            }

            useCapture = !!useCapture;

            // wrap hanlder, so that it can be put into element for direct invocation
            wrappedHandler = function (evt) {
                var listenedComp = this.getHTMLElement().__comp,
                    target = evt.target,
                    targetComp = target.__comp;

                while (!targetComp) {
                    target = target.parentNode;
                    targetComp = target.__comp;
                }

                if (type === evtType.CLICK) {
                    // find the clickable component, we should use that as event target
                    while (!targetComp.isClickable()) {
                        if (targetComp === listenedComp) {
                            // none of the children and component itself is clickable
                            // just do nothing
                            return;
                        }
                        targetComp = targetComp.getParent();
                    }
                }

                newEvt = new Event(type, targetComp);

                util.bind(handler, listenedComp)(newEvt);

                if (once) {
                    listenedComp.removeEventListener(type, handler, useCapture);
                }

                evt.stopPropagation();
                evt.preventDefault();
            };

            this._root.addEventListener(domEvtType, wrappedHandler, useCapture);

            // prepare for later removal from element
            if (!handler.$$guid) {
                handler.$$guid = core.getGuid();
            }
            if (!this.__wrappedListeners[domEvtType]) {
                this.__wrappedListeners[domEvtType] = {};
            }
            if (!this.__wrappedListeners[domEvtType][handler.$$guid]) {
                this.__wrappedListeners[domEvtType][handler.$$guid] = {};
            }
            if (!this.__wrappedListeners[domEvtType][handler.$$guid][useCapture]) {
                this.__wrappedListeners[domEvtType][handler.$$guid][useCapture] = [];
            }
            this.__wrappedListeners[domEvtType][handler.$$guid][useCapture].push(wrappedHandler);

            return this._super(type, handler, useCapture, once);
        },
        /**
         * Overrides parent's method {@link xdk-ax/evt/DualEventDispatcher#removeEventListener|removeEventListener}.
         * Note: second param must be provided.
         * @method removeEventListener
         * @param {module:xdk-ax/evt/type|String} type Event type
         * @param {Function} handler event listener function. This param is not optional.
         * @param {Boolean} [useCapture] whether listener is registered to capturing phase. If not provided, it **defaults to false.**
         * @public
         * @memberof xdk-ax/Component#
         */
        removeEventListener: function (type, handler, useCapture) {
            var domEvtType = this.__getMappedDOMEvent(type),
                wrappedHandler;

            if (!domEvtType) {
                return this._super(type, handler, useCapture);
            }

            useCapture = !!useCapture;

            if (!this.__wrappedListeners || !this.__wrappedListeners[domEvtType] || !this.__wrappedListeners[domEvtType][handler.$$guid] || !this.__wrappedListeners[domEvtType][handler.$$guid][useCapture] || !this.__wrappedListeners[domEvtType][handler.$$guid][useCapture].length) {
                // this event handler is not registered before
                return this._super(type, handler, useCapture);
            }
            wrappedHandler = this.__wrappedListeners[domEvtType][handler.$$guid][useCapture].pop();

            this._root.removeEventListener(domEvtType, wrappedHandler, useCapture);

            return this._super(type, handler, useCapture);
        },
        /**
         * Overrides parent's method {@link xdk-ax/evt/DualEventDispatcher#removeAllListeners|removeAllListeners}.
         * @method removeAllListeners
         * @public
         * @memberof xdk-ax/Component#
         */
        removeAllListeners: function () {
            this.__wrappedListeners = {};
            this._root.removeAllListeners();
            return this._super();
        },
        /**
         * Set the visibility of the component. The latest setting will override previous setting.
         * @method setVisibility
         * @param {Boolean|xdk-ax/mvc/ModelRef} visible state(True to show, false to hide) or ModelRef to modify its visibility with a model
         * @return {xdk-ax/Component} The component itself, for chaining
         * @fires module:xdk-ax/evt/type.HIDDEN
         * @fires module:xdk-ax/evt/type.SHOWN
         * @public
         * @memberof xdk-ax/Component#
         */
        setVisibility: function (visible) {

            //remove the previous model ref
            if (this.__visibilityModelRef && this.__visibilityListener) {
                this.__visibilityModelRef.getModel().off("change:" + this.__visibilityModelRef.getAttr(), this.__visibilityListener);
                this.__visibilityModelRef = null;
            }

            //add new model ref
            if (visible instanceof ModelRef) {

                if (!this.__visibilityListener) {
                    this.__visibilityListener = util.bind(function (evt) {
                        this.__setVisible(evt.newVal);
                    }, this);
                }

                visible.getModel().on("change:" + visible.getAttr(), this.__visibilityListener);
                this.__visibilityModelRef = visible;
                visible = this.__visibilityModelRef.getVal();
            }

            return this.__setVisible(visible);
        },
        /**
         * Perfom action to show or hide this component
         * @method __setVisible
         * @private
         * @param {Boolean} state True to show, false to hide
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Component#
         * @fires module:xdk-ax/evt/type.SHOWN
         * @fires module:xdk-ax/evt/type.HIDDEN
         */
        __setVisible: function (visible) {
            var eventName;

            if (typeof visible !== "boolean") {
                var id = this.getOption("id", undefined);
                console.warn("[Component] Expecting boolean value for visibility" + (id ? " on component " + id : "") + "; actual: " + visible);
            }

            this._hidden = !visible;

            if (this._hidden) {
                this._root.hide();
                eventName = evtType.HIDDEN;
            } else {
                this._root.show();
                eventName = evtType.SHOWN;

            }

            this._updateAncestorHidden();

            //Dispatches an event
            evtMgr.trigger(eventName, this, {
                hidden: this._hidden
            });

            return this;
        }
    });
});
/**
 * Renders view templates. Views are built with trees of {@link xdk-ax/Component|Component}.
 * @module xdk-ax/mvc/view
 */
define("xdk-ax/mvc/view", ["xdk-base/core", "xdk-ax/Component", "xdk-base/util"], function (core, Component, util) {
    "use strict";
    return {
        _templateRenderHooks: {},
        /**
         * Hook template rendering by recognizing a **key** in the template object.
         * The hook handler function will be called if the **key** exists.
         * @name hookTemplateRenderer
         * @param {String} hook The object key to hook to
         * @param {Function} handler Handler function to be called on hook. Expected to
         * return render view (i.e. Component). Template object will be passed as
         * the first argument.
         * @example
         *      view.hookTemplateRenderer("controller", function(viewTemplate){
         *          ...
         *          return component;
         *      })
         * @method
         * @memberof module:xdk-ax/mvc/view
         * @public
         */
        hookTemplateRenderer: function (hook, handler) {
            if (!util.isString(hook)) {
                throw core.createException("IncorrectParam", "Template hook attribute (hookAttr) should be a string : " + hook);
            }

            if (!util.isFunction(handler)) {
                throw core.createException("IncorrectParam", "Template hook helper (helperFn) should be a function : " + handler);
            }

            if (this._templateRenderHooks[hook]) {
                throw core.createException("TemplateRenderHelperTaken", "Template helper for hook (" + hook + ") is already taken.");
            }

            this._templateRenderHooks[hook] = handler;
        },
        /**
         *
         * Renders a view template.
         * Note: The root of view template must be a component, while its children can contain controllers.
         * @param {Object|Function} template View template object or a function that produces the template
         * @param {Object} modelObj the object containing models and information needed for the template
         * @return {xdk-ax/Component} the reference to the root of the component tree i.e. view
         * @method
         * @memberof module:xdk-ax/mvc/view
         * @public
         * @example
         * var template = {
         *   klass: Container,
         *   id: "#my-container",
         *   children: [
         *     {
         *       klass: ButtonWidget,
         *       css: "my-button-class"
         *     },
         *     {
         *       controller: MyController
         *     }
         *   ]
         * },
         * myView = view.render(template);
         */
        render: function (template, modelObj) {

            // view is a function that takes models
            if (util.isFunction(template)) {
                template = template(modelObj);
            }

            if (!util.isPlainObject(template)) {
                throw core.createException("ViewTemplateInvalid", "View template is incorrect: " + util.stringify(template));

            }

            if (!util.isFunction(template.klass)) {
                throw core.createException("ViewTemplateInvalid", "Trying to create an unknown type. Template: " + util.stringify(template));

            }

            if (!(template.klass.prototype instanceof Component)) {
                throw core.createException("ViewTemplateInvalid", "View template root must be a component! Template:" + util.stringify(template));

            }

            var view, opts, i, len, childTemp, childComp;

            opts = util.clone(template);
            delete opts.klass;
            delete opts.children;

            // create the root component first, in case need to open controller under it
            view = new template.klass(opts);

            // renders any children that need rendering
            if (util.isArray(template.children) && template.children.length) {
                len = template.children.length;
                for (i = 0; i < len; i++) {
                    childComp = null;
                    childTemp = template.children[i];

                    if (!util.isPlainObject(childTemp)) {
                        // incorrect child template
                        throw core.createException("ViewTemplateInvalid", "Sub-view template rendering has failed for: " + template.children[i]);

                    }

                    util.each(this._templateRenderHooks, function (pair) {

                        if (util.isUndefined(childTemp[pair.key])) {
                            return;
                        }

                        //if helper function exists, delegate template creation to helper
                        childComp = this._templateRenderHooks[pair.key](childTemp);

                        if (!(childComp instanceof Component)) {
                            throw core.createException("UnexpectedViewTemplateHelperResponse", "View template helper did not return a Component: " + childComp);
                        }

                        view.attach(childComp);

                        return util.breaker;
                    }, this);

                    if (childComp) {
                        // hooked
                        continue;
                    }

                    if (childTemp.klass.prototype instanceof Component) {
                        // renders the child if it is a template
                        childComp = this.render(childTemp, true);
                        view.attach(childComp);
                        continue;
                    }

                    // incorrect child template
                    throw core.createException("ViewTemplateInvalid", "Sub-view template contains unknown class! Sub-view template: " + util.stringify(childTemp));
                }
            }

            return view;
        }
    };
});
/**
 * A base controller class.
 * @class xdk-ax/mvc/Controller
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @example
 *  var myController = klass.create(Controller, {}, {
 *       init: function() {
 *           this.setView(view.render(mainTmpl, {}));
 *           this._super();
 *       },
 *       setup: function(context) {
 *           ....
 *       }
 *  });
 */
define("xdk-ax/mvc/Controller", ["xdk-base/class", "xdk-base/core", "xdk-base/util", "xdk-ax/mvc/view", "xdk-base/console", "xdk-base/promise"], function(klass, core, util, view, console, promise) {
    "use strict";
    view.hookTemplateRenderer("controller", function(template) {
        var Ctrl = template.controller;

        if (!Ctrl.prototype instanceof Controller) {
            throw core.createException("IncorrectAttribute", "Controller attribute should be a Sub-Class of Controller");
        }

        view = (new Ctrl()).getView();

        return view;
    });

    var Controller = klass.create({}, {
        /**
         * The view this controller attached to.
         * @memberof xdk-ax/mvc/Controller#
         * @protected
         */
        _view: null,
        /**
         * The sub-controllers array.
         * @memberof xdk-ax/mvc/Controller#
         * @protected
         */
        _subControllers: [],
        /**
         * The parent controller.
         * @memberof xdk-ax/mvc/Controller#
         * @protected
         */
        _parentController: null,
        /**
         * The controller"s ID, please use {@link xdk-ax/mvc/Controller#getId()|getId()} to get it.
         * @memberof xdk-ax/mvc/Controller#
         * @private
         */
        __id: null,
        /**
         * Overriding the deinit function
         * @protected
         * @method
         * @memberof xdk-ax/mvc/Controller#
         */
        deinit: function() {
            this._view.deinit();

            this._view = null;
        },
        /**
         * Set view for the current controller.
         * @param {xdk-ax/Componenet} component View object
         * @public
         * @method
         * @memberof xdk-ax/mvc/Controller#
         */
        setView: function(component) {
            if (this._view) {
                throw core.createException("ViewAlreadySet", "This controller already has a view set, it is not supposed to be overwritten!");
            }
            this._view = component;
            this._view.attachController(this);

            // start tracking the sub-controllers in the view
            var subControllers = this._extraSubController(),
                self = this;
            util.each(subControllers, function(subCtrl) {
                self._addSubController(subCtrl);
            });
        },
        /**
         * Extra sub-controllers from a view, so that when a view is set,
         *     all the sub-controllers is being kept track of.
         * @param {xdk-ax/Componenet} [view] component object to set as view
         *     default value: view of cucrent controller
         * @param {Array} [subControllers] an array to contain all the discovered sub-controllers
         * @return {Array} the discovered sub-controllers
         * @protected
         * @method
         * @memberof xdk-ax/mvc/Controller#
         */
        _extraSubController: function(view, subControllers) {
            // check parameters
            if (!view && this._view) {
                view = this._view;
            }
            if (!subControllers) {
                subControllers = [];
            }

            var controller = view.getAttachedController(),
                children, curChild, i, len;
            if (view !== this._view && controller) {
                // found controller already
                subControllers.push(controller);
                return subControllers;
            }

            if (view.isLeaf()) {
                // no more children, just return
                return subControllers;
            }

            // search all children
            children = view.getChildren();
            len = children.length;
            for (i = 0; i < len; i++) {
                curChild = children[i];
                subControllers = this._extraSubController(curChild, subControllers);
            }
            return subControllers;
        },
        /**
         * Get view from the current controller.
         * @public
         * @return {xdk-ax/Componenet} The attached view object
         * @method
         * @memberof xdk-ax/mvc/Controller#
         */
        getView: function() {
            return this._view;
        },
        /**
         * Get the current controller"s ID.
         * @public
         * @return {String} the current controller's ID
         * @method
         * @memberof xdk-ax/mvc/Controller#
         */
        getId: function() {
            if (!this.__id) {
                this.__id = "" + core.getGuid();
            }
            return this.__id;
        },
        /**
         * Find a controller instance by its class.
         * @public
         * @param {xdk-ax/mvc/Controller} Controller The controller class
         * @return {xdk-ax/mvc/Controller} the controller instance
         * @method
         * @memberof xdk-ax/mvc/Controller#
         */
        getControllerByClass: function(Controller) {
            if (this instanceof Controller) {
                return this;
            }
            var i, len = this._subControllers.length,
                result;
            for (i = 0; i < len; i++) {
                result = this._subControllers[i].getControllerByClass(Controller);
                if (result) {
                    return result;
                }
            }
            return false;
        },
        /**
         * Setup the controller as well as the sub-controllers if context data for them exists.
         * @memberof xdk-ax/mvc/Controller#
         * @method
         * @param {Object} context - Data for controller to update
         * @returns {Promise.<Undefined>} when all the subcontrollers(optionals) and postSetup(optional) are run.
         * @protected
         */
        _setupSubtree: function(context) {
            var i = 0,
                len = this._subControllers.length,
                subController,
                subCtrlrId,
                subContext,
                pendingSubcontrollers = [],
                pending,
                setupPending,
                isSetupPendingPromise = false;


            setupPending = this.setup(context);

            if (promise.isPromise(setupPending)) {
                isSetupPendingPromise = true;
            }

            //setup sub controllers if context.subContexts[controllerId] exists
            for (; i < len; i++) {
                subController = this._subControllers[i];
                subCtrlrId = subController.getId();

                if (context && context.subContexts && context.subContexts[subCtrlrId]) {
                    subContext = context.subContexts[subCtrlrId];
                } else {
                    subContext = {};
                }

                if (isSetupPendingPromise) {

                    //wait for parent controller to finish setup
                    pendingSubcontrollers.push(setupPending.then(function() {
                        return subController._setupSubtree(subContext);
                    }));

                } else {
                    pendingSubcontrollers.push(
                        subController._setupSubtree(subContext)
                    );
                }
            }

            pending = pendingSubcontrollers.length > 0 ? promise.all(pendingSubcontrollers) : setupPending;

            if (this.postSetup) {

                if (pending && isSetupPendingPromise) {
                    return pending.then(util.bind(function() {
                        this.postSetup(context);
                    }, this));
                }

                return promise.resolve(this.postSetup(context));
            }

            if (promise.isPromise(pending)) {
                return pending;
            }

            return promise.resolve();

        },
        /**
         * Setup the controller with context data. This function will be called
         * before the controller is being show.
         * Developer should hanlde controller's context data here.
         * @memberof xdk-ax/mvc/Controller#
         * @protected
         * @param {Object} [context] - Data for controller to update from
         */
        setup: function(context) {
            console.debug("controller set up" + context);
        },
        /**
         * Reset the subcontrollers, then calls this controller's reset.
         * @protected
         * @memberof xdk-ax/mvc/Controller#
         * @method
         */
        _resetSubtree: function() {

            var i = 0,
                len = this._subControllers.length;

            //setup sub controllers if context.subContexts[controllerDef] exists
            for (; i < len; i++) {
                this._subControllers[i]._resetSubtree();
            }

            this.reset();
        },
        /**
         * Reset controller's current data. This function will be called before
         * a controller is hidden. Developer should handle resetting the
         * controllers context data here.
         * @memberof xdk-ax/mvc/Controller#
         * @method
         * @protected
         */
        reset: function() {},
        /**
         * Track one more sub-controller that is to add to this controller
         * @protected
         * @method
         * @param {xdk-ax/mvc/Controller} controller instance
         * @return {Boolean} successful or not
         * @memberof xdk-ax/mvc/Controller#
         */
        _addSubController: function(controller) {

            if (this._subControllers.indexOf(controller) > 0) {
                console.warn(controller.getId() + " is already a sub-controller of " + this.getId());
                return false;
            }

            this._subControllers.push(controller);
            controller._parentController = this;

            return true;
        },
        /**
         * Track one less sub-controller that was added to this controller
         * @protected
         * @method
         * @param {xdk-ax/mvc/Controller} controller instance
         * @return {Boolean} successful or not
         * @memberof xdk-ax/mvc/Controller#
         */
        _removeSubController: function(controller) {

            var idx = this._subControllers.indexOf(controller);

            if (idx < 0) {
                return false;
            }
            this._subControllers.splice(idx, 1);

            return true;
        },
        /**
         * Retreive the sub-controllers array
         * @method
         * @return {Array} Controllers
         * @public
         * @memberof xdk-ax/mvc/Controller#
         */
        getSubControllers: function() {
            return this._subControllers;
        },
        /**
         * Retreive the a sub controller attached to this controller by a controller class or an index
         * @param {Number|xdk-ax/mvc/Controller} klass class or the array index for the sub-controller
         * @method
         * @return {xdk-ax/mvc/Controller|null} The specified controller or null if not found
         * @public
         * @memberof xdk-ax/mvc/Controller#
         */
        getSubController: function(klass) {
            if (util.isNumber(klass)) {
                return this._subControllers[klass];
            }

            var subCtrlr, i, len = this._subControllers.length;

            for (i = 0; i < len; i++) {
                subCtrlr = this._subControllers[i];
                if (subCtrlr instanceof klass) {
                    return subCtrlr;
                }
            }

            for (i = 0; i < len; i++) {
                subCtrlr = this._subControllers[i].getSubController();
                if (subCtrlr) {
                    return subCtrlr;
                }
            }

            return null;
        },
        /**
         * Gets the parent controller
         * @method
         * @return {xdk-ax/mvc/Controller} The parent controller
         * @public
         * @memberof xdk-ax/mvc/Controller#
         */
        getParentController: function() {
            return this._parentController;
        },
        /**
         * Retreives the context object, along with the sub-controllers' contexts
         * @method
         * @return {Object} The context object, also, all the sub-controller contexts will be stored under key "subContexts"
         * @public
         * @memberof xdk-ax/mvc/Controller#
         */
        getContextTree: function() {

            var subCtrlr, context = this.getContext(),
                subContext = null,
                i = 0,
                len = this._subControllers.length;

            for (; i < len; i++) {
                subCtrlr = this._subControllers[i];
                subContext = subCtrlr.getContextTree();
                if (subContext) {
                    context = context || {};
                    context.subContexts = context.subContexts || {};
                    context.subContexts[subCtrlr.getId()] = subContext;
                }
            }
            return context;
        },
        /**
         * Retreives the context object, suppose to be override by extending controller
         * @method
         * @return {Object} The context object (which would be null for this base class)
         * @public
         * @memberof xdk-ax/mvc/Controller#
         */
        getContext: function() {
            return null;
        }
    });

    return Controller;
});
/**
 * Basic container component to accomplish parent-child relationship for the view's tree structure.
 * @class xdk-ax/Container
 * @extends xdk-ax/Component
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/Container", ["xdk-base/class", "xdk-ax/Component", "xdk-base/core", "xdk-ax/evt/eventManager", "xdk-base/util", "xdk-ax/evt/type", "xdk-base/console"], function (klass, Component, core, evtMgr, util, evtType, console) {
    "use strict";
    var Container = klass.create(Component, {}, {
        /**
         * This array holds pointers to all child components in DOM order.
         * @protected
         * @memberof xdk-ax/Container#
         */
        _children: [],
        /**
         * This array holds pointers to all child components in activeness order.
         * @private
         * @memberof xdk-ax/Container#
         */
        __activeness: [],
        /**
         * Overrides the init() method inherits from Component
         * @method
         * @memberof xdk-ax/Container#
         * @public
         * @protected
         */
        init: function (opts) {
            this._super(opts);
        },
        /**
         * Deinit remove event listeners for itself and also ask its children to remove the event listers
         * @method
         * @memberof xdk-ax/Container#
         * @protected
         */
        deinit: function () {
            var i, children = this._children.slice(0),
                len = children.length;

            for (i = 0; i < len; i++) {
                children[i].deinit();
            }

            this._super();
        },
        /**
         * To do after the initialization, when all children are readily included
         * @method
         * @memberof xdk-ax/Container#
         * @protected
         */
        postInit: function () {
            this._super();

            if (!this._opts.children || !util.isArray(this._opts.children)) {
                return;
            }
            //do when there are children
            var i = 0,
                len = this._opts.children.length,
                child;
            if (len <= 0) {
                return;
            }
            for (; i < len; i++) {
                child = this._opts.children[i];
                this.attach(child);
            }
        },
        /**
         * This function retrieves a child object by its ID. It is worth
         * noting that this is a recursive function, so it will search
         * child containers as well for the give ID.
         * @method
         * @param {String} id The component id
         * @returns {xdk-ax/Component|null} The component with the given id, null if not found
         * @memberof xdk-ax/Container#
         * @public
         */
        find: function (id) {
            if (this.getId() === id) {
                return this;
            }

            var i, len = this._children.length,
                obj;
            for (i = 0; i < len; i++) {
                obj = this._children[i].find(id);
                if (obj) {
                    return obj;
                }
            }
            return null;
        },
        /**
         * This function retrives the current set of children of this container.
         * @method
         * @return {Array} The children array
         * @memberof xdk-ax/Container#
         * @public
         */
        getChildren: function () {
            return this._children.slice(0);
        },
        /**
         * Attach a child component.
         * @method
         * @param {xdk-ax/Component} child - The child component to be attached
         * @param {xdk-ax/Component.PLACE_BEFORE | xdk-ax/Component.PLACE_AFTER | xdk-ax/Component.PLACE_APPEND | xdk-ax/Component.PLACE_PREPEND}
         * [placement] - position the child should be placed. By default {@link xdk-ax/Component.PLACE_APPEND}.
         * @param {xdk-ax/Component} [marker] - must be a child of current container,
         * the placement of child will be in relative to this marker.
         * @memberof xdk-ax/Container#
         * @fires module:xdk-ax/evt/type.ATTACH
         * @fires module:xdk-ax/evt/type.ATTACHED_TO_DOM
         * @fires module:xdk-ax/evt/type.ATTACHED_TO_CONTROLLER
         * @public
         */
        attach: function (child, placement, marker) {
            if (util.indexOf(this._children, child) >= 0) {
                console.warn("Child is already attached to container");
                return this;
            }

            if (!placement) {
                placement = Container.PLACE_APPEND;
            }


            var idx = marker ? util.indexOf(this._children, marker) : this._children.length - 1;

            switch (placement) {
            case Container.PLACE_APPEND:
                this._children.push(child);
                break;
            case Container.PLACE_PREPEND:
                this._children.unshift(child);
                break;
            case Container.PLACE_BEFORE:
                if (idx < 0) {
                    throw core.createException("IncorrectParam", "The insert place marker component must be a child of this container!");
                }
                this._children.splice(idx, 0, child);
                break;
            case Container.PLACE_AFTER:
                if (idx < 0) {
                    throw core.createException("IncorrectParam", "The insert place marker component must be a child of this container!");
                }
                this._children.splice(idx + 1, 0, child);
                break;
            }

            // do the real work
            this._doAttach(child, placement, marker);

            this.__activeness.push(child);

            child._parent = this;

            // update members
            child._updateAncestorHidden();
            if (this._root.isInDOMTree()) {
                child._updateInDOMTree(true);
            }

            // fire events
            evtMgr.trigger(evtType.ATTACH, child);
            if (this._root.isInDOMTree()) {
                evtMgr.trigger(evtType.ATTACHED_TO_DOM, child);
            }

            return this;
        },
        /**
         * Internal function to really attach a child component.
         * @method
         * @param {xdk-ax/Component} child - The child component to be attached
         * @param {xdk-ax/Component.PLACE_BEFORE | xdk-ax/Component.PLACE_AFTER | xdk-ax/Component.PLACE_APPEND | xdk-ax/Component.PLACE_PREPEND}
         * [placement] - position the child should be placed. By default {@link xdk-ax/Component.PLACE_APPEND}.
         * @param {xdk-ax/Component} [marker] - must be a child of current container,
         * the placement of child will be in relative to this marker.
         * @memberof xdk-ax/Container#
         * @protected
         */
        _doAttach: function (child, placement, marker) {
            switch (placement) {
            case Container.PLACE_APPEND:
                this._root.append(child.getRoot());
                break;
            case Container.PLACE_PREPEND:
                this._root.prepend(child.getRoot());
                break;
            case Container.PLACE_BEFORE:
                this._root.insertBefore(marker.getRoot(), child.getRoot());
                break;
            case Container.PLACE_AFTER:
                this._root.insertAfter(marker.getRoot(), child.getRoot());
                break;
            }
        },
        /**
         * This function replace an existing child component with a new child component.
         * @method
         * @param {xdk-ax/Component} targetChild - Target child to replace.
         * @param {xdk-ax/Component} replacement - The replacement child component
         * @memberof xdk-ax/Container#
         * @public
         */
        replace: function (targetChild, replacement) {
            if (replacement === targetChild) {
                return;
            }

            var targetIdx = util.indexOf(this._children, targetChild),
                activeIdx = util.indexOf(this.__activeness, targetChild),
                inDOM = this._root.isInDOMTree();

            if (targetIdx < 0) {
                throw core.createException("IncorrectParam", "The replace target component must be a child of this container!");
            }

            this._children.splice(targetIdx, 1, replacement);
            this.__activeness.splice(activeIdx, 1, replacement);

            // do the real work
            this._doReplace(targetChild, replacement);

            replacement._parent = this;
            targetChild._parent = null;

            // update members
            replacement._updateAncestorHidden();
            if (inDOM) {
                replacement._updateInDOMTree(true);
            }
            // fire events
            evtMgr.trigger(evtType.ATTACH, replacement);
            if (inDOM) {
                evtMgr.trigger(evtType.ATTACHED_TO_DOM, replacement);
            }

            // update members
            targetChild._updateAncestorHidden();
            if (inDOM) {
                targetChild._updateInDOMTree(false);
            }
            // fire events
            evtMgr.trigger(evtType.DETACH, targetChild);
            if (inDOM) {
                evtMgr.trigger(evtType.DETACHED_FROM_DOM, targetChild);
            }
        },
        /**
         * The internal function that really replace an existing child component with a new child component.
         * @method
         * @param {xdk-ax/Component} targetChild - Target child to replace.
         * @param {xdk-ax/Component} replacement - The replacement child component
         * @memberof xdk-ax/Container#
         * @protected
         */
        _doReplace: function (targetChild, replacement) {
            this._root.replaceChild(targetChild.getRoot(), replacement.getRoot());
        },
        /**
         * This function detaches a child object. If no child provided, it will remove container itself.
         * @method
         * @param {xdk-ax/Component} child The child object to detach
         * @return {xdk-ax/Component} The component itself, for chaining
         * @memberof xdk-ax/Container#
         * @public
         */
        detach: function (child) {
            if (!child) {
                //if no child provided, it will remove itself via component detach function
                return this._super();
            }

            var idx = util.indexOf(this._children, child),
                activeIdx;

            if (idx < 0) {
                throw core.createException("IncorrectParam", "The detach target component must be a child of this container!");
            }


            this._children.splice(idx, 1);
            activeIdx = util.indexOf(this.__activeness, child);
            this.__activeness.splice(activeIdx, 1);

            child.getRoot().detach();

            child._parent = null;

            // update members
            child._updateAncestorHidden();
            if (this._root.isInDOMTree()) {
                child._updateInDOMTree(false);
            }

            // fire events
            evtMgr.trigger(evtType.DETACH, child);
            if (this._root.isInDOMTree()) {
                evtMgr.trigger(evtType.DETACHED_FROM_DOM, child);
            }

            return this;
        },
        /**
         * This function detaches all child objects.
         * @method
         * @memberof xdk-ax/Container#
         * @public
         */
        detachAll: function () {
            var i = this._children.length;
            while (i--) {
                this._children[i].detach();
            }
            this._children = [];
        },
        /**
         * Set the child as most active
         * @method
         * @param {String | xdk-ax/Component} child - id or child instance
         * @memberof xdk-ax/Container#
         * container
         */
        setActiveChild: function (child) {
            if (!(child instanceof Component)) {
                child = this.find(child);
            }

            var idx = util.indexOf(this.__activeness, child);

            if (idx < 0) {
                throw core.createException("IncorrectParam", "The target component must be a child of this container!");
            }

            if (idx === 0) {
                return;
            }

            this.__activeness.splice(idx, 1);

            //add to the front
            this.__activeness.unshift(child);

            //dispatch inactive event
            evtMgr.trigger(evtType.INACTIVED, this.__activeness[1]);

            //dispatch active event
            evtMgr.trigger(evtType.ACTIVED, this.__activeness[0]);

            return;
        },

        /**
         * Get the children by activeness
         * @method getActiveChildren
         * @return {xdk-ax/Component[]} return children array sort by activeness
         * @memberof xdk-ax/Container#
         */
        getActiveChildren: function () {
            return this.__activeness.slice(0);
        },

        /**
         * Get the most active child
         * @method
         * @param {Number} [activeIdx] - Get the child with specified activeness rank.
         * 0 by default. 0 is most active.
         * @return {xdk-ax/Component | null} return null if there's not found
         * @memberof xdk-ax/Container#
         */
        getActiveChild: function (activeIdx) {

            if (util.isUndefined(activeIdx)) {
                activeIdx = 0;
            }

            //out of scope
            if (activeIdx < 0 || activeIdx > this.__activeness.length - 1) {
                return null;
            }

            return this.__activeness[activeIdx];
        },
        /**
         * Get the most active leaf component from this node downwards
         * @method
         * @return {xdk-ax/Component} the most the most active leaf component
         * @memberof xdk-ax/Container#
         * @public
         */
        getActiveLeaf: function () {
            var leaf = this;
            while (!leaf.isLeaf()) {
                leaf = leaf.getActiveChild();
            }

            return leaf;
        },
        /**
         * Returns true if the child is active
         * @param {xdk-ax/Component} child child component to check
         * @return {Boolean} True if the child is active
         * @memberof xdk-ax/Container#
         * @method
         * @public
         */
        isChildActive: function (child) {
            return child === this.__activeness[0];
        },
        /**
         * Updates the internal _ancestorHidden field for current and child components
         * @memberof xdk-ax/Container#
         * @method
         * @protected
         */
        _updateAncestorHidden: function () {
            this._super();

            util.each(this._children, function (child) {
                // update all children recursively
                child._updateAncestorHidden();
            });
        },
        /**
         * Updates the internal _inDOMTree field for current and child components
         * @memberof xdk-ax/Container#
         * @method
         * @protected
         */
        _updateInDOMTree: function (isAttached) {
            this._super(isAttached);

            util.each(this._children, function (child) {
                child._updateInDOMTree(isAttached);
            });
        },
        /**
         * Returns true if itself is leaf component
         * @method
         * @return {Boolean} True if itself is leaf component
         * @memberof xdk-ax/Container#
         * @public
         */
        isLeaf: function () {
            return this._children.length === 0;
        }
    });
    return Container;
});
/**
 * Controller Manager centralizes the manipulation of controllers: open, replace and close controller(s).
 *
 * This class is designed as a singleton, developer should use {@link xdk-ax/mvc/ControllerManager.singleton|singleton} to obtain the instance.
 * Creating instance using the _new_ keyword is prohibited.
 *
 * @class xdk-ax/mvc/ControllerManager
 * @author Andy Hui <andy.hui@accedo.tv>
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/mvc/ControllerManager", [
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/EventDispatcher",
    "xdk-ax/mvc/Controller",
    "xdk-base/promise",
    "xdk-base/util",
    "xdk-base/exception",
    "require"
], function (core,
    klass,
    EventDispatcher,
    Controller,
    promise,
    util,
    exception,
    require) {
    "use strict";
    var ControllerManager,
        instance;

    ControllerManager = klass.create(EventDispatcher, {
        /**
         * Event fired when replace controller complete
         * @event
         * @type {Object}
         * @property {xdk-ax/mvc/Controller} exist The original controller instance that is being replaced
         * @property {xdk-ax/mvc/Controller} replacement The new controller instance that replaces with
         * @property {Object} [options] Option value which will pass from the replace function
         * @memberof xdk-ax/mvc/ControllerManager#
         */
        EVT_REPLACED: "ui:ctrlMgr:replaced",
        /**
         * Event fired when open controller complete
         * @event
         * @type {Object}
         * @property {xdk-ax/mvc/Controller} exist The controller instance that is being opened
         * @property {xdk-ax/Container} container The parent container of the controller where it is attached
         * @property {Object} [options] Option value which will pass from the open function
         * @memberof xdk-ax/mvc/ControllerManager#
         */
        EVT_OPENED: "ui:ctrlMgr:opened",
        /**
         * Event fired when close controller complete
         * @event
         * @type {Object}
         * @property {xdk-ax/mvc/Controller} controller The original controller instance that is being closed
         * @property {xdk-ax/Container} container The parent container of the controller where it is detached from
         * @property {Object} [options] Option value which will pass from the close function
         * @memberof xdk-ax/mvc/ControllerManager#
         */
        EVT_CLOSED: "ui:ctrlMgr:closed",

        /**
         * Get the singleton instance of this class.
         * @method
         * @static
         * @returns {xdk-ax/mvc/ControllerManager} The singleton
         * @memberOf xdk-ax/mvc/ControllerManager
         */
        singleton: function () {
            if (!instance) {
                instance = new ControllerManager();
            }

            return instance;
        }
    }, {
        /**
         * Replace a controller with a new one.
         * @param {xdk-ax/mvc/Controller} exist The existing controller instance or class.
         * @param {xdk-ax/mvc/Controller} replacement The replacement controller class or instance.
         * @param {Object} [options] Options for this operation
         * @param {Object} [options.context] Context object to be passed to the new controller
         * @return {Promise.<xdk-ax/mvc/Controller>} the replacement controller instance
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} When the existing controller (exist) is not a Controller instance or class or replacement controller (replacement) is not a Controller instance or class
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} When the existing controller or replacement controller don't have a view
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} When the existing controller is not attached to parent
         * @memberof xdk-ax/mvc/ControllerManager#
         * @fires xdk-ax/mvc/ControllerManager.EVT_REPLACED
         * @public
         */
        replace: function (exist, replacement, options) {
            var sAppRoot, existView, replaceView, existParent, existViewParent, context;

            sAppRoot = require("xdk-ax/mvc/AppRoot").singleton();

            if (!(exist instanceof Controller)) {
                if (exist.prototype instanceof Controller) {
                    exist = sAppRoot.getControllerByClass(exist);
                } else {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Fail to get the current controller instance."));
                }
            }

            if (!(replacement instanceof Controller)) {
                if (replacement.prototype instanceof Controller) {
                    /*jshint newcap: false */
                    replacement = new replacement();
                    /*jshint newcap: true*/
                } else {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Replacement controller is not a Controller class!"));
                }
            }

            existView = exist.getView();
            replaceView = replacement.getView();
            existParent = exist.getParentController();

            if (!existView || !replaceView) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "One of the controllers does not have a view!"));
            }

            existViewParent = existView.getParent();
            if (!existViewParent) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Controller to be replaced is not attached to a parent!"));
            }

            options = options || {};
            context = options.context || {};

            // extract controller data from commit function
            existViewParent.replace(existView, replaceView);

            if (existParent) {
                existParent._removeSubController(exist);
                existParent._addSubController(replacement);
            }

            //reset the last controller conext data
            exist._resetSubtree();

            //setup the controller with context data
            return replacement._setupSubtree(context).then(util.bind(function () {

                this.dispatchEvent(this.constructor.EVT_REPLACED, {
                    exist: exist,
                    replacement: replacement,
                    options: options
                });

                return replacement;
            }, this));

        },
        /**
         * Open a controller in a container.
         * @param {xdk-ax/mvc/Controller} controller The controller instance or class to open.
         * @param {xdk-ax/Container|xdk-ax/mvc/Controller} container Container or controller
         *     under which the controller should be opened under.
         * @param {Object} [context] Context object to be passed to the new controller
         * @param {Object} [options] Options for this operation
         * @param {Object} [options.context] Options for this operation
         * @return {Promise.<xdk-ax/mvc/Controller>} the opened controller instance
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} when fail to get the container
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} when fail to create the new controller
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} when the target new controller has no view
         * @memberof xdk-ax/mvc/ControllerManager#
         * @fires xdk-ax/mvc/ControllerManager.EVT_OPENED
         * @public
         */
        open: function (controller, container, options) {
            var context, view, parent;
            options = options || {};
            context = options.context || {};


            if (container instanceof Controller) {
                container = container.getView();
            }

            if (!container) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Fail to find the container to open a new controller."));
            }


            if (!(controller instanceof Controller)) {
                if (controller.prototype instanceof Controller) {
                    /*jshint newcap: false */
                    controller = new controller();
                    /*jshint newcap: true */
                } else {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Fail to get the controller instance when opening controller."));
                }
            }

            view = controller.getView();
            parent = container.getController();

            if (!view) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Fail to get the view from the controller instance."));
            }

            container.attach(view);

            if (parent) {
                parent._addSubController(controller);
            }

            //setup the controller with context data
            return controller._setupSubtree(context).then(util.bind(function () {
                this.dispatchEvent(this.constructor.EVT_OPENED, {
                    controller: controller,
                    container: container,
                    options: options
                });
                return controller;
            }, this));
        },
        /**
         * Close a controller.
         * @param {xdk-ax/mvc/Controller} controller The controller instance or class to close.
         * @param {Object} [options] Options for this operation
         * @return {Promise.<Undefined>}
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} the controller does not exist
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} when the controller has no view
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} when the controller isn't attached to parent
         * @memberof xdk-ax/mvc/ControllerManager#
         * @fires xdk-ax/mvc/ControllerManager.EVT_CLOSED
         * @public
         */
        close: function (controller, options) {
            var sAppRoot, view, parent, viewParent;
            options = options || {};
            sAppRoot = require("xdk-ax/mvc/AppRoot").singleton();

            if (!(controller instanceof Controller)) {
                if (controller.prototype instanceof Controller) {
                    controller = sAppRoot.getControllerByClass(controller);
                } else {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Fail to get the controller instance when closing controller."));
                }
            }

            view = controller.getView();
            parent = controller.getParentController();

            if (!view) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Fail to get the view from the controller instance."));
            }

            viewParent = view.getParent();
            if (!viewParent) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "The controller instance to be closed is not attached to a parent!"));
            }

            if (parent) {
                parent._removeSubController(controller);
            }

            // detach the view
            view.detach();
            // reset the controller
            controller._resetSubtree();


            this.dispatchEvent(this.constructor.EVT_CLOSED, {
                controller: controller,
                container: viewParent,
                options: options
            });

            return promise.resolve();
        }

    });

    // enforce the instance creation before returning, preventing 2 instances being created
    // (2 executions may go into the creation at the same time...)
    ControllerManager.singleton();

    return ControllerManager;

});
/**
 * {@link xdk-ax/Component|Component} Breath first search iterator.
 * @class xdk-ax/iterator/BFSCompIt
 * @extends xdk-ax/iterator/interface/Iterator
 * @param {xdk-ax/Component} targetComp capturing target component
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-ax/iterator/BFSCompIt", ["xdk-base/class", "xdk-ax/iterator/interface/Iterator", "xdk-base/core"], function (klass, IIterator, core) {
    "use strict";
    return klass.create([IIterator], {}, {
        /**
         * internal component array
         * @private
         */
        __compArr: [],
        init: function (targetComp) {
            this._include(targetComp);
        },
        _include: function (comp) {

            if (comp.isLeaf()) {
                return;
            }

            var i, children = comp.getChildren();

            for (i in children) {
                this.__compArr.unshift(children[i]);
            }

            for (i in children) {
                this._include(children[i]);
            }
        },
        next: function () {
            if (!this.__compArr.length) {
                core.createException("NoSuchElement", "No more element is available for current iteraion!");
            }
            return this.__compArr.pop();
        },
        hasNext: function () {
            return !!this.__compArr.length;
        }
    });
});
/**
 * Active first search iterator.
 * @class xdk-ax/iterator/AFSCompIt
 * @extends xdk-ax/iterator/interface/Iterator
 * @param {xdk-ax/Component} targetComp capturing target component
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-ax/iterator/AFSCompIt", ["xdk-base/class", "xdk-ax/iterator/interface/Iterator", "xdk-base/core"], function (klass, IIterator, core) {
    "use strict";
    return klass.create([IIterator],{}, {
        /**
         * internal component array
         * @private
         **/
        __compArr: [],
        init: function (targetComp) {

            this._include(targetComp);

        },
        _include: function (comp) {

            if (comp.isLeaf()) {
                this.__compArr.unshift(comp);
                return;
            }

            var i, children = comp.getActiveChildren();
            for (i = 0; i < children.length; i++) {
                this._include(children[i]);
            }

            this.__compArr.unshift(comp);
        },
        next: function () {
            if (!this.__compArr.length) {
                core.createException("NoSuchElement", "No more element is available for current iteraion!");
            }
            return this.__compArr.pop();
        },
        hasNext: function () {
            return !!this.__compArr.length;
        }
    });
});
/**
 *
 * Handling the focus automation here. Based on options defined in components:
 *
 * * nextRight      : Target component's id / abstract component / callback function
 * * nextLeft       : Target component's id / abstract component / callback function
 * * nextUp         : Target component's id / abstract component / callback function
 * * nextDown       : Target component's id / abstract component / callback function
 *
 * If the nextUp/nextDown/nextRight/nextLeft is a callback function, it will run the callback in focus direction change and check the return value.
 *
 * When return value is false/undefined, it will keep going to find its parent navigation option until the toppest (which has no navigation Handle) or
 * the parent navigation handling.
 *
 * When return value is true, it will stop checking the parent. So when writing callback of nextUp/nextDown/nextRight/nextTop,
 * please make sure if it is necessary to continue the navigation handling after the callback.
 *
 *  For example, the nextUp/nextDown option in list/grid are callback functions. If you want to just do the internal nextUp/nextDown without
 *  find the parent one,you need to return true
 *
 *  If you reach the border,it will return the original set value when initial.It may not defined and need to look up for the parent handling,so you may need to return false to keep looping the parent.
 *
 * __forwardFocus__  : Taget descendant component's id / Boolean(true) / Boolean(false)
 * When forwardFocus is set to true, automated forward focus mechanism is enabled.
 * This mechanism forwards the focus to the last focused descendant component.
 * If there's no last focus, it will try to breath first search for the first 'focusable' child.
 * However, whenever the search reachs a Container with 'forwardFocus:false', the search of it's descendents is be terminated.
 *
 * __focus root__ : A container, which is the root of the focusable component sub tree.
 * When focus root is not null, any focus request beyond this container will be rejected.
 * This setting will eventually set up a boundary on where the focus can go.
 * Please note that the direction check for focus automation will not exceed this boundary as well.
 * (ie. if the __next*__ of a component is not set, the recusive search in the parent will only be effective up to the focus root)
 * To clear the boundary, set it to null.
 *
 * @module xdk-ax/focusManager
 * @author Andy Hui <andy.hui@accedo.tv>
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ax/focusManager", [
    "xdk-ax/Component",
    "xdk-base/util",
    "xdk-ax/evt/eventManager",
    "xdk-ax/evt/type",
    "xdk-base/device/vKey",
    "xdk-base/console",
    "xdk-base/config",
    "xdk-ax/iterator/BFSCompIt",
    "xdk-ax/iterator/AFSCompIt",
    "xdk-ax/Container",
    "xdk-base/core",
    "xdk-base/exception"
], function (
    Component,
    util,
    evtMgr,
    evtType,
    vKey,
    console,
    config,
    BFSCompIt,
    AFSCompIt,
    Container,
    core,
    exception
) {

    "use strict";

    /**
     * Get the inherited forwardFocus option. It will loop to find the available value until the root or available option
     * @param {xdk-ax/Component} component Component to start with and look for its inherited forwardfocus option
     * @return {Boolean | xdk-ax/Component | String} The option of the inherited forwardFocus
     * @memberof module:xdk-ax/focusManager
     * @method inheritForwardFocusOption
     * @private
     */
    function inheritForwardFocusOption(comp) {
        var option;

        while (!option) {
            comp = comp.getParent();
            if (!comp) {
                break;
            }
            option = comp.getOption("forwardFocus");
        }

        return option;
    }

    /**
     * To obtain the next Level first focusable component
     * @param {xdk-ax/Component} component Component to start with and look for its parent forwardfocus option
     * @return {xdk-ax/Component} The focusbale components. If it is unable to find, it will return null
     * @memberof module:xdk-ax/focusManager
     * @method getNextFocusableChild
     * @private
     */
    function getNextFocusableChild(comp) {
        var child, i,
            target = null,
            children;

        if (comp.isLeaf()) {
            return null;
        }

        children = comp.getChildren();

        for (i = 0; i < children.length; i++) {

            child = children[i];

            if (isCompFocusable(child)) {
                return child;
            }

        }
        return target;
    }

    /**
     * To get the next forward focus.
     * @param {xdk-ax/Component} component Component to start with and look for its parent forwardfocus option
     * @param {Boolean} [parentForwardFocusOption] true if there is parentForwardFocusOption and then it will find the next level forward focus. if it is undefined, it won't loop to the leaf and find the next forwardFocus
     * @return {xdk-ax/Component} The focusbale components. If it is unable to find, it will return null
     * @memberof module:xdk-ax/focusManager
     * @method findNextLevelFirstFocusableChild
     * @private
     */
    function getNextForwardFocus(comp, parentForwardFocusOption) {
        var child, i,
            target = null,
            children;

        if (comp.isLeaf()) {
            return null;
        }

        children = comp.getChildren();
        for (i = 0; i < children.length; i++) {

            child = children[i];
            target = getForwardFocus(child, parentForwardFocusOption);

            if (target) {
                return target;
            }

        }

        return target;

    }

    /**
     * To find and handle the forwardFocus of the component. It will find if there is lastFocusChild, if not, it will find the next Level Focusbale children
     * @param {xdk-ax/Component} component the target component
     * @return {xdk-ax/Component} the target focusable component
     * @memberof module:xdk-ax/focusManager
     * @method forwardFocusHandling
     * @private
     */
    function forwardFocusHandling(comp) {
        var lastFocus = comp._lastFocusChild;

        if ((lastFocus instanceof Component) && comp.isAncestorOf(lastFocus) && isCompFocusable(lastFocus)) {

            console.info("Using last focus for forward focus");
            return lastFocus;
        } else {
            console.info("Find the next level focusable item");
            return getNextFocusableChild(comp);
        }
    }

    var focusMgrModule = null,
        rootController = null,
        lastFocus = null,
        // last focused component
        curFocus = null,
        // current focuesed component
        getForwardFocus, getLastActiveFocus, handleFocusDetached, onBlurAction, onFocusAction, isCompFocusable, isCompChildFocused, isCompFocused, getCompLastFocusedTime;


    /**
     * Get the forwarded focus of a specified component.
     * @param {xdk-ax/Component} component Component to be focused
     * @param {Boolean} parentForwardFocusOption used to determine if need to search for focusable children. Default is false. If it is not set, it will get the inherit forward focus option from the parent.
     * @memberof module:xdk-ax/focusManager
     * @method
     * @private
     */
    getForwardFocus = function (component, parentForwardFocusOption) {
        if (!component) {
            return null;
        }

        if (isCompFocusable(component)) {
            return component;
        }

        var forwardFocusOption, forwardFocusComp;

        //Step 1. Get current comp forwardFocus
        forwardFocusOption = component.getOption("forwardFocus");

        //Step 2. Handle the forward Focus

        if (forwardFocusOption === true) {
            //Step 2a. Handle current comp forwardFocus true based on focusable
            forwardFocusComp = forwardFocusHandling(component);

            //Step 2ai go deeper to the children and find the forwardFocus when it is unable to find the forward focus
            if (!forwardFocusComp) {
                forwardFocusComp = getNextForwardFocus(component, true);
            }

        } else if (forwardFocusOption === false) {
            //Step 2b. do nothing
            return null;
        } else if (util.isUndefined(forwardFocusOption)) {
            //Step 2c. Handle when no setting on forward Focus 

            if (parentForwardFocusOption) {
                //Step 2ci go deeper to the children and find the forwardFocus if it is capture
                forwardFocusComp = getNextForwardFocus(component, parentForwardFocusOption);
            } else {
                //Step 2cii Get Parent forward Focus Option (inherit from the parent)
                forwardFocusOption = inheritForwardFocusOption(component);

                //Step 2ciii if parent forwardFocus is true, then need to find the forwardFocus start from the current level
                if (forwardFocusOption === true) {

                    forwardFocusComp = forwardFocusHandling(component);

                    if (!forwardFocusComp) {
                        forwardFocusComp = getNextForwardFocus(component, true);
                    }

                }
            }
        } else {
            //to convert the option into comp
            forwardFocusComp = forwardFocusOption;
        }


        //Step 3. Get the focus if id/String
        // fallback case: a valid "forwardFocus" option is specified (in string)
        if (forwardFocusComp && util.isString(forwardFocusComp)) {
            //only have default focus when it is mouseoff
            forwardFocusComp = component.find(forwardFocusComp);
        }

        // fallback case: a valid "forwardFocus" option is specified (as a component)
        if (forwardFocusComp && (forwardFocusComp instanceof Component)) {
            if (isCompFocusable(forwardFocusComp)) {
                return forwardFocusComp;
            } else {
                return getForwardFocus(forwardFocusComp);
            }
        }

        return null;
    };

    /**
     * Checks if component is focused.
     * @method isCompFocused
     * @public
     * @param {xdk-ax/Component} comp component
     * @return {Boolean} true if focused, false otherwise.
     * @memberof module:xdk-ax/focusManager
     */
    isCompFocused = function (comp) {
        return comp._focused || false;
    };
    /**
     * Returns whether any of it's child is focused
     * @name isCompChildFocused
     * @function
     * @param {xdk-ax/Component} comp component
     * @memberof module:xdk-ax/focusManager
     * @public
     */
    isCompChildFocused = function (comp) {
        return comp._root.hasClass("focus-trail") || (util.isUndefined(comp._focusTrail) ? false : comp._focusTrail);
    };
    /**
     * Returns true if component is focusable, false otherwise.
     * @method
     * @public
     * @param {xdk-ax/Component} comp component
     * @return {Boolean}
     * @memberof module:xdk-ax/focusManager
     */
    isCompFocusable = function (comp) {
        //not focusable if it's disabled
        if (comp._disabled || comp.isHidden() || comp.isAncestorHidden()) {
            return false;
        }

        //return default focusability
        return comp.getOption("focusable", false);
    };
    /**
     * Get the timesptamp when component last focused
     * @method
     * @param {xdk-ax/Component} comp component
     * @return {Integer|null} The timestamp when this component is focused
     * @memberof module:xdk-ax/focusManager
     * @public
     */
    getCompLastFocusedTime = function (comp) {
        return comp._lastFocused;
    };

    /**
     * Find the latest focused component from most active trail.
     * @method
     * @param {xdk-ax/Component} [from] - The component node to start
     * at.
     * @return {xdk-ax/Component|null} the found component, null if entire trail has not
     * been focused before.
     * @memberof module:xdk-ax/focusManager
     * @public
     */
    getLastActiveFocus = function (from) {

        from = from || rootController.getView();
        var component,
            focusedTime = 0,
            lastActiveFocus = null,
            afsCompIt = new AFSCompIt(from);

        while (afsCompIt.hasNext()) {

            component = afsCompIt.next();

            if (!isCompFocusable(component)) {
                component = component.getParent();
                continue;
            }

            if (focusedTime < getCompLastFocusedTime(component)) {
                lastActiveFocus = component;
                focusedTime = getCompLastFocusedTime(component);
            }
        }

        if (!focusedTime) {
            return null;
        }

        return lastActiveFocus;
    };
    /**
     * handler for focused component detached from DOM
     * @method
     * @private
     */
    handleFocusDetached = function () {
        focusMgrModule.focus(getLastActiveFocus(), {
            noActive: true
        });
    };
    /**
     * Remove focus from a component.
     * @method
     * @param {xdk-ax/Component} toBlur - The component to blur
     * @memberof module:xdk-ax/focusManager
     * @private
     */
    onBlurAction = function (toBlur, related) {
        var tempComp = curFocus.getParent(),
            evtOpts;

        // udpate component to be blured
        toBlur.removeClass("focused");
        toBlur._focused = false;
        // update focus trail
        while (tempComp) {
            if (focusMgrModule.isCompFocusTrailOn(tempComp)) {
                tempComp.removeClass("focus-trail");
            } else {
                tempComp._focusTrail = false;
            }

            tempComp = tempComp.getParent();
        }

        // fire events
        if (related) {
            evtOpts = {
                relatedTarget: related
            };
        }
        evtMgr.trigger(evtType.BLUR, curFocus, evtOpts);

        lastFocus = curFocus;
        curFocus = null;
        // commented out in case we need this again
        //lastFocus.removeEventListener(evtType.DETACHED_FROM_DOM, handleFocusDetached);
    };
    /**
     * Focus on a component.
     * @method
     * @param {xdk-ax/Component} toFocus - The component to focus.
     * @param {Object} [options] focus options
     * @param {Object} [options.noActive] do not set active for the focused component
     * @memberof module:xdk-ax/focusManager
     * @private
     */
    onFocusAction = function (toFocus, related, options) {
        var tempComp = toFocus.getParent(),
            evtOpts;

        curFocus = toFocus;
        // update component to be focused
        toFocus.getRoot().addClass("focused");
        toFocus._focused = true;
        toFocus._lastFocused = (new Date()).getTime();
        // update focus trail
        while (tempComp) {
            if (focusMgrModule.isCompFocusTrailOn(tempComp)) {
                tempComp.getRoot().addClass("focus-trail");
            } else {
                tempComp._focusTrail = true;
            }

            if (tempComp.getOption("forwardFocus") === true) {
                tempComp._lastFocusChild = toFocus;
            }
            tempComp = tempComp.getParent();
        }

        //Set focus to be active
        if (!options || !options.noActive) {
            curFocus.setActive();
        }

        console.info("[FocusMgr] focused on component " + curFocus + " with id'" + curFocus.getId() + "'");

        // fire events
        if (related) {
            evtOpts = {
                relatedTarget: related
            };
        }
        evtMgr.trigger(evtType.FOCUS, curFocus, evtOpts);


        // commented out in case we need this again
        //curFocus.addEventListener(evtType.DETACHED_FROM_DOM, handleFocusDetached);
    };
    // the actual module
    focusMgrModule = {
        /**
         * Focus direction: UP.
         * @memberof module:xdk-ax/focusManager
         */
        FOCUS_UP: 0x01,
        /**
         * Focus direction: DOWN.
         * @memberof module:xdk-ax/focusManager
         */
        FOCUS_DOWN: 0x02,
        /**
         * Focus direction: LEFT.
         * @memberof module:xdk-ax/focusManager
         */
        FOCUS_LEFT: 0x04,
        /**
         * Focus direction: RIGHT.
         * @memberof module:xdk-ax/focusManager
         */
        FOCUS_RIGHT: 0x08,
        /* Sets the root controller for this focus manager,
         * so it knows where to start when searching for a component
         * @method
         * @param {xdk-ax/mvc/Controller} controller
         *     the root controller where component searching starts from
         * @memberof module:xdk-ax/focusManager
         */
        _setRootController: function (controller) {
            rootController = controller;
        },

        /**
         * Set the root of the focusable tree that bound the focus.
         * @method
         * @param {xdk-ax/Container} container The root container of the focusable tree. Set to null to clear the boundary.
         * @throws {Exception.<exception.ILLEGAL_ARGUMENT>} If the root is not valid
         * @memberof module:xdk-ax/focusManager
         */
        setFocusRoot: function (container) {
            if (container && !(container instanceof Container)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "Focus root should be an instance of xdk-ax/Container");
            }

            this._focusRoot = container;
            console.info("[focusManager] focus root is set to [" + (container ? container.getId() : container) + "]");
        },

        /**
         * Get the current focus root.
         * @method
         * @returns {xdk-ax/Container} The current focus root
         * @memberof module:xdk-ax/focusManager
         */
        getFocusRoot: function () {
            return this._focusRoot;
        },

        /**
         * Check if the component is outside of the current focus root.
         * @method
         * @protected
         * @param {xdk-ax/Component} component A component
         * @returns {Boolean} True if the component is outside the focus root, false otherwise
         * @memberof module:xdk-ax/focusManager
         */
        _isComponentOutsideFocusRoot: function (component) {
            return this._focusRoot && !(component.isDescendantOf(this._focusRoot) || component === this._focusRoot);
        },

        /**
         * Explicitly focus a given component, if possible.
         * @param {xdk-ax/Component} component Component to focus
         * @param {Object} [options] focus options
         * @param {Boolean} [options.noActive] whether to update the focused component's activeness
         * @param {Boolean} [options.skipForwardFocus] whether to skip focus forwarding
         * @method
         * @memberof module:xdk-ax/focusManager
         * @return {Boolean} true if successfully focused a component or removed focus (if so is requested), false if otherwise
         */
        focus: function (component, options) {
            options = options || {};

            if (!component) {
                if (curFocus) {
                    onBlurAction(curFocus);
                }

                return true;
            }

            var skipForwardFocus = !!options.skipForwardFocus,
                forward = null,
                catchedFocus = curFocus,
                ret;

            // recursive logics to sort out the target component

            if (component.getOption("focusable")) {
                //checks whether a component wanna handle the focus itself
                if (util.isFunction(component.onRequestFocus)) {
                    //focus handler can return a component to forward the focus to
                    ret = component.onRequestFocus();
                }

                //If onRequestFocus return a string / abstract component, it will return the focus item
                if (util.isString(ret)) {
                    ret = component.find(ret);
                }

                if (ret instanceof Component) {
                    // found a component to restart the focus
                    return focusMgrModule.focus(ret);
                }

                // return true by onRequestFocus prevent default focus handling
                if (ret) {
                    return true;
                }
            }
            // find forward focus if it's not focusable
            else if (!skipForwardFocus) {
                forward = getForwardFocus(component);

                if (!(forward instanceof Component)) {
                    console.warn("[focusManger] no valid forward focus, abort focus process.");
                    return false;
                }

                if (forward === component) {
                    console.warn("[focusManager] forward focus is the same as the original component, abort focus process.");
                    return false;
                }

                // call focusManager.focus(forward) so that the forwarded component get chance to handle onRequestFocus()
                return focusMgrModule.focus(forward);
            }

            // at this point, target component is located

            if (this._isComponentOutsideFocusRoot(component)) {
                console.warn("[focusManager] the requested focus target [" + component.getId() + "] is out of the focus root [" + this._focusRoot.getId() + "]");
                return false;
            }

            if (!isCompFocusable(component)) {
                console.warn("Delegated component is not Focusable! Component ID: " + component.getId());
                return false;
            }

            // do actual switch focus handling, blur before focus

            // only blur if there is a current focus, and it is not the target component
            if (curFocus && !isCompFocused(component)) {
                onBlurAction(curFocus, component);
            }

            onFocusAction(component, catchedFocus, options);

            return true;
        },
        /**
         * return the current focus
         * @return {xdk-ax/Component} current focused component
         * @method
         * @memberof module:xdk-ax/focusManager
         */
        getCurFocus: function () {
            return curFocus || null;
        },
        /**
         * ** Deprecated: see directionChangeByKey instead **
         * Directionally change focus using an arrow key
         * @param {xdk-base/device/vKey} key on the direction
         * @param  {xdk-ax/Component} [container] to check the directional focus forward upto this container.(excluding the checking on this container)
         * @return {Boolean} true if directional navigation is successfully made
         * @method
         * @deprecated
         * @memberof module:xdk-ax/focusManager
         */
        directionalFocusChangeByKey: function (key, container) {
            var ret = false;
            switch (key.id) {
            case vKey.UP.id:
                ret = this.directionalFocusChange(focusMgrModule.FOCUS_UP, container);
                break;
            case vKey.DOWN.id:
                ret = this.directionalFocusChange(focusMgrModule.FOCUS_DOWN, container);
                break;
            case vKey.LEFT.id:
                ret = this.directionalFocusChange(focusMgrModule.FOCUS_LEFT, container);
                break;
            case vKey.RIGHT.id:
                ret = this.directionalFocusChange(focusMgrModule.FOCUS_RIGHT, container);
                break;
            }
            return ret;
        },

        /**
         * Directionally change focus using an arrow key
         * @param {xdk-base/device/vKey} key on the direction
         * @param  {xdk-ax/Component} [container] to check the directional focus forward upto this container.(excluding the checking on this container)
         * @return {xdk-ax/Component|Boolean} component if directional navigation is successfully made , direction key consumed.
         * true if direction key consumed but navigation not successfully made.
         * @method
         * @memberof module:xdk-ax/focusManager
         */
        directionChangeByKey: function (key, container) {
            var ret = false;
            switch (key.id) {
            case vKey.UP.id:
                ret = this.directionChange(focusMgrModule.FOCUS_UP, container);
                break;
            case vKey.DOWN.id:
                ret = this.directionChange(focusMgrModule.FOCUS_DOWN, container);
                break;
            case vKey.LEFT.id:
                ret = this.directionChange(focusMgrModule.FOCUS_LEFT, container);
                break;
            case vKey.RIGHT.id:
                ret = this.directionChange(focusMgrModule.FOCUS_RIGHT, container);
                break;
            }
            return ret;
        },
        /**
         *
         * **This function is deprecated, see directionChange ***
         * Change focus in given direction. It will check the option of that direction.
         * Firstly, it will check if the direction handling of current Element exist.
         * If it is undefined, it will check upwards along the component tree.
         *
         * When a directional focus handling option is found, it will go through the following sequence:
         *
         * *  'null' value will stop the focus direction change.
         * *  callback function will be run first and get back the return value. Boolean false return value will stop the focus direction change, other value will continued to be used for the below checking
         * *  String, the Component with this String as ID will be focused
         * *  Component, it will be focused.
         * *  Otherwise, check parent's directional focus handling option, and start over
         * @param {module:xdk-ax/focusManager.FOCUS_UP|module:xdk-ax/focusManager.FOCUS_DOWN
         * |module:xdk-ax/focusManager.FOCUS_LEFT|module:xdk-ax/focusManager.FOCUS_RIGHT}
         * direction focus direction
         * @param  {xdk-ax/Component} [container] to check the directional focus forward upto this container.
         * @return {Boolean} true if directional navigation is successfully made
         * @memberof module:xdk-ax/focusManager
         * @deprecated
         * @method
         */
        directionalFocusChange: function (direction, container) {

            var ret = this.directionChange(direction, container);

            if (ret) {
                return true;
            }

            return false;
        },

        /**
         *
         * Change focus in given direction. It will check the option of that direction.
         * Firstly, it will check if the direction handling of current Element exist.
         * If it is undefined, it will check upwards along the component tree.
         *
         * When a directional focus handling option is found, it will go through the following sequence:
         *
         * *  'null' value will stop the focus direction change.
         * *  callback function will be run first and get back the return value. Boolean false return value will stop the focus direction change, other value will continued to be used for the below checking
         * *  String, the Component with this String as ID will be focused
         * *  Component, it will be focused.
         * *  Otherwise, check parent's directional focus handling option, and start over
         * @param {module:xdk-ax/focusManager.FOCUS_UP|module:xdk-ax/focusManager.FOCUS_DOWN
         * |module:xdk-ax/focusManager.FOCUS_LEFT|module:xdk-ax/focusManager.FOCUS_RIGHT}
         * direction focus direction
         * @param  {xdk-ax/Component} [container] to check the directional focus forward upto this container.
         * @return {Component|Boolean} componenet if directional navigation is successfully made , direction key consumed.
         * true if direction key consumed but navigation not successfully made.
         * @memberof module:xdk-ax/focusManager
         * @method
         */

        directionChange: function (direction, container) {
            if (container && !this.isCompChildFocused(container)) {
                // container does not have child focused, so nothing could be done
                console.warn("Directional focus change is not possible!");
                return false;
            }

            container = container || rootController.getView();
            var toFocus, opt, component;
            if (!curFocus) {
                toFocus = getLastActiveFocus();

                if (!toFocus) {
                    return false;
                }

                if (this.focus(toFocus)) {
                    return toFocus;
                }

            }

            //Block checking predefines
            component = curFocus;
            if (direction === focusMgrModule.FOCUS_UP) {
                direction = "nextUp";
            } else if (direction === focusMgrModule.FOCUS_DOWN) {
                direction = "nextDown";
            } else if (direction === focusMgrModule.FOCUS_LEFT) {
                direction = "nextLeft";
            } else if (direction === focusMgrModule.FOCUS_RIGHT) {
                direction = "nextRight";
            }


            //check for parent's direction recursively until it's defined or
            //up to root
            while (component && component !== container) {

                if (this._isComponentOutsideFocusRoot(component)) {
                    console.warn("[focusManager] abort direction check: the parent component [" + component.getId() + "] is out of the focus root [" + this._focusRoot.getId() + "]");
                    return false;
                }

                opt = component.getOption(direction);

                /*additional checking to ensure the return value of the callback function
                 if return value is true, it will stop the recursion and won't do anything.
                 If it is false/ undefined, it will keep running the recursion to check the parent*/

                if (util.isFunction(opt)) {
                    opt = opt.call(curFocus);
                    console.debug("directional focus callback return value: " + opt);
                }

                if (opt === true) {
                    return opt;
                }

                if (opt === false || util.isUndefined(opt)) {
                    // no directional option is defined
                    component = component.getParent();
                    continue;
                }

                if (opt === null) {
                    //Explicit empty difinition found - block navigation
                    return true;
                }

                //If opt is a component ID / a abstract component, it will stop recursion
                if (util.isString(opt)) {
                    toFocus = container.find(opt);
                    if (!toFocus && container !== rootController.getView()) {
                        toFocus = rootController.getView().find(opt);
                    }
                    break;
                }
                if (opt instanceof Component) {
                    toFocus = opt;
                    break;
                }

                component = component.getParent();
            }

            if (!toFocus) {
                return false;
            }

            if (this.focus(toFocus)) {
                return toFocus;
            }

        },

        /**
         * Ensure the focus is not null
         * @memberof module:xdk-ax/focusManager
         * @method
         */
        ensureFocus: function () {
            if (curFocus) {
                return true;
            }
            if (lastFocus) {
                return this.focus(lastFocus);
            }
            return false;
        },
        /**
         * Set the flag for the use of css focus-trail
         * @method
         * @name setCompFocusTrail
         * @param {xdk-ax/Component} component to set
         * @param {Boolean} flag yes or no
         * @return {Boolean | undefined} current css focus-trail flag
         * @memberof module:xdk-ax/focusManager
         * @public
         */
        setCompFocusTrail: function (comp, flag) {
            if (util.isBoolean(flag)) {
                comp._enableTrail = flag;
            }
            return comp._enableTrail;
        },
        /**
         * Reset the flag for the use of css focus-trail
         * @method
         * @name resetCompFocusTrail
         * @param {xdk-ax/Component} component to reset
         * @return {Boolean | undefined} current css focus-trail flag
         * @memberof module:xdk-ax/focusManager
         * @public
         */
        resetCompFocusTrail: function (comp) {
            comp._enableTrail = undefined;
            return comp._enableTrail;
        },
        /**
         * Get the flag for the use of css focus-trail
         * @method
         * @name isCompFocusTrailOn
         * @param {xdk-ax/Component} component to reset
         * @return {Boolean} current css focus-trail flag
         * @memberof module:xdk-ax/focusManager
         * @protected
         */
        isCompFocusTrailOn: function (comp) {

            if (comp && util.isUndefined(comp._enableTrail)) {
                return config.get("ui.focus.enableTrail", true);
            }

            if (!comp._enableTrail) {
                return false;
            }

            return true;
        },
        getLastActiveFocus: getLastActiveFocus,
        isCompFocused: isCompFocused,
        isCompChildFocused: isCompChildFocused,
        isCompFocusable: isCompFocusable,
        getCompLastFocusedTime: getCompLastFocusedTime
    };

    return focusMgrModule;
});
/**
 * A CSS loader plugin that is responsible to load CSS files.
 * @module css
 */
define("css", [], function() {
    "use strict";
    var exports = {
            /**
             * If the plugin has a dynamic property set to true, then it means
             * the loader MUST NOT cache the value of a normalized plugin dependency,
             * instead call the plugin's load method for each instance of a plugin dependency.
             * @property {Boolean} dynamic
             * @memberof module:css
             */
            dynamic: false,

            /**
             * pluginBuilder is a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build. 
             * Without this property, the optimization WILL fail. 
             * @see {@link http://requirejs.org/docs/plugins.html#apipluginbuilder}
             * @property {String} pluginBuilder
             * @memberof module:css
             */
            pluginBuilder: "xdk-base/loader/cssBuilder"
        },
        head = document.getElementsByTagName("head")[0];

    /**
     * Load a CSS file by inserting a <link> node to the DOM head section. 
     * This will execute the onSuccess callback when the node gets loaded. 
     * If the CSS file does not have an extension (.css), one will be appended.
     * @method
     * @private
     * @param {String} cssFile The CSS file location
     * @param {Function} onSuccess The success callback
     * @memberof module:css
     */
    function loadCssFile(cssFile, onSuccess) {
        if (cssFile.indexOf(".css") === -1) {
            cssFile += ".css";
        }

        var node = document.createElement("link");
        node.type = "text/css";
        node.rel = "stylesheet";
        node.href = cssFile;

        // inject the node, then execute the callback (assume it can be loaded)
        head.appendChild(node);
        onSuccess(cssFile);
    }

    /**
     * Load a resource.  
     * Assuming the resource IDs do not need special ID normalization.
     * @method
     * @param {String} resourceId The resource ID that the plugin should load. This ID MUST be normalized.
     * @param {Function} require A local require function to use to load other modules. This require function has some utilities on it: 
     *  * require.toUrl("moduleId+extension"). See the require.toUrl API notes for more information.
     * @param {Function} load A function to call once the value of the resource ID has been determined. This tells the loader that the plugin is done loading the resource.
     * @param {Object} [config] A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. An optimization tool may set an isBuild property in the config to true if this plugin (or pluginBuilder (TODOC)) is being called as part of an optimizer build.
     * @memberof module:css
     */
    exports.load = function (resourceId, require, load) {
        // load the CSS file
        loadCssFile(require.toUrl(resourceId), function (value) {
            load(value);
        });
    };

    return exports;
});


define('css!xdk-ax/mvc/css/AppRoot',[],function(){});
/**
 * Application root controller, the root for the controller hierarchy.
 * Responsible for App level logic such as default key actions.
 *
 * This class is designed as a singleton, developer should use {@link xdk-ax/mvc/AppRoot.singleton|singleton} to obtain the instance.
 * Creating instance using the _new_ keyword is prohibited.
 *
 * @class xdk-ax/mvc/AppRoot
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-ax/mvc/AppRoot", [
    "xdk-base/class",
    "xdk-ax/mvc/Controller",
    "xdk-base/core",
    "xdk-base/Env",
    "xdk-ax/Container",
    "xdk-base/promise",
    "xdk-base/util",
    "xdk-base/device/vKey",
    "xdk-ax/evt/type",
    "xdk-ax/evt/eventManager",
    "xdk-base/device",
    "xdk-ax/mvc/ControllerManager",
    "xdk-ax/focusManager",
    "xdk-base/exception",
    "require",
    "css",
    "css!./css/AppRoot"
], function (klass,
    Controller,
    core,
    Env,
    Container,
    promise,
    util,
    vKey,
    evtType,
    evtMgr,
    device,
    ControllerManager,
    focusMgr,
    exception,
    require) {
    "use strict";
    var AppRoot,
        instance,
        sEnv = Env.singleton(),
        sCtrlMgr = ControllerManager.singleton();

    AppRoot = klass.create(Controller, {
        /**
         * Get the singleton instance of this class.
         * @method
         * @static
         * @returns {xdk-ax/mvc/AppRoot} The singleton
         * @memberOf xdk-ax/mvc/AppRoot
         */
        singleton: function () {
            if (!instance) {
                instance = new AppRoot();
            }

            return instance;
        }
    }, {
        /**
         * whether environment is loaded
         * @protected
         * @memberof xdk-ax/mvc/AppRoot#
         */
        _envLoaded: false,
        /**
         * mapping of key actions
         * @protected
         * @memberof xdk-ax/mvc/AppRoot#
         */
        _keyActions: {},
        /**
         * Overrides the init method
         * @method
         * @protected
         * @memberof xdk-ax/mvc/AppRoot#
         */
        init: function () {
            this._super();
            var self = this;
            sEnv.addEventListener(sEnv.EVT_ONLOAD, function () {

                self._onEnvLoad();

            });

        },
        /**
         * An env onload listener
         * @method
         * @protected
         * @memberof xdk-ax/mvc/AppRoot#
         */
        _onEnvLoad: function () {
            this._envLoaded = true;

            var self = this,
                view = new Container({
                    id: "#TVArea"
                }),
                resolution = device.system.getDisplayResolution(),
                defaultKeyAction;

            view.getRoot().appendTo(core.root.document.body);
            view.addClass(device.platform);

            view.addClass("_" + resolution.width + "x" + resolution.height);

            this.setView(view);

            focusMgr._setRootController(this);

            // default key behaviors
            defaultKeyAction = util.bind(function (evt) {
                var handled;

                // handle external key actions in priority
                if (this._keyActions[evt.id]) {
                    handled = this._keyActions[evt.id](evt);
                    if (handled) {
                        return;
                    }
                }

                switch (evt.id) {
                case vKey.EXIT.id:
                    device.system.exit();
                    break;
                case vKey.UP.id:
                case vKey.DOWN.id:
                case vKey.LEFT.id:
                case vKey.RIGHT.id:
                    focusMgr.directionChangeByKey(evt, this.getView());
                    break;


                case vKey.OK.id:
                    // translate enter key into click
                    if (evt.target.isClickable()) {
                        evtMgr.trigger(evtType.CLICK, evt.target);
                    }
                    break;
                default:
                    return;
                }
            }, this);
            // fire key event into MVC structure
            sEnv.addEventListener(sEnv.EVT_ONKEY, function (evt) {
                var curFocus = require("xdk-ax/focusManager").getCurFocus();

                // if not focus, at least have default action
                curFocus = curFocus || self.getView();

                evtMgr.trigger(evtType.KEY, curFocus, util.extend({
                    source: evt.source,
                    defaultAction: defaultKeyAction
                }, evt));
            });


            /**
             * @TODO loading controller stuff
             */
        },
        /**
         * Register default key action handlin. Default action will be called when
         * key events reached the AppRoot during event propagation. Each
         * key can only be registered once.
         *
         * @method
         * @public
         * @name setDefaultKeyAction
         * @param {Array} keyIds Array of vKeys to be registered. e.g. "device:vKey:back".
         * @param {Function} actionHandler Action handler to be called
         * @memberof xdk-ax/mvc/AppRoot#
         */
        setDefaultKeyAction: function (keyIds, actionHandler) {

            if (!util.isArray(keyIds)) {
                keyIds = [keyIds];
            }

            util.each(keyIds, function (key) {

                if (this._keyActions[key]) {
                    throw core.createException("KeyactionAlreadyRegisterd", "Key (" + key + ") is already set");
                }

                this._keyActions[key] = actionHandler;

            }, this);

        },
        /**
         * Sets a controller to be the main controller of the application.
         * @method
         * @public
         * @param {xdk-ax/mvc/Controller} controller The controller instance or class to use.
         * @param {Object} [options] Options for this operation.
         * @param {Object} [options.context] Context object to be passed to the new controller
         *     Refer to {@link xdk-ax/mvc/ControllerManager#replaceController} for details.
         * @return {Promise.<xdk-ax/mvc/Controller>} the controller instance
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} When the existing controller is not attached to parent
         * @memberof xdk-ax/mvc/AppRoot#
         */
        setMainController: function (controller, options) {
            if (!this._envLoaded) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, "AppRoot is waiting for environment to load, therefore it is not ready!"));
            }
            options = options || {};
            var activeChild, activeCtrl;

            activeChild = this.getView().getActiveChild();

            if (activeChild) {
                activeCtrl = activeChild.getController();
                return sCtrlMgr.replace(activeCtrl, controller, options);
            }

            // flag event on first main controller
            options.appRootFirstController = true;

            return sCtrlMgr.open(controller, this, options);
        },
        /**
         * Overrides the {@link xdk-ax/mvc/Controller#getParentController|getParentController} method
         * @return {null} returns null as this is the application root
         * @method
         * @public
         * @memberof xdk-ax/mvc/AppRoot#
         */
        getParentController: function () {
            return null;
        }
    });

    // enforce the instance creation before returning, preventing 2 instances being created
    // (2 executions may go into the creation at the same time...)
    AppRoot.singleton();

    return AppRoot;

});
/**
 * Ajax module
 * * ###Configuration Parameters
 *
 * Attribute | Value
 * --------- | ---------
 * Key       | ajax-method-override
 * Type      | Boolean
 * Desc      | There is a practice to override the existing method and convert into post method with that as parameter in _method.
 * Default   | true
 * Usage     | {@link module:xdk-base/config}
 * --------------------------
 * @module xdk-base/ajax
 */
/* jshint strict:false*/
define("xdk-base/ajax", [
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "xdk-base/config"
], function (
    core,
    util,
    promise,
    console,
    config
) {
    //util fn
    var requestRefs = {};

    //determine whether need clone the transport object since some devices will delete the transport to have a better memory control
    //and avoid multiple transport, so we have to clone the response and keep the data.
    var needCloneTransport = (function () {
        var ua = navigator.userAgent.toLowerCase();
        if (ua.indexOf("maple") !== -1 || typeof tizen !== "undefined") {
            return true;
        }
        return false;
    })();

    //determine whether support specific method
    function isMethodSupported(method) {
        //final check for different platform to avoid those unsupported request
        var agent = navigator.userAgent.toLowerCase();

        //samsung 2010 checking (user agent will container maple 5.1 )since delete is not supported.
        if (agent.indexOf("maple 5.1") !== -1 && method === "delete") {
            return false;
        }

        //sharp && huawei
        if (agent.indexOf("aquosbrowser") > -1 || agent.indexOf("ipad;") > -1) {
            if (method === "delete" || method === "put") {
                return false;
            }
        }

        return true;
    }

    //to determine whether the method is allowed to override
    function isMethodAllowed(method) {
        //to keep the backward compatible and ajax-method-override will be default as true.
        return !config.get("ajax-method-override", true) || !!~["get", "post", "delete", "put"].indexOf(method);
    }

    /**
     * Keep reference a request by id
     * @name refRequest
     * @memberof module:xdk-base/ajax
     * @private
     */

    function refRequest(requestId, request) {

        if (!requestId || !request) {
            return;
        }

        if (requestRefs[requestId]) {
            throw core.createException("Repeated id for deferred creation");
        }

        requestRefs[requestId] = request;

        return requestRefs[requestId];

    }

    /**
     * Get the reference of a request by id
     * @name refRequest
     * @memberof module:xdk-base/ajax
     * @private
     */

    function getRequest(requestId) {
        return requestRefs[requestId];
    }


    /**
     * Get the reference of a request by id
     * @name unrefRequest
     * @memberof module:xdk-base/ajax
     * @private
     */

    function unrefRequest(requestId) {
        requestRefs[requestId] = undefined;
    }


    /**
     * create the XMLHttpRequest
     * @returns {Object} A new XHR object
     * @memberof module:xdk-base/ajax
     * @method createStandardXHR
     * @private
     */

    function createStandardXHR() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    }
    /**
     * create the ActiveXObject("Msxml2.XMLHTTP")
     * @returns {Object} a new XHR Object
     * @memberof module:xdk-base/ajax
     * @method createActiveXHR
     * @private
     */

    function createActiveXHR() {
        try {
            return new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {}
    }
    /**
     * create the ActiveXObject("Microsoft.XMLHTTP")
     * @returns {Object} a new XHR Object
     * @memberof module:xdk-base/ajax
     * @method createActiveXHRMicrosoft
     * @private
     */

    function createActiveXHRMicrosoft() {
        try {
            return new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {}
    }
    /**
     * Gets a transport by trying all of the know XHR objects
     * @returns A new XHR object or false if none found
     * @memberof module:xdk-base/ajax
     * @method getTransport
     * @private
     */

    function getTransport() {
        //TODO: see if we would like to support IE XDomainRequest
        //http://msdn.microsoft.com/en-us/library/ie/cc288060(v=vs.85).aspx
        return createStandardXHR() || createActiveXHR() || createActiveXHRMicrosoft() || false;
    }


    /**
     * The internal Ajax request object used by {@link module:xdk-base/util}
     *
     * @class AjaxRequest
     * @see {@link module:xdk-base/util}
     * @memberof module:xdk-base/ajax
     * @param {String} url the URL to send request to
     * @param {Object} options the options passed in during an Aajx request
     * @private
     */

    function AjaxRequest(url, options) {

        options = options || {};

        /**
         * The native ajax transport object.
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @type {XMLHttpRequest}
         * @private
         */
        var __transport = null,

            /**
             * The native ajax transport object.
             * @memberof module:xdk-base/ajax.AjaxRequest#
             * @type {XMLHttpRequest}
             * @private
             */
            __deferred,
            /**
             * Whether this request has finished.
             * @memberof module:xdk-base/ajax.AjaxRequest#
             * @type {boolean}
             * @private
             */
            __completed = false,
            /**
             * To store the timeout when it sends out the request
             * @memberof module:xdk-base/ajax.AjaxRequest#
             * @type {Object}
             * @private
             */
            __connectionTimeout,
            /**
             * Options mapping.
             * @memberof module:xdk-base/ajax.AjaxRequest#
             * @type {Object}
             * @private
             */
            __options, __aborted = false,
            __url = url,
            params, body;



        //default is 30s
        options.timeOut = util.isNumber(options.timeOut) ? options.timeOut : 30;

        // options should be a Hash object, cast to plain object
        if (util.isFunction(options.toObject)) {
            options = options.toObject();
        }

        // Defaults
        __options = {
            method: "get",
            async: true,
            checkContentType: false,
            parameters: ""
        };



        util.extend(__options, options);


        __options.method = __options.method.toLowerCase();

        __transport = getTransport();

        //reference this request by id
        if (__options.id) {
            refRequest(__options.id, this);
        }

        //Request parameters
        params = util.isString(__options.parameters) ? __options.parameters : util.toQueryString(__options.parameters);

        //In common practice, we will override the method when it is not available/allowed. It will convert the method of ajax into post
        //and then add an extra parameter `_method`. It expects the server side will read the information and handle those requests.
        //So if any methods other than get, post, put, delete, we expect the client doesn't suppprt those methods and convert here.
        if (!isMethodAllowed(__options.method)) {
            params += (params ? "&" : "") + "_method=" + __options.method;
            __options.method = "post";
        }


        //Prepare URL for GET request
        if (params && __options.method === "get") {
            if (util.isString(params) && params.length > 0) {
                // when GET, append parameters to URL
                __url += ((__url.indexOf("?") > 0) ? "&" : "?") + params;
            }
        }

        /**
         * Internal State change callback function.
         * Dispatched ReadyState handler if needed.
         * @method __onStateChange
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @private
         */

        function __onStateChange() {
            var readyState = this.readyState;
            if (readyState > 1 && !((readyState === 4) && __completed)) {
                __respondToReadyState.apply(this);
            }
        }



        /**
         * Internal ReadyState handler.
         * Parses the response and also tries to parse the response to JSON if needed.
         * Calls state handlers from options array if such are set.
         * @method __respondToReadyState
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @private
         */

        function __respondToReadyState() {
            var readyState = this.readyState,
            data = null, 
            status, success, resp, contentType, newTransport;
            try {
                // State == 4 means DONE
                if (readyState === 4 && !__aborted) {
                    //when able to receive any data within time, clear timeout
                    if (__connectionTimeout) {
                        clearTimeout(__connectionTimeout);
                        __connectionTimeout = null;
                    }

                    __completed = true;
                    status = this.status;
                    success = true;
                    resp = this.responseText;

                    //Parse the json if response if json
                    contentType = this.getResponseHeader("content-type");

                    if (contentType && contentType.toLowerCase().indexOf("json") > -1) {
                        try {
                            this.responseJSON = util.parse(resp);
                        } catch (ex) {
                            console.info("Unable to parse JSON");
                        }
                    }

                    //clone the transport object for samsung
                    if (needCloneTransport) {
                        newTransport = {};
                        newTransport.response = this.response || "";
                        newTransport.responseText = this.responseText || "";
                        newTransport.responseType = this.responseType || "";
                        newTransport.responseJSON = this.responseJSON || "";
                        newTransport.responseXML = this.responseXML || "";
                        newTransport.readyState = this.readyState || null;
                        newTransport.status = this.status;
                        newTransport.statusText = this.statusText || "";
                        (function (allHeaders) {
                            newTransport.getAllResponseHeaders = function () {
                                return allHeaders;
                            };

                            var allHeadersObj;
                            newTransport.getResponseHeader = function (key) {
                                if (!key) {
                                    return null;
                                }

                                // only parse allheaders when needed
                                if (!allHeadersObj) {
                                    allHeadersObj = {};

                                    if (allHeaders) {
                                        util.each(allHeaders.split("\n"), function (line) {
                                            var colIdx = line.indexOf(":");

                                            if (colIdx < 0) {
                                                return;
                                            }

                                            var k = line.substr(0, colIdx).toLowerCase();

                                            allHeadersObj[k] = line.substr(colIdx + 1);
                                        });
                                    }
                                }

                                // Header keys are case-insensitive
                                key = key.toLowerCase();

                                // Return null according to standard
                                return key in allHeadersObj ? allHeadersObj[key] : null;
                            };
                        })(this.getAllResponseHeaders());
                    }

                    //status 0 means its state is in UNSENT / OPENED or ERROR flag is set
                    if (((status >= 200 && status < 300) || status === 304)) {

                        __deferred.resolve(newTransport || this);


                    } else {
                        //Unsuccessfull request
                        success = false;
                        __deferred.reject({
                            transport: newTransport || this,
                            type: "failure"
                        });

                    }

                    cleanUp();
                }

            } catch (ex) {

                __deferred.reject({
                    transport: newTransport || this,
                    ex: ex,
                    type: "exception"
                });

                cleanUp();

                console.error(ex);
            }
        }

        /**
         * Do the abort requst task
         * @name __abort
         * @method
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @private
         */

        function cleanUp() {
            // unref from promise registry
            if (__options.id) {
                unrefRequest(__options.id);
            }

            //this is for Samsung only, in official doc they say if not destroy() it"ll cause memory issue
            if (__transport.destroy) {
                __transport.destroy();
            }
            __transport.onreadystatechange = null;
            __transport = null;
            /*jshint -W051 */
            delete __transport; // this is also for Samsung, on 3.0 compatible TVs
        }

        /**
         * Do the abort requst task
         * @name doAbort
         * @method
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @private
         */

        function doAbort() {

            console.info("abort the transport");
            /* The idea is to allow user to abort the request and stop execution.*/
            //Notify this request has been aborted (will be checked against in the onSuccess)
            __aborted = true;

            try {
                __transport.abort();
            } catch (e) {
                //Abort is not supported
                __aborted = null;
            }

            if (__connectionTimeout) {
                clearTimeout(__connectionTimeout);
                __connectionTimeout = null;
            }

            cleanUp();

        }

        /**
         * The abort function for external trigger
         * @name abort
         * @method
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @private
         */

        function abort() {
            console.info("abort the transport");
            /* The idea is to allow user to abort the request and stop execution.*/
            //Notify this request has been aborted (will be checked against in the onSuccess)
            doAbort();

            __deferred.reject({
                transport: __transport,
                type: "abort"
            });
        }

        this.abort = abort;


        /**
         * Opens the transport, initialize it correctly and send the request
         * @name send
         * @method
         * @memberof module:xdk-base/ajax.AjaxRequest#
         * @private
         */

        function send() {
            var headers, name, avoid;
            //Prepare request and send it

            //to create promise
            __deferred = promise.defer();

            try {

                __transport.open(__options.method.toUpperCase(), __url, __options.async);

                //ReadyState
                __transport.onreadystatechange = __onStateChange;

                //Set request headers if needed
                avoid = false;
                headers = __options.requestHeaders || {};

                for (name in headers) {
                    console.info(name + " - " + headers[name]);
                    __transport.setRequestHeader(name, headers[name]);
                }

                /* withCredentials support on request: http://www.html5rocks.com/en/tutorials/cors/
                make sure XHR supports withCredentials, it only works with cookies */

                // only set withCredentials if it is explicitly set to true in options
                if (!!__options.withCredentials) {
                    var withCredentialsException = function () {
                        doAbort();
                        console.warn("withCredentials is not supported in this browser");
                        return promise.reject({
                            transport: __transport,
                            ex: core.createException("withCredentials is not supported in this browser"),
                            type: "exception"
                        });
                    };

                    if ("withCredentials" in __transport) {
                        try {
                            __transport.withCredentials = true;
                        } catch (ex) {
                            return withCredentialsException();
                        }
                    } else {
                        return withCredentialsException();
                    }
                }


                body = null;

                //Prepare body
                if (!util.isUndefined(__options.postBody)) {
                    body = __options.postBody;
                } else if (!util.isUndefined(params)) {
                    body = params;
                }

                avoid = !isMethodSupported(__options.method);

                if (avoid) {
                    doAbort();
                    console.info("unsupport method in this device" + __options.method);

                    return promise.reject({
                        transport: __transport,
                        ex: core.createException("unsupport method in this device"),
                        type: "exception"
                    });
                }

                //set connection timeout before send
                __connectionTimeout = setTimeout(function () {

                    doAbort();

                    //treat timeout as connection failure
                    __deferred.reject({
                        transport: __transport,
                        type: "failure"
                    });


                    cleanUp();

                    __connectionTimeout = null;

                }, __options.timeOut * 1000);

                if (body) {
                    __transport.send(body);
                } else {
                    __transport.send();
                }

                /* Force Firefox to handle ready state 4 for synchronous requests */
                /* Seems current Firefox does not have this issue, so code block removed */

            } catch (ex) {
                __deferred.reject({
                    transport: __transport,
                    ex: ex,
                    type: "exception"
                });
                console.error(ex.stack);
            }

            return __deferred.promise;
        }
        this.send = send;
    }
    return {
        /**
         *  Extends from XMLHttpRequest <http://www.w3.org/TR/XMLHttpRequest/>
         * Transport object
         * @typedef Transport
         * @memberof module:xdk-base/ajax
         * @property {Object} responseJSON Parsed JSON from repsonseText if ContentType is JSON
         */

        /**
         * Rejection object
         * @typedef Rejection
         * @memberof module:xdk-base/ajax
         * @property {module:xdk-base/ajax.Transport}  transport
         * @property {String} type either "failure", "exception" or "abort"
         * @property {Exception} [ex] the exception thrown
         */

        /**
         * Extends from {@link module:xdk-base/promise~Promise}
         * It is an extends promise to call then and done. Inside the promise on the ajax, we promise to give the success response.
         * If the request if successful, the promise is fullfilled and you will get the Transport {@link module:xdk-base/ajax.Transport}  object from fulfilled callback.
         * Other than sucessfully, failure, abort, and exception cases the ajax will go into rejected one. And the Rejection {@link module:xdk-base/ajax.Rejection} object  will be passed inside.
         * @typedef Promise
         * @property {Function} abort To abort the ajax.
         * @memberof module:xdk-base/ajax
         * @see module:xdk-base/ajax.Rejection
         * @see module:xdk-base/ajax.Transport
         * @example <caption> To handle succeed case and error case, so it is easier to handle and be more promise...</caption>
         *
         * // normally
         * ajax.request("http://accedo.tv").then(
         *     function(transport){
         *         console.log(transport.responseJSON);
         *     },
         *     function(rejection){
         *         //rejection.type may be "onFailure"/"onAbort"/"onException"
         *         console.log(rejection.type);
         *     }
         * );
         *
         **/

        /**
         * Sends an ajax request.
         *
         * Tested platform : Samsung, LG, Sharp, huawei, opera tv store
         * LG,Samsung 2011TV,Samsung 2012 TV, opera and workstation support post, get, put and delete methods
         * Samsung 2010 TV supports post,get and put methods.But method delete will crash the apps
         * Sharp and huawei supports post and get methods. Delete and put methods will automatically change into get method
         *
         * Tested platform : Samsung, LG, Sharp, huawei, opera tv store
         * LG,Samsung 2011TV,Samsung 2012 TV, opera and workstation support post, get, put and delete methods
         * Samsung 2010 TV supports post,get and put methods.But method delete will crash the apps
         * Sharp and huawei supports post and get methods. Delete and put methods will automatically change into get method
         *
         * @method request
         * @param {String} url The URL to send request to.
         * @param {Object} [options] Object to be set by using the different attributes
         * @param {String} [options.method]  the HTTP request method, i.e. "get" "post", use lower case only! Defaults to "get".
         * @param {String} [options.async] whether the request to send is asynchronous or not. Defaults to be true.
         * @param {Object} [options.requestHeaders]  the header settings, should be contained in an Javascript plain object.e.g content tpye. But some devices may not support.
         * e.g WD Liverpool is unable to set "Content-Type".
         * @param {String} [options.postBody] the post body for the "post" and "put" reqeust.
         * @param {Number} [options.timeOut] request timeout interval(in sec), defaults to 30 seconds.
         * @param {Number|String} [options.id] provide request id for ajax.abort usage.
         * @param {Boolean} [options.withCredentials] enable the withCredentials for the request. It needs to work with exist value in document.cookies
         * @param {String | Object} [options.parameters] the request parameters. Note that it would be set as postBody when doing "post" or "put" request.
         * In case to add querystring in "post" or "put", you should append to url instead
         * @returns {Promise.<Object>} the native transport object. The actual object may differ from platforms
         * @throws {Promise.<Object>} an error object that consists of the native transport object and the failure type
         * @memberof module:xdk-base/ajax
         * @public
         * @example <caption> POST request and send as form data</caption>
         *
         * ajax.request("http://analytics.appledaily.com.hk/smarttv/m.php", {
         *      method: "post",
         *      requestHeaders: {
         *           "Content-Type" : "application/json;charset=UTF-8"
         *      },
         *      parameters:{
         *          type:"pageview",
         *          pageview:"/article/2"
         * }}).then(function(transport) {
         *      console.log (transport.responseJSON);
         * }, function(rejection) {
         *      if (rejection.type == "failure") {
         *          //dosomething
         *      }
         * });
         *
         */
        request: function (url, options) {
            var request = new AjaxRequest(url, options);
            //Manage the transport and send the request
            return request.send();
        },
        /**
         * Abort an ajax request.
         * @method abort
         * @param {Number|String} requestId The request id to abort
         * @memberof module:xdk-base/ajax
         * @public
         * @example
         * var requestId = core.getGuid();
         *
         * ajax.request("http://analytics.appledaily.com.hk/smarttv/m.php", {
         *      id: requestId
         * }});
         *
         * //abort a request
         * ajax.abort(requestId);
         *
         */
        abort: function (requestId) {

            var request = getRequest(requestId);

            if (request) {
                request.abort();
            }
        }

    };


});
/* jshint strict:true */
;
/**
 * AX - The short hand module for XDK core package. To avoid too much ceremony
 * using AMD.
 * @module xdk-base/ax
 */
define("xdk-base/ax", ["xdk-base/core", "xdk-base/Element", "xdk-base/class", "xdk-base/config", "xdk-base/device", "xdk-base/Env", "xdk-base/util", "xdk-base/console", "xdk-base/ajax", "xdk-base/promise"], function (core, Element, klass, config, device, Env, util, console, ajax, promise) {
    "use strict";
    /**
     * exports ax/ax
     */
    var ax = {},
        sEnv = Env.singleton();


    /**
     * @var {module} core
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/core
     */
    ax.core = core;

    /**
     * @var {Class} Element
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/Element
     */
    ax.Element = Element;

    /**
     * @var {module} klass
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/class
     */
    ax.klass = klass;

    /**
     * @var {module} config
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/config
     */
    ax.config = config;
    /**
     * @var {module} sEnv
     * @memberOf module:xdk-base/ax
     * @see ax/Env
     */
    ax.sEnv = sEnv;

    /**
     * @var {module} util
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/util
     */
    ax.util = util;

    /**
     * @var {module} ajax
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/ajax
     */
    ax.ajax = ajax;

    /**
     * @var {module} promise
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/promise
     */
    ax.promise = promise;

    /**
     * @var {module} console
     * @memberOf module:xdk-base/ax
     * @see module:xdk-base/console
     */
    ax.console = console;
    //add into ax by sEnv EVT_ONLOAD since the device is not ready and not loaded yet, so the platform info will only be known when it is ready
    sEnv.addEventListener(sEnv.EVT_ONLOAD, function () {
        /**
         * @var {module} platform
         * @memberOf module:xdk-base/ax
         * @see module:xdk-base/device
         */
        ax.platform = device.platform;

        /**
         * @var {module} vKey
         * @memberOf module:xdk-base/ax
         * @see module:xdk-base/device/vKey
         */
        ax.vKey = device.vKey;

        /**
         * @var {module} id
         * @memberOf module:xdk-base/ax
         * @see module:xdk-base/device/AbstractId
         */
        ax.id = device.id;

        /**
         * @var {module} system
         * @memberOf module:xdk-base/ax
         * @see module:xdk-base/device/AbstractSystem
         */
        ax.system = device.system;

        /**
         * @var {module} storage
         * @memberOf module:xdk-base/ax
         * @see module:xdk-base/device/AbstractStroage
         */
        ax.storage = device.storage;

        /**
         * @var {ax/device/Media} media
         * @memberOf module:xdk-base/ax
         */
        ax.media = device.media;
    });

    return ax;
});
/**
 * Mediator allows communication between different components within the application through channel subscription.  
 * @module xdk-ax/mediator
 * @since 2.1
 * @author Thomas Lee <thomas.lee@accedo.tv>
 * @example
 *  // Subscribe the channel and console log when receive the message in the channel "hi"
 *  var handler = function(i) {
 *      console.log('hey ' + i)
 *  };
 *
 *  mediator.subscribe('hi', handler);
 *
 *  // publish the message "bob" on the channel "hi" and those handler will receive the message including the above subscriber
 *  mediator.publish('hi', 'bob');
 *
 *  //remove the handler and then above handler won't receive any events.
 *  mediator.unsubscribe('hi', handler);
 */
define("xdk-ax/mediator", ["xdk-base/EventDispatcher", "xdk-base/util"], function(EventDispatcher, util) {
    "use strict";
    var mediator = new EventDispatcher();
    return {
        /**
         * Publish the message via the channel
         * @method publish
         * @param {String} type event type to dispatch
         * @param {Object} data the event data object
         * @return {Boolean} result dispatch success for true
         * @memberof module:xdk-ax/mediator
         * @public
         */
        publish: function (type, data) {
            //all errors should be handled gracefully in mediator
            mediator.dispatchEvent.apply(mediator, [type, data, true]);
        },
        /**
         * Subscribe the message via the channel
         * @method subscribe
         * @param {String} type event type
         * @param {Function} handler event listener function
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @memberof module:xdk-ax/mediator
         * @public
         */
        subscribe: util.bind(mediator.addEventListener, mediator),

        /**
         * Unsubscribe the channel
         * @method unsubscribe
         * @param {String} type Event type
         * @param {Function} handler event listener function.  If not provided, all listeners will be removed for the specific type.
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @memberof module:xdk-ax/mediator
         * @public
         */
        unsubscribe: util.bind(mediator.removeEventListener, mediator)
    };
});

/**
 * Error handling for TVE Blocks
 * @name TVEError
 * @memberof tve
 * @class tve/TVEError
 * @example
 *      new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.NOT_FOUND, 'a custom error message');
 * @augments Error
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/TVEError", ["xdk-base/class"], function(klass) {

    var TVEError = klass.create(Error, {
            /**
             * Available facility codes of TVE Error
             * @name FACILITY
             * @type {object}
             * @public
             * @memberof tve/TVEError
             * @static
             */
            FACILITY: {

                /**
                 * Configuration service
                 * @name CONFIGURATION_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                CONFIGURATION_SERVICE: 11,

                /**
                 * User settings service
                 * @name USER_SETTINGS_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                USER_SETTINGS_SERVICE: 12,

                /**
                 * Analytics service
                 * @name ANALYTICS_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                ANALYTICS_SERVICE: 13,

                /**
                 * Status service
                 * @name STATUS_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                STATUS_SERVICE: 14,

                /**
                 * Resource service
                 * @name RESOURCE_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                RESOURCE_SERVICE: 15,

                /**
                 * Log service
                 * @name LOG_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                LOG_SERVICE: 16,

                /**
                 * Ad Mediate
                 * @name AD_MEDIATE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                AD_MEDIATE: 21,

                /**
                 * Playback service
                 * @name PLAYBACK_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                PLAYBACK_SERVICE: 22,

                /**
                 * VOD content service
                 * @name VOD_CONTENT_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                VOD_CONTENT_SERVICE: 40,

                /**
                 * Linear content service
                 * @name LINEAR_CONTENT_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                LINEAR_CONTENT_SERVICE: 41,

                /**
                 * Authentication service
                 * @name AUTHENTICATION_SERVICE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                AUTHENTICATION_SERVICE: 43,

                /**
                 * Linear manager
                 * @name LINEAR_MANAGER
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                LINEAR_MANAGER: 50,

                /**
                 * VOD manager
                 * @name VOD_MANAGER
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                VOD_MANAGER: 51,

                /**
                 * Navigation manager
                 * @name NAVIGATION_MANAGER
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                NAVIGATION_MANAGER: 52,

                /**
                 * General
                 * @name GENERAL
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.FACILITY
                 * @static
                 */
                GENERAL: 90
            },

            /**
             * Available error codes of TVE Error
             * @name ERROR
             * @type {object}
             * @public
             * @memberof tve/TVEError
             * @static
             */
            ERROR: {

                /**
                 * Requested item has not been found
                 * @name NOT_FOUND
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.ERROR
                 * @static
                 */
                NOT_FOUND: 1,

                /**
                 * Network problem during communication
                 * @name NETWORK
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.ERROR
                 * @static
                 */
                NETWORK: 2,

                /**
                 * Internal error occurred
                 * @name INTERNAL
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.ERROR
                 * @static
                 */
                INTERNAL: 3,

                /**
                 * Unauthorized to access the requested resource
                 * @name UNAUTHORIZED
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.ERROR
                 * @static
                 */
                UNAUTHORIZED: 4,

                /**
                 * Error while parsing response
                 * @name INVALID
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.ERROR
                 * @static
                 */
                INVALID: 5,

                /**
                 * Storing resource failed
                 * @name STORAGE
                 * @type {Number}
                 * @public
                 * @memberof tve/TVEError.ERROR
                 * @static
                 */
                STORAGE: 6
            }
        },

        {
            /**
             * Init the TVEError moudle
             * @method init
             * @param {Number} facility 2 digital numbers, the facility of the error
             * @param {Number} errorCode 3 digital numbers, the error code of the error
             * @param {String} message the error message of the error, this parameter will be a public memeber
             * @param {String|Number|Boolean|Object} cause (optional) the error cause of the error
             * @memberof tve/TVEError
             * @private
             */
            init: function(facility, errorCode, message, cause) {
                this.__facility = facility;
                this.__errorCode = errorCode;
                this.__cause = cause || null;
                this.__code = this.__facility * 1000 + this.__errorCode;

                //message and name are public memebers
                this.message = message;
                this.name = this.__code.toString();
            },

            /**
             * Get the facility of the error object.
             * @method getCode
             * @return {Number} 2 digital numbers
             * @memberof tve/TVEError
             * @public
             */
            getFacility: function() {
                return this.__facility;
            },

            /**
             * Get the error code of the error object.
             * @method getCode
             * @return {Number} 1-3 digital numbers
             * @memberof tve/TVEError
             * @public
             */
            getErrorCode: function() {
                return this.__errorCode;
            },

            /**
             * Get the combined code (facility and error code) of the error object.
             * @method getCode
             * @return {Number} 5 digital numbers
             * @memberof tve/TVEError
             * @public
             */
            getCode: function() {
                return this.__code;
            },

            /**
             * Get the error message of the error object.
             * @method getMessage
             * @return {String} the error message
             * @memberof tve/TVEError
             * @public
             */
            getMessage: function() {
                return this.message;
            },

            /**
             * Get the error cause of the error object.
             * @method getCause
             * @return {Object} the error cause
             * @memberof tve/TVEError
             * @public
             */
            getCause: function() {
                return this.__cause;
            }
        });

    return TVEError;
});

define('css!xdk-ui-basic/css/Layout',[],function(){});
define("xdk-ui-basic/Layout", [
    "xdk-base/class",
    "xdk-ax/Container",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "css!./css/Layout"
], function (
    klass,
    Container,
    focusMgr,
    evtType,
    vKey,
    util
) {
    "use strict";

    return klass.create(Container, {
                VERTICAL: 0x01,
                HORIZONTAL: 0x02
    }, {
                _rows: [],
                init: function (opts) {
            //default autoNavigation will be true
            if (!util.isBoolean(opts.autoNavigation)) {
                opts.autoNavigation = true;
            }

            //Set default alignment
            if (!opts.alignment) {
                opts.alignment = this.constructor.HORIZONTAL;
            }

            if (util.isUndefined(opts.width)) {
                opts.width = opts.children ? opts.children.length : 10;
            }

            this._super(opts);

            this._root.addClass("wgt-layout");
            if (opts.alignment === this.constructor.HORIZONTAL) {
                this._root.addClass("align-h");
            } else {
                this._root.addClass("align-v");
            }
        },
                postInit: function () {
            this._super();

            if (this._opts.autoNavigation) {
                this.addEventListener(evtType.KEY, this._keyHandler);
            }
        },
                __redraw: function () {
            var curCol, curRow, i, children, width, targetPrevMarker;

            children = this._children;
            width = this._opts.width;

            this._rows.length = 0;

            //remove from dom and update the css
            this.getRoot().removeAll();
            this.__refresh();

            //to redraw everythings since the dom and css order are changed
            for (i = 0; i < children.length; i++) {
                curCol = Math.floor(i / width);
                curRow = i % width;

                if (curCol > 0) {
                    targetPrevMarker = this._rows[curRow][curCol - 1];
                    this._root.insertAfter(targetPrevMarker.getRoot(), children[i].getRoot());
                } else {
                    this._root.append(children[i].getRoot());
                }
            }
        },
                __refresh: function (index) {

            //if undefined, refresh all of them
            if (util.isUndefined(index)) {
                index = 0;
            }

            var curRow, curCol, child, i,
                width = this._opts.width,
                align = this._opts.alignment,
                children = this._children.slice(0);



            for (i = index; i < children.length; i++) {

                child = children[i];

                if (align === this.constructor.HORIZONTAL) {
                    curRow = Math.floor(i / width);
                    curCol = i % width;
                } else {
                    curCol = Math.floor(i / width);
                    curRow = i % width;
                }

                this.__updateChild(child, curRow, curCol);
            }

        },
                __updateChild: function (child, curRow, curCol) {
            var rowEnd;

            if (this._opts.alignment === this.constructor.HORIZONTAL) {
                rowEnd = this._opts.width - 1;
            } else {
                //if next col has no stuff.then rowEnd will be itself
                if ((curCol + 1) * this._opts.width + curRow >= this._children.length) {
                    rowEnd = curCol;
                } else {
                    rowEnd = Math.floor((this._children.length - 1) / this._opts.width);
                }

            }
            //clear previous css class
            child.removeClass("row-begin");
            child.removeClass("row-end");

            if (!this._rows[curRow]) {
                this._rows[curRow] = [];
            }

            //update the ref to the row
            this._rows[curRow][curCol] = child;

            //it is unable to update the style by css, so use inner in the 2011 and 2010 samsung tv
            child.getRoot().css({
                "float": "left"
            });
            child.getRoot().css({
                "clear": "none"
            });

            if (curCol === 0) {
                child.addClass("row-begin");
                child.getRoot().css({
                    "clear": "left"
                });
            }
            if (curCol === rowEnd) {
                child.addClass("row-end");
            }

            return child;
        },
                        _doAttach: function (child, placement, marker) {

            var targetPrevMarker, index, curCol, curRow, parentNode, nextSibling, children,
                width = this._opts.width,
                align = this._opts.alignment;

            //search for the position
            index = util.indexOf(this._children, child);

            //get the current position in the map
            if (align === this.constructor.HORIZONTAL) {
                curRow = Math.floor(index / width);
                curCol = index % width;
            } else {
                curCol = Math.floor(index / width);
                curRow = index % width;
            }

            //update the map and css
            this.__updateChild(child, curRow, curCol);

            children = this._children;

            //detach all the layout since it involves the change in dom or css
            //the purpose is to render once instead of rendering many times
            if (this.getRoot().isInDOMTree()) {
                nextSibling = this.getRoot().getHTMLElement().nextSibling;
                parentNode = this.getRoot().getParent();
                parentNode.removeChild(this.getRoot());
            }

            //attach the new item for the new child

            //for horizontal, the order of children in layout is same as dom
            if (align === this.constructor.HORIZONTAL) {

                switch (placement) {
                case Container.PLACE_APPEND:
                    this._root.append(child.getRoot());
                    break;
                case Container.PLACE_PREPEND:
                    this._root.prepend(child.getRoot());
                    break;
                case Container.PLACE_BEFORE:
                    this._root.insertBefore(marker.getRoot(), child.getRoot());
                    break;
                case Container.PLACE_AFTER:
                    this._root.insertAfter(marker.getRoot(), child.getRoot());
                    break;
                }

                //refresh the other layout children css start from the current index + 1
                if (index + 1 < children.length) {
                    this.__refresh(index + 1);
                }

            } else {

                //special dom handling

                //refresh the css start from 0 since whenever there are change. The css will be changed.
                this.__refresh();

                //for vertical alignment, need to change the dom order accroding to the index
                if (placement === Container.PLACE_APPEND) {

                    if (curCol > 0) {
                        //append the col next to the previous col
                        targetPrevMarker = this._rows[curRow][curCol - 1];
                        this._root.insertAfter(targetPrevMarker.getRoot(), child.getRoot());
                    } else {
                        //append the first col items
                        this._root.append(child.getRoot());
                    }

                } else {
                    //other cases, redraw everything since the dom and css order are changed.
                    this.__redraw();
                }

            }

            //attach the layout back to the DOM
            if (parentNode) {

                if (nextSibling) {
                    parentNode.insertBefore(nextSibling, this.getRoot());
                } else {
                    parentNode.append(this.getRoot());
                }

            }

        },
                detach: function (child) {
            if (!child) {
                //if no child provided, it will remove itself via component detach function
                return this._super();
            }

            var index = util.indexOf(this._children, child),
                ret = this._super(child),
                parentNode, prevSibling;

            //for horizontal, just update the css
            if (this._opts.alignment === this.constructor.HORIZONTAL) {
                this.__refresh(index);
                //remove the last map since a child is removed
                this._rows[this._rows.length - 1].splice([this._rows[this._rows.length - 1].length - 1], 1);
                if (this._rows[this._rows.length - 1].length === 0) {
                    //remove the last row array when it is empty
                    this._rows.splice(this._rows.length - 1, 1);
                }
                return ret;
            }

            //detach all the layout since it involves the change in dom or css
            //the purpose is to render once instead of render many times
            if (this.getRoot().isInDOMTree()) {
                prevSibling = this.getRoot().getHTMLElement().previousSibling;
                parentNode = this.getRoot().getParent();
                parentNode.removeChild(this.getRoot());
            }

            //for vertical, need to redraw everything, so remove all and update the css
            this.__redraw();

            //attach back to the DOM
            if (parentNode) {

                if (prevSibling) {
                    parentNode.insertAfter(prevSibling, this.getRoot());
                } else {
                    parentNode.append(this.getRoot());
                }

            }

            return ret;
        },
                getAlignment: function () {
            return this._opts.alignment;
        },
                _keyHandler: function (evt) {
            if (!(this._opts.autoNavigation)) {
                return;
            }

            var focusRet, evtKey = evt.id,
                curFocus, parent, child, curIdx, width = this._opts.width,
                align = this._opts.alignment,
                curRow, curCol;

            switch (evtKey) {
            case vKey.UP.id:
            case vKey.DOWN.id:
            case vKey.LEFT.id:
            case vKey.RIGHT.id:
                focusRet = focusMgr.directionChangeByKey(evt, this);
                break;
            default:
                return;

            }

            if (focusRet) {
                return false;
            }

            curFocus = focusMgr.getCurFocus();
            child = curFocus;
            parent = child.getParent();
            while (parent && parent !== this) {
                child = parent;
                parent = child.getParent();
            }

            if (!parent) {
                return;
            }

            curIdx = util.indexOf(this._children, child);

            while (curIdx >= 0) {

                if (align === this.constructor.HORIZONTAL) {
                    curRow = Math.floor(curIdx / width);
                    curCol = curIdx % width;
                } else {
                    curCol = Math.floor(curIdx / width);
                    curRow = curIdx % width;
                }

                switch (evt.id) {
                case vKey.UP.id:
                    curRow--;
                    break;
                case vKey.DOWN.id:
                    curRow++;
                    break;
                case vKey.LEFT.id:
                    curCol--;
                    break;
                case vKey.RIGHT.id:
                    curCol++;
                    break;
                }


                if (this._opts.connectRows) {
                    if (align === this.constructor.HORIZONTAL && (curCol >= width || curCol < 0)) {
                        curRow += Math.floor(curCol / width);
                        curCol = ((curCol % width) + width) % width;
                    } else if (curRow >= width || curRow < 0) {
                        curCol += Math.floor(curRow / width);
                        curRow = ((curRow % width) + width) % width;
                    }
                }

                if (this._rows[curRow] && this._rows[curRow][curCol]) {

                    //consumed the event
                    if (focusMgr.focus(this._rows[curRow][curCol])) {
                        return false;
                    }

                    //skip when focus failed
                    curIdx = util.indexOf(this._children, this._rows[curRow][curCol]);
                } else {
                    return;
                }
            }
        }
    });
});
define("xdk-ui-basic/Label", [
    "xdk-base/class",
    "xdk-ax/Component",
    "xdk-base/Element",
    "xdk-base/util",
    "xdk-ax/mvc/ModelRef",
    "xdk-base/console"
], function (
    klass,
    Component,
    Element,
    util,
    ModelRef,
    console
) {
    "use strict";

    return klass.create(Component, {}, {
                _lastModelRef: null,
                _modelListener: null,
                init: function (opts) {
            opts.text = opts.text || "";

            opts.root = new Element("div");
            opts.root.addClass("wgt-label");

            this._super(opts);

            this.setText(opts.text, !!opts.isPureText);
        },
                deinit: function () {
            // remove listener from last model reference
            if (this._lastModelRef && this._modelListener) {
                this._lastModelRef.getModel().off("change:" + this._lastModelRef.getAttr(), this._modelListener);
                this._lastModelRef = null;
            }
            this._modelListener = null;

            this._super();
        },
                _isPureText: false,
                setText: function (text, isPureText) {
            // remove listener from last model reference
            if (this._lastModelRef && this._modelListener) {
                this._lastModelRef.getModel().off("change:" + this._lastModelRef.getAttr(), this._modelListener);
                this._lastModelRef = null;
            }

            isPureText = !!isPureText;
            this._isPureText = isPureText;
            var setTextFn = util.bind(function (text) {
                if (this._isPureText) {
                    this.getRoot().setInnerText(text);
                } else {
                    this.getRoot().setInnerHTML(text);
                }
            }, this);

            if (text instanceof ModelRef) {
                if (!this._modelListener) {
                    this._modelListener = util.bind(function (labelId, evt) {
                        var newValue = evt.newVal;

                        if (newValue === undefined || newValue === null) {
                            console.warn("[Label] Text" + (labelId ? " of label " + labelId : "") + " binded to the model value is changing to an undesired data type/value: " + newValue);
                            newValue = "";
                        }

                        setTextFn(newValue);
                    }, null, this.getOption("id", undefined));
                }
                text.getModel().on("change:" + text.getAttr(), this._modelListener);

                // save the model object
                this._lastModelRef = text;

                text = text.getVal();
            }
            setTextFn(text);
        },
                getText: function () {
            if (this._isPureText) {
                return this.getRoot().getInnerText();
            }
            return this.getRoot().getInnerHTML();
        }
    });
});

define('css!xdk-ui-basic/css/Button',[],function(){});
define("xdk-ui-basic/Button", ["xdk-base/class", "xdk-ax/Container", "xdk-ui-basic/Label", "xdk-base/Element", "css!./css/Button"], function (klass, Container, Label, Element) {
    "use strict";
	return klass.create(Container, {}, {
				_label: null,
				init: function (opts) {

			opts.focusable = true;
			opts.clickable = true;
			opts.text = opts.text || "";
			opts.root = opts.root || new Element("div");

			this._super(opts);

			this.getRoot().addClass("wgt-button");

			this._label = new Label({
				text: opts.text,
				isPureText: !! opts.isPureText,
				parent: this
			});
		},
				setText: function (text, isPureText) {
			this._label.setText(text || "", !! isPureText);
		},
				getText: function () {
			return this._label.getText();
		}
	});
});

define('css!xdk-ui-basic/css/Dialog',[],function(){});
define("xdk-ui-basic/Dialog", [
	"xdk-base/class",
	"xdk-ax/Container",
	"xdk-ax/focusManager",
	"xdk-ui-basic/Layout",
	"xdk-ui-basic/Button",
	"xdk-ui-basic/Label",
	"xdk-base/util",
	"xdk-ax/evt/type",
	"xdk-base/console",
	"xdk-base/device/vKey",
	"require",
	"css!./css/Dialog"
], function (
	klass,
	Container,
	fm,
	Layout,
	Button,
	Label,
	util,
	evtType,
	console,
	vKey,
	require) {
	"use strict";
	return klass.create(Container, {}, {
				_headerComp: null,
				_contentComp: null,
				_footerComp: null,
				_overlay: null,
				_view: null,
				_container: null,
				_isOpen: false,
				_buttons: null,
				_lastFocus: null,
				init: function (opts) {
			opts = opts || {};

			opts.focusable = false;

			if (util.isUndefined(opts.forwardFocus)) {
				opts.forwardFocus = true;
			}

			opts.dialogCss = opts.dialogCss || "";
			this._super(opts);
			this._root.addClass("wgt-dialog");


			if (opts.modal !== false) {
				this._root.addClass("wgt-dialog-modal");
				this._overlay = new Container({
					parent: this,
					css: "wgt-dialog-overlay"
				});
			}

			if (opts.horizontalFooter !== false) {
				opts.horizontalFooter = true;
			}

			this._headerComp = new Container({
				css: "wgt-dialog-header",
				nextDown: util.bind(function () {
					return this._contentComp;
				}, this)
			});
			this._contentComp = new Container({
				css: "wgt-dialog-content",
				nextUp: util.bind(function () {
					return this._headerComp;
				}, this),
				nextDown: util.bind(function () {
					return this._footerComp;
				}, this)
			});
			this._footerComp = new Container({
				css: "wgt-dialog-footer",
				nextUp: util.bind(function () {
					return this._contentComp;
				}, this)
			});
			this._container = new Container({
				type: Container,
				parent: this,
				css: "wgt-dialog-container " + opts.dialogCss,
				children: [this._headerComp, this._contentComp, this._footerComp]
			});


			var self = this,
				header = opts.header,
				content = opts.content,
				footer = opts.footer,
				buttons, button;

			// build header
			if (util.isString(opts.title)) {
				header = new Label({
					text: opts.title,
					isPureText: opts.isPureText
				});
			}

			if (header) {
				this._headerComp.attach(header);
			}

			//  build content
			if (util.isString(content)) {
				content = new Label({
					text: opts.content,
					isPureText: opts.isPureText
				});
			}
			if (content) {
				this._contentComp.attach(content);
				this._contentComp.setOption("forwardFocus", content);
				this.setOption("forwardFocus", this._contentComp);
			} else {
				console.info("Dialog widget: content is set to empty!");
			}

			// build footer
			if (opts.closeText) {
				opts.buttons = opts.buttons || [];
				opts.buttons.push({
					text: opts.closeText,
					click: function () {
						this.close();
					}
				});
			}
			if (!footer && opts.buttons && opts.buttons.length) {
				buttons = [];
				util.each(opts.buttons, function (buttonOpt) {
					button = new Button({
						text: buttonOpt.text,
						isPureText: opts.isPureText
					});
					button.addEventListener(evtType.CLICK, util.bind(buttonOpt.click, self));
					buttons.push(button);
				});

				footer = new Layout({
					alignment: opts.horizontalFooter ? Layout.HORIZONTAL : Layout.VERTICAL,
					fowardFocus: true,
					children: buttons
				});

				footer.setOption("forwardFocus", buttons[0]);

				this._buttons = buttons;
			}
			if (footer) {
				this._footerComp.attach(footer);
				this._footerComp.setOption("forwardFocus", footer);
				this.setOption("forwardFocus", this._footerComp); // favor focus on footer than content
			}

			if (opts.autoOpen !== false) {
				this.open();
			}

			this.addEventListener(evtType.KEY, this._keyHandler);
		},
				attachToHeader: function (child, placement, marker) {
			this._headerComp.attach(child, placement, marker);
		},
				attachToContent: function (child, placement, marker) {
			this._contentComp.attach(child, placement, marker);
		},
				attachToFooter: function (child, placement, marker) {
			this._footerComp.attach(child, placement, marker);
		},
				open: function () {
			var parent = this._opts.parent;
			parent = parent || (this.getRootController() || require("xdk-ax/mvc/AppRoot").singleton()).getView();
			parent.attach(this);

			this._isOpen = true;

			this.dispatchEvent(evtType.OPEN);
			if (this._buttons && this._buttons.length) {
				this._lastFocus = fm.getCurFocus();
				fm.focus(this);
			} else {
				this.setActive();
			}
		},
				close: function () {
			this.detach();
			this._isOpen = false;
			this.dispatchEvent(evtType.CLOSE);
			if (this._lastFocus) {
				fm.focus(this._lastFocus);
				this._lastFocus = null;
			}
		},
				_keyHandler: function (evt) {
			if (this._opts.closeOnBack === false) {
				return true;
			}

			var focusRet, evtKey = evt.id;

			switch (evtKey) {
			case vKey.UP.id:
			case vKey.DOWN.id:
			case vKey.LEFT.id:
			case vKey.RIGHT.id:
				focusRet = fm.directionalFocusChangeByKey(evt, this);
				return false;
			case vKey.BACK.id:
				this.close();
				return false;
			default:
				return;
			}
		}

	});
});
/**
 * Dialog class inherited from "xdk-ui-basic/Dialog"
 * Fixes:
 *  - check that the dialog is not already closed before closing it
 *  - do not consume the back key event if the dialog was already closed when receiving it
 */
define("fix/Dialog", [
    "xdk-base/class",
    "xdk-ui-basic/Dialog",
    "xdk-base/device",
    "xdk-base/device/vKey",
    "xdk-base/console",
    "xdk-base/util",
    "xdk-base/core",
    "xdk-base/config",
    "xdk-ax/focusManager"
], function (
    klass,
    Dialog,
    device,
    vKey,
    console,
    util,
    core,
    config,
    focusManager) {
    var lastFocus = [];
    return klass.create(Dialog, {}, {

        init: function (opts) {
            lastFocus.push(focusManager.getCurFocus());
            console.warn("Using custom Dialog component, careful if the original one gets updated!");
            this._super(opts);
            var tEnable = (device.platform === "samsung") || (device.platform === "workstation");
            this._timerEnabled = tEnable ? true : false;
        },

        _keyHandler: function (evt) {
            if (this._opts.closeOnBack === false) {
                return true;
            }
            if (evt.id === vKey.BACK.id || evt.id === vKey.EXIT.id) {
                // if the dialog is already closed, we don't prevent the event from bubbling up
                if (!this._isOpen) {
                    return true;
                }
                this.close();
                return false;
            }

            return this._super(evt);
        },

        _initAutoCloseTimer: function (timeLimit) {
            if (this._timerEnabled && timeLimit > 0) {
                this._timerId = "dialogTimer-"+core.getGuid();
                util.delay(timeLimit, this._timerId)
                .then(util.bind(function() {
                    this._clearAutoCloseTimer();
                    this.close();
                }, this));
            }
        },

        _clearAutoCloseTimer: function () {
            if (this._timerEnabled && this._timerId) {
                util.clearDelay(this._timerId);
                this._timerId = null;
            }
        },
        
        close: function () {
            if (!this._isOpen) {
                return;
            }
            this._clearAutoCloseTimer();
            focusManager.focus(lastFocus.pop());
            this._super();
        }
    });
});
/**
 * AlertDialog is a dialog that informs the user with some important messages.
 * There are several customization points that the developer can configure:
 *  - title: the text shown as the dialog title
 *  - message: the text shown in the dialog content area as a main message
 *  - buttonText: the text shown on the button
 *
 * @name AlertDialog
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/AlertDialog
 */
define("tvedemo/wgt/AlertDialog", [
    "xdk-base/class",
    "fix/Dialog",
    "xdk-base/util",
    "xdk-ax/Container",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Label",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/config"
], function (
    klass,
    Dialog,
    util,
    Container,
    evtType,
    Button,
    Label,
    focusManager,
    vKey,
    config) {

    var dialogTimeLimit = 0;

    return klass.create(Dialog, {}, {

        init: function (opts) {
            opts = opts || {};

            opts.title = opts.title || "Attention";

            var button = new Button({
                css: "wgt-alertdialog-button",
                text: opts.buttonText || "OK"
            });

            opts.content = new Container({
                forwardFocus: button,
                children: [
                    new Label({
                        css: "wgt-dialog-message",
                        text: opts.message
                    }),
                    button
                ]
            });


            opts.forwardFocus = button;


            this._super(opts);
            this.addClass("wgt-alertdialog");

            button.addEventListener(evtType.CLICK, util.bind(this.close, this));

            dialogTimeLimit = config.get("dialogTimeLimit", null).alert;
            this._initAutoCloseTimer(dialogTimeLimit);
        },

        _keyHandler: function (evt) {
            // reset timer on user interaction, except close Popup actions.
            if (evt.id !== vKey.BACK.id && evt.id !== vKey.OK.id) {
                this._clearAutoCloseTimer();
                this._initAutoCloseTimer(dialogTimeLimit);
            }
            
            this._super(evt);
        },

        open: function () {
            this._super();

            // remember the last focus, that can be resumed after the dialog is closed
            this._lastFocus = focusManager.getCurFocus();

            //to ensure the focus is button instead of footer (which is overwrite in the dialog widget)
            this.setOption("forwardFocus", this.getOption("content"));
            //to ensure open has focus on the alert dialog
            focusManager.focus(this);

        },

        close: function () {
            focusManager.focus(this._lastFocus);

            this._super();
            this.deinit();
        }
    });
});
/**
 * ConfirmDialog is a dialog that gives the user 2 options to choose from, either positive or negative.
 * There are several customization points that the developer can configure:
 *  - title: the text shown as the dialog title
 *  - message: the text (usually a question) shown in the dialog content area as a main message
 *  - positiveText: the text shown on the positive button
 *  - negativeText: the text shown on the negative button
 *  - defaultOption: the default option among the 2 options (ConfirmDialog.POSITIVE/ConfirmDialog.NEGATIVE). The corresponding button will be focused after initiation.
 *  - positiveAction: the callback function for the positive button click
 *  - negativeAction: the callback function for the negative button click
 *
 * @name ConfirmDialog
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/ConfirmDialog
 */
define("tvedemo/wgt/ConfirmDialog", [
    "xdk-base/class",
    "fix/Dialog",
    "xdk-base/util",
    "xdk-ax/Container",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Label",
    "xdk-base/device/vKey",
    "xdk-base/config"
], function (
    klass,
    Dialog,
    util,
    Container,
    focusManager,
    evtType,
    Layout,
    Button,
    Label,
    vKey,
    config) {

    "use strict";

    var dialogTimeLimit = 0;
    
    return klass.create(Dialog, {
        POSITIVE: 1,
        NEGATIVE: 2,

        VERTICAL_BUTTON_LAYOUT: 0x01,
        HORIZONTAL_BUTTON_LAYOUT: 0x02
    }, {

        init: function (opts) {
            opts = opts || {};

            opts.title = opts.title || "Confirmation";

            var positiveButton = new Button({
                    css: "wgt-confirmdialog-button positive",
                    text: opts.positiveText || "Yes"
                }),
                negativeButton = new Button({
                    css: "wgt-confirmdialog-button negative",
                    text: opts.negativeText || "No"
                }),
                defaultFocus = positiveButton;

            if (opts.defaultOption === this.constructor.NEGATIVE) {
                defaultFocus = negativeButton;
            }

            opts.content = new Container({
                forwardFocus: defaultFocus,
                children: [
                    new Label({
                        css: "wgt-dialog-message",
                        text: opts.message,
                        id: "message"
                    }),
                    new Layout({
                        css: "wgt-confirmdialog-button-container",
                        forwardFocus: defaultFocus,
                        id: "buttonContainer",
                        nextUp: null,
                        alignment: (opts.buttonLayout || this.constructor.HORIZONTAL_BUTTON_LAYOUT),
                        children: [
                            positiveButton,
                            negativeButton
                        ]
                    })
                ]
            });

            this._super(opts);
            this.addClass("wgt-confirmdialog");

            // button click action for positive button
            if (util.isFunction(opts.positiveAction)) {
                positiveButton.addEventListener(evtType.CLICK, util.bind(function (evt) {
                    try { // Make sure we always do the action, even if focus handling is gone wrong.
                        this.close();
                    } catch (e)
                    {}
                    opts.positiveAction();
                }, this));
            } else {
                positiveButton.addEventListener(evtType.CLICK, util.bind(function (evt) {
                    this.close();
                }, this));
            }

            // button click action for negative button
            if (util.isFunction(opts.negativeAction)) {
                negativeButton.addEventListener(evtType.CLICK, util.bind(function (evt) {
                    try { // Make sure we always do the action, even if focus handling is gone wrong.
                        this.close();
                    } catch (e)
                    {}
                    opts.negativeAction();
                }, this));
            } else {
                negativeButton.addEventListener(evtType.CLICK, util.bind(function (evt) {
                    this.close();
                }, this));
            }

            this.setOption("forwardFocus", defaultFocus);

            // remember the last focus, that can be resumed after the dialog is closed
            this._lastFocus = focusManager.getCurFocus();

            // set focus on the dialog
            focusManager.focus(defaultFocus);

            var dialogTimeLimits = config.get("dialogTimeLimit", null),
                timeoutBlocked = (this._opts.dialogCss === "search-dialog" || this._opts.dialogCss === "pin-dialog" || this._opts.dialogCss === "resume-dialog");
            
            dialogTimeLimit = timeoutBlocked ? 0 : dialogTimeLimits.confirm;
            
            this._initAutoCloseTimer(dialogTimeLimit);
        },

        _keyHandler: function (evt) {
            // reset timer on user interaction, except close Popup actions.
            if (evt.id !== vKey.BACK.id) {
                this._clearAutoCloseTimer();
                this._initAutoCloseTimer(dialogTimeLimit);
            }
            
            return this._super(evt);
        },

        close: function () {
            this._super();
            this.deinit();
        }
    });
});

define('css!xdk-ui-input/css/Keyboard',[],function(){});
define("xdk-ui-input/Keyboard", ["xdk-base/class", "xdk-base/console", "xdk-base/util", "xdk-base/Element", "xdk-ui-basic/Button", "xdk-ax/evt/type", "xdk-ax/Container", "xdk-ax/focusManager", "xdk-base/device", "xdk-base/Env", "xdk-ax/Component", "css!./css/Keyboard"], function (klass, console, util, Element, Button, evtType, Container, focusManager, device, Env, Component) {
    "use strict";
    var sEnv = Env.singleton(),
        keyboard;

    keyboard = klass.create(Container, {
                DEFAULT: "default"
    }, {
                __keyMaps: {},
                __containers: {},
                __navMaps: {},
                __mapId: null,
                __focusPosition: {},
                onEdge: null,
                onHandler: null,
                __curRow: 0,
                __curCol: 0,
        init: function (opts) {
            opts.focusPosition = opts.focusPosition || [0, 0];
            opts.keyMaps = opts.keyMaps || {};
            opts.forwardFocus = opts.useLastFocus || undefined;
            opts.root = new Element("div", {
                "class": "wgt-keyboard"
            });
            this._super(opts);
            this.__curRow = opts.focusPosition[0];
            this.__curCol = opts.focusPosition[1];
            util.each(opts.keyMaps, util.bind(function (obj) {
                this.addKeyMap(obj.key, obj.value);
            }, this));
            this.addEventListener(evtType.KEY, util.bind(this._keyHandler, this), true);
            this.addEventListener(evtType.CLICK, util.bind(this._keyHandler, this));
            if (opts.defaultMap) {
                this.switchKeyMap(opts.defaultMap);
            } else if (this.__keyMaps["default"]) {
                this.switchKeyMap("default");
            } else {
                console.warn("no default maps");
            }

        },
                getFocusPosition: function (id) {
            if (util.isUndefined(id)) {
                return this.__focusPosition[this.getMapId()];
            }
            return this.__focusPosition[id];
        },
                getFocusedKey: function (id) {
            return this.getKey(this.getFocusPosition(id));
        },
                setFocusPosition: function (id, arr) {
            var row = arr[0] || 0,
                col = arr[1] || 0;
            this.__focusPosition[id] = [row, col];
        },
                addKeyMap: function (id, keyMapConfig) {
            var obj = this.__initKeyMap(keyMapConfig);
            if (this.__keyMaps[id]) {
                console.warn("Specific key map " + id + " is already exist.");
            }

            this.__keyMaps[id] = obj.map;
            this.__containers[id] = obj.container;
            this.__focusPosition[id] = obj.defaultFocus;
            obj.container.addClass("wgt-keyboard-container-" + id);
            //then it will run through the keymap and create specific navigation map which will be used when navigation.
            //keyMapObj which is the setting of array with the setting and obj.map is array of created button
            this.__navMaps[id] = this.__initNavMap(keyMapConfig, obj.map);
            this.setFocusPosition(id, this.__focusPosition[id]);
        },
                removeKeyMap: function (id) {
            if (this.getMapId() === id) {
                console.warn("unable to remove the current displayMap");
                return;
            }

            //remove the id stuff
            delete this.__keyMaps[id];
            delete this.__containers[id];
            delete this.__navMaps[id];
            delete this.__focusPosition[id];
        },
                switchKeyMap: function (id) {
            if (!this.__keyMaps[id] || !this.__containers[id] || !this.__navMaps[id]) {
                console.warn("Unable to load the id " + id + " as it is not exist");
                return false;
            }
            this.detach(this.__containers[this.__mapId]);
            this.__mapId = id;
            this.attach(this.__containers[this.__mapId]);
            console.info("Switch successfully" + id);
            this.setOption("forwardFocus", this.getKey(this.getFocusPosition(id)));
            if (focusManager.isCompChildFocused(this)) {
                focusManager.focus(this);
            }
            return true;
        },
                __initKeyMap: function (keyMapConfig) {
            var map = [],
                button, originalConfig, tempKey, defaultFocus = [0, 0],
                container = new Container();
            util.each(keyMapConfig, function (row, i) {
                map[i] = [];
                util.each(row, function (item, j) {
                    if (item.defaultFocus) {
                        defaultFocus = [i, j];
                    }
                    button = this.__initKey(item);

                    //handle css about the position and setObject row and col number
                    if (j === 0) {
                        button.addClass("row-begin");
                        //button.getRoot().css("clear", "left");
                    }
                    if (j === row.length - 1) {
                        button.addClass("row-end");
                        //button.getRoot().css("float", "left");
                    }
                    map[i][j] = button;
                    //standardise the config of each key
                    originalConfig = keyMapConfig[i][j];
                    if (util.isString(originalConfig)) {
                        tempKey = originalConfig;
                        originalConfig = {};
                        keyMapConfig[i][j] = originalConfig;
                        originalConfig.display = tempKey;
                    }
                    //originalConfig.input = originalConfig.input || originalConfig.display;
                    originalConfig.colSpan = originalConfig.colSpan || 1;
                    originalConfig.rowSpan = originalConfig.rowSpan || 1;
                    container.attach(button, null, null);
                }, this);
            }, this);
            return {
                map: map,
                container: container,
                defaultFocus: defaultFocus
            };
        },
                __initKey: function (attr) {
            var obj;
            //string, and create a default button
            if (util.isString(attr) || (attr && !(attr.display instanceof Component))) {
                obj = this.__createButton(attr);
            } else if (attr.display instanceof Component) {
                obj = attr.display;
                if (attr.css) {
                    obj.addClass(attr.css);
                }
            } else {
                console.warn("unable to construct or assign the key into the keyboad");
                return;
            }

            obj.addClass("wgt-keyboard-comp");

            if (!util.isUndefined(attr.rowSpan)) {
                obj.addClass("rowSpan-" + attr.rowSpan);
            }
            if (!util.isUndefined(attr.colSpan)) {
                obj.addClass("colSpan-" + attr.colSpan);
            }
            return obj;
        },
                __createButton: function (attr) {
            var btnObject, display;
            if (!attr) {
                console.warn("unable to create the button without any setting");
                return null;
            }

            if (util.isString(attr)) {
                btnObject = new Button({
                    text: attr,
                    isPureText: true
                });
                btnObject.getRoot().setClass("");
            } else if (attr) {
                display = attr.display;
                btnObject = new Button({
                    text: display,
                    isPureText: true
                });
                if (attr.css) {
                    btnObject.getRoot().setClass(attr.css);
                }
                if (attr.disable) {
                    btnObject.disable();
                }
            }

            if (btnObject) {
                return btnObject;
            } else {
                console.warn("unable to create the obj" + attr);
                return null;
            }

        },
                __initNavMap: function (keyMapConfig, keyMap) {
            var navMap = [],
                k, colPlaced, rowSpan, colSpan, set;
            util.each(keyMapConfig, function (row, i) {
                if (!navMap[i]) {
                    navMap[i] = [];
                }
                util.each(row, function (item, j) {
                    rowSpan = item.rowSpan || 1;
                    colSpan = item.colSpan || 1;
                    set = false;
                    //to save the x and y position of the button which will be easier to locate them later.
                    keyMapConfig[i][j].__y = i;
                    keyMap[i][j].__keyboard_config = keyMapConfig[i][j];
                    //to find the first free empty space
                    for (k = 0; k < navMap[i].length; k++) {
                        if (!navMap[i][k]) {
                            navMap[i][k] = keyMap[i][j];
                            keyMapConfig[i][j].__x = k;
                            set = true;
                            break;
                        }
                    }

                    if (!set) {
                        navMap[i].push(keyMap[i][j]);
                        keyMapConfig[i][j].__x = navMap[i].length - 1;
                        set = true;
                    }

                    colPlaced = keyMapConfig[i][j].__x;
                    if (rowSpan > 1) {

                        if (colSpan > 1) {
                            for (k = 1; k < rowSpan; k++) {
                                if (!navMap[i + k]) {
                                    navMap[i + k] = [];
                                }
                                for (k = colPlaced; k < colSpan; k++) {
                                    navMap[i][k] = keyMap[i][j];
                                }
                            }
                        } else {
                            //only has row  Span
                            for (k = 1; k < rowSpan; k++) {
                                if (!navMap[i + k]) {
                                    navMap[i + k] = [];
                                }
                                navMap[i + k][colPlaced] = keyMap[i][j];
                            }
                        }
                    } else {
                        if (colSpan > 1) {
                            //only has colSpan
                            for (k = 1; k < colSpan; k++) {
                                if (!navMap[i][colPlaced + k]) {
                                    navMap[i][colPlaced + k] = keyMap[i][j];
                                }
                            }
                        }
                    }
                });
            });
            return navMap;
        },
                _keyHandler: function (evt) {
            var vKey = device.vKey,
                evtKey = evt.id,
                curFocus, curRow, curCol, targetBtn, btn, direction = null,
                ret, keyInfo;
            curFocus = focusManager.getCurFocus();
            //do Nothing when there is no focus
            if (!curFocus) {
                return;
            }

            curRow = this.__curRow;
            curCol = this.__curCol;
            //to ensure the row and col are correct with respect to the focus key (mainly when mouse case)
            if (curCol > curFocus.__keyboard_config.__x + curFocus.__keyboard_config.colSpan - 1 || curCol < curFocus.__keyboard_config.__x) {
                curCol = curFocus.__keyboard_config.__x;
            }

            if (curRow > curFocus.__keyboard_config.__y + curFocus.__keyboard_config.rowSpan - 1 || curRow < curFocus.__keyboard_config.__y) {
                curRow = curFocus.__keyboard_config.__y;
            }

            this.setFocusPosition(this.getMapId(), [curRow, curCol]);
            if ((evt.type === evtType.KEY && evtKey === vKey.OK.id) || evt.type === evtType.CLICK) {
                this.__focusPosition[this.getMapId()] = [curRow, curCol];
                keyInfo = this.getKeyInfo([curRow, curCol]);
                //to check if there are keyId in the object. If return true and then stop dispatch and don't input anything
                if (keyInfo.keyId && this.onHandler) {
                    ret = this.onHandler(keyInfo.keyId, this.getKey([curRow, curCol]));
                    if (ret === false) {
                        return false;
                    } else {
                        //to dispatch event to let the xdk know key input
                        sEnv.dispatchEvent(sEnv.EVT_ONKEY, {
                            id: keyInfo.keyId,
                            text: ret || undefined,
                            source: "soft-keyboard"
                        });
                        return false;
                    }
                }

                //to dispatch event to let the xdk know key input
                sEnv.dispatchEvent(sEnv.EVT_ONKEY, {
                    id: keyInfo.display,
                    text: keyInfo.input || keyInfo.display,
                    source: "soft-keyboard"
                });
                return false;
            }

            if (evtKey === vKey.DOWN.id || evtKey === vKey.UP.id || evtKey === vKey.LEFT.id || evtKey === vKey.RIGHT.id) {
                //to handle the navigaton based on the current position of the focus item
                do {
                    switch (evtKey) {
                    case vKey.DOWN.id:
                        direction = !direction ? "nextDown" : direction;
                        curRow++;
                        break;
                    case vKey.UP.id:
                        curRow--;
                        direction = !direction ? "nextUp" : direction;
                        break;
                    case vKey.LEFT.id:
                        curCol--;
                        direction = !direction ? "nextLeft" : direction;
                        break;
                    case vKey.RIGHT.id:
                        curCol++;
                        direction = !direction ? "nextRight" : direction;
                        break;
                    }
                    targetBtn = this.getKey([curRow, curCol]);
                    if (!targetBtn || curCol < 0 || curRow < 0) {
                        break;
                    }
                    if (targetBtn && targetBtn !== curFocus && focusManager.isCompFocusable(targetBtn)) {
                        btn = targetBtn;
                        break;
                    }
                } while (true);

                if (btn) {
                    this.__curRow = curRow;
                    this.__curCol = curCol;
                    this.__focusPosition[this.getMapId()] = [curRow, curCol];
                    focusManager.focus(btn);
                    // no need for default action
                    evt.preventDefault();
                    return false;
                }

                console.info("reach edge of the keyboard and dedicate to developer to handle");
                //to dedicate to the develop to handle the edge end.
                if (this.onEdge) {
                    ret = this.onEdge(direction, this.getFocusPosition());
                    if (ret === false) {
                        evt.preventDefault();
                        return false;
                    }
                }
                return;
            }
        },
                getKeyInfo: function (arr) {
            var btn = this.getKey(arr);
            return btn.__keyboard_config;
        },
                getKey: function (arr) {
            return this.__getChildByNaviMap(arr);
        },
                __getChildByNaviMap: function (arr) {
            return this.__getChildByMap(this.__navMaps, arr);
        },
                __getChildByKeyMap: function (arr) {
            return this.__getChildByMap(this.__keyMaps, arr);
        },
                __getChildByMap: function (target, arr) {
            var row = arr[0],
                col = arr[1],
                obj;
            if (row < 0 || col < -1) {
                return null;
            }
            obj = target[this.getMapId()];
            if (obj && obj.length <= row) {
                return null;
            }
            obj = target[this.getMapId()][row];
            if (col === -1) {
                col = target[this.getMapId()][row].length - 1;
            }
            if (obj && obj.length <= col) {
                return null;
            }
            obj = target[this.getMapId()][row][col];
            if (obj) {
                return obj;
            }
            return null;
        },
                getMapId: function () {
            return this.__mapId;
        }
    });
    return keyboard;
});
define("xdk-ui-input/interface/InputImpl", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    return Interface.create("InputImpl", {
                insertChar: ["char", "insertPos"],
                backspace: [],
                del: [],
                setMaxLength: ["length"],
                getMaxLength: [],
                getText: [],
                setText: ["text"],
                clearText: [],
                moveCursor: ["direction"],
                setCursorPos: ["pos"],
                startInput: [],
                stopInput: [],
                isCapturing: []
    });
});

define('css!xdk-ui-input/css/InputDivImpl',[],function(){});
define("xdk-ui-input/InputDivImpl", [
    "xdk-base/class",
    "xdk-base/Element",
    "xdk-base/util",
    "xdk-base/device",
    "xdk-ax/evt/type",
    "xdk-base/core",
    "./interface/InputImpl",
    "css!./css/InputDivImpl"
], function (
    klass,
    Element,
    util,
    device,
    evtType,
    core,
    InputImpl
) {
    "use strict";

    return klass.create([InputImpl], {}, {
                __oldSamsung: device.platform === "samsung" && device.id.getFirmwareYear() <= 2011,
                __inputFieldWidth: null,
                __wrapper: null,
                __wrapperCopy: null,
                __cursor: null,
                __cursorPosition: null,
                __cursorLeftPosition: null,
                __labelText: null,
                __labelTextCopy: null,
                __wrapperLeft: null,
                __inputState: false,
                __passwordTimer: null,
                __initEnvOnKey: false,
                __maxLength: 20,
                __isPassword: false,
                __passwordChar: null,
                __hideTimeout: 0,
                __widgetInstance: null,
                __placeHolder: null,
                __placeHolderDiv: null,
                init: function (opts) {
            opts = opts || {};

            opts.root.addClass("wgt-input-div");

            this.setMaxLength(util.isNumber(opts.maxLength) ? opts.maxLength : 20);
            this.__isPassword = opts.isPassword || false;
            this.__passwordChar = opts.passwordChar || "*";
            this.__hideTimeout = opts.hideTimeout || 0;
            this.__placeHolder = opts.placeHolder || "";

            this.__labelText = opts.text || "";
            this.__cursorPosition = this.__labelText.length;
            this.__widgetInstance = opts.widgetInstance;

            // Create div structure
            this.container = new Element("div");
            this.container.addClass("container");

            this.__wrapper = new Element("pre");
            this.__wrapper.addClass("wrapper");

            this.__wrapperCopy = new Element("pre");
            this.__wrapperCopy.addClass("wrapperCopy");

            this.__cursor = new Element("div");
            this.__cursor.addClass("cursor");
            this.__cursor.css({
                visibility: "hidden"
            });


            //XDK-1838
            //since it is part of the implementation of the input and thus append the current container to the root instead of create a new root in the component
            opts.root.append(this.container);
            this.container.append(this.__wrapper);
            this.container.append(this.__wrapperCopy);
            this.container.append(this.__cursor);

            //add the place Holder when it is not empty
            if (this.__placeHolder !== "") {
                this.__placeHolderDiv = new Element("div");
                this.__placeHolderDiv.addClass("placeholder");
                this.__placeHolderDiv.setInnerText(this.__placeHolder);

                if (this.__labelText.length > 0) {
                    this.__placeHolderDiv.hide();
                }

                this.container.append(this.__placeHolderDiv);
            }

            this.setText(opts.text, true);
        },
                insertChar: function (ch, insertPos) {
            if (!this.__inputState || !ch) {
                return;
            }
            if (this.__labelText.length >= this.getMaxLength()) { // If length of __labelText reach maximum, do nothing, and return
                return;
            }

            insertPos = util.isUndefined(insertPos) ? this.__cursorPosition : insertPos;
            var t = this.getText();
            t = util.insert(t, insertPos, ch);
            this.__cursorPosition = this.__cursorPosition + ch.length;
            this.setText(t, undefined, true);
            this.updateLeft("add");
            this.updateCursorPosition();
        },
                backspace: function () {
            if (!this.__inputState) {
                return;
            }
            if (this.__cursorPosition <= 0) { // If cursorPosition == 0, there must be no char before cursor, do nothing, and return
                return;
            }

            var text = this.getText(),
                newText = "";
            if (this.__cursorPosition === 1) { // Exception case when delete the first char while the string is have more than 1 char
                if (text.length > 1) {
                    newText = text.slice(this.__cursorPosition, text.length);
                }
            } else {
                if (text.length > 1) {
                    newText = text.slice(0, this.__cursorPosition - 1) + text.slice(this.__cursorPosition, text.length);
                }
            }
            this.__cursorPosition--;
            this.setText(newText, undefined, true);
            this.updateLeft("del");
            this.updateCursorPosition();
        },
                del: function () {
            if (!this.__inputState) {
                return;
            }
            var text = this.getText(),
                newText = "";
            if (this.__cursorPosition >= text.length) { // If __cursorPosition == text.length, there must be no char after cursor, do nothing, and return
                return;
            }

            if (this.__cursorPosition === text.length - 1) { // Exception case when delete the last char
                newText = text.slice(0, text.length - 1);
            } else {
                newText = text.slice(0, this.__cursorPosition) + text.slice(this.__cursorPosition + 1, text.length);
            }
            this.setText(newText, undefined, true);
        },
                setMaxLength: function (l) {
            this.__maxLength = l;
        },
                getMaxLength: function () {
            return this.__maxLength;
        },
                getText: function () {
            return this.__labelText;
        },
                setText: function (text, forceNoTimeout, noUpdateCursorPosition) {

            // incorrect input
            if (util.isUndefined(text)) {
                return;
            }

            if (!text) {
                text = "";
            }

            var textChanged = (text !== this.__labelText),
                len, passwordWrapperText = "",
                passwordWrapperCopyText = "",
                i, wrapperCopyText, isAddition, useTimeout, hideTextFn;
            if (text.length > this.getMaxLength()) {
                this.__cursorPosition = this.getMaxLength();
            } else if (!noUpdateCursorPosition) {
                this.__cursorPosition = text.length;
            }
            text = util.truncate(text, this.getMaxLength(), "");
            if (this.__isPassword) {
                isAddition = text.length > this.__labelText.length; // we are having more characters or not
                useTimeout = (this.__hideTimeout > 0) && isAddition && !forceNoTimeout; // do we briefly show the last character before cursor or not
                this.__labelText = text;
                len = this.__labelText.length;

                if (this.__passwordTimer) {
                    util.clearDelay(this.__passwordTimer);
                    this.__passwordTimer = null;
                }

                for (i = 0; i < this.__cursorPosition - 1; i++) { // leave out the last character before cursor position
                    passwordWrapperText += this.__passwordChar;
                    passwordWrapperCopyText += this.__passwordChar;
                }
                if (!useTimeout && this.__cursorPosition > 0) {
                    passwordWrapperText += this.__passwordChar; // directly hide that last typed character as "*"
                    passwordWrapperCopyText += this.__passwordChar;
                } else {
                    passwordWrapperText += text[this.__cursorPosition - 1]; // show the last typed character
                    passwordWrapperCopyText += text[this.__cursorPosition - 1];
                }

                for (i = 0; i < len - this.__cursorPosition; i++) { // fill the remaining characters
                    passwordWrapperText += this.__passwordChar;
                }

                this.__setElementText(this.__wrapper, passwordWrapperText);
                this.__setElementText(this.__wrapperCopy, passwordWrapperCopyText);

                hideTextFn = util.bind(function () { // hide
                    passwordWrapperText = "";
                    passwordWrapperCopyText = "";
                    for (i = 0; i < len; i++) {
                        passwordWrapperText += this.__passwordChar;
                    }
                    for (i = 0; i < this.__cursorPosition; i++) {
                        passwordWrapperCopyText += this.__passwordChar;
                    }
                    this.__setElementText(this.__wrapper, passwordWrapperText);
                    this.__setElementText(this.__wrapperCopy, passwordWrapperCopyText);
                    this.updateCursorPosition();
                    this.__passwordTimer = null;
                }, this);

                if (useTimeout) {
                    this.__passwordTimer = core.getGuid();
                    util.delay(this.__hideTimeout, this.__passwordTimer).then(hideTextFn);
                } else {
                    hideTextFn();
                }

            } else {
                this.__setElementText(this.__wrapper, text);
                if (this.__cursorPosition === 0) {
                    this.__setElementText(this.__wrapperCopy, "");
                } else {
                    wrapperCopyText = util.truncate(text, this.__cursorPosition, "");
                    this.__setElementText(this.__wrapperCopy, wrapperCopyText);
                }
            }

            this.__labelText = text;
            this.__labelTextCopy = util.truncate(this.__labelText, this.__cursorPosition, "");
            if (!noUpdateCursorPosition) {
                this.updateCursorPosition();
            }

            if (!textChanged) {
                return;
            }

            if (this.__placeHolderDiv) {
                if (this.__labelText.length > 0) {
                    this.__placeHolderDiv.hide();
                } else {
                    this.__placeHolderDiv.show();
                }
            }

            if (this.__widgetInstance) {
                this.__widgetInstance.dispatchEvent(evtType.TEXT_CHANGED, this.__labelText);
            }
        },
                __setElementText: function (element, text) {
            var tailingSpan;
            element.setInnerText(text);
            //use a span to detect workaround for the first trailing space issue
            if (text.length > 0 && element === this.__wrapperCopy && this.__oldSamsung) {
                tailingSpan = new Element("span");
                tailingSpan.setInnerText("t");
                element.append(tailingSpan);
            }
        },
                clearText: function () {
            this.setText("");
        },
                updateLeft: function (method) {
            this.wrapperWidth = this.__wrapper.getHTMLElement().clientWidth;
            this.__wrapperLeft = this.__wrapper.getHTMLElement().offsetLeft;
            this.wrapperCopyWidth = this.__wrapperCopy.getHTMLElement().clientWidth;
            this.wrapperCopyLeft = this.__wrapperCopy.getHTMLElement().offsetLeft;
            var leftPos, wrapperCopyEle, wrapperCopyEndSpan;

            if (this.__oldSamsung && this.__cursorPosition > 0) {
                wrapperCopyEle = this.__wrapperCopy.getHTMLElement();
                wrapperCopyEndSpan = wrapperCopyEle.lastChild;
                this.wrapperCopyWidth -= wrapperCopyEndSpan.clientWidth;
            }

            if (!this.__inputFieldWidth) {
                this.__inputFieldWidth = this.container.getHTMLElement().clientWidth;
            }
            // Perform checking to ensure the cursor is within the inputField visually
            if ((this.wrapperWidth >= this.__inputFieldWidth) && (this.__cursorPosition === this.__labelText.length)) {
                // The cursor on the end, the leftPos of wrapper should be equal to ([InputField.Width] - [Wrapper.Width])
                // in order not to have empty space at the end of inputField, and leftPos must be a negative number.
                leftPos = this.__inputFieldWidth - this.wrapperWidth;
            } else if (this.wrapperWidth >= this.__inputFieldWidth) {
                // There must be some charcter outside the inputField visually
                if (method === "del") {
                    if ((this.wrapperWidth + this.__wrapperLeft) <= this.__inputFieldWidth) {
                        leftPos = this.__inputFieldWidth - this.wrapperWidth;
                    }
                }
            } else {
                // The text is within the width of the InputField, set leftPos to 0
                leftPos = 0;
            }

            if (!util.isUndefined(leftPos)) {
                this.updateLeftByCursor(leftPos);
            }
        },
                updateLeftByCursor: function (leftPos) {
            this.__wrapper.css({
                "left": leftPos + "px"
            });
            this.__wrapperCopy.css({
                "left": leftPos + "px"
            });
            this.__wrapperLeft = leftPos;
        },
                updateCursorPosition: function () {
            var tempA, leftPos, wrapperCopyEle, wrapperCopyEndSpan, offsetLeft;
            // Cursor position is at the beginning
            // When there is no content, the cursor should sit at the left of the wrapper.
            if (this.__cursorPosition === 0) {
                this.__cursor.css({
                    "left": "0px"
                });
                this.updateLeftByCursor(0);
                return;
            }
            
            offsetLeft = this.__wrapperCopy.getHTMLElement().offsetLeft;
            leftPos = 0;
            this.wrapperCopyWidth = this.__wrapperCopy.getHTMLElement().offsetWidth;

            if (this.__oldSamsung && this.__cursorPosition > 0) {
                wrapperCopyEle = this.__wrapperCopy.getHTMLElement();
                wrapperCopyEndSpan = wrapperCopyEle.lastChild;
                this.wrapperCopyWidth -= wrapperCopyEndSpan.clientWidth;
            }

            tempA = (this.wrapperCopyWidth + offsetLeft);

            if (tempA > this.__inputFieldWidth - 1) {
                // cursor will go out of inputField, force it back to the end position
                // modify the leftPos of both wrapper and wrapperCopy
                leftPos = this.__inputFieldWidth - 1;
                this.updateLeftByCursor(this.__inputFieldWidth - this.wrapperCopyWidth);
            } else if (tempA > 0) {
                // cursor still within the inputField area, only need to update the cursor position, the leftPos no need to change
                leftPos = tempA;
            } else {
                // cursor will go out of inputField, force it back to the beginning position
                // modify the leftPos of both wrapper and wrapperCopy
                leftPos = 0;
                this.updateLeftByCursor(-this.wrapperCopyWidth);
            }

            this.__cursor.css({
                "left": leftPos + "px"
            });

            this.__cursorLeftPosition = leftPos;
        },
                moveCursor: function (direction) {
            if (!this.__inputState) {
                return;
            }
            if (direction.toLowerCase() === "left") {
                this.setCursorPos(this.__cursorPosition - 1);
            } else if (direction.toLowerCase() === "right") {
                this.setCursorPos(this.__cursorPosition + 1);
            }
        },
                setCursorPos: function (pos) {
            if (pos > this.getText().length) {
                pos = this.getText().length;
            } else if (pos < 0) {
                pos = 0;
            }

            if (this.__cursorPosition !== pos) {
                this.__cursorPosition = pos;

                if (this.__cursorPosition === 0) {
                    this.__labelTextCopy = "";
                } else if (this.__isPassword) {
                    this.__labelTextCopy = util.truncate(this.__wrapper.getInnerText(), this.__cursorPosition, "");
                } else {
                    this.__labelTextCopy = util.truncate(this.__labelText, this.__cursorPosition, "");
                }
                this.__setElementText(this.__wrapperCopy, this.__labelTextCopy);
                this.updateCursorPosition();
            }
        },
                startInput: function () {
            this.__inputState = true;
            if (!this.__inputFieldWidth) {
                this.__inputFieldWidth = this.container.getHTMLElement().clientWidth;
                this.updateLeft("add");
                this.updateCursorPosition();
            }
            this.__cursor.css({
                visibility: "visible"
            });
        },
                stopInput: function () {
            this.__inputState = false;
            this.__cursor.css({
                visibility: "hidden"
            });

        },
                isCapturing: function () {
            return this.__inputState;
        },
                deinit: function () {
            //no need to super since it is just part of the input which doesn't inside the xdk hierarchy (no parent)
            //so deinit just go through the remove all listner and element deinit only. The Dom element deinit of input will be handled in the input.js
            this.container.deinit();
            this.__wrapper.deinit();
            this.__wrapperCopy.deinit();
            this.__cursor.deinit();
        }
    });
});
/**
 * Contains the definition for keyboard virtual keys. Used by device packages who support fixed keyboards. e.g.
 * {@link xdk-base/device/workstation/TvKey|Workstation},{@link xdk-ext-device-boxee/TvKey|Boxee}
 *
 * @module xdk-base/device/shared/keyboardVKey
 * @author Andy Hui <andy.hui@accedo.tv>
 */
define("xdk-base/device/shared/keyboardVKey", ["xdk-base/device/vKey"], function (vKey) {
    "use strict"; 
    return {
        /**
         *
         * @name A
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:A"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        A: {
            id: "device:kb-vkey:A",
            text: "A"
        },
        /**
         *
         * @name B
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:B"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        B: {
            id: "device:kb-vkey:B",
            text: "B"
        },
        /**
         *
         * @name C
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:C"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        C: {
            id: "device:kb-vkey:C",
            text: "C"
        },
        /**
         *
         * @name D
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:D"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        D: {
            id: "device:kb-vkey:D",
            text: "D"
        },
        /**
         *
         * @name E
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:E"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        E: {
            id: "device:kb-vkey:E",
            text: "E"
        },
        /**
         *
         * @name F
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:F"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        F: {
            id: "device:kb-vkey:F",
            text: "F"
        },
        /**
         *
         * @name G
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:G"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        G: {
            id: "device:kb-vkey:G",
            text: "G"
        },
        /**
         *
         * @name H
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:H"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        H: {
            id: "device:kb-vkey:H",
            text: "H"
        },
        /**
         *
         * @name I
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:I"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        I: {
            id: "device:kb-vkey:I",
            text: "I"
        },
        /**
         *
         * @name J
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:J"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        J: {
            id: "device:kb-vkey:J",
            text: "J"
        },
        /**
         *
         * @name K
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:K"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        K: {
            id: "device:kb-vkey:K",
            text: "K"
        },
        /**
         *
         * @name L
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:L"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        L: {
            id: "device:kb-vkey:L",
            text: "L"
        },
        /**
         *
         * @name M
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:M"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        M: {
            id: "device:kb-vkey:M",
            text: "M"
        },
        /**
         *
         * @name N
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:N"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        N: {
            id: "device:kb-vkey:N",
            text: "N"
        },
        /**
         *
         * @name O
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:O"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        O: {
            id: "device:kb-vkey:O",
            text: "O"
        },
        /**
         *
         * @name P
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:P"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        P: {
            id: "device:kb-vkey:P",
            text: "P"
        },
        /**
         *
         * @name Q
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:Q"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        Q: {
            id: "device:kb-vkey:Q",
            text: "Q"
        },
        /**
         *
         * @name R
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:R"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        R: {
            id: "device:kb-vkey:R",
            text: "R"
        },
        /**
         *
         * @name S
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:S"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        S: {
            id: "device:kb-vkey:S",
            text: "S"
        },
        /**
         *
         * @name T
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:T"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        T: {
            id: "device:kb-vkey:T",
            text: "T"
        },
        /**
         *
         * @name U
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:U"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        U: {
            id: "device:kb-vkey:U",
            text: "U"
        },
        /**
         *
         * @name V
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:V"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        V: {
            id: "device:kb-vkey:V",
            text: "V"
        },
        /**
         *
         * @name W
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:W"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        W: {
            id: "device:kb-vkey:W",
            text: "W"
        },
        /**
         *
         * @name X
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:X"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        X: {
            id: "device:kb-vkey:X",
            text: "X"
        },
        /**
         *
         * @name Y
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:Y"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        Y: {
            id: "device:kb-vkey:Y",
            text: "Y"
        },
        /**
         *
         * @name Z
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:Z"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        Z: {
            id: "device:kb-vkey:Z",
            text: "Z"
        },
        /**
         *
         * @name A_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:a"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        A_LOWER: {
            id: "device:kb-vkey:a",
            text: "a"
        },
        /**
         *
         * @name B_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:b"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        B_LOWER: {
            id: "device:kb-vkey:b",
            text: "b"
        },
        /**
         *
         * @name C_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:c"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        C_LOWER: {
            id: "device:kb-vkey:c",
            text: "c"
        },
        /**
         *
         * @name D_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:d"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        D_LOWER: {
            id: "device:kb-vkey:d",
            text: "d"
        },
        /**
         *
         * @name E_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:e"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        E_LOWER: {
            id: "device:kb-vkey:e",
            text: "e"
        },
        /**
         *
         * @name F_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:f"
         * @property {String} text Text value of keys
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        F_LOWER: {
            id: "device:kb-vkey:f",
            text: "f"
        },
        /**
         *
         * @name G_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:g"
         * @property {String} text Text value of keys
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        G_LOWER: {
            id: "device:kb-vkey:g",
            text: "g"
        },
        /**
         *
         * @name H_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:h"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        H_LOWER: {
            id: "device:kb-vkey:h",
            text: "h"
        },
        /**
         *
         * @name I_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:i"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        I_LOWER: {
            id: "device:kb-vkey:i",
            text: "i"
        },
        /**
         *
         * @name J_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:j"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        J_LOWER: {
            id: "device:kb-vkey:j",
            text: "j"
        },
        /**
         *
         * @name K_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:k"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        K_LOWER: {
            id: "device:kb-vkey:k",
            text: "k"
        },
        /**
         *
         * @name L_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:l"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        L_LOWER: {
            id: "device:kb-vkey:l",
            text: "l"
        },
        /**
         *
         * @name M_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:m"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        M_LOWER: {
            id: "device:kb-vkey:m",
            text: "m"
        },
        /**
         *
         * @name N_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:n"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        N_LOWER: {
            id: "device:kb-vkey:n",
            text: "n"
        },
        /**
         *
         * @name O_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:o"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        O_LOWER: {
            id: "device:kb-vkey:o",
            text: "o"
        },
        /**
         *
         * @name P_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:p"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        P_LOWER: {
            id: "device:kb-vkey:p",
            text: "p"
        },
        /**
         *
         * @name Q_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:q"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        Q_LOWER: {
            id: "device:kb-vkey:q",
            text: "q"
        },
        /**
         *
         * @name R_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:r"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        R_LOWER: {
            id: "device:kb-vkey:r",
            text: "r"
        },
        /**
         *
         * @name S_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:s"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        S_LOWER: {
            id: "device:kb-vkey:s",
            text: "s"
        },
        /**
         *
         * @name T_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:t"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        T_LOWER: {
            id: "device:kb-vkey:t",
            text: "t"
        },
        /**
         *
         * @name U_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:u"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        U_LOWER: {
            id: "device:kb-vkey:u",
            text: "u"
        },
        /**
         *
         * @name V_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:v"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        V_LOWER: {
            id: "device:kb-vkey:v",
            text: "v"
        },
        /**
         *
         * @name W_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:w"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        W_LOWER: {
            id: "device:kb-vkey:w",
            text: "w"
        },
        /**
         *
         * @name X_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:x"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        X_LOWER: {
            id: "device:kb-vkey:x",
            text: "x"
        },
        /**
         *
         * @name Y_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:y"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        Y_LOWER: {
            id: "device:kb-vkey:y",
            text: "y"
        },
        /**
         *
         * @name Z_LOWER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:z"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        Z_LOWER: {
            id: "device:kb-vkey:z",
            text: "z"
        },
        /**
         *
         * @name SPACE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:space"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        SPACE: {
            id: "device:kb-vkey:space",
            text: " "
        },
        /**
         *
         * @name TILDE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:tilde"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        TILDE: {
            id: "device:kb-vkey:~",
            text: "~"
        },
        /**
         *
         * @name BACK_QUOTE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:`"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        BACK_QUOTE: {
            id: "device:kb-vkey:`",
            text: "`"
        },
        /**
         *
         * @name EXC
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:!"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        EXC: {
            id: "device:kb-vkey:!",
            text: "!"
        },
        /**
         *
         * @name AT
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:@"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        AT: {
            id: "device:kb-vkey:@",
            text: "@"
        },
        /**
         *
         * @name HASH
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:#"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        HASH: {
            id: "device:kb-vkey:#",
            text: "#"
        },
        /**
         *
         * @name DOLLAR
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:$"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        DOLLAR: {
            id: "device:kb-vkey:$",
            text: "$"
        },
        /**
         *
         * @name PERCENT
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:%"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PERCENT: {
            id: "device:kb-vkey:%",
            text: "%"
        },
        /**
         *
         * @name CARET
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:^"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        CARET: {
            id: "device:kb-vkey:^",
            text: "^"
        },
        /**
         *
         * @name AMP
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:&"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        AMP: {
            id: "device:kb-vkey:&",
            text: "&"
        },
        /**
         *
         * @name STAR
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:*"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        STAR: {
            id: "device:kb-vkey:*",
            text: "*"
        },
        /**
         *
         * @name OPEN_PAREN
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:("
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        OPEN_PAREN: {
            id: "device:kb-vkey:(",
            text: "("
        },
        /**
         *
         * @name CLOSE_PAREN
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:)"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        CLOSE_PAREN: {
            id: "device:kb-vkey:)",
            text: ")"
        },
        /**
         *
         * @name MINUS
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:-"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        MINUS: {
            id: "device:kb-vkey:-",
            text: "-"
        },
        /**
         *
         * @name UNDERSCORE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:_"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        UNDERSCORE: {
            id: "device:kb-vkey:_",
            text: "_"
        },
        /**
         *
         * @name EQUALS
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:="
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        EQUALS: {
            id: "device:kb-vkey:=",
            text: "="
        },
        /**
         *
         * @name PLUS
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:+"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PLUS: {
            id: "device:kb-vkey:+",
            text: "+"
        },
        /**
         *
         * @name OPEN_BRACKET
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:["
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        OPEN_BRACKET: {
            id: "device:kb-vkey:[",
            text: "["
        },
        /**
         *
         * @name OPEN_BRACE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:{"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        OPEN_BRACE: {
            id: "device:kb-vkey:{",
            text: "{"
        },
        /**
         *
         * @name CLOSE_BRACKET
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:]"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        CLOSE_BRACKET: {
            id: "device:kb-vkey:]",
            text: "]"
        },
        /**
         *
         * @name CLOSE_BRACE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:}"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        CLOSE_BRACE: {
            id: "device:kb-vkey:}",
            text: "}"
        },
        /**
         *
         * @name BACK_SLASH
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:\\"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        BACK_SLASH: {
            id: "device:kb-vkey:\\",
            text: "\\"
        },
        /**
         *
         * @name PIPE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:|"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PIPE: {
            id: "device:kb-vkey:|",
            text: "|"
        },
        /**
         *
         * @name SEMICOLON
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:;"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        SEMICOLON: {
            id: "device:kb-vkey:;",
            text: ";"
        },
        /**
         *
         * @name COLON
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey::"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        COLON: {
            id: "device:kb-vkey::",
            text: ":"
        },
        /**
         *
         * @name SINGLE_QUOTE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:'"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        SINGLE_QUOTE: {
            id: "device:kb-vkey:'",
            text: "'"
        },
        /**
         *
         * @name QUOTE
         * @type {object}
         * @property {String} id Virtual key Id. 'device:kb-vkey:"'
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        /*jshint quotmark:single */
        QUOTE: {
            id: 'device:kb-vkey:"',
            text: '"'
        },
        /*jshint quotmark:double */
        /**
         *
         * @name COMMA
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:,"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        COMMA: {
            id: "device:kb-vkey:,",
            text: ","
        },
        /**
         *
         * @name LESS
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:<"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        LESS: {
            id: "device:kb-vkey:<",
            text: "<"
        },
        /**
         *
         * @name PERIOD
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:."
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PERIOD: {
            id: "device:kb-vkey:.",
            text: "."
        },
        /**
         *
         * @name GREATER
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:>"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        GREATER: {
            id: "device:kb-vkey:>",
            text: ">"
        },
        /**
         *
         * @name SLASH
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:/"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        SLASH: {
            id: "device:kb-vkey:/",
            text: "/"
        },
        /**
         *
         * @name QUESTION
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:?"
         * @property {String} text Text value of key
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        QUESTION: {
            id: "device:kb-vkey:?",
            text: "?"
        },
        /**
         *
         * @name BACKSPACE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:back-space"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        BACKSPACE: {
            id: "device:kb-vkey:backspace"
        },
        /**
         *
         * @name TAB
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:tab"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        TAB: {
            id: "device:kb-vkey:tab"
        },
        /**
         *
         * @name INSERT
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:insert"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        INSERT: {
            id: "device:kb-vkey:insert"
        },
        /**
         *
         * @name DELETE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:delete"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        DELETE: {
            id: "device:kb-vkey:delete"
        },
        /**
         *
         * @name HOME
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:home"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        HOME: {
            id: "device:kb-vkey:home"
        },
        /**
         *
         * @name END
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:end"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        END: {
            id: "device:kb-vkey:end"
        },
        /**
         *
         * @name PAGE_UP
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:page-up"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PAGE_UP: {
            id: "device:kb-vkey:page-up"
        },
        /**
         *
         * @name PAGE_DOWN
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:page-down"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PAGE_DOWN: {
            id: "device:kb-vkey:page-down"
        },
        /**
         *
         * @name ESCAPE
         * @type {object}
         * @property {String} id Virtual key Id. "device:kb-vkey:page-escape"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        ESCAPE: {
            id: "device:kb-vkey:escape"
        },
        /**
         *
         * @name UP
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.UP}
         * @property {String} id Virtual key Id. "device:kb-vkey:up"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        UP: vKey.UP,
        /**
         *
         * @name DOWN
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.DOWN}
         * @property {String} id Virtual key Id. "device:kb-vkey:down"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        DOWN: vKey.DOWN,
        /**
         *
         * @name LEFT
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.LEFT}
         * @property {String} id Virtual key Id. "device:kb-vkey:left"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        LEFT: vKey.LEFT,
        /**
         *
         * @name RIGHT
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.RIGHT}
         * @property {String} id Virtual key Id. "device:kb-vkey:right"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        RIGHT: vKey.RIGHT,
        /**
         *
         * @name PAUSE
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.PAUSE}
         * @property {String} id Virtual key Id. "device:kb-vkey:pause"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        PAUSE: vKey.PAUSE,
        /**
         *
         * @name OK
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.OK}
         * @property {String} id Virtual key Id. "device:kb-vkey:ok"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        OK: vKey.OK,
        /**
         *
         * @name KEY_0
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.KEY_0}
         * @property {String} id Virtual key Id. "device:kb-vkey:0"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_0: vKey.KEY_0,
        /**
         *
         * @name KEY_1
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.KEY_1}
         * @property {String} id Virtual key Id. "device:kb-vkey:1"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_1: vKey.KEY_1,
        /**
         *
         * @name KEY_2
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.KEY_2}
         * @property {String} id Virtual key Id. "device:kb-vkey:2"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_2: vKey.KEY_2,
        /**
         *
         * @name KEY_3
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.KEY_3}
         * @property {String} id Virtual key Id. "device:kb-vkey:3"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_3: vKey.KEY_3,
        /**
         *
         * @name KEY_4
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.KEY_4}
         * @property {String} id Virtual key Id. "device:kb-vkey:4"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_4: vKey.KEY_4,
        /**
         *
         * @name KEY_5
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.OK}
         * @property {String} id Virtual key Id. "device:kb-vkey:5"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_5: vKey.KEY_5,
        /**
         *
         * @name KEY_6
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.PAUSE}
         * @property {String} id Virtual key Id. "device:kb-vkey:6"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_6: vKey.KEY_6,
        /**
         *
         * @name KEY_7
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.OK}
         * @property {String} id Virtual key Id. "device:kb-vkey:7"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_7: vKey.KEY_7,
        /**
         *
         * @name KEY_8
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.PAUSE}
         * @property {String} id Virtual key Id. "device:kb-vkey:8"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_8: vKey.KEY_8,
        /**
         *
         * @name KEY_9
         * @type {object}
         * @see {@link module:xdk-base/device/vKey.OK}
         * @property {String} id Virtual key Id. "device:kb-vkey:9"
         * @memberof module:xdk-base/device/shared/keyboardVKey
         */
        KEY_9: vKey.KEY_9
    };
});
/**
 * The browser keyMap key which is normally used in the tvKey to get the normal remote keys and keyboard keys information
 * @module xdk-base/device/shared/browser/keyMap
 **/
define("xdk-base/device/shared/browser/keyMap", ["xdk-base/device/shared/keyboardVKey", "xdk-base/util"], function (keyboardVKey, util) {
    "use strict";
    var REMOTE, KEYBOARD_CHAR, KEYBOARD_KEY, i, key;
    /*
     * * The REMOTE keycode object, which contain the following keys with keyCode. and all of them are keyCode
     * * UP : 38
     * * DOWN : 40
     * * LEFT : 37
     * * RIGHT : 39
     * * OK : 13
     * * KEY_1 : 48
     * * KEY_2 :49
     * * KEY_3 : 50
     * * KEY_4 : 51
     * * KEY_5 : 52
     * * KEY_6 : 53
     * * KEY_7 : 54
     * * KEY_8 : 55
     * * KEY_9 : 56
     * It provide two mapping keyCode to keyboardVKey/VKey or word to keyCode, please refer to the example
     * @name REMOTE
     * @constant
     * @memberof module:xdk-base/device/shared/browser/keyMap
     * @public
     * @example
     * REMOTE = {
     * VKey:{
     * 38: keyboardVKey.UP,
     * 39: keyboardVKey.RIGHT,
     * 40: keybaordVKey.DOWN,
     * 37: keyboardVKey.LEFT
     * },
     * keyCode:{
     * "UP":38,
     * "DOWN":40,
     * "LEFT":37,
     * "RIGHT:"39
     * }
     * }
     */
    REMOTE = {
        VKey: {},
        keyCode: {
            "UP": 38,
            "DOWN": 40,
            "LEFT": 37,
            "RIGHT": 39,
            "OK": 13
        }
    };
    /*
     * The keyboard key down key code mapping (and char code of keyboard, please refer {@see module:xdk-base/device/shared/browser/keyMap#KEYBOARD_CHAR} ) , it provides 2 key mappings which are keyCode to VKey/KeyboardVKey and word to keyCode.
     * * UP : 38
     * * DOWN : 40
     * * LEFT : 37
     * * RIGHT : 39
     * * OK : 13
     * * PAGE_UP : 34
     * * PAGE_DOWN :35
     * * END : 36
     * * HOME : 19
     * * TAB : 9
     * * INSERT : 45
     * * DELETE : 46
     * * BACKSPACE : 8
     * * ESCAPE : 27
     * It provide two mapping keyCode to keyboardVKey/VKey or word to keyCode, please refer to the example
     * @name KEYBOARD_KEY
     * @constant
     * @memberof module:xdk-base/device/shared/browser/keyMap
     * @public
     * @example
     * KEYBOARD_KEY = {
     * VKey:{
     * 38: keyboardVKey.UP,
     * 39: keyboardVKey.RIGHT,
     * 40: keybaordVKey.DOWN,
     * 37: keyboardVKey.LEFT
     * },
     * keyCode:{
     * "UP":38,
     * "DOWN":40,
     * "LEFT":37,
     * "RIGHT:"39
     * }
     * }
     */
    KEYBOARD_KEY = {
        VKey: {},
        keyCode: {
            "UP": 38,
            "DOWN": 40,
            "LEFT": 37,
            "RIGHT": 39,
            "OK": 13,
            "PAGE_UP": 33,
            "PAGE_DOWN": 34,
            "END": 35,
            "HOME": 36,
            "PAUSE": 19,
            "TAB": 9,
            "INSERT": 45,
            "DELETE": 46,
            "BACKSPACE": 8,
            "ESCAPE": 27
        }
    };
    /*
     *The keyboard key down char code mapping (and key code of keyboard, please refer {@see module:xdk-base/device/shared/browser/keyMap#KEYBOARD_KEY} ) , it provides 2 key mappings which are keyCode to VKey/KeyboardVKey and word to keyCode.
     * * SPACE : 32,
     * * EXC : 33,
     * * HASH : 35,
     * * DOLLAR : 36,
     * * PERCENT : 37,
     * * AMP : 38,
     * * SINGLE_QUOTE : 39,
     * * OPEN_PAREN : 40,
     * * CLOSE_PAREN : 41,
     * * STAR : 42,
     * * PLUS : 43,
     * * COMMA : 44,
     * * MINUS : 45,
     * * PERIOD : 46,
     * * SLASH : 47,
     * * COLON : 58,
     * * SEMICOLON : 59,
     * * LESS : 60,
     * * EQUALS : 61,
     * * GREATER : 62,
     * * QUESTION : 63,
     * * AT : 64,
     * * OPEN_BRACKET : 91,
     * * BACK_SLASH : 92,
     * * CLOSE_BRACKET : 93,
     * * CARET : 94,
     * * UNDERSCORE : 95,
     * * BACK_QUOTE : 96,
     * * OPEN_BRACE : 123,
     * * PIPE : 124,
     * * CLOSE_BRACE : 125,
     * * TILDE : 126
     * Apart from the above it also provides a-z or A-Z key mapping
     * @name KEYBOARD_CHAR
     * @constant
     * @memberof module:xdk-base/device/shared/browser/keyMap
     * @public
     * @example
     * KEYBOARD_CHAR = {
     * VKey:{
     *     32: keyboardVKey.SPACE,
     *     33: keyboardVKey.EXC,
     *     35: keybaordVKey.HASH,
     *     36: keyboardVKey.DOLLAR
     * },
     * keyCode:{
     *    "SPACE": 32,
     *    "EXC": 33,
     *    "HASH": 35,
     *    "DOLLAR": 36,
     *  }
     * }
     */
    KEYBOARD_CHAR = {
        VKey: {},
        keyCode: {
            "SPACE": 32,
            "EXC": 33,
            "HASH": 35,
            "DOLLAR": 36,
            "PERCENT": 37,
            "AMP": 38,
            "SINGLE_QUOTE": 39,
            "OPEN_PAREN": 40,
            "CLOSE_PAREN": 41,
            "STAR": 42,
            "PLUS": 43,
            "COMMA": 44,
            "MINUS": 45,
            "PERIOD": 46,
            "SLASH": 47,
            "COLON": 58,
            "SEMICOLON": 59,
            "LESS": 60,
            "EQUALS": 61,
            "GREATER": 62,
            "QUESTION": 63,
            "AT": 64,
            "OPEN_BRACKET": 91,
            "BACK_SLASH": 92,
            "CLOSE_BRACKET": 93,
            "CARET": 94,
            "UNDERSCORE": 95,
            "BACK_QUOTE": 96,
            "OPEN_BRACE": 123,
            "PIPE": 124,
            "CLOSE_BRACE": 125,
            "TILDE": 126
        }
    };

    util.each(REMOTE.keyCode, function (item) {
        REMOTE.VKey[item.value] = keyboardVKey[item.key];
    });

    util.each(KEYBOARD_CHAR.keyCode, function (item) {
        KEYBOARD_CHAR.VKey[item.value] = keyboardVKey[item.key];
    });

    util.each(KEYBOARD_KEY.keyCode, function (item) {
        KEYBOARD_KEY.VKey[item.value] = keyboardVKey[item.key];
    });
    for (i = 65; i <= 90; i++) { // A-Z
        KEYBOARD_CHAR.VKey[i] = keyboardVKey[String.fromCharCode(i)];
        KEYBOARD_CHAR.keyCode[String.fromCharCode(i)] = i;
    }

    for (i = 97; i <= 122; i++) { // a-z
        KEYBOARD_CHAR.VKey[i] = keyboardVKey[String.fromCharCode(i).toUpperCase() + "_LOWER"];
        KEYBOARD_CHAR.keyCode[String.fromCharCode(i).toUpperCase() + "_LOWER"] = i;
    }

    for (i = 48; i <= 57; i++) { // 1-0
        key = "KEY_" + (i - 48);
        KEYBOARD_CHAR.VKey[i] = keyboardVKey[key];
        KEYBOARD_CHAR.keyCode[key] = i;
        REMOTE.keyCode[key] = i;
        REMOTE.VKey[i] = keyboardVKey[key];
    }



    return {
        "REMOTE": REMOTE,
        "KEYBOARD_KEY": KEYBOARD_KEY,
        "KEYBOARD_CHAR": KEYBOARD_CHAR
    };
});

define('css!xdk-ui-input/css/InputNativeImpl',[],function(){});
define("xdk-ui-input/InputNativeImpl", [
    "xdk-base/class",
    "xdk-base/Element",
    "xdk-base/util",
    "xdk-base/device",
    "xdk-base/console",
    "xdk-ax/evt/type",
    "xdk-base/device/shared/browser/keyMap",
    "xdk-base/core",
    "./interface/InputImpl",
    "css!./css/InputNativeImpl"
], function (
    klass,
    Element,
    util,
    device,
    console,
    evtType,
    keyMap,
    core,
    InputImpl
) {
    "use strict";

    return klass.create([InputImpl], {}, {
                __oldSamsung: device.platform === "samsung" && device.id.getFirmwareYear() <= 2011,
                __cursorPosition: null,
                __labelText: null,
                __inputState: false,
                __passwordTimer: null,
                __initEnvOnKey: false,
                __maxLength: 20,
                __isPassword: false,
                __passwordChar: null,
                __hideTimeout: 0,
                __widgetInstance: null,
                __input: null,
                __element: null,
                __placeHolder: null,
                __isSetPlaceHolder: false,
                init: function (opts) {
            var self = this,
                handleClickFunc, handleMouseOut, handleKeyFunc, samsungHandleKeyFunc, handleTextEditKeyFunc, checkDangerousKeyFunc, upKey = keyMap.KEYBOARD_KEY.keyCode.UP,
                downKey = keyMap.KEYBOARD_KEY.keyCode.DOWN,
                leftKey = keyMap.KEYBOARD_KEY.keyCode.LEFT,
                rightKey = keyMap.KEYBOARD_KEY.keyCode.RIGHT,
                insertKey = keyMap.KEYBOARD_KEY.keyCode.INSERT,
                delKey = keyMap.KEYBOARD_KEY.keyCode.DELETE,
                homeKey = keyMap.KEYBOARD_KEY.keyCode.HOME,
                endKey = keyMap.KEYBOARD_KEY.keyCode.END,
                pageUpKey = keyMap.KEYBOARD_KEY.keyCode.PAGE_UP,
                pageDownKey = keyMap.KEYBOARD_KEY.keyCode.PAGE_DOWN,
                tabKey = keyMap.KEYBOARD_KEY.keyCode.TAB,
                backspaceKey = keyMap.KEYBOARD_KEY.keyCode.BACKSPACE;
            //those keys on the keyboard suppose to be blocked and no default navigation/behvaiour on the input field
            opts = opts || {};

            opts.root.addClass("wgt-input-native");

            this.setMaxLength(util.isNumber(opts.maxLength) ? opts.maxLength : 20);
            this.__isPassword = opts.isPassword || false;
            this.__passwordChar = opts.passwordChar || "*";
            this.__hideTimeout = opts.hideTimeout || 0;
            this.__placeHolder = opts.placeHolder || "";

            this.__labelText = opts.text || "";
            this.__cursorPosition = this.__labelText.length;
            this.__widgetInstance = opts.widgetInstance;

            // Create div structure
            this.container = new Element("div");
            this.container.addClass("container");

            this.__input = new Element("input");


            this.__input.addClass("wgt-input-native-ele");
            //XDK-1838
            //since it is part of the implementation of the input and thus append the current container to the root instead of create a new root in the component
            opts.root.append(this.container);
            this.container.append(this.__input);
            this.__element = this.__input.getHTMLElement();
            this.setText(opts.text, true);

            checkDangerousKeyFunc = function (evt) {
                // checks dangerous keys that interacts with input. If there are any specific keys on the platforms, it needs to be included here
                switch (evt.keyCode) {
                case upKey:
                case downKey:
                case leftKey:
                case rightKey:
                case insertKey:
                case delKey:
                case homeKey:
                case endKey:
                case pageUpKey:
                case pageDownKey:
                case tabKey:
                case backspaceKey:
                    return true;
                default:
                    return false;
                }
            };
            // end of ugly keyboard related platform checking
            handleClickFunc = function (evt) {
                console.info("inputNativeImpl: mouse click; inputState: " + self.__inputState);


                util.defer().then(function () {
                    //to make the cursor to be position 0 when there is place holder
                    if (self.__isSetPlaceHolder) {
                        self.setCursorPos(0);
                    } else {
                        self.__updateCursorPosition();
                    }
                    self.startInput();
                }).done();
                return true;
            };
            handleMouseOut = function (evt) {
                console.info("inputNativeImpl: mouse out; inputState: " + self.__inputState);

                self.stopInput();
                return true;
            };
            handleKeyFunc = function (evt) {
                try {
                    evt.preventDefault();
                } catch (ex) {
                    ex.returnValue = false;
                }
                return true; // keep bubbling
            };
            handleTextEditKeyFunc = function (evt) {
                if (checkDangerousKeyFunc(evt)) { // catches dangerous keys that interacts with textarea
                    console.info("inputNativeImpl: blocking text edit key:" + evt.keyCode);
                    try {
                        evt.preventDefault();
                    } catch (ex) {
                        ex.returnValue = false;
                    }
                }
                return true; // keep bubbling
            };

            switch (device.platform) {
            case "samsung":
                if (device.id.getFirmwareYear() === 2010) {
                    console.debug("inputNativeImpl: samsung 2010 device detected, using special handler");
                    samsungHandleKeyFunc = function (evt) {
                        console.debug("inputNativeImpl: samsung workaround handler in action...");
                        // === all these should be in vain ===
                        try {
                            evt.preventDefault();
                        } catch (ex) {
                            ex.returnValue = false;
                        }
                        // === end ===
                        self.setText(self.__value, self.__cursorPosition);
                        return true; // return false won't work as well
                    };
                    this.__input.addEventListener("keydown", samsungHandleKeyFunc); //workaround
                    break;
                }
                            default:
                this.container.addEventListener("mousedown", handleClickFunc);
                this.container.addEventListener("mouseout", handleMouseOut);
                this.__input.addEventListener("keydown", handleTextEditKeyFunc);
                this.__input.addEventListener("keypress", handleKeyFunc);
                break;
            }

        },
                __addPlaceHolder: function () {
            this.__isSetPlaceHolder = true;
            //set the placeholder value into the input
            this.__element.value = this.__placeHolder;
            this.__input.addClass("placeholder");
            //make sure the cursor position to be at 0 position.
            this.__setRealCursorPos();
        },
                __removePlaceHolder: function () {
            this.__isSetPlaceHolder = false;
            this.__element.value = "";
            this.__input.removeClass("placeholder");
        },
                insertChar: function (ch, insertPos) {
            if (!this.__inputState || !ch) {
                return;
            }
            if (this.__labelText.length >= this.__maxLength) { // If length of __labelText reach maximum, do nothing, and return
                return;
            }

            insertPos = util.isUndefined(insertPos) ? this.__cursorPosition : insertPos;
            var t = this.getText();
            t = util.insert(t, insertPos, ch);
            this.__cursorPosition = this.__cursorPosition + ch.length;
            this.setText(t, undefined, true);

            //XDK-3083 Fail to update the cursor position and change the page automatically when typing in the edge in windows
            if (device.platform === "windows") {
                //workaround to move left and then right to force update the cursor position and view
                this.setCursorPos(this.__cursorPosition - 1);
                this.setCursorPos(this.__cursorPosition + 1);
            } else {
                this.__updateCursorPosition();
            }

            //in huawei device, it is unable to update the cursor position into new line when at the end of the text area
            this.__element.blur();
            this.__element.focus();
        },
                backspace: function () {
            if (!this.__inputState) {
                return;
            }
            if (this.__cursorPosition <= 0) { // If cursorPosition == 0, there must be no char before cursor, do nothing, and return
                return;
            }

            var text = this.getText(),
                newText = "";
            if (this.__cursorPosition === 1) { // Exception case when delete the first char while the string is have more than 1 char
                if (text.length > 1) {
                    newText = text.slice(this.__cursorPosition, text.length);
                }
            } else {
                if (text.length > 1) {
                    newText = text.slice(0, this.__cursorPosition - 1) + text.slice(this.__cursorPosition, text.length);
                }
            }
            this.__cursorPosition--;
            this.setText(newText, undefined, true);
            this.__updateCursorPosition();
            this.__setRealCursorPos();
        },
                del: function () {
            if (!this.__inputState) {
                return;
            }
            var text = this.getText(),
                newText = "";
            if (this.__cursorPosition >= text.length) { // If __cursorPosition == t.length, there must be no char after cursor, do nothing, and return
                return;
            }

            if (this.__cursorPosition === text.length - 1) { // Exception case when delete the last char
                newText = text.slice(0, text.length - 1);
            } else {
                newText = text.slice(0, this.__cursorPosition) + text.slice(this.__cursorPosition + 1, text.length);
            }
            this.setText(newText, undefined, true);
            this.__setRealCursorPos();
        },
                setMaxLength: function (l) {
            this.__maxLength = l;
        },
                getMaxLength: function () {
            return this.__maxLength;
        },
                getText: function () {
            return this.__labelText;
        },
                setText: function (text, forceNoTimeout, noUpdateCursorPosition) {

            // incorrect input
            if (util.isUndefined(text)) {
                return;
            }

            if (!text) {
                text = "";
            }

            //original has nothing and set text, it will first remove the placeHolder
            if (this.__placeHolder !== null && this.getText() === "" && text !== "") {
                this.__removePlaceHolder();
            }

            var textChanged = (text !== this.__labelText),
                len, wrapperText = "",
                i, isAddition, useTimeout, hideTextFn;
            if (text.length > this.__maxLength) {
                this.__cursorPosition = this.__maxLength;
            } else if (!noUpdateCursorPosition) {
                this.__cursorPosition = text.length;
            }
            text = util.truncate(text, this.__maxLength, "");
            if (this.__isPassword) {
                isAddition = text.length > this.__labelText.length; // we are having more characters or not
                useTimeout = (this.__hideTimeout > 0) && isAddition && !forceNoTimeout; // do we briefly show the last character before cursor or not
                this.__labelText = text;
                len = this.__labelText.length;

                if (this.__passwordTimer) {
                    util.clearDelay(this.__passwordTimer);
                    this.__passwordTimer = null;
                }

                for (i = 0; i < this.__cursorPosition - 1; i++) { // leave out the last character before cursor position
                    wrapperText += this.__passwordChar;
                }
                if (!useTimeout && this.__cursorPosition > 0) {
                    wrapperText += this.__passwordChar;
                } else if (text.length > 0 && this.__cursorPosition - 1 < text.length) {
                    wrapperText += text[this.__cursorPosition - 1];
                }

                for (i = 0; i < len - this.__cursorPosition; i++) { // fill the remaining characters
                    wrapperText += this.__passwordChar;
                }

                this.__setElementText(wrapperText);

                hideTextFn = util.bind(function () { // hide
                    wrapperText = "";
                    for (i = 0; i < this.__labelText.length; i++) {
                        wrapperText += this.__passwordChar;
                    }
                    this.__setElementText(wrapperText);
                    this.__updateCursorPosition();
                    this.__passwordTimer = null;
                }, this);

                if (useTimeout) {
                    this.__passwordTimer = core.getGuid();
                    util.delay(this.__hideTimeout, this.__passwordTimer).then(hideTextFn).done();
                } else {
                    hideTextFn();
                }

            } else {
                this.__setElementText(text);
            }

            this.__labelText = text;
            this.__labelTextCopy = util.truncate(this.__labelText, this.__cursorPosition, "");

            if (!noUpdateCursorPosition) {
                this.__updateCursorPosition();
            }

            if (textChanged && this.__widgetInstance) {
                this.__widgetInstance.dispatchEvent(evtType.TEXT_CHANGED, this.__labelText);
            }

            //if the text is empty, it will set the place holder
            if (this.__placeHolder !== null && text === "") {
                this.__addPlaceHolder();
            }

        },
                __setElementText: function (text) {
            text = util.truncate(text, this.__maxLength, "");

            if (!this.__isPassword) {
                this.__labelText = text;
            }

            this.__element.value = text;

            if (this.__inputState) {
                this.__element.blur();
                this.__element.focus();
            }
            this.__setRealCursorPos();
        },
                clearText: function () {
            this.setText("");
        },
                __updateCursorPosition: function () {
            //block the cursor update when place holder is set.
            if (this.__isSetPlaceHolder) {
                return;
            }

            var ctrl = this.__element,
                cursorPos = 0,
                selection;

            // IE 9+ and all other browsers
            if (ctrl.selectionStart || String(ctrl.selectionStart) === "0") {
                console.debug("InputNativeImpl: element has selectionStart");
                cursorPos = ctrl.selectionStart;
            }
            // IE 9+ and all other browsers (normally the above already works)
            else if (document.getSelection) {
                console.debug("InputNativeImpl: document has getSelection()");
                ctrl.focus();
                selection = document.getSelection().createRange();

                selection.moveStart("character", -ctrl.value.length);

                cursorPos = selection.text.length;
            }

            this.__cursorPosition = cursorPos;
            console.debug("InputNativeImpl: __updateCursorPos() reports cursor position is " + cursorPos);
            return cursorPos;
        },
                moveCursor: function (direction) {
            if (!this.__inputState) {
                return;
            }
            if (direction.toLowerCase() === "left") {
                this.setCursorPos(this.__cursorPosition - 1);
            } else if (direction.toLowerCase() === "right") {
                this.setCursorPos(this.__cursorPosition + 1);
            }
        },
                setCursorPos: function (pos) {
            if (pos > this.getText().length) {
                pos = this.getText().length;
            } else if (pos < 0) {
                pos = 0;
            }

            if (this.__cursorPosition !== pos) {
                this.__cursorPosition = pos;
                this.__setRealCursorPos();
            }
        },
                startInput: function () {
            this.__element.focus();
            this.__inputState = true;
            // update the cursor position when first enter input status for safe-guarding
            // because updating the cursor position during initialization may not work
            if (this.__inputStateFirstOn) {
                this.__inputStateFirstOn = false;
                this.setCursorPos(this.__cursorPosition);
            }

            // some browser (webkit for e.g.) may move the real cursor around when arrow keys are pressed, and no known way to prevent it, not even preventDefault...
            // so here added a work-around to force reset again the cursor position to the correct position
            util.defer().then(util.bind(this.__setRealCursorPos, this)).done();
        },
                __setRealCursorPos: function () {
            var pos = this.__cursorPosition,
                ctrl = this.__element,
                offset = 0,
                range;
            if (this.__oldSamsung) {
                console.debug("InputNativeImpl: samsung 2011 or 2010 device detected");

                ctrl.focus();

                ctrl.selectionStart = pos;
            }
            // Chrome, FF/Gecko, IE 9+, Opera 8+
            // Samsung maple
            else if (ctrl.setSelectionRange) {
                try {
                    ctrl.setSelectionRange(pos + offset, pos + offset);
                } catch (e) {
                    console.debug("inputNativeImpl: setSelectionRange() error:" + e.message);
                }
                // the native input will not reflect the selection change on the UI if the selection is not visible and the focus persists.
                // Here we blur the input and regain its focus so that the selection can be reflected correctly.
                // https://accedobroadband.jira.com/browse/XDK-2255
                ctrl.blur();
                ctrl.focus();
            }
            // IE and Opera under 10.5
            else if (ctrl.createTextRange) {
                console.debug("inputNativeImpl: element has createTextRange()");
                range = ctrl.createTextRange();
                range.collapse(true);
                range.moveEnd("character", pos);
                range.moveStart("character", pos);
                range.select();
            }
        },
                stopInput: function () {
            this.__element.blur();
            this.__inputState = false;
        },
                isCapturing: function () {
            return this.__inputState;
        },
                deinit: function () {
            this.container.deinit();
            this.__input.deinit();
        }
    });
});
define("xdk-ui-input/interface/InputDisplay", ["xdk-base/Interface"], function(Interface) {
    "use strict";
    return Interface.create("InputDisplay", {
                insertChar: ["char", "insertPos"],
                backspace: [],
                del: [],
                setMaxLength: ["length"],
                getMaxLength: [],
                getText: [],
                setText: ["text"],
                clearText: [],
                moveCursor: ["direction"],
                setCursorPos: ["pos"],
                startInput: [],
                stopInput: [],
                isCapturing: []
    });
});
define('xdk-ui-input/InputBase',[
    "xdk-base/class",
    "./interface/InputDisplay",
    "xdk-base/Element",
    "xdk-base/device",
    "xdk-base/util",
    "./InputDivImpl",
    "./InputNativeImpl",
    "xdk-base/Env",
    "xdk-ax/evt/type",
    "xdk-ax/Component"
], function (
    klass,
    IInput,
    Element,
    device,
    util,
    InputDivImpl,
    InputNativeImpl,
    Env,
    evtType,
    Component
) {
    "use strict";

    return klass.create(Component, [IInput], {}, {
                __impl: null,
                __initEnvOnKey: false,
                __bindedOnKey: null,
                __blockedKeyList: [],
        init: function (opts) {
            opts = opts || {};

            opts.text = opts.text || "";
            opts.isPassword = opts.isPassword || false;
            opts.focusable = opts.focusable || false;
            opts.placeHolder = opts.placeHolder || "";


            if (util.isUndefined(opts.clickable)) {
                opts.clickable = true; // default clickable
            }

            opts.passwordChar = opts.passwordChar || "*";
            opts.hideTimeout = opts.hideTimeout || 0;

            opts.root = new Element("div");
            opts.widgetInstance = this; // internal implementation needs the for event firing, as this is the "real component"

            if (util.isUndefined(opts.useNative)) {
                opts.useNative = true;
            }

            switch (device.platform) {
            case "tizen":
            case "toshiba":
            case "ps3":
            case "playstation":
            case "sony":
            case "panasonic":
            case "humax":
                // the above will bring up the IME keyboard
            case "wiiu":
                // wii brings up software keyboard, it doesn't work well with our native implementation
            case "tcl":
            case "hisense":
            case "amazon":
            case "android":
                // android device not support native because it will pop up a IME keyboard which may mess up with the natvie input.   
            case "sharp":
            case "opera":
            case "webos":
                // webos devices are not compatible with the IME. if use IME and then use input api, it will mess up the input.
                opts.useNative = false;
                break;
            case "samsung":
                if (device.id.getFirmwareYear() <= 2011) {
                    opts.useNative = false;
                    break;
                }
                // 2012 use native implementation
            }

            this.__bindedOnKey = util.bind(function (obj) {
                //to ignore the blocked key
                if (this.__blockedKeyList.indexOf(obj.id) > -1) {
                    return true;
                }

                // to perform action when there is text inside
                if (this.isCapturing() && obj.text) {
                    this.insertChar(obj.text);
                }

                return true;
            }, this);

            this._super(opts);
        },
                addBlockedKey: function (key) {
            var curBlockedKeyList = [];

            if (util.isString(key)) {
                curBlockedKeyList.push(key);
            } else if (util.isArray(key)) {
                curBlockedKeyList = key;
            }

            util.each(curBlockedKeyList, util.bind(function (item) {
                if (this.__blockedKeyList.indexOf(item) === -1) {
                    this.__blockedKeyList.push(item);
                }
            }, this));
        },
                removeBlockedKey: function (key) {
            var removeBlockedKeyList = [];

            if (util.isString(key)) {
                removeBlockedKeyList.push(key);
            } else if (util.isArray(key)) {
                removeBlockedKeyList = key;
            }

            util.each(removeBlockedKeyList, util.bind(function (item) {
                var position = this.__blockedKeyList.indexOf(item);

                if (position > -1) {
                    this.__blockedKeyList.splice(position, 1);
                }
            }, this));
        },
                setBlockedKey: function (key) {
            this.__blockedKeyList = [];
            this.addBlockedKey(key);
        },
                insertChar: function (ch, insertPos) {
            this.__impl.insertChar(ch, insertPos);
        },
                backspace: function () {
            this.__impl.backspace();
        },
                del: function () {
            this.__impl.del();
        },
                setMaxLength: function (l) {
            this.__impl.setMaxLength(l);
        },
                getMaxLength: function () {
            return this.__impl.getMaxLength();
        },
                getText: function () {
            return this.__impl.getText();
        },
                setText: function (text) {
            this.__impl.setText(text);
        },
                clearText: function () {
            this.__impl.clearText();
        },
                setSelection: function () {
            this.getRoot().addClass("selected");
        },
                removeSelection: function () {
            this.getRoot().removeClass("selected");
        },
                isSelected: function () {
            return this.getRoot().hasClass("selected");
        },
                moveCursor: function (direction) {
            this.__impl.moveCursor(direction);
        },
                setCursorPos: function (pos) {
            var len = this.getText().length;
            if (pos > len) {
                pos = len;
            } else if (pos < 0) {
                pos = 0;
            }
            this.__impl.setCursorPos(pos);
        },
                startInput: function () {
            this.getRoot().addClass("input");
            this.__impl.startInput();

            //only add at the first time startInput and remove when deinit the instance
            if (!this.__initEnvOnKey) {
                var sEnv = Env.singleton();
                sEnv.addEventListener(sEnv.EVT_ONKEY, this.__bindedOnKey);
                this.__initEnvOnKey = true;
            }
        },
                stopInput: function () {
            this.getRoot().removeClass("input");
            this.__impl.stopInput();

            // remove the onKey event handler
            var sEnv = Env.singleton();
            sEnv.removeEventListener(sEnv.EVT_ONKEY, this.__bindedOnKey);
            this.__initEnvOnKey = false;
        },
                isInput: function () {
            return this.isCapturing();
        },
                isCapturing: function () {
            return this.__impl.isCapturing();
        },
                deinit: function () {
            // Remove sEnv.EVT_ONKEY EventListener
            this.stopInput();
            //perform the input deinit and the implmentation deinit like elements
            this._super();
            this.__impl.deinit();
        }
    });
});
define('xdk-ui-input/Input',[
    "xdk-base/class",
    "xdk-base/Element",
    "xdk-base/device",
    "xdk-base/util",
    "./InputDivImpl",
    "./InputNativeImpl",
    "xdk-base/Env",
    "xdk-ax/evt/type",
    "xdk-ui-input/InputBase"
], function (
    klass,
    Element,
    device,
    util,
    InputDivImpl,
    InputNativeImpl,
    Env,
    evtType,
    InputBase
) {
    "use strict";

    return klass.create(InputBase, {}, {
        init: function (opts) {
            opts = opts || {};
            opts.maxLength = util.isNumber(opts.maxLength) ? opts.maxLength : 20;
            opts.css = (!opts.css) ? "wgt-input" : opts.css + " wgt-input";

            this._super(opts);

            opts.root.addClass("wgt-input");

            // useNative to override or default
            if (!opts.useNative) {
                this.__impl = new InputDivImpl(opts);
            } else {
                this.__impl = new InputNativeImpl(opts);
            }
        }
    });
});
/**
 * Extending the XDK Input, to support for LG native keyboard.
 *
 * Input widget is an input field where the user can enter data.
 * There are two implementations in the input widget.
 *
 * 1. InputDiv use the div to enter the data
 * 2. InputNative use the input tag as an input field and then enter the data
 *
 *
 * Input will listen to the sEnv onKey event.It inputs the text when its state is startInput and the key value from the key event has an attribute called text.
 * So it will automatically update the display of the input without any handling. It should be worked in both hard keyboard and keyboard widget.
 *
 * In fact, when clicking the button within the keyboard widget, it will dispatch the key event with the text attribute.
 * After that, Input will then receive the event and insert the character when in startInput state.
 *
 * There are two states in the input (which are capturing and non-capturing state)
 * startInput will change the input to capturing state that allows char insert.
 * stopInput will change into the non-capturing state that disable char insert.
 *
 * @class tvedemo/ext/ui/input/Input
 * @extends ax/ext/ui/input/Input
 * @param {Object} opts The options object
 * @param {String} opts.text The preset text to use
 * @param {Boolean} opts.isPassword To set the value shown to be password which make use of the opts.passwordChar
 * @param {Number} opts.maxLength The available length to be entered in the input.Default is 20
 * @param {String} opts.passwordChar The char to use when it is password. Default is "*"
 * @param {Number} opts.hideTimeout The time to hide the character to the passwordChar.
 * @param {Boolean} opts.useNative To use the native impl.
 *
 */
define("tvedemo/ext/ui/input/Input", [
    "xdk-ui-input/Input", 
    "xdk-base/class", 
    "xdk-ui-input/interface/InputDisplay", 
    "xdk-base/Element", 
    "xdk-base/device", 
    "xdk-base/util", 
    "xdk-ui-input/InputDivImpl", 
    "xdk-ui-input/InputNativeImpl", 
    "xdk-base/Env", 
    "xdk-ax/evt/type", 
    "xdk-ax/Component"
], function (
    Input, 
    klass, 
    IInput, 
    Element, 
    device, 
    util, 
    InputDivImpl, 
    InputNativeImpl, 
    Env, 
    evtType, 
    Component
) {
    "use strict";
    
    return klass.create(Input, {}, {
        
        init: function(opts) {
            opts = opts || {};
            
            switch (device.platform) {
                case "lg":
                    opts.useNative = false; // false to disable it
                    break;
            }
            opts.useNative = false;
            
            this._super(opts);
        }
        
    });
});
define("xdk-ui-basic/Image", [
    "xdk-base/class",
    "xdk-ax/Component",
    "xdk-base/Element",
    "xdk-base/util",
    "xdk-ax/mvc/ModelRef",
    "xdk-base/promise"
], function (
    klass,
    Component,
    Element,
    util,
    ModelRef,
    promise
) {
    "use strict";
    return klass.create(Component, {}, {
                __setSrcDeferred: null,
                __imageNode: null,
                __loadHandlerRef: null,
                __errorHandlerRef: null,
                __url: null,
                __alt: null,
                __errorImg: null,
                __errorCallback: null,
                __counter: 0,
                __lastModelRef: {
            src: null,
            alt: null,
            errorImg: null
        },
                __modelListener: {
            src: null,
            alt: null,
            errorImg: null
        },
                init: function (opts) {
            opts = opts || {};
            opts.src = opts.src || "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
            opts.alt = opts.alt || "";
            opts.errorImg = opts.errorImg || "";

            opts.root = new Element("img");

            this._super(opts);

            this.__imageNode = this.getRoot().getHTMLElement();
            this.__loadHandlerRef = util.bind(this.__loadHandler, this);
            this.__errorHandlerRef = util.bind(this.__errorHandler, this);

            this.setSrc(opts.src);
            this.setAlt(opts.alt);
            this.setErrorImg(opts.errorImg);

            this.__addEvents();
        },
                setSrc: function (src) {
            //cancel the previous deferObj and remove the previous events
            if (this.__setSrcDeferred) {
                this.__setSrcDeferred.promise.cancel("Set another source and cancel the previous image.");
                this.__setSrcDeferred = null;
            }

            this.__setSrcDeferred = promise.defer();
            this.__modelHandling("src", util.bind(this.__setSrcFunc, this), src);
            return this.__setSrcDeferred.promise;
        },
                __addEvents: function () {
            this.__imageNode.addEventListener("error", this.__errorHandlerRef);
            this.__imageNode.addEventListener("load", this.__loadHandlerRef);
        },
                __removeEvents: function () {
            this.__imageNode.removeEventListener("error", this.__errorHandlerRef);
            this.__imageNode.removeEventListener("load", this.__loadHandlerRef);
        },
                __errorHandler: function (evt) {
            this.__setSrcDeferred.reject({
                message: "Error in image loading",
                evt: evt
            });
        },
                __loadHandler: function (evt) {
            this.__setSrcDeferred.resolve({
                message: "image loaded",
                evt: evt
            });
        },
                __setSrcFunc: function (src) {
            this.__url = src;
            this.getRoot().attr("src", src);
            this.__counter = 0;
        },
                getSrc: function () {
            return this.__url;
        },
                setAlt: function (alt) {
            this.__modelHandling("alt", util.bind(this.__setAltFunc, this), alt);
        },
                __setAltFunc: function (alt) {
            this.__alt = alt;
            this.getRoot().attr("alt", alt);
        },
                getAlt: function () {
            return this.__alt;
        },
                setErrorCallback: function (cb) {
            if (cb && util.isFunction(cb)) {
                this.__errorCallback = cb;
                this.getRoot().getHTMLElement().onerror = this.__errorCallback;
                this.__errorImg = null;
                this.__counter = 0;
            }
        },
                resetErrorCallback: function () {
            //to rest the counter to 0
            this.__counter = 0;
            this.__errorCallback = null;
            if (this.__errorImg) {
                this.getRoot().getHTMLElement().onerror = util.bind(function () {
                    //to avoid setting errorImg and error again which cause deadlock, so just set once when failure.
                    if (!this.__counter) {
                        this.getRoot().attr("src", this.__errorImg);
                        this.__counter++;
                    }
                }, this);
            } else {
                this.getRoot().getHTMLElement().onerror = null;
            }
        },
                setErrorImg: function (value) {
            this.__modelHandling("errorImg", util.bind(this.__setErrorImgFunc, this), value);
        },
                __setErrorImgFunc: function (value) {
            if (value) {
                this.__errorImg = value;
            }
            this.resetErrorCallback();
        },
                __modelHandling: function (field, func, value) {
            // remove listener from last model reference
            if (this.__lastModelRef[field] && this.__modelListener[field]) {
                this.__lastModelRef[field].getModel().off("change:" + this.__lastModelRef[field].getAttr(), this.__modelListener[field]);
                this.__lastModelRef[field] = null;
            }

            if (!util.isString(value) && value instanceof ModelRef) {
                this.__lastModelRef[field] = value;
                if (!this.__modelListener[field]) {
                    this.__modelListener[field] = function (evt) {
                        func(evt.newVal);
                    };
                }
                value.getModel().on("change:" + value.getAttr(), this.__modelListener[field]);
                value = value.getVal();
            }
            func(value);
        },
                deinit: function () {
            //setting source to be empty will cause an error, remove those events first
            this.getRoot().getHTMLElement().onerror = null;
            this.__removeEvents();
            
            //set the source empty
            this.getRoot().attr("src", "");
            
            if (this.__setSrcDeferred) {
                this.__setSrcDeferred.promise.cancel("Deinit the image");
                this.__setSrcDeferred = null;
            }
            
            this.__imageNode = null;
            this.__loadHandlerRef = null;
            this.__errorHandlerRef = null;
            this._super();
        }
    });
});

/**
 * Image inherits the XDK "xdk-ui-basic/Image" class
 * It adds support for placeholder/placeholderPromise if the src image
 * cannot be loaded
 *
 * @name Image
 * @class storm/wgt/Image
 * @extends ax/ext/ui/Image
 */
define("storm/wgt/Image", [
    "xdk-base/class",
    "xdk-ui-basic/Image",
    "xdk-base/util",
    "xdk-base/promise"
], function (
    klass,
    Image,
    util,
    promise
    ) {

    "use strict";

    var TRANSPARENT_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAA1JREFUCNdjYGBgMAYAADgANNF/knAAAAAASUVORK5CYII=";

    return klass.create(Image, {}, {

        init: function (opts) {
            this._super(opts);
            opts.placeHolder = opts.placeHolder || TRANSPARENT_IMAGE;
            this._opts = opts;
            this.setErrorCallback(util.bind(this.fallback, this));
            this.setSrc(opts.src);
        },

        setSrc: function(src) {
            if (!this.getRoot()) {
                return promise.resolve();
            }
            return this._super(src);
        },

        fallback: function() {
            // we don't want any error handling here as we will do it ourselves
            this.resetErrorCallback();
            // to prevent any icon "not found" let's hide the image until we resolve this
            this.getRoot().getHTMLElement().style.visibility = "hidden";
            var showImage = util.bind(function() {
                    this.getRoot().getHTMLElement().style.visibility = "visible";
                }, this),
                loadDefaultImage = util.bind(function() {
                    return this.setSrc(this._opts.placeHolder).then(showImage);
                }, this),
                fallbackPromise;
            // if a placeholder promise is provided, we try to fetch the image
            if (this._opts.placeHolderPromise) {
                fallbackPromise = this._opts.placeHolderPromise().then(util.bind(function(url) {
                    return this.setSrc(url).then(showImage, loadDefaultImage);
                }, this));
            }
            // the placeholder failed, load a transparent image
            else {
                fallbackPromise = loadDefaultImage();
            }

            return fallbackPromise.then(util.bind(function() {
                // once the error handling is over we restore our error callback
                this.setErrorCallback(this.fallback);
            }, this));
        }
    });
});

/**
 * An image button widget.
 * @name ImageButton
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/ImageButton
 * @param {Object} opts The options object
 * @param {String} opts.src the image src url
 */
define("tvedemo/wgt/ImageButton", [
    "xdk-base/class",
    "xdk-ax/Container",
    "xdk-base/Element",
    "storm/wgt/Image",
    "xdk-ui-basic/Label",
    "xdk-base/util",
    "xdk-ax/evt/type"
], function (
    klass,
    Container,
    Element,
    Image,
    Label,
    util,
    evtType) {

    "use strict";

    return klass.create(Container, {}, {
        /**
         * The internal image widget to show button text
         * @protected
         * @name __image
         * @memberof tvedemo/wgt/ImageButton#
         */
        __image: null,
        /**
         * The internal label widget to show button text
         * @protected
         * @name __text
         * @memberof tvedemo/wgt/ImageButton#
         */
        __text: null,
        /**
         * override parent"s init() method
         * @method
         * @memberof  tvedemo/wgt/ImageButton#
         * @protected
         */
        init: function (opts) {
            opts.focusable = true;
            opts.clickable = true;
            opts.root = opts.root || new Element("div");
            opts.src = opts.src || "";
            opts.isPureText = opts.isPureText || false;

            this._super(opts);

            this.getRoot().addClass("wgt-imageButton");

            this.__image = new Image({
                css: "image",
                src: opts.src,
                parent: this,
                placeHolder: opts.placeHolder,
                placeHolderPromise: opts.placeHolderPromise
            });

            if (opts.text) {
                this.__label = this.__createLabel(opts.text, opts.isPureText);
            }

        },
        __createLabel: function (text, isPureText) {
            return new Label({
                text: text,
                css: "text",
                isPureText: isPureText,
                parent: this
            });
        },
        /**
         * Set the button text
         * @param {String} text of the button
         * @method setText
         * @public
         * @memberof tvedemo/wgt/ImageButton#
         */
        setText: function (text, isPureText) {

            if (!this.__text) {
                this.__text = this.__createLabel(text, isPureText);
            }

            this.__text.setText(text, isPureText);
        },
        /**
         * Set the button text
         * @return {String} text of the button
         * @method getText
         * @public
         * @memberof tvedemo/wgt/ImageButton#
         */
        getText: function () {
            if (!this.__text) {
                return null;
            }
            return this.__text.getText();
        },
        /**
         * Set the button image src
         * @param {String} url of the button
         * @method setSrc
         * @public
         * @memberof tvedemo/wgt/ImageButton#
         */
        setSrc: function (url) {
            this.__image.setSrc(url);
        },

        fallback: function () {
            this.__image.fallback();
        },
        
        /**
         * Get the button image src
         * @return {String} url of the button
         * @method getSrc
         * @public
         * @memberof tvedemo/wgt/ImageButton#
         */
        getSrc: function () {
            return this.__image.getSrc();
        },
        /**
         * Disable the button and add greyed out styling.
         * @return {void}
         */
        inactivate: function () {
            this._inactivated = true;
            this.addClass("button-inactivated");
            this.disable();
        },
        /**
         * Enable the button and remove greyed out styling.
         * @return {void}
         */
        activate: function () {
            this._inactivated = false;
            this.removeClass("button-inactivated");
            this.enable();
        },
        /**
         * Get the activation state of the button.
         * @return {Boolean} True if button is inactivated, false if button is activated.
         */
        isInactive: function () {
            return this._inactivated;
        },
        onDispatchEvent: function(type) {

            if (type === evtType.CLICK) {

                if (this._inactivated) {
                    return false;
                }
            }

            return true;
        }
    });
});
/*globals IMEShell_Common */
/* The above line is only to prevent JSHint from compaining about the Samsung-specific IMEShell_Common method */
define("tvedemo/wgt/Keyboard",
    [
        "xdk-base/class",
        "xdk-base/Env",
        "xdk-ax/Container",
        "xdk-base/Element",
        "xdk-ui-input/Keyboard",
        "tvedemo/ext/ui/input/Input",
        "xdk-ui-basic/Label",
        "xdk-ui-basic/Layout",
        "tvedemo/wgt/ImageButton",
        "xdk-base/device",
        "xdk-base/util",
        "xdk-ax/mvc/view",
        "xdk-ax/evt/type",
        "xdk-base/console",
        "xdk-base/core",
        "xdk-base/config",
        "xdk-base/promise"
    ],
    function(
        klass,
        Env,
        Container,
        Element,
        Keyboard,
        Input,
        Label,
        Layout,
        ImageButton,
        device,
        util,
        view,
        evtType,
        console,
        core,
        config,
        promise
        ) {

        "use strict";

        var sEnv = Env.singleton(),
            KEYBOARD_KEYS = {
                ENTER: "keyboard:enter",
                SEARCH: "keyboard:search",
                DELETE: "keyboard:delete",
                LEFT_ARROW: "keyboard:left-arrow",
                RIGHT_ARROW: "keyboard:right-arrow",
                CAPS_TO_SMALL: "keyboard:FromABCToabc",
                SMALL_TO_CAPS: "keyboard:FromabcToABC",
                NUMBER_TO_SMALLABC: "keyboard:FromNumberToabc",
                NUMBER_TO_ABC: "keyboard:FromNumberToABC",
                ABC_TO_NUMBER: "keyboard:FromABCToNumber",
                SMALLABC_TO_NUMBER: "keyboard:FromabcToNumber",
                ABC: "keyboard:ABC"
            };

        return klass.create(Container, {        

        }, {
            init: function(opts) {
                opts.css = opts.css || "overlay-keyboard";
                this._super(opts);

                this.__keyboardReadyDefer = promise.defer();
                this.opts = opts;

                if (device.platform === "samsung" && device.id.getFirmwareYear() > 2011) {

                    //
                    // Require the needed Samsung IME parts.
                    // Note that this is asynchronous, hence __keyboardReadyDefer required.
                    //
                    amd.require(["$MANAGER_WIDGET/Common/IME_XT9/ime.js", "$MANAGER_WIDGET/Common/IME_XT9/inputCommon/ime_input.js"], util.bind(function() {
                        console.log("Keyboard require succeeded");
                        //create samsung needed parts
                        this._setupSamsungKeyboard(opts);
                        this.__keyboardReadyDefer.resolve("Requires are satisfied");
                    }, this), function(e) {
                        // This should never happen, fingers crossed
                        console.log("Keyboard require failed: " + e);
                        this.__keyboardReadyDefer.reject();
                    });
                } else {
                    this._createKeyboard(opts);
                    this.__keyboardReadyDefer.resolve("Immediately resolved");
                }

                this.hide();
            },

            getReadyPromise: function() {
                return this.__keyboardReadyDefer.promise;
            },

            /**
             * Placeholder for the on close callback.
             */
            _onCloseCallback: function() {
                console.log("on keyboard close");
            },

            /**
             * Placerholder for on text change callback.
             */
            _onTextChange: function() {
                console.log("text changed");
            },

            /**
             * Sets the on text change callback.
             * This will be called upon text change in the keyboard.
             * 
             * @param {function} onTextChange The callback function for when the text changes.
             */
            setOnTextChange: function(onTextChange) {
                this._onTextChange = onTextChange;
            },

            /**
             * Sets the callback function for when the keyboard is closed.
             * @param {function} onClose Callback function for when the keyboard closes.
             */
            setOnClose: function(onClose) {
                this._onCloseCallback = onClose;
            },

            /**
             * This function will hide the keyboard.  It will be called when "search" or back key is pressed.
             */
            onClose: function() {
                this.hideKeyboard();
                //this._onCloseCallback();
            },

            /**
             * Creates the on screen keyboard using XDK keyboard widget.
             */
            _createKeyboard: function(opts) {
                opts = opts || {};
                var maxLength   = typeof(opts.maxLength) === "undefined" ? 100 : opts.maxLength;
                var isPassword  = typeof(opts.isPassword) === "undefined" ? false : opts.isPassword;
                var inputCss    = typeof(opts.inputCss) === "undefined" ? "keyboard-input" : opts.inputCss;
                var keyboardCss = inputCss === "keyboard-input" ? "onscreen-keyboard" : "onscreen-"+inputCss;
                
                var container = view.render({
                    klass: Container,
                    id: "keyboardContainer",
                    css: "keyboard-container",
                    forwardFocus: true,
                    children: [{
                        klass: Input,
                        id: "input",
                        css: inputCss,
                        maxLength: maxLength,
                        isPassword: isPassword,
                        clickable: false,
                        focusable: false
                    }, {
                        klass: Keyboard,
                        id: "kb",
                        css: keyboardCss,
                        keyMaps: {
                            "default": [
                                ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "", {
                                    display: new ImageButton({
                                        src: "img/keyboard/delete.png",
                                        id: "#keyDelete"
                                    }),
                                    keyId: "keyboard:delete"
                                }],
                                ["q", "w", "e", "r", "t", "z", "u", "i", "o", "p", "", "*"],
                                ["a", "s", "d", "f", "g", "h", "j", "k", "l", "", "", "@"],
                                ["y", "x", "c", "v", "b", "n", "m", ",", ".", "?", "!", "-"],
                                [{
                                    display: "Leertaste",
                                    input: " ",
                                    colSpan: 6
                                }, {
                                    display: "Eingabe" /* "search" */,
                                    keyId: "keyboard:search",
                                    colSpan: 4
                                }, {
                                    display: new ImageButton({
                                        src: "img/keyboard/left-arrow.png"
                                    }),
                                    keyId: "keyboard:left-arrow"
                                }, {
                                    display: new ImageButton({
                                        src: "img/keyboard/right-arrow.png"
                                    }),
                                    keyId: "keyboard:right-arrow"
                                }]
                            ],
                            "capital": [
                                ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "", {
                                    display: new ImageButton({
                                        src: "img/keyboard/delete.png",
                                        id: "#keyDelete"
                                    }),
                                    keyId: "keyboard:delete"
                                }],
                                ["Q", "W", "E", "R", "T", "Z", "U", "I", "O", "P", "", "^", "*"],
                                ["A", "S", "D", "F", "G", "H", "J", "K", "L", "", "", "~", "@"],
                                ["Y", "X", "C", "V", "B", "N", "M", ",", ".", "?", "!", "-", {
                                    display: new ImageButton({
                                        src: "img/keyboard/enter.png"
                                    }),
                                    keyId: "keyboard:enter"
                                }],
                                [{
                                    display: "abc",
                                    keyId: "keyboard:FromABCToabc"
                                }, {
                                    display: "12#",
                                    keyId: "keyboard:FromABCToNumber"
                                }, {
                                    display: "Leertaste",
                                    input: " ",
                                    colSpan: 2
                                }, {
                                    display: "search",
                                    keyId: "keyboard:search",
                                    colSpan: 2
                                }, {
                                    display: new ImageButton({
                                        src: "img/keyboard/left-arrow.png"
                                    }),
                                    keyId: "keyboard:left-arrow"
                                }, {
                                    display: new ImageButton({
                                        src: "img/keyboard/right-arrow.png"
                                    }),
                                    keyId: "keyboard:right-arrow"
                                }]
                            ],
                            "number": [
                                ["0", "1", "2", "3", "4"],
                                ["5", "6", "7", "8", "9"],
                                [{
                                    display: "Eingabe" /* "search" */,
                                    keyId: "keyboard:search",
                                    colSpan: 4
                                }, 
                                {
                                    display: new ImageButton({
                                        src: "img/keyboard/delete.png",
                                        id: "#keyDelete"
                                    }),
                                    keyId: "keyboard:delete"
                                }]
                                /*
                                ["1", "2", "3", "4", "5", "6"],
                                ["7", "8", "9", "0", ":", ";"],
                                [".", ",", "?", "!", "'", "\""],
                                ["@", "&", "$", "#", "(", ")"],
                                ["-", "\\", {
                                    display: new ImageButton({
                                        src: "img/keyboard/delete.png"
                                    }),
                                    keyId: "keyboard:delete"
                                }, {
                                    display: new ImageButton({
                                        src: "img/keyboard/enter.png"
                                    }),
                                    keyId: "keyboard:enter"
                                }],
                                [{
                                    display: "ABC",
                                    keyId: "keyboard:FromNumberToABC"
                                }, {
                                    display: "abc",
                                    keyId: "keyboard:FromNumberToabc",
                                    defaultFocus: true
                                }, {
                                    display: "space",
                                    input: " ",
                                    colSpan: 2
                                }, {
                                    display: "search",
                                    keyId: "keyboard:search",
                                    colSpan: 2
                                }]
                                */
                            ]
                        }
                    }]
                });

                this.attach(container);

                this.keyboard = container.find("kb");
                this.keyboardInputField = container.find("input");

                // This should be tweaked later on
                // This is needed so the focus doesn't automagically jump away from the keyboard.

                this.keyboard.onEdge = function(direction, pos) {
                    console.log(arguments);
                    if (direction === "nextDown") {
                        return true;
                    }
                    return false;
                };
                // Listen to text change on the keyboard input field.
                this.keyboardInputField.__impl.addEventListener = undefined;

                this._setupKeyboardHandling();
            },

            /**
             * Show suggestions for samsung native keyboard.
             * @param  {object} suggestions containing settings for the suggestion to be displayed.
             *                               e.g {request : "searchtext", items : ["search text", "search for this instead"]}
             *                               will display the items as suggestions.
             */
            showSuggestions: function(suggestions) {
                console.log("show suggestions");
                if (device.platform === "samsung") {
                    this.imeBox.showAutoCompletePopup(suggestions);
                }
            },

            /**
             * Shows the keyboard
             */
            showKeyboard: function(opts) {
                if (this.imeBox) {

                    if (this.keyboardInputField && opts.text) {
                        this.keyboardInputField.value = opts.text;
                    }

                    this.imeBox.onShow();
                } else {
                    
                    if (typeof(opts.keyMap) !== 'undefined')
                    {
                        this.keyboard.switchKeyMap(opts.keyMap);
                    }

                    this.show();

                    if (this.keyboardInputField && opts.text) {
                        this.keyboardInputField.setText(opts.text);
                    }
                }
            },

            /**
             * [hideKeyboard description]
             * @return {[type]} [description]
             */
            hideKeyboard: function() {
                if (this.imeBox) {
                    document.getElementById("samsungTextInputField").value = "";
                    this.imeBox.onClose();
                    sEnv.removeEventListener(sEnv.EVT_ONUNLOAD, util.bind(function() {
                        this.imeBox.onClose();
                    }, this));
                } else {
                    this.keyboardInputField.setText("");
                    this.hide();
                }
            },

            setInputName: function(name) {
                if (device.platform === "samsung") {
                    this.imeBox.inputTitle = name;
                }
            },
            
            /**
             * Creates a samsung native keyboard.
             * @param  {object} opts Additional settings for the keyboard. e.g inputTitle
             */
            _setupSamsungKeyboard: function(opts) {

                var samsungInputField = document.getElementById("samsungTextInputField");

                if(samsungInputField) {
                    samsungInputField.parentNode.removeChild(samsungInputField);
                }
                
                // samsungTextInputFied needs to be recreated every time so that type can be set.
                // type can be changed from text to password, but not password to text..
                var inputType = opts.type ? opts.type : "text";
                var maxLength = inputType === "password" ? 4 : config.get("samsungMaxInputLength", 100);
                samsungInputField = new Element("input", {
                    id: "samsungTextInputField",
                    css: "samsungTextInputField",
                    type: inputType,
                    maxlength: maxLength
                },
                    core.root.document.body
                );
                samsungInputField = samsungInputField.getHTMLElement();

                this.imeBox = new IMEShell_Common();

                // This is needed for samsung 2013 to make sure the keyboard is closed if exiting the app by using source / smarthub key.
                sEnv.addEventListener(sEnv.EVT_ONUNLOAD, util.bind(function() {
                    this.imeBox.onClose();
                }, this));

                this.imeBox.inputTitle = this.opts.inputTitle || "Input Title";
                this.imeBox.inputboxID = "samsungTextInputField";
                this.imeBox.setUseShowHidePasswordMenu(false);
                this.keyboardInputField = samsungInputField;

                this.imeBox.onKeyPressFunc = util.bind(function(key, str, id) {
                    console.log("ONKEYPRESSFUNC: " + key + ", " + str);
                    switch (key) {
                        case (29443):
                            // Enter Key
                            this._onCloseCallback(str);
                            this.hideKeyboard();
                            break;
                        case (222):
                            this.hideKeyboard();
                            break;
                        case (88):
                            //return
                        case (45):
                            //exit
                            this.hideKeyboard();
                            this._onCloseCallback(false);
                            break;
                    }
                }, this);

                // It's needed to override this function if you want to handle search suggestion by yourself and disable the default suggestions.
                this.imeBox.onCompleteFunc = function(value) {
                    console.log("onCompleteFunc: " + value);
                };

                this.imeBox.onTextChangeFunc = util.bind(function(value) {
                    console.log("onTextChangeFunc: " + value);
                    if (this._onTextChange) {
                        this._onTextChange(value);
                    }
                }, this);

                this.imeBox.onClose();

            },

            /**
             * Setup event handling for the xdk keyboard
             */
            _setupKeyboardHandling: function() {

                this.keyboardInputField.startInput();

                this.keyboard.onHandler = util.bind(function(id) {
                    
                    var info = id;
                    switch (info) {
                        // Do the actual search here.
                        case KEYBOARD_KEYS.ENTER:
                        case KEYBOARD_KEYS.SEARCH:
                            this._onCloseCallback(this.keyboardInputField.getText());
                            this.onClose();
                            break;

                        case KEYBOARD_KEYS.DELETE:
                            this.keyboardInputField.backspace();
                            break;

                        case KEYBOARD_KEYS.LEFT_ARROW:
                            this.keyboardInputField.moveCursor("left");
                            break;

                        case KEYBOARD_KEYS.RIGHT_ARROW:
                            this.keyboardInputField.moveCursor("right");
                            break;


                        case KEYBOARD_KEYS.FromABCToabc:
                            this.keyboard.setFocusPosition("default", [5, 0]);
                            this.keyboard.switchKeyMap("default");
                            break;

                        case KEYBOARD_KEYS.SMALL_TO_CAPS:
                            this.keyboard.setFocusPosition("capital", [5, 0]);
                            this.keyboard.switchKeyMap("capital");
                            break;

                        case KEYBOARD_KEYS.NUMBER_TO_SMALLABC:
                            this.keyboard.setFocusPosition("default", [5, 1]);
                            this.keyboard.switchKeyMap("default");
                            break;
                        case KEYBOARD_KEYS.NUMBER_TO_ABC:
                            this.keyboard.setFocusPosition("capital", [5, 0]);
                            this.keyboard.switchKeyMap("capital");
                            break;

                        case KEYBOARD_KEYS.ABC_TO_NUMBER:
                        case KEYBOARD_KEYS.SMALLABC_TO_NUMBER:
                            this.keyboard.setFocusPosition("number", [5, 1]);
                            this.keyboard.switchKeyMap("number");
                            break;
                        case KEYBOARD_KEYS.ABC:
                            this.keyboard.switchKeyMap("capital");
                            break;

                    }
                    return false;
                }, this);

                this.addEventListener(evtType.KEY, util.bind(function(key) {
                    this.keyboardInputField.startInput();
                    if (key.id === "device:vkey:back") {
                        this._onCloseCallback(false /* this.keyboardInputField.getText() */);
                        this.onClose();
                        return false;
                    }
                }, this));

                this.addEventListener(evtType.FOCUS, util.bind(function () {
                    this.keyboardInputField.startInput();
                }, this));

                this.addEventListener(evtType.BLUR, util.bind(function() {
                    this.keyboardInputField.stopInput();
                }, this));
            }
        });
    });

/**
 *
 * Input Native widget use the input tag and is compatible to the mouse. User can click and move the cursor.
 *
 * ###Dom Structure
 *      <div class="wgt-input wgt-input-native" id="input">
 *          <div class="container">
 *              <input class="wgt-input-native-ele">
 *          </div>
 *      </div>
 *
 * ###CSS
 * ####Structural CSS
 *      //To display input properly.
 *      .wgt-input-native-ele{
 *          resize: none;
 *          margin: 0px;
 *          padding: 0px;
 *          border: 0px;
 *          outline: none;
 *          word-wrap: break-word;
 *          height: 100%;
 *      }
 *
 * ####Customizable CSS
 * .wgt-input - to set the size of the input
 *
 * @class ax/ext/ui/input/InputNativeImpl
 * @augments ax/ext/ui/input/interface/InputImpl
 * @param {Object} opts The options object
 * @param {Number} opts.maxLength The available length of the input
 * @param {Boolean} opts.isPassword True if it is password and it will be "*" for the input
 * @param {String} opts.text The default text of the input
 * @param {Number} opts.hideTimeout time to hide the password and only available when opts.isPassword true
 * @param {String} opts.passwordChar The char to replace the "*" which is the default character.
 */
define("tvedemo/wgt/input/TizenInputNativeImpl", [
    "xdk-base/class",
    "xdk-base/Element",
    "xdk-base/util",
    "xdk-base/device",
    "xdk-base/console",
    "xdk-ax/evt/type",
    "xdk-base/device/shared/browser/keyMap",
    "xdk-base/core",
    "xdk-ui-input/interface/InputImpl",
    "css!xdk-ui-input/css/InputNativeImpl"
], function (
    klass,
    Element,
    util,
    device,
    console,
    evtType,
    keyMap,
    core,
    InputImpl
) {
    "use strict";

    return klass.create([InputImpl], {}, {

        _onStartInput: 'tizen-on-startinput',

        /**
         * To check if it old samsung device which is older than or equal 2011
         * @private
         * @name __oldSamsung
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __oldSamsung: device.platform === "samsung" && device.id.getFirmwareYear() <= 2011,
        /**
         * @private
         * @name __cursorPosition
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __cursorPosition: null,
        /**
         * @private
         * @name __labelText
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __labelText: null,
        /**
         * @private
         * @name __inputState
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __inputState: false,
        /**
         * @private
         * @name __passwordTimer
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __passwordTimer: null,
        /**
         * @private
         * @name __initEnvOnKey
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __initEnvOnKey: false,
        /**
         * @private
         * @name __maxLength
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __maxLength: 20,
        /**
         * @private
         * @name __isPassword
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __isPassword: false,
        /**
         * @private
         * @name __passwordChar
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __passwordChar: null,
        /**
         * @private
         * @name __hideTimeout
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __hideTimeout: 0,
        /**
         * @private
         * @name __widgetInstance
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __widgetInstance: null,
        /**
         * @private
         * @name __input
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __input: null,
        /**
         * @private
         * @name __element
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __element: null,
        /**
         * To store the place holder word
         * @private
         * @name __placeHolder
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __placeHolder: null,
        /**
         * Flag to see if placeHolder is set or not
         * @private
         * @name __placeHolder
         * @memberof ax/ext/ui/input/InputNativeImpl#
         */
        __isSetPlaceHolder: false,
        /**
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @private
         */
        init: function (opts) {
            var self = this,
                handleClickFunc, handleMouseOut, handleKeyFunc, samsungHandleKeyFunc, handleTextEditKeyFunc, checkDangerousKeyFunc, upKey = keyMap.KEYBOARD_KEY.keyCode.UP,
                downKey = keyMap.KEYBOARD_KEY.keyCode.DOWN,
                leftKey = keyMap.KEYBOARD_KEY.keyCode.LEFT,
                rightKey = keyMap.KEYBOARD_KEY.keyCode.RIGHT,
                insertKey = keyMap.KEYBOARD_KEY.keyCode.INSERT,
                delKey = keyMap.KEYBOARD_KEY.keyCode.DELETE,
                homeKey = keyMap.KEYBOARD_KEY.keyCode.HOME,
                endKey = keyMap.KEYBOARD_KEY.keyCode.END,
                pageUpKey = keyMap.KEYBOARD_KEY.keyCode.PAGE_UP,
                pageDownKey = keyMap.KEYBOARD_KEY.keyCode.PAGE_DOWN,
                tabKey = keyMap.KEYBOARD_KEY.keyCode.TAB,
                backspaceKey = keyMap.KEYBOARD_KEY.keyCode.BACKSPACE,
                inputAttributes = {};
            //those keys on the keyboard suppose to be blocked and no default navigation/behvaiour on the input field
            opts = opts || {};

            opts.root.addClass("wgt-input-native");

            if (opts.maxLength) {
            	inputAttributes.maxlength = opts.maxLength;
            }

            this.setMaxLength(util.isNumber(opts.maxLength) ? opts.maxLength : 20);
            this.__isPassword = opts.isPassword || false;
            this.__passwordChar = opts.passwordChar || "*";
            this.__hideTimeout = opts.hideTimeout || 0;
            this.__placeHolder = opts.placeHolder || "";

            this.__labelText = opts.text || "";
            this.__cursorPosition = this.__labelText.length;
            this.__widgetInstance = opts.widgetInstance;

            // Create div structure
            this.container = new Element("div");
            this.container.addClass("container");

            
            inputAttributes.type = opts.isPassword === true ? "password" : "text";

            this.__input = new Element("input", inputAttributes);


            this.__input.addClass("wgt-input-native-ele");
            //XDK-1838
            //since it is part of the implementation of the input and thus append the current container to the root instead of create a new root in the component
            opts.root.append(this.container);
            this.container.append(this.__input);
            this.__element = this.__input.getHTMLElement();

            this.setText(opts.text, true);

            checkDangerousKeyFunc = function (evt) {
                // checks dangerous keys that interacts with input. If there are any specific keys on the platforms, it needs to be included here
                switch (evt.keyCode) {
                case upKey:
                case downKey:
                //case leftKey:
                //case rightKey:
                case insertKey:
                //case delKey:
                case homeKey:
                case endKey:
                case pageUpKey:
                case pageDownKey:
                case tabKey:
                //case backspaceKey:
                    return true;
                default:
                    return false;
                }
            };
            // end of ugly keyboard related platform checking
            handleClickFunc = function (evt) {
                console.info("inputNativeImpl: mouse click; inputState: " + self.__inputState);
                self.startInput();

                return true;
            };
            handleMouseOut = function (evt) {
                console.info("inputNativeImpl: mouse out; inputState: " + self.__inputState);

                self.stopInput();
                return true;
            };
            handleKeyFunc = function (evt) {
                try {
                    evt.preventDefault();
                } catch (ex) {
                    ex.returnValue = false;
                }
                return true; // keep bubbling
            };
            handleTextEditKeyFunc = function (evt) {
                if (checkDangerousKeyFunc(evt)) { // catches dangerous keys that interacts with textarea
                    console.info("inputNativeImpl: blocking text edit key:" + evt.keyCode);
                    evt.preventDefault();
                    evt.stopPropagation();
                } else {
                    switch(evt.keyCode){
                        case 46: // Clear key
                            self.setText('');
                            break;
                        case 8: // Del key - not always handled by the IME -.-
                            self.backspace();
                            break;
                        case 32: // Space key
                            self.insertChar(' ');
                            break;
                        case 37: // left key
                            self.moveCursor('left');
                            break;
                        case 39: // Space key
                            self.moveCursor('right');
                            break;
                        case 65385:
                        case 65376:
                            console.log('Key code : ' + evt.keyCode);
                            evt.preventDefault();
                            self.stopInput();
                        break;
                        default:
                           console.log('Key code : ' + evt.keyCode);
                        break;
                    }
                }

                return true; // keep bubbling
            };

            
            //this.container.addEventListener("mousedown", handleClickFunc);
            //this.container.addEventListener("mouseout", handleMouseOut);
            this.__input.addEventListener("keydown", handleTextEditKeyFunc);
            this.__input.addEventListener("keypress", handleKeyFunc);

            this.onStartInputEventBind = util.bind(this.onStartInputEvent, this);

            this.addOnStartInputHandler();

            // Listen to onfocus incase tizen pointer is used outside keyboard.
            this.__element.onfocus = util.bind(this.startInput, this);

        },
        /**
         * add the place holder when the text value is ""
         * @method __addPlaceHolder
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @private
         */
        __addPlaceHolder: function () {
            this.__isSetPlaceHolder = true;
            //set the placeholder value into the input
            this.__element.value = this.__placeHolder;
            this.__input.addClass("placeholder");
            //make sure the cursor position to be at 0 position.
            this.__setRealCursorPos();
        },
        /**
         * remove the place holder when the text value is not ""
         * @method __removePlaceHolder
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @private
         */
        __removePlaceHolder: function () {
            this.__isSetPlaceHolder = false;
            this.__element.value = "";
            this.__input.removeClass("placeholder");
        },
        /**
         * Insert character to the input field
         * @name insertChar
         * @function
         * @param {String} ch The character to insert to
         * @param {Number} insertPos The position character insert to
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        insertChar: function (ch, insertPos) {
            this.__element.value = this.__element.value + ch;
        },
        /**
         * Delete the last character in the input field
         * @name backspace
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        backspace: function () {
            var value = this.__element.value,
                selectionStart = this.__element.selectionStart,
                newSelectionStart = selectionStart - 1;

            if (selectionStart > 0) {
                this.__element.value = value.substr(0, this.__element.selectionStart - 1) + value.substr(this.__element.selectionStart, value.length);
                this.__element.setSelectionRange(newSelectionStart, newSelectionStart);
            }
        },
        /**
         * Delete the character after cursor in the input field
         * @name del
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        del: function () {
        },
        /**
         * Set max length of input field
         * @name setMaxLength
         * @function
         * @param {Integer} l The number of characters to set
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        setMaxLength: function (l) {
            this.__maxLength = l;
        },
        /**
         * Get max length of input field
         * @method getMaxLength
         * @returns {Integer} The maximum character length in the input
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        getMaxLength: function () {
            return this.__maxLength;
        },
        /**
         * Get the input field text
         * @name getText
         * @function
         * @return {String} __labelText Return the current label text
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        getText: function () {
            return this.__element.value;
        },
        /**
         * Set text on the input field
         * @name setText
         * @function
         * @param {String} text
         * @param {Boolean} forceNoTimeout
         * @param {Boolean} noUpdateCursorPosition true won't update the cursor position after the setText, default is false and will update the cursor position to the end when setText
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        setText: function (text, forceNoTimeout, noUpdateCursorPosition) {
            text = util.truncate(text, this.__maxLength, "");

            if (!this.__isPassword) {
                this.__labelText = text;
            }

            this.__element.value = text;
        },
        /**
         * Sets the text to one of the elements
         * @name __setElementText
         * @param {ax/Element} element Element to set text to
         * @param {String} text Text to set
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @private
         */
        __setElementText: function (text) {
            text = util.truncate(text, this.__maxLength, "");

            if (!this.__isPassword) {
                this.__labelText = text;
            }

            this.__element.value = text;

            if (this.__inputState) {
                this.__element.blur();
                this.__element.focus();
            }
            this.__setRealCursorPos();
        },
        /**
         * Clear input field text
         * @name clearText
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        clearText: function () {
            this.setText("");
        },
        /**
         * Update the UI of the cursor according to the __cursorPosition number
         * @name __updateCursorPosition
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        __updateCursorPosition: function () {
        },
        /**
         * Move the cursor in certain direction
         * @name moveCursor
         * @function
         * @param {String} direction either "left" or "right"
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        moveCursor: function (direction) {
            var directionValue = 1, // Right by default.
                textLength,
                newPosition;

            switch (direction) {
                case 'left':
                    directionValue = -1;
                break;
                case 'right':
                    directionValue = 1;
                break;
            }

            textLength = this.__element.value.length;
            newPosition = this.__element.selectionStart + directionValue;

            // Make sure the selection is not out of bounds.
            if (newPosition >= 0 && newPosition <= textLength) {
                this.__element.setSelectionRange(newPosition, newPosition);
            }

        },

        getTVArea: function() {
            var sAppRoot = require("xdk-ax/mvc/AppRoot").singleton(),
                tvArea = sAppRoot.getView();

            return tvArea;
        },

        /**
         * Move the cursor to a specific position
         * @name setCursorPos
         * @function
         * @param {Number} pos cursor position
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        setCursorPos: function (pos) {
        },

        animateTVAreaUp: function() {
            var tvArea = this.getTVArea();
            tvArea.addClass('tizen-keyboard-visible');
        },

        animateTVAreaDown: function() {
            var tvArea = this.getTVArea();
            tvArea.removeClass('tizen-keyboard-visible');
        },

        addOnStartInputHandler: function() {
            var sEnv = require("xdk-base/Env").singleton();
            sEnv.addEventListener(this._onStartInput, this.onStartInputEventBind);
        },

        onStartInputEvent: function() {
            // Set onblur to a no-op function to avoid stopInput to be called after a startinput has happened on another input field.
            this.__element.onblur = function() {};
        },

        dispatchStartInputEvent: function() {
            var sEnv = require("xdk-base/Env").singleton();
            sEnv.dispatchEvent(this._onStartInput);
        },

        /**
         * Make the inputField ready for capturing
         * @name startInput
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        startInput: function () {
            if (this.__inputState === true) {
                console.info('Tizen native input - Already in inputstate no need to focus it.');
                return;
            }

            this.dispatchStartInputEvent();

            // Listen to onblur incase tizen pointer is used outside keyboard.
            this.__element.onblur = util.bind(this.stopInput, this);

            this.__inputState = true;
            this.__element.focus();

            this.animateTVAreaUp();
        },
        /**
         * Set the real cursor to go to position at this.__cursorPosition.
         * This method is also used as a work-around when some glitches causes real cursor to move to an incorrect position.
         * @name __setRealCursorPos
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @private
         */
        __setRealCursorPos: function () {
        },
        /**
         * Make the inputField non-capturing
         * @name stopInput
         * @function
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        stopInput: function () {
            if (this.__inputState === false) {
                console.info('Tizen native input - Not in inputstate no need to blur it.');
                return;
            }

            this.animateTVAreaDown();

            this.__element.blur();
            this.__inputState = false;
        },
        /**
         * Check if inputField is capturing
         * @name isCapturing
         * @function
         * @returns {Boolean} true if capturing; false otherwise
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @public
         */
        isCapturing: function () {
            return this.__inputState;
        },
        /**
         * @method
         * @memberof ax/ext/ui/input/InputNativeImpl#
         * @protected
         */
        deinit: function () {
            var sEnv = require("xdk-base/Env").singleton();
            sEnv.removeEventListener(this._onStartInput, this.onStartInputEventBind);

            this.container.deinit();
            this.__input.deinit();
        }
    });
});
/**
 *
 * Input widget is an input field where the user can enter data.
 * There are two implementations in the input widget.
 *
 * 1. InputDiv use the div to enter the data
 * 2. InputNative use the input tag as an input field and then enter the data
 *
 *
 * Input will listen to the sEnv onKey event.It inputs the text when its state is startInput and the key value from the key event has an attribute called text.
 * So it will automatically update the display of the input without any handling. It should be worked in both hard keyboard and keyboard widget.
 *
 * In fact, when clicking the button within the keyboard widget, it will dispatch the key event with the text attribute.
 * After that, Input will then receive the event and insert the character when in startInput state.
 *
 * There are two states in the input (which are capturing and non-capturing state)
 * startInput will change the input to capturing state that allows char insert.
 * stopInput will change into the non-capturing state that disable char insert.
 *
 * @class ax/ext/ui/input/Input
 * @augments ax/ext/ui/input/InputBase
 * @fires module:ax/af/evt/type.TEXT_CHANGED
 * @param {Object} opts The options object
 * @param {String} opts.text The preset text to use
 * @param {Boolean} opts.isPassword To set the value shown to be password which make use of the opts.passwordChar
 * @param {Number} opts.maxLength The available length to be entered in the input.Default is 20
 * @param {String} opts.passwordChar The char to use when it is password. Default is "*"
 * @param {Number} opts.hideTimeout The time to hide the character to the passwordChar.
 * @param {Boolean} opts.useNative To use the native impl.
 *
 */
define(
    "tvedemo/wgt/input/Input",
    [
        "xdk-base/class",
        "xdk-base/Element",
        "xdk-base/device",
        "xdk-base/util",
        "xdk-ui-input/InputDivImpl",
        "xdk-ui-input/InputNativeImpl",
        "xdk-base/Env",
        "xdk-ax/evt/type",
        "xdk-ui-input/InputBase",
        "xdk-base/device/vKey",
        "tvedemo/wgt/input/TizenInputNativeImpl"
    ],
    function (
        klass,
        Element,
        device,
        util,
        InputDivImpl,
        InputNativeImpl,
        Env,
        evtType,
        InputBase,
        vKey,
        TizenInputNativeImpl
    ) {
        "use strict";

        return klass.create(InputBase, {}, {

            CLICK: 'input-field-click',
            KEY: 'input-field-key',

            init: function (opts) {
                opts = opts || {};
                opts.maxLength = util.isNumber(opts.maxLength) ? opts.maxLength : 20;
                opts.css = (!opts.css) ? "wgt-input" : opts.css + " wgt-input";

                this._super(opts);

                opts.root.addClass("wgt-input");

                if (device.platform === 'tizen') {
                    this.__impl = new TizenInputNativeImpl(opts);
                } else if (!opts.useNative) {
                    this.__impl = new InputDivImpl(opts);
                } else {
                    this.__impl = new InputNativeImpl(opts);
                }

                this._clickEventBind = util.bind(this._clickEvent, this);
                this._keyEventBind = util.bind(this._keyEvent, this);


                this.addInputListeners();
            },

            _clickEvent: function() {
                if (device.platform === 'tizen') {
                    this.__impl.startInput();
                } else {
                    this.dispatchEvent(this.CLICK);
                }
            },

            _keyEvent: function(keyEvent) {
                switch(keyEvent.id)  {
                    case vKey.KEY_0.id:
                    case vKey.KEY_1.id:
                    case vKey.KEY_2.id:
                    case vKey.KEY_3.id:
                    case vKey.KEY_4.id:
                    case vKey.KEY_5.id:
                    case vKey.KEY_6.id:
                    case vKey.KEY_7.id:
                    case vKey.KEY_8.id:
                    case vKey.KEY_9.id:
                        if (device.platform === 'tizen') {
                            this.__impl.startInput();
                        } else {
                            this.dispatchEvent(this.KEY, keyEvent);
                        }
                }
            },

            addInputListeners: function() {
                this.addEventListener(evtType.CLICK, this._clickEventBind);
                this.addEventListener(evtType.KEY, this._keyEventBind);
            },

            removeInputListeners: function () {
                this.removeEventListener(evtType.CLICK, this._clickEventBind);
                this.removeEventListener(evtType.KEY, this._keyEventBind);
            }
        });
    }
);
/**
 * InputDialog is a dialog that gives the user the oportunity to input text.
 * There are several customization points that the developer can configure:
 *
 * @name InputDialog
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/InputDialog
 */
define("tvedemo/wgt/InputDialog", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-ax/Container",
    "xdk-ax/Component",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Layout",
    "tvedemo/wgt/ConfirmDialog",
    "tvedemo/wgt/Keyboard",
    "tvedemo/wgt/input/Input",
    "xdk-base/device",
    "xdk-base/device/vKey",
    "xdk-base/console"
], function (
    klass,
    util,
    Container,
    Component,
    focusManager,
    evtType,
    Layout,
    ConfirmDialog,
    Keyboard,
    Input,
    device,
    vKey,
    console) {

    "use strict";

    return klass.create(ConfirmDialog, {
    }, {

        init: function (options) {
            options = options || {};

            options.title = options.title || "";
            options.message = options.message || "";
            options.positiveText = options.positiveText || "";
            options.negativeText = options.negativeText || "";
            options.maxLength    = options.maxLength || 32;
            options.keyMap       = options.keyMap || "default";
            
            options.positiveAction = util.bind(function () {
                if (options.finishedTextInput) {
                    options.finishedTextInput(this._inputField.getText());
                }
            }, this);
            options.negativeAction = util.bind(function () {
                if (options.canceledTextInput) {
                    options.canceledTextInput();
                }
            }, this);

            // Remember the last focus, that can be resumed after the dialog is closed.
            this._lastFocus = focusManager.getCurFocus();

            this._super(options);

            // @TODO: This input popup isn't properly modal? If so, users can close it with BACK, and leave related promises dangling!

            this._inputField = new Input({
                css: "wgt-input-dialog-input-field",
                isPassword: options.isPassword || false,
                focusable: true,
                nextDown: "buttonContainer"
            });

            // Work around the fact the InputDialog > ConfirmDialog calls deinit() but InputNativeImpl.js doesn't inherit from Component so has no such function.
            if (util.isUndefined(this._inputField.__impl.removeAllListeners)) {
                this._inputField.__impl.removeAllListeners = function () {
                    console.warn("Stub removeAllListeners() invoked");
                };
            }

            this.__boundInputClick = util.bind(function() {
                this._keyboard = new Keyboard({ id: "keyboard", type: (options.isPassword ? "password" : "text"), forwardFocus: true, maxLength: options.maxLength, isPassword: options.isPassword, inputCss: options.inputCss });
                this._input = this._inputField;
                this._keyboard.getReadyPromise().then(util.bind(function() {
                    this._keyboard.setInputName(options.title);
                    this._keyboard.showKeyboard({ text: this._input.getText(), keyMap: options.keyMap });
                    focusManager.focus(this._keyboard);
                    this._keyboardOnClose();
                    var currentView = this.getRootController().getView() || amd.require("xdk-ax/mvc/AppRoot").singleton().getView();
                    currentView.attach(this._keyboard);
                }, this), function(error) {
                    console.warn("Input dialog: Keyboard cannot be ready due to " + error);
                });

            }, this);

            this.__boundInputKey = util.bind(this._fieldKeyHandler, this, this.__boundInputClick);

            this._inputField.addEventListener(this._inputField.KEY, this.__boundInputKey);
            this._inputField.addEventListener(this._inputField.CLICK, this.__boundInputClick);

            var buttonContainer = this._contentComp.find("buttonContainer");

            buttonContainer.setOption("nextUp", this._inputField);

            options.content.attach(this._inputField, Component.PLACE_BEFORE, buttonContainer);

            this.addClass("wgt-inputdialog");

            this.setOption("forwardFocus", this._inputField);

            this._inputField.__impl.updateLeft && this._inputField.__impl.updateLeft();

            // Set focus on the dialog.
            focusManager.focus(this._inputField);
        },

        /**
         * A user has hit a key while the field focused. Maybe show the keyboard?
         * @method
         * @protected
         * @memberOf tvedemo/wgt/InputDialog#
         */
        _fieldKeyHandler: function(clickHandler, keyEvent) {
            console.log(keyEvent);
            switch(keyEvent.id)  {
                case vKey.KEY_0.id:
                case vKey.KEY_1.id:
                case vKey.KEY_2.id:
                case vKey.KEY_3.id:
                case vKey.KEY_4.id:
                case vKey.KEY_5.id:
                case vKey.KEY_6.id:
                case vKey.KEY_7.id:
                case vKey.KEY_8.id:
                case vKey.KEY_9.id:
                    clickHandler();
            }
        },

        _keyboardOnClose: function() {
            this._keyboard.setOnClose(util.bind(function(text) {

                this._keyboardClosed = true;

                if (text !== false) {
                    this._input.setText(text);
                }

                this._keyboard.removeAllListeners();
                this._keyboard.detach();

                this._input.__impl.__input && this._input.__impl.__input.getHTMLElement().blur(); //  Deactivate the cursor on <input> element

                var buttonContainer = this._contentComp.find("buttonContainer");
                focusManager.focus(buttonContainer);

            }, this));
        },

        close: function () {
            focusManager.focus(this._lastFocus);
            this._super();
        },

        reset: function () {
            this._inputField.removeEventListener(this._inputField.KEY, this.__boundInputKey);
            this._inputField.removeEventListener(this._inputField.CLICK, this.__boundInputClick);

            this._inputField.removeInputListeners();
        }
    });
});
/**
 * @author Andy Hui <andy.hui@accedo.tv>
 * @ignore
 */
define("xdk-ax/iterator/DFSCtrlIt", ["xdk-base/class", "xdk-ax/iterator/interface/Iterator", "xdk-base/core"], function (klass, IIterator, core) {
    "use strict";
    /**
     * @class xdk-ax/iterator/DFSCtrlIt
     * @extends xdk-ax/iterator/interface/Iterator
     * @classdesc Depth first search controller iterator.
     */

    return klass.create([IIterator], {}, {
        /**
         * internal component array
         * @private
         */
        __ctrlArr: [],
        /**
         * @name init
         * @param {xdk-ax/mvc/Controller} targetCtrl capturing target controller
         * @method
         * @memberOf xdk-ax/iu/DFSCtrlIt#
         */
        init: function (targetCtrl) {
            this._include(targetCtrl);
        },
        _include: function (ctrl) {

            var i, children = ctrl.getSubControllers();

            this.__ctrlArr.unshift(ctrl);

            for (i in children) {
                this._include(children[i]);
            }

        },
        next: function () {
            if (!this.__ctrlArr.length) {
                core.createException("NoSuchElement", "No more element is available for current iteraion!");
            }
            return this.__ctrlArr.pop();
        },
        hasNext: function () {
            return !!this.__ctrlArr.length;
        }
    });
});
/*jslint browser: true, devel: true */
/**
 * Historical back handling module that works with {@link xdk-ax/mvc/ControllerManager|Controller Manager}.
 * The history manager can take care of the focus while doing history back.
 * Make sure the promise will be resolved after the controller is properly set up.
 *
 * This class is designed as a singleton, developer should use {@link xdk-history/HistoryManager.singleton|singleton} to obtain the instance.
 * Creating instance using the _new_ keyword is prohibited.
 *
 * @class xdk-history/HistoryManager
 * @author Andy Hui <andy.hui@accedo.tv>
 * @example
 * // In this example, the controller will try to get data from a remote API,
 * // then update the grid, and finally update the UI for the login status.
 * // But if the controller is shown because of a history back, only update the login status.
 * // (The data should be in the grid already)
 *
 * setup: function (context) {
 *     // inside the controller's setup function
 *
 *     // do the set up that should take place every time
 *     this.registerEventListeners();
 *
 *     // context.historyBack must be true if this is a history back
 *     if (context.historyBack) {
 *         return this.updateLoginStatus(); // return promise to inform the set up is finished
 *     }
 *
 *     // normal navigation
 *     return this.getDataFromRemoteApi()
 *         .then(util.bind(this.showDataOnGrid, this))
 *         .then(util.bind(this.updateLoginStatus, this));
 *
 *     // end of setup()
 * }
 *
 * // the history manager will handle the history focus once that promise is resolved.
 * // This feature can ease the focus handling on history back cases.
 */
define("xdk-history/HistoryManager", [
    "xdk-base/core", "xdk-base/class", "xdk-base/util", "xdk-base/EventDispatcher",
    "xdk-ax/mvc/Controller", "xdk-ax/mvc/ControllerManager", "xdk-ax/mvc/AppRoot",
    "xdk-ax/iterator/DFSCtrlIt", "xdk-base/device/vKey", "xdk-base/console", "xdk-base/exception",
    "xdk-base/promise", "xdk-ax/focusManager"
], function(core, klass, util, EventDispatcher,
    Controller, ControllerManager, AppRoot,
    DFSCtrlIt, vKey, console, Exception,
    promise, focusMgr) {
    "use strict";
    var HistoryManager,
        instance,
        sAppRoot = AppRoot.singleton(),
        sCtrlMgr = ControllerManager.singleton();

    HistoryManager = klass.create(EventDispatcher, {
        /**
         * Default back keys: [vKey.BACK.id]
         * @constant
         * @name DEFAULT_BACK_KEYS
         * @memberof xdk-history/HistoryManager
         */
        DEFAULT_BACK_KEYS: [vKey.BACK.id],
        /**
         * fired when a history back is done
         * @constant
         * @name EVT_HISTORY_BACK
         * @memberof xdk-history/HistoryManager
         */
        EVT_HISTORY_BACK: "ui:history:back",

        /**
         * Get the singleton instance of this class.
         * @method
         * @static
         * @returns {xdk-history/HistoryManager} The singleton
         * @memberOf xdk-history/HistoryManager
         */
        singleton: function() {
            if (!instance) {
                instance = new HistoryManager();
            }

            return instance;
        }
    }, {
        /**
         * Keys array that will be considered as back keys for historyManager.
         * @protected
         * @name _backKeys
         * @memberof xdk-history/HistoryManager#
         */
        _backKeys: null,
        /**
         * Storing the history stack
         * @protected
         * @name _history
         * @memberof xdk-history/HistoryManager#
         */
        _history: [],
        /**
         * Initialize the history manager
         * @protected
         * @name init
         * @memberof xdk-history/HistoryManager#
         */
        init: function() {

            this._super();

            this.setBackKeys(this.constructor.DEFAULT_BACK_KEYS);

        },
        /*jshint unused:false*/
        /**
         * Activate the history manager. Normally it will be activated at the beginning of the application.
         * And it is unable to deactivate or reactivate again.
         * @name activate
         * @memberof xdk-history/HistoryManager#
         * @function
         * @public
         */
        activate: function() {

            var self = this;
            //register to AppRoot as default history handling
            sAppRoot.setDefaultKeyAction(
                this._backKeys,

                function(keyEvt) {
                    self.back();
                }

            );

            //listen to ControllerManager's events
            sCtrlMgr.addEventListener(sCtrlMgr.constructor.EVT_REPLACED, function(param) {

                //skip on doing history back
                if (param.options.__doHistoryBack) {
                    return;
                }

                self._push({
                    front: param.exist,
                    frontContext: param.exist.getContextTree(),
                    controller: param.replacement,
                    options: param.options
                });
            });

            sCtrlMgr.addEventListener(sCtrlMgr.constructor.EVT_OPENED, function(param) {

                //skip on doing history back
                if (param.options.__doHistoryBack) {
                    return;
                }

                if (param.options.appRootFirstController) {
                    //skip if opening first controller
                    return;
                }

                self._push({
                    front: null,
                    controller: param.controller,
                    options: param.options
                });
            });

            sCtrlMgr.addEventListener(sCtrlMgr.constructor.EVT_CLOSED, function(param) {


                //skip on doing history back
                if (param.options.__doHistoryBack) {
                    return;
                }

                self._push({
                    front: param.controller,
                    frontContext: param.controller.getContextTree(),
                    controller: null,
                    container: param.container,
                    options: param.options
                });
            });
        },
        /*jshint unused:true*/
        /**
         * Wrapper function to set controller's navigation history data
         * @name _setCtrlNav
         * @param ctrl Target controller
         * @memberof xdk-history/HistoryManager#
         * @function
         * @protected
         */
        _setCtrlNav: function(ctrl, navigation) {
            ctrl.__navigation = navigation;
        },
        /**
         * Wrapper function to get controller's navigation history data
         * @name _getCtrlNav
         * @param ctrl Target controller
         * @memberof xdk-history/HistoryManager#
         * @function
         * @protected
         */
        _getCtrlNav: function(ctrl) {
            return ctrl.__navigation;
        },
        /**
         * Wrapper function to clear controller's navigation history data
         * @name _clearCtrlNav
         * @param ctrl Target controller
         * @memberof xdk-history/HistoryManager#
         * @function
         * @protected
         */
        _clearCtrlNav: function(ctrl) {
            if (!ctrl) {
                return;
            }

            ctrl.__navigation = null;
            delete ctrl.__navigation;
        },
        /**
         * Used by {@link xdk-history/HistoryManager#_push|_push}. Remove the
         * skipped history from provide skipped controlller
         * @name _removeSkippedHistory
         * @param {Object} controller The skipped controller
         * @param {Boolean} [__nested] For internal use
         * @returns {Object|Undefined} Navigation history of skipped
         * controller's or undefined is not found
         * @memberof xdk-history/HistoryManager#
         * @function
         * @protected
         */
        _removeSkippedHistory: function(controller, __nested) {
            var itr = new DFSCtrlIt(controller),
                toSkip = [],
                nav = this._getCtrlNav(controller),
                idx, ctrl;

            //get all the navigations within controller subtree
            while (itr.hasNext()) {
                ctrl = itr.next();

                if (this._getCtrlNav(ctrl)) {
                    toSkip.push(this._getCtrlNav(ctrl));
                }
            }

            //remove children navigations that's skipped
            util.each(toSkip, function(nav) {

                //remove the __navigation object from front controller
                this._clearCtrlNav(nav.controller);

                //remove the front's navigation from history
                idx = util.indexOf(this._history, nav);

                if (idx === -1) {
                    return;
                }

                util.remove(this._history, idx);

                // dig to front navigations if not root call
                if ((__nested || nav.controller !== controller) && nav.front) {
                    this._removeSkippedHistory(nav.front, true);
                }

            }, this);

            return nav;

        },
        /**
         * Used by {@link xdk-history/HistoryManager#push|push}. Do the history back controller handling
         * @name _doHistoryBack
         * @param {Object} navigation {@link xdk-history/HistoryManager#push|Navigation object} that stores the navigation data
         * @param {Object} [context] context param passed from {@link xdk-history/HistoryManager#push|push} method.
         * @returns {Promise} A promise that will be resolved after the history back operation is done
         * @memberof xdk-history/HistoryManager#
         * @function
         * @protected
         */
        _doHistoryBack: function(navigation, context) {
            context = context || {};

            //add the state to check the 
            context.historyBack = true;

            var updateSubContexts = function(subContexts) {
                util.each(subContexts, function(pair) {
                    pair.value.historyBack = true;

                    if (pair.value.subContexts) {
                        updateSubContexts(pair.value.subContexts);
                    }
                });
            };

            if (navigation.front) {
                if (util.isPlainObject(navigation.frontContext)) {
                    context = util.extend(navigation.frontContext, context);
                }

                if (context.subContexts) {
                    updateSubContexts(context.subContexts);
                }
            }

            // change the controller
            return this._changeController(navigation, context).complete(function() {

                var historyFocus;

                function isCompInDOM(comp) {
                    return comp && comp.getRoot() && comp.getRoot().isInDOMTree();
                }

                historyFocus = navigation.options.historyFocus ? navigation.options.historyFocus : null;

                // focus on the history focus only if it is in DOM
                // if not, focus on last active focus
                if (isCompInDOM(historyFocus)) {
                    focusMgr.focus(historyFocus);
                } else {
                    focusMgr.focus(focusMgr.getLastActiveFocus());
                }
            });
        },

        /**
         * Actually change the controller based on the navigation object.
         * @method
         * @protected
         * @param {Object} navigation Navigation object that stores the navigation data
         * @param {Object} context The context object pass to the controller manager for context restore
         * @returns {Promise.<xdk-ax/mvc/Controller>|Promise.<Undefined>} return the controller when replace with new one or the new opened one. Return promise with undefined when close controller.
         * @returns {Promise.<module:xdk-base/exception.INTERNAL> Fail to find the container to open
         * @memberof xdk-history/HistoryManager#
         */
        _changeController: function(navigation, context) {
            // check if the controller is currently displaying
            if (navigation.front && navigation.controller) {
                return sCtrlMgr.replace(navigation.controller, navigation.front, {
                    context: context,
                    __doHistoryBack: true
                });
            } else if (navigation.front) {
                if (!navigation.container) {
                    return promise.reject(core.createException(Exception.INTERNAL, "When doing History back to the previous controller, it fails to find the container to open"));
                }

                return sCtrlMgr.open(navigation.front, navigation.container, {
                    context: context,
                    __doHistoryBack: true
                });
            } else {
                return sCtrlMgr.close(navigation.controller, {
                    __doHistoryBack: true
                });
            }
        },

        /**
         * To push the navigation as history.
         * @name _push
         * @param {Object} navigation Key value map for the input parameters
         * @param {xdk-ax/mvc/Controller|null} [navigation.front] The front controller
         * @param {xdk-ax/mvc/Controller|null} [navigation.controller] The new controller
         * @param {Object} [navigation.options] Options object that was passed to the {@link xdk-ax/mvc/ControllerManager|Controller Manager}'s open, replace and close methods
         * @param {boolean} [navigation.options.historySkip] True if need skip this navigation from history (Note: only appliable to {@link xdk-ax/ControllerManager#replace|replace} method). Default: false.
         * @param {boolean} [navigation.options.controllerCache]  False if need disable the view cache when saving the view via navigation (Note: only appliable to {@link xdk-ax/ControllerManager#replace|replace} method). Default: true.
         * @memberof xdk-history/HistoryManager#
         * @function
         * @protected
         */
        _push: function(navigation) {

            var lastNavigation, skippedNav;

            if (navigation.options && navigation.options.historySkip) {
                // skip history handling on replace
                if (!navigation.front || !navigation.controller) {
                    console.warn("cannot skip history on open and close controller");
                    return;
                } else {
                    skippedNav = this._removeSkippedHistory(navigation.front);

                    if (!(skippedNav && skippedNav.front)) {
                        return;
                    }

                    //relinked skipped navigation's front controller
                    navigation.front = skippedNav.front;
                }
            }

            if (navigation.controller) {
                //save the previous navigation previous controller as linked
                this._setCtrlNav(navigation.controller, navigation);
            }

            //update the cache on controller, only the class contructors are saved
            if (navigation.options.controllerCache === false) {

                //deinit the front controller since no cache. So replace and close manager case will set controller to be constrcuctor.
                if (navigation.front) {
                    navigation.front = navigation.front.constructor;

                    //to set the previous history to be the constructor
                    if (this._history.length > 0) {
                        lastNavigation = this._history[this._history.length - 1];
                        lastNavigation.controller = lastNavigation.controller.constructor;
                    }
                }
            }

            this._history.push(navigation);

        },
        /**
         * Do a history back. Default to back history by one step.
         *
         * Note: The return type of this function has changed to {@link Promise} since 2.2.0, which is breaking the backward compatibility prior 2.1.
         *
         * @name back
         * @memberof xdk-history/HistoryManager#
         * @function
         * @param {Object} [options]
         * @param {Class} [options.ctrl] Controller's class to back to. The latest occurance will be taken .
         * @param {Object} [options.context] Context object that will be passed to {@link xdk-ax/mvc/ControllerManager|Controller Manager}
         * @returns {Promise} A promise object that will be resolved after the history back operation is done
         * @public
         */
        back: function(options) {
            options = options || {};

            var navSteps, navigation, unused, i, ctrl, pendingBack;

            if (util.isUndefined(options.ctrl)) {
                navSteps = 1;
            } else {
                ctrl = options.ctrl;
                if (!ctrl.prototype instanceof Controller) {
                    throw core.createException("IncorrectParam", "first arugment should be either a Number or a Controller Subclass.");
                }

                for (i = this._history.length - 1; i >= 0; i--) {
                    if (this._history[i].front instanceof ctrl) {
                        navSteps = this._history.length - i;
                        break;
                    } else if (i === 0) {
                        //unable to find the controller in the history
                        return promise.reject(false);
                    }
                }

            }


            //to handle go to homepage case
            if (navSteps === -1) {
                navSteps = this._history.length;
            }


            if (!this._history.length || navSteps > this._history.length) {
                return promise.reject(false);
            }

            if (navSteps > 1) {

                unused = this._history.splice(this._history.length - navSteps + 1, navSteps - 1);
                //back to the desired step one by one
                for (i = unused.length - 1; i >= 0; i--) {

                    //since there are two connections in reference to the controllers,so need to unref twice
                    console.info("history manager multiback from " + i);

                    if (pendingBack) {
                        pendingBack = pendingBack.then(util.bind(this._doHistoryBack, this, unused[i]));
                    } else {
                        pendingBack = this._doHistoryBack(unused[i]);
                    }
                }

                //remove the reference of the unused items
                unused.splice(0, unused.length);

                console.info(this._history);
            }

            //the last naviation
            navigation = this._history.pop();

            // set up the actual promise on history back done
            if (pendingBack) {
                pendingBack = pendingBack.then(util.bind(this._doHistoryBack, this, navigation, options.context));
            } else {
                pendingBack = this._doHistoryBack(navigation, options.context);
            }

            // dispatch EVT_HISTORY_BACK event after the final step of history back is done
            return pendingBack.then(util.bind(this.dispatchEvent, this, this.constructor.EVT_HISTORY_BACK, navigation));
        },
        /**
         * @name setBackKeys
         * @param {Array} vkeys - Set the keys that History Manager should handle
         * them as going back
         * @memberof xdk-history/HistoryManager#
         * @function
         * @public
         */
        setBackKeys: function(vkeys) {
            this._backKeys = vkeys;
        },
        /**
         * Clears history.
         * @name clear
         * @memberof xdk-history/HistoryManager#
         * @function
         * @public
         */
        clear: function() {

            util.each(this._history, function(nav) {
                this._clearCtrlNav(nav.controller);
            }, this);

            util.clear(this._history);

        },
        /**
         * Returns the current history stack
         * @name getHistoryStack
         * @returns {Array} stack of navigation
         * @public
         * @memberof xdk-history/HistoryManager#
         * @function
         */
        getHistoryStack: function() {
            return util.clone(this._history);
        }
    });

    // enforce the instance creation before returning, preventing 2 instances being created
    // (2 executions may go into the creation at the same time...)
    HistoryManager.singleton();

    return HistoryManager;

});
/**
 * Module that returns an singleton of {@link ax/af/HistoryManager|History Manager} class
 * @name sHistoryManager
 * @memberof tvedemo/mgr
 * @module tvedemo/mgr/sHistoryManager
 * @author Andy Hui<andy.hui@accedo.tv>
 */
define("tvedemo/mgr/sHistoryManager", [
    "xdk-base/core", "xdk-base/class", "xdk-base/util",
    "xdk-base/EventDispatcher", "xdk-ax/mvc/Controller", "xdk-ax/mvc/ControllerManager",
    "xdk-ax/mvc/AppRoot", "xdk-ax/iterator/DFSCtrlIt", "xdk-base/device/vKey",
    "xdk-base/console", "xdk-history/HistoryManager", "xdk-base/promise",
    "xdk-ax/focusManager"
], function (core, klass, util,
    EventDispatcher, Controller, CtrlMgr,
    AppRoot, DFSCtrlIt, vKey,
    console, HistoryManager, promise,
    focusMgr) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        sCtrlMgr = CtrlMgr.singleton(),
        sHistoryManager = HistoryManager.singleton(),

        StormHistoryManager = klass.create(sHistoryManager.constructor, {}, {

        /**
         * Initialize the history manager
         * @override
         * @protected
         * @name init
         * @memberof ax/af/HistoryManager#
         */
        init: function () {
            this.setBackKeys(this.constructor.DEFAULT_BACK_KEYS);
        },

        /**
         * Used by {@link ax/af/HistoryManager#push|push}. Do the history back controller handling
         * @name _doHistoryBack
         * @param {Object} navigation {@link ax/af/HistoryManager#push|Navigation object} that stores the navigation data
         * @param {Object} [context] context param passed from {@link ax/af/HistoryManager#push|push} method.
         * @memberof tvedemo/mgr/sHistoryManager#
         * @function
         * @protected
         */
        _doHistoryBack: function (navigation, _context) {

            _context = _context || {};

            //add the state to check the 
            _context.historyBack = true;

            var updateSubContexts = function (subContexts) {

                util.each(subContexts, function (pair) {
                    pair.value.historyBack = true;

                    if (pair.value.subContexts) {
                        updateSubContexts(pair.value.subContexts);
                    }
                });

            };

            if (navigation.front) {

                _context = util.extend(navigation.frontContext, _context);

                if (_context.subContexts) {
                    updateSubContexts(_context.subContexts);
                }

            }

            // change the controller
            return this._changeController(navigation, _context).then(function() {
                promise.resolve(_context.setupPending);  // occasionally never resolve and block the following focus
            }).complete(function() {

                var historyFocus;

                function isCompInDOM(comp) {
                    return comp && comp.getRoot() && comp.getRoot().isInDOMTree();
                }

                historyFocus = navigation.options.historyFocus ? navigation.options.historyFocus : null;

                // focus on the history focus only if it is in DOM
                // if not, focus on last active focus
                if (isCompInDOM(historyFocus)) {
                    focusMgr.focus(historyFocus);
                } else {
                    focusMgr.focus(focusMgr.getLastActiveFocus());
                }
            });
        },

        /**
         * Register to AppRoot as default history handling, listen to ControllerManager's events
         * Rewrite the active of the extended history manager.
         * @name activate
         * @memberof tvedemo/mgr/sHistoryManager#
         * @function
         * @public
         */
        activate: function () {
            var self = this;

            //register to AppRoot as default history handling
            sAppRoot.setDefaultKeyAction(
                this._backKeys,

                function () { // We make no use of the keyEvt parameter to this function.
                    self.back();
                }

            );

            //listen to ControllerManager's events
            sCtrlMgr.addEventListener(sCtrlMgr.constructor.EVT_REPLACED, function (param) {

                //skip on doing history back
                if (param.options.__doHistoryBack) {
                    return;
                }

                self._push({
                    front: param.exist,
                    frontContext: param.exist.getContextTree(),
                    controller: param.replacement,
                    options: param.options
                });
            });

            sCtrlMgr.addEventListener(sCtrlMgr.constructor.EVT_OPENED, function (param) {

                //skip on doing history back
                if (param.options.__doHistoryBack) {
                    return;
                }

                if (param.options.appRootFirstController) {
                    //skip if opening first controller
                    return;
                }

                self._push({
                    front: null,
                    frontContext: param.options.frontContext,
                    controller: param.controller,
                    options: param.options
                });
            });

            sCtrlMgr.addEventListener(sCtrlMgr.constructor.EVT_CLOSED, function (param) {

                //skip on doing history back
                if (param.options.__doHistoryBack) {
                    return;
                }

                self._push({
                    front: param.controller,
                    frontContext: param.controller.getContextTree(),
                    controller: null,
                    options: param.options
                });
            });
        }

    });


    return new StormHistoryManager();
});
define("xdk-ui-basic/interface/Scrollable", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    return Interface.create("Scrollable", {
                registerMediator: ["mediator"],
                unregisterMediator: ["mediator"],
                unregisterAllMediator: []
    });
});
 define("xdk-ui-basic/AbstractScrollable", ["xdk-ui-basic/interface/Scrollable", "xdk-base/class", "xdk-ax/Container", "xdk-ax/evt/type", "xdk-base/console", "xdk-base/util", "xdk-base/core"], function(IScrollable, klass, Container, evtType, console, util, core) {
    "use strict";
    return klass.createAbstract(Container, [IScrollable], {}, {
                __mediator: [],
                registerMediator: function(mediator) {
            if (!mediator.setScrollable) {
                throw core.createException("IncorrectParam", "Incorrect mediator implementation or not a proper mediator!");
            }

            // pass current instance to mediator to set
            mediator.setScrollable(this);
        },
                unregisterMediator: function(mediator) {
            if (!mediator.setScrollable) {
                throw core.createException("IncorrectParam", "Incorrect mediator implementation or not a proper mediator!");
            }
            var index = util.indexOf(this.__mediator, mediator);
            if (index > -1) {
                this.__mediator.splice(index, 1);
                // pass current instance to mediator to unset
                mediator.unsetScrollable(this);
            }
        },
                unregisterAllMediator: function() {
            util.each(this.__mediator, util.bind(function(obj) {
                this.unregisterMediator(obj);
            }, this));
        },
                dispatchScrolledInfo: function(start, length, total) {
            var opt = {
                start: start || 0,
                length: length || 1,
                total: total || 1
            };
            console.info(opt);
            this.dispatchEvent(evtType.SCROLLED_INDICATOR, opt);
        },
                dispatchScrolledUpdate: function(percent) {
            this.dispatchEvent(evtType.SCROLLED_PERCENTAGE, percent);
        },
               
        update: function(reverse, percent) {
            console.warn("update is not implemented in Scrollable Object");
        }

    });
});

define("xdk-ui-basic/interface/Indicator", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    return Interface.create("Indicator", {
                update: ["percent"],
                set: ["start", "length", "total"]
    });
});
define("xdk-ui-basic/AbstractIndicator", ["xdk-ui-basic/interface/Indicator", "xdk-base/class", "xdk-ax/Component", "xdk-ax/evt/type", "xdk-base/console"], function (IIndicator, klass, Component, evtType, console) {
	"use strict";
	return klass.createAbstract(Component, [IIndicator], {}, {
				update: function (percent) {
			console.warn("update is not implemented in Indicator Object");
		},
				set: function (start, length, total) {
			console.warn("set is not implemented in Indicator Object");
		},
				dispatchIndicatorUpdate: function (reverse, percent) {
			var obj = {};
			obj.reverse = reverse || false;
			obj.percent = percent || 0;
			this.dispatchEvent(evtType.INDICATOR_UPDATED, obj);
		}
	});
});


define('css!xdk-ui-basic/css/Scrollbar',[],function(){});
define("xdk-ui-basic/Scrollbar", ["xdk-base/class", "xdk-base/util", "xdk-base/Element", "xdk-base/console", "xdk-ui-basic/AbstractIndicator", "css!./css/Scrollbar"], function (klass, util, Element, console, Indicator) {
    "use strict";
	return klass.create(Indicator, {
				VERTICAL: 0x01,
				HORIZONTAL: 0x02
	}, {
				_track: null,
				_nodeTable: null,
				_vertical: true,
				_trackTopTd: null,
				_nodeTopTd: null,
				_nodeMiddleTd: null,
				_nodeBottomTd: null,
				_trackTopping: true,
				__previousPosition: 0,
				init: function (opts) {
			if (!opts.orientation) {
				opts.orientation = this.constructor.VERTICAL;
			}

			if (!opts.trackTopping) {
				this._trackTopping = opts.trackTopping;
			}

			if (!opts.trackTopping) {
				this._trackTopping = opts.trackTopping;
			}

			this._super(opts);
			var trackTopTr, trackMiddleTd, trackBottomTd, trackBottomTr, trackMiddleTr, nodeMiddleTd, nodeTopTr, nodeMiddleTr, nodeBottomTr;
			this.getRoot().addClass("wgt-scrollbar");
			if (opts.orientation === this.constructor.HORIZONTAL) {
				this._vertical = false;
				this.getRoot().addClass("wgt-scrollbar-h");
			} else {
				this.getRoot().addClass("wgt-scrollbar-v");
			}

			this._trackTable = new Element("table", {
				cellpadding: "0",
				cellspacing: "0",
				width: "100%"
			});

			this._trackTable.addClass("track");
			trackTopTr = new Element("tr");
			this._trackTopTd = new Element("td");
			this._trackTopTd.addClass("trackTop");
			if (this._vertical) {
				trackMiddleTr = new Element("tr");
				trackBottomTr = new Element("tr");
			}

			trackMiddleTd = new Element("td");
			trackMiddleTd.addClass("trackMiddle");
			trackBottomTd = new Element("td");
			trackBottomTd.addClass("trackBottom");
			this._nodeTable = new Element("table", {
				cellpadding: "0",
				cellspacing: "0"
			});
			this._nodeTable.addClass("nodeTable");

			nodeTopTr = new Element("tr");
			if (this._vertical) {
				nodeTopTr.addClass("nodeTopTr");
			}

			this._nodeTopTd = new Element("td");
			this._nodeTopTd.addClass("nodeTop");
			if (this._vertical) {
				nodeMiddleTr = new Element("tr");
				nodeMiddleTr.addClass("nodeMiddleTr");
				nodeBottomTr = new Element("tr");
				nodeBottomTr.addClass("nodeBottomTr");
			}

			nodeMiddleTd = new Element("td");
			nodeMiddleTd.addClass("nodeMiddle");
			this._nodeBottomTd = new Element("td");
			this._nodeBottomTd.addClass("nodeBottom");
			trackTopTr.append(this._trackTopTd);
			if (this._vertical) {
				trackMiddleTr.append(trackMiddleTd);
				trackBottomTr.append(trackBottomTd);
			} else {
				trackTopTr.append(trackMiddleTd);
				trackTopTr.append(trackBottomTd);
			}

			this._trackTable.append(trackTopTr);
			if (this._vertical) {
				this._trackTable.append(trackMiddleTr);
				this._trackTable.append(trackBottomTr);
			}

			nodeTopTr.append(this._nodeTopTd);
			if (this._vertical) {
				nodeMiddleTr.append(nodeMiddleTd);
				nodeBottomTr.append(this._nodeBottomTd);
			} else {
				nodeTopTr.append(nodeMiddleTd);
				nodeTopTr.append(this._nodeBottomTd);
			}

			this._nodeTable.append(nodeTopTr);
			if (this._vertical) {
				this._nodeTable.append(nodeMiddleTr);
				this._nodeTable.append(nodeBottomTr);
			}

			this.getRoot().append(this._trackTable);
			this.getRoot().append(this._nodeTable);
		},
				set: function (start, length, total) {
			if (start + length > total) {
				length = total - start;
			}
			var deferFunc = function () {
					var trackE = this._trackTable.getHTMLElement(),
						nodeStyle = this._nodeTable.getHTMLElement().style,
						trackTopTdE = this._trackTopTd.getHTMLElement(),
						nodeTopTdE = this._nodeTopTd.getHTMLElement(),
						nodeBottomTdE = this._nodeBottomTd.getHTMLElement(),
						trackHeight, trackY, nodeHeight, nodeY, trackWidth, trackX, nodeWidth, nodeX;
					if (this._vertical) {
						trackHeight = trackE.scrollHeight - (this._trackTopping ? trackTopTdE.scrollHeight * 2 : 0);
						trackY = trackE.scrollTop;
						nodeHeight = Math.ceil(trackHeight * length / total) + (this._trackTopping ? trackTopTdE.scrollHeight * 2 : 0);
						nodeHeight = Math.max(nodeTopTdE.scrollHeight + nodeBottomTdE.scrollHeight, nodeHeight);
						if (total === length) {
							nodeY = 0;
						} else {
							nodeY = Math.ceil(trackY + (this._trackTopping ? trackTopTdE.scrollHeight : 0) + start / (total - length) * (trackHeight - nodeHeight));
						}
						console.info("trackHeight: " + trackHeight + " trackY: " + trackY + " nodeHeight: " + nodeHeight + " nodeY: " + nodeY);
						nodeStyle.height = nodeHeight + "px";
						nodeStyle.top = nodeY + "px";
						this.__nodeHeight = nodeHeight;
						this.__trackHeight = trackHeight;
					} else {
						trackWidth = trackE.scrollWidth - (this._trackTopping ? trackTopTdE.scrollWidth * 2 : 0);
						trackX = trackE.scrollLeft;
						nodeWidth = Math.ceil(trackWidth * length / total) + (this._trackTopping ? trackTopTdE.scrollWidth * 2 : 0);
						nodeWidth = Math.max(nodeTopTdE.scrollWidth + nodeBottomTdE.scrollWidth, nodeWidth);
						if (total === length) {
							nodeX = 0;
						} else {
							nodeX = Math.ceil(trackX + (this._trackTopping ? trackTopTdE.scrollWidth : 0) + start / (total - length) * (trackWidth - nodeWidth));
						}

						nodeStyle.left = nodeX + "px";
						nodeStyle.width = nodeWidth + "px";

						this.__nodeWidth = nodeWidth;
						this.__trackWidth = trackWidth;
					}
					//need to add it here to make it work properly    
					this._nodeTable.css("tableLayout", "fixed");
					if (this.getRoot().css("display") !== "none") {
						this.show();
					}

				};
			util.defer().then(util.bind(deferFunc, this)).done();
		},
				update: function (percent) {
			if (percent < 0 || percent > 1) {
				console.warn("percentage should be within 0 to 1");
				return;
			}
			if (this._vertical) {
				this._nodeTable.css("top", (this.__trackHeight - this.__nodeHeight) * percent + "px");
			} else {
				this._nodeTable.css("left", (this.__trackWidth - this.__nodeWidth) * percent + "px");
			}
		}
	});
});
/**
 * Scrollbar class inherited from "xdk-ui-basic/Scrollbar"
 * Fixes an issue with the scrollbar elevator height that could start off large,
 * and then shrink as the user scrolls down
 */
define("fix/Scrollbar", ["xdk-base/class", "xdk-base/console", "xdk-base/util", "xdk-ui-basic/Scrollbar"], function (klass, console, util, Scrollbar) {

    "use strict";

	return klass.create(Scrollbar, {}, {

		init: function (opts) {
			console.warn("Using custom Scrollbar component, careful if the original one gets updated!");
			this._super(opts);
		},

		set: function (start, length, total) {
			var baseLength = length;
			if (start + length > total) {
				length = total - start;
			}
			var deferFunc = function () {
					var trackE = this._trackTable.getHTMLElement(),
						nodeStyle = this._nodeTable.getHTMLElement().style,
						trackTopTdE = this._trackTopTd.getHTMLElement(),
						/* nodeTopTdE = this._nodeTopTd.getHTMLElement(),
						nodeBottomTdE = this._nodeBottomTd.getHTMLElement(),*/
						trackHeight, trackY, nodeHeight, nodeY, trackWidth, trackX, nodeWidth, nodeX;
					if (this._vertical) {
						trackHeight = trackE.scrollHeight - (this._trackTopping ? trackTopTdE.scrollHeight * 2 : 0);
						trackY = trackE.scrollTop;
						//nodeHeight = Math.ceil(trackHeight * length / total) + (this._trackTopping ? trackTopTdE.scrollHeight * 2 : 0);
						//nodeHeight = Math.max(nodeTopTdE.scrollHeight + nodeBottomTdE.scrollHeight, nodeHeight);
						// FIX RIGHT BELOW
						// not sure what all the other stuff was doing; in our case this calculation is enough
						nodeHeight = Math.ceil(baseLength * Math.min(1, baseLength / total));							
						if (total === length) {
							nodeY = 0;
						} else {
							nodeY = Math.ceil(trackY + (this._trackTopping ? trackTopTdE.scrollHeight : 0) + start / (total - length) * (trackHeight - nodeHeight));
						}
						console.info("trackHeight: " + trackHeight + " trackY: " + trackY + " nodeHeight: " + nodeHeight + " nodeY: " + nodeY);
						nodeStyle.height = nodeHeight + "px";
						nodeStyle.top = nodeY + "px";
						this.__nodeHeight = nodeHeight;
						this.__trackHeight = trackHeight;
					} else {
						trackWidth = trackE.scrollWidth - (this._trackTopping ? trackTopTdE.scrollWidth * 2 : 0);
						trackX = trackE.scrollLeft;
						//nodeWidth = Math.ceil(trackWidth * length / total) + (this._trackTopping ? trackTopTdE.scrollWidth * 2 : 0);
						//nodeWidth = Math.max(nodeTopTdE.scrollWidth + nodeBottomTdE.scrollWidth, nodeWidth);
						// FIX IS NEXT LINE (same comment as above)
						nodeWidth = Math.ceil(baseLength * Math.min(1, baseLength / total));							
						if (total === length) {
							nodeX = 0;
						} else {
							nodeX = Math.ceil(trackX + (this._trackTopping ? trackTopTdE.scrollWidth : 0) + start / (total - length) * (trackWidth - nodeWidth));
						}

						nodeStyle.left = nodeX + "px";
						nodeStyle.width = nodeWidth + "px";

						this.__nodeWidth = nodeWidth;
						this.__trackWidth = trackWidth;
					}
					//need to add it here to make it work properly    
					this._nodeTable.css("tableLayout", "fixed");
					if (this.getRoot().css("display") !== "none") {
						this.show();
					}

				};
			util.defer().then(util.bind(deferFunc, this)).done();
		}

	});
});
/**
 * A util to add some css into document.head. Temporary before AMD css plugin is
 * ready
 * @module xdk-base/cssUtil
 */
amd.define("xdk-base/cssUtil", ["xdk-base/promise", "xdk-base/console"], function (promise, console) {
    "use strict";
    return {
        /**
         * Add some CSS into document.head using <style> tag.  
         * Returns a promise containing a reference to the style node. 
         * Promise resolves when the style node is added to the DOM, but not necessarily before the CSS has been parsed and applied.
         *
         * @method
         * @param {String} css The CSS rules to add
         * @return {Promise.<HTMLStyleElement>} The node which has been added to the DOM
         * @memberof module:xdk-base/cssUtil
         */
        addCss: function (css) {
            var deferred = promise.defer();

            domReady(function () {
                try {
                    var head = document.head || document.getElementsByTagName("head")[0],
                        node = document.createElement("style");

                    node.type = "text/css";
                    if (node.styleSheet) {
                        node.styleSheet.cssText = css;
                    } else {
                        node.appendChild(document.createTextNode(css));
                    }

                    head.appendChild(node);
                    deferred.resolve(node);
                } catch (ex) {
                    deferred.reject(ex);
                }
            });

            return deferred.promise;
        },

        /**
         * Remove a style node created by addCss().
         * @method
         * @param {HTMLStyleElement} node The CSS node to remove
         * @memberof module:xdk-base/cssUtil
         */
        removeCssNode: function(node) {
            if (node && node.parentNode) {
                node.parentNode.removeChild(node);
            } else {
                console.warn("[cssUtil] node is not a valid HTMLStyleElement, or is not in DOM");
            }
        },

        /**
         * Append CSS to a style node
         * @method
         * @param {String} css The CSS rules to append
         * @param {HTMLStyleElement} node The CSS node for the rules to append
         * @memberof module:xdk-base/cssUtil
         */
        appendCss: function(css, node) {
            if (node) {
                if (node.styleSheet) {
                    node.styleSheet.cssText += css;
                } else {
                    node.appendChild(document.createTextNode(css));
                }
            } else {
                console.warn("[cssUtil] node is not a valid HTMLStyleElement");
            }
        }
    };
});

define("xdk-base/cssUtil", function(){});

define("xdk-ui-basic/ScrollingMediator", ["xdk-base/class","xdk-ax/evt/DualEventDispatcher","xdk-ui-basic/interface/Scrollable","xdk-base/console","xdk-ax/evt/type","xdk-base/util","xdk-ui-basic/interface/Indicator"], function (klass, EventDispatcher, IScrollable, console, evtType, util, IIdicator) {
    "use strict";
    var mediator = klass.create(EventDispatcher, {}, {
                __indicator: [],
                __scrollableComp: null,
                __scrollable: [],
                __emitScrolledPercentHandler: null,
                __emitIndicatorInfoHandler: null,
                __emitUpdatedHandler: null,
        init: function (opts) {
            this._super(opts);
            this.__emitScrolledPercentHandler = util.bind(this.__emitScrolledPercent, this);
            this.__emitIndicatorInfoHandler = util.bind(this.__emitIndicatorInfo, this);
            this.__emitUpdatedHandler = util.bind(this.__emitUpdated, this);
        },
                registerIndicator: function (indicator) {

            //@deprecated since it won't listen to indicator update anymore.
            indicator.addEventListener(evtType.INDICATOR_UPDATED, this.__emitUpdatedHandler);

            this.__indicator.push(indicator);
        },
                setScrollable: function (scrollable) {
            if (!klass.hasImpl(scrollable.constructor, IScrollable)) {
                console.warn("scrollable does not implement scrollable interface");
                return;
            }

            if (this.__scrollableComp) {
                console.warn("scrollable exists, replace with new scrollable");
                this.unsetScrollable();
            }


            scrollable.addEventListener(evtType.SCROLLED_PERCENTAGE, this.__emitScrolledPercentHandler);
            scrollable.addEventListener(evtType.SCROLLED_INDICATOR, this.__emitIndicatorInfoHandler);

            this.__scrollableComp = scrollable;
        },
                __emitIndicatorInfo: function (evt) {

            var start, length, total;
            start = evt.start || 0;
            length = evt.length || 1;
            total = evt.total || 1;

            util.each(this.__indicator, function (obj) {
                if (obj.set) {
                    obj.set(start, length, total);
                }
            });

        },
                __emitScrolledPercent: function (percent) {

            util.each(this.__indicator, function (obj) {
                if (obj.update) {
                    obj.update(percent);
                }
            });
        },
                unregisterIndicator: function (indicator) {
            var index;

            index = util.indexOf(this.__indicator, indicator);

            if (index > -1) {

                 //@deprecated since it won't listen to indicator update anymore.
                indicator.removeEventListener(evtType.INDICATOR_UPDATED, this.__emitUpdatedHandler);
                
                this.__indicator.splice(index, 1);

            }

        },
                unsetScrollable: function () {

            var scrollable = this.__scrollableComp;

            if (!scrollable) {
                return;
            }

            scrollable.removeEventListener(evtType.SCROLLED_PERCENTAGE, this.__emitScrolledPercentHandler);
            scrollable.removeEventListener(evtType.SCROLLED_INDICATOR, this.__emitIndicatorInfoHandler);

            this.__scrollableComp = null;
        },

                unregisterAllIndicators: function () {

            util.each(this.__indicator, util.bind(function (obj) {
                this.unregisterIndicator(obj);
            }, this));

        },
                unregisterAll: function () {

            this.unregisterAllIndicators();
            this.unsetScrollable();

            // keep for Backward Compatible
            this.unregisterScrollables();
        },

                registerScrollable: function (scrollable) {

            scrollable.addEventListener(evtType.SCROLLED_PERCENTAGE, this.__emitScrolledPercentHandler);
            scrollable.addEventListener(evtType.SCROLLED_INDICATOR, this.__emitIndicatorInfoHandler);

            this.__scrollable.push(scrollable);
        },
                unregisterScrollable: function (scrollable) {
            var index;

            index = util.indexOf(this.__scrollable, scrollable);

            if (index > -1) {

                scrollable.removeEventListener(evtType.SCROLLED_PERCENTAGE, this.__emitScrolledPercentHandler);
                scrollable.removeEventListener(evtType.SCROLLED_INDICATOR, this.__emitIndicatorInfoHandler);

                this.__scrollable.splice(index, 1);
            }
        },
                __emitUpdated: function (obj) {

            var reverse, percent;
            reverse = obj.reverse || false;
            percent = obj.percent || 0;

            //notify each scrollable comp about the change
            util.each(this.__scrollable, function (item) {
                if (item.update) {
                    item.update(reverse, percent);
                }
            });

            //notify the scrollable comp about the update which is received from indicator.
            if (this.__scrollableComp && this.__scrollableComp.update) {
                this.__scrollableComp.update(reverse, percent);
            }

        },
                unregisterScrollables: function () {

            util.each(this.__scrollable, util.bind(function (obj) {
                this.unregisterScrollable(obj);
            }, this));

        }
    });

    return mediator;
});
/**
 * The scroll Label consist of label and scroll bar. It will scroll when focused and user presses UP or DOWN key.
 * @name ScrollLabel
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/ScrollLabel
 * @extends ax/ext/ui/Container
 */
define("tvedemo/wgt/ScrollLabel", [
    "xdk-base/class", "xdk-ui-basic/AbstractScrollable", "xdk-base/util",
    "xdk-ui-basic/Label", "fix/Scrollbar", "xdk-base/Element",
    "xdk-ax/evt/type", "xdk-base/cssUtil", "xdk-ui-basic/ScrollingMediator",
    "xdk-base/console", "xdk-base/device/vKey"
], function (klass, AbstractScrollable, util,
    Label, Scrollbar, Element,
    evtType, cssUtil, ScrollingMediator,
    console, vKey) {
    "use strict";

    cssUtil.addCss(".wgt-scrollLabel .container{\
                        position: absolute;\
                        overflow:hidden;\
                    }\
                    .wgt-scrollLabel .text{\
                        position:absolute;\
                        top:0px;\
                    }");

    return klass.create(AbstractScrollable, {}, {

        // Store the label.
        __label: null,

        // Store the label container which will be measured the height of this container and label height.
        __labelContainer: null,

        // Store the scrollbar.
        __scrollbar: null,

        // Store the status.
        __inited: false,

        // The scrollable container height.
        __containerHeight: 0,

        // The label height.
        __labelHeight: 0,

        // If the label is able to scroll or not.
        __scrollable: false,

        // The maximum step to scroll.
        __maxStep: 0,

        // Each step size.
        __stepSize: 0,
        
        // If the component is focused
        __focused: false,

        /**
         * Overrides parent init() function.
         * @param {Object} opts            Options
         * @param {String} opts.text       The text to display inside the label
         * @param {Number} opts.scrollStep The length to scroll for each step in pixel. Default is 50 pixels.
         * @return {void}
         */
        init: function (opts) {
            var mediator = new ScrollingMediator(),
                text;

            opts = opts || {};
            opts.focusable = true;
            opts.root = new Element("div");

            text = opts.text || "";
            this.__stepSize = opts.scrollStep || 50;

            this._super(opts);

            this.getRoot().addClass("wgt-scrollLabel");

            // Add a scroll container for scrolling text.
            this.__labelContainer = new Element("div").addClass("container");
            this.getRoot().append(this.__labelContainer);

            this.__label = new Label({
                parent: this
            });

            // Set it to be text class only.
            this.__label.getRoot().setClass("text");

            this.__scrollbar = new Scrollbar({
                css: "scrollbar",
                parent: this
            });

            this.setText(text);

            // Update the position.
            this.__attachToDomRef = util.bind(this.__attachToDom, this);
            this.addEventListener(evtType.ATTACHED_TO_DOM, this.__attachToDomRef);

            this.__detachFromDomRef = util.bind(this.__detachFromDom, this);
            this.addEventListener(evtType.DETACHED_FROM_DOM, this.__detachFromDomRef);
            
            this._onFocusRef = util.bind(this._onFocus, this);
            this.addEventListener(evtType.FOCUS, this._onFocusRef);
            
            this._onBlurRef = util.bind(this._onBlur, this);
            this.addEventListener(evtType.BLUR, this._onBlurRef);

            mediator.registerIndicator(this.__scrollbar);
            mediator.setScrollable(this);

            this.addEventListener(evtType.KEY, util.bind(this._onKey, this));
            this.getRoot().addEventListener("mousewheel", util.bind(this._onScrollWheel, this));

            this.__inited = true;
        },

        /**
         * Handling When the widget gets focus
         * @param  {Object} event Event information.
         * @return {boolean} true if event has been handled.
         */
        _onFocus: function (event) {
            this.__focused = true;
        },

        /**
         * Handling When the widget loses focus
         * @param  {Object} event Event information.
         * @return {boolean} true if event has been handled.
         */
        _onBlur: function (event) {
            this.__focused = false;
        },

        /**
         * Handling Scroll Wheel Events.
         * @param  {Object} scrollEvent Scroll event information.
         * @return {boolean} true if event has been handled.
         */
        _onScrollWheel: function (scrollEvent) {
            if (this.__focused)
            {
                var evt     = scrollEvent || window.event;
                var delta   = evt.detail ? evt.detail*(-120) : evt.wheelDelta;
                if (delta > 0)
                {
                    // Scroll down if it's HORIZONTAL scrollbar.
                    (this.__scrollbar._opts.orientation === Scrollbar.HORIZONTAL) ? this.scroll(true) : this.scroll(false);
                }
                else
                {
                    // Scroll up if it's HORIZONTAL scrollbar.
                    (this.__scrollbar._opts.orientation === Scrollbar.HORIZONTAL) ? this.scroll(false) : this.scroll(true);
                }
            }
        },

        /**
         * Handling key Events.
         * @param  {Object} keyEvent Key event information.
         * @return {boolean} true if event has been handled.
         */
        _onKey: function (keyEvent) {

            switch (keyEvent.id) {

                case vKey.UP.id:

                    // Make sure that focus only is forwarded upwards if no more upward scrolling is possible.
                    if (this.scroll(false)) {
                        return false;
                    }

                    return true;
                case vKey.DOWN.id:

                    // Make sure that focus only is forwarded downwards if no more downward scrolling is possible.
                    if (this.scroll(true)) {
                        return false;
                    }

                    return true;
                default:
                    break;
            }

            return true;
        },

        /**
         * Set the text to be displayed on the label.
         * @param {String} text the text to set
         * @return {void}
         */
        setText: function (text) {
            this.__label.setText(text);

            // Update the size when setText after inited. If it is in inited stage, it will update when attach to dom.
            if (this.__inited) {

                // Scroll to back immediately.
                this.__updateSize();
                this._scrollTo(0);
            }
        },

        /**
         * Get the text in the label.
         * @return {String} The text
         */
        getText: function () {
            return this.__label.getText();
        },

        /**
         * Perform the actual scroll on the label.
         * This function will detect the current position and decide the next target position.
         * @param {Boolean} downward True if scroll downward, false if scroll upward
         * @return {void}
         */
        scroll: function (downward) {

            if (!this.__scrollable) {
                console.info("Abort the scroll: The content is fit into the label, no scroll is needed.");
                return;
            }

            // currentPosition would be a non-positive number.
            var currentPosition = parseInt(this.__label.getRoot().getHTMLElement().offsetTop, 10),
                size = this.__stepSize,
                targetPosition;

            downward = util.isUndefined(downward) ? true : downward;
            targetPosition = currentPosition + (downward ? -size : size);

            if (targetPosition >= 0) {

                if (currentPosition >= 0) {
                    return false;
                }

                // Scroll upward and exceed the boundary.
                this._scrollTo(0);

            } else if (targetPosition > this.__maxStep) {

                // Normal scrolling case.
                this._scrollTo(targetPosition);

            } else {

                if (currentPosition === this.__maxStep) {
                    return false;

                } else {

                    // If the target < the bottom boundary, scroll to the boundary.
                    this._scrollTo(this.__maxStep);
                }
            }

            return true;
        },
        /**
         * Set the focusable option of label.
         * @param {Boolean} focusable option to set
         * @return {void}
         */
        setFocusable: function (value) {
            // Should be focusable if scrolling is possible.
            if (this.__scrollable) {
                if (this.getOption("focusable") === false) {
                    this.setOption("focusable", true);
                }
                return;
            }
            var focusableValue = !!value;
            this.setOption("focusable", focusableValue);
        },
        /**
         * Get the label position.
         * @return {Number} The position
         */
        __getPosition: function () {
            return parseInt(this.__label.getRoot().getHTMLElement().offsetTop, 10);
        },

        /**
         * Scroll to the specific position.
         * @param {Number} targetPosition The target position of the label
         * @return {void}
         */
        _scrollTo: function (targetPosition) {
            var currentPosition = this.__getPosition();
            if (currentPosition === targetPosition) {
                console.info("Abort the scroll: Label is at target position.");
                return;
            }

            this.__label.getRoot().css("top", targetPosition + "px");
            this.dispatchScrolledInfo(-targetPosition, this.__containerHeight, this.__labelHeight);

            this.__processing = true;
        },

        /**
         * To get the size when attached to dom.
         * @return {void}
         */
        __attachToDom: function () {
            this.__updateSize();
        },

        /**
         * To append the label into the container.
         * @param {Object} label     Label to be attached
         * @param {Object} placement Where to place the label
         * @param {Object} marker    Scrolling marker
         * @return {void}
         */
        _doAttach: function (child, placement, marker) {

            // To ensure the structure of the scrolling label.
            if (this.__inited) {
                console.info("Unavailable to append more children after inited.");
                return;
            }

            var parent = this._root;

            // Attach the label to the scroll container.
            if (child instanceof Label) {
                parent = this.__labelContainer;
            }

            switch (placement) {
                case AbstractScrollable.PLACE_APPEND:
                    parent.append(child.getRoot());
                    break;
                case AbstractScrollable.PLACE_PREPEND:
                    parent.prepend(child.getRoot());
                    break;
                case AbstractScrollable.PLACE_BEFORE:
                    parent.insertBefore(marker.getRoot(), child.getRoot());
                    break;
                case AbstractScrollable.PLACE_AFTER:
                    parent.insertAfter(marker.getRoot(), child.getRoot());
                    break;
            }
        },

        /**
         * To update the container size.
         * @return {void}
         */
        __updateSize: function () {
            this.__labelHeight = this.__label.getRoot().getHTMLElement().offsetHeight;
            this.__containerHeight = this.__labelContainer.getHTMLElement().offsetHeight;

            // To determine whether scrolling is possible.
            if (this.__labelHeight > this.__containerHeight) {
                this.__scrollable = true;
                this.__scrollbar.show();
                this.dispatchScrolledInfo(0, this.__containerHeight, this.__labelHeight);

            } else {
                this.__scrollable = false;
                this.__scrollbar.hide();
                //
                // This added, so that we have a full height 'elevator' instead of no elevator...
                //
                this.dispatchScrolledInfo(0, this.__containerHeight, this.__containerHeight);
            }

            this.__maxStep = -(this.__labelHeight - this.__containerHeight);
        },

        /**
         * To remove the event listener.
         * @return {void}
         */
        __detachFromDom: function () {
            this.removeEventListener(evtType.ATTACHED_TO_DOM, this.__attachToDomRef);
            this.removeEventListener(evtType.DETACHED_FROM_DOM, this.__detachFromDomRef);
        }
    });
});

define('css!xdk-ui-basic/css/Checkbox',[],function(){});
define("xdk-ui-basic/Checkbox", ["xdk-base/class", "xdk-ax/Component", "xdk-base/Element", "xdk-ax/evt/type", "xdk-base/util", "css!./css/Checkbox"], function (klass, Component, Element, evtType, util) {
    "use strict";
	return klass.create(Component, {}, {
				_value: false,
				_image: null,
				init: function (opts) {

			opts.focusable = true;
			opts.clickable = true;

			this._super(opts);

			this.getRoot().addClass("wgt-checkbox");

			this._value = !! opts.checked;
			this._image = new Element("span");

			if ( !! this._value) {
				this._image.addClass("checked");
			}

			this.getRoot().append(this._image);

			//to listen the event and toggle the check
			this.addEventListener(evtType.CLICK, util.bind(function () {
				this.toggle();
			}, this));
		},
				toggle: function () {
			this.check(!this._value);
		},
				check: function (isChecked) {
			var toCheck = util.isUndefined(isChecked) || !! isChecked;

			if (toCheck && !this._value) {
				this._image.addClass("checked");
			} else if (!toCheck && this._value) {
				this._image.removeClass("checked");
			}
			this._value = toCheck;
			this.dispatchEvent(evtType.VALUE_CHANGED, this._value);
		},
				uncheck: function () {
			this.check(false);
		},
				getValue: function () {
			return this._value;
		}
	});
});
/* jshint ignore:start */
//! moment.js
//! version : 2.4.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

define("lib/moment", [],function() {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.4.0",
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO seperator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        // preliminary iso regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000)
        isoRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d:?\d\d|Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            'YYYY-MM-DD',
            'GGGG-[W]WW',
            'GGGG-[W]WW-E',
            'YYYY-DDD'
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds': 1,
            'Seconds': 1e3,
            'Minutes': 6e4,
            'Hours': 36e5,
            'Days': 864e5,
            'Months': 2592e6,
            'Years': 31536e6
        },

        unitAliases = {
            ms: 'millisecond',
            s: 'second',
            m: 'minute',
            h: 'hour',
            d: 'day',
            D: 'date',
            w: 'week',
            W: 'isoWeek',
            M: 'month',
            y: 'year',
            DDD: 'dayOfYear',
            e: 'weekday',
            E: 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear: 'dayOfYear',
            isoweekday: 'isoWeekday',
            isoweek: 'isoWeek',
            weekyear: 'weekYear',
            isoweekyear: 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M: function() {
                return this.month() + 1;
            },
            MMM: function(format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM: function(format) {
                return this.lang().months(this, format);
            },
            D: function() {
                return this.date();
            },
            DDD: function() {
                return this.dayOfYear();
            },
            d: function() {
                return this.day();
            },
            dd: function(format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd: function(format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd: function(format) {
                return this.lang().weekdays(this, format);
            },
            w: function() {
                return this.week();
            },
            W: function() {
                return this.isoWeek();
            },
            YY: function() {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY: function() {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY: function() {
                return leftZeroFill(this.year(), 5);
            },
            gg: function() {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg: function() {
                return this.weekYear();
            },
            ggggg: function() {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG: function() {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG: function() {
                return this.isoWeekYear();
            },
            GGGGG: function() {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e: function() {
                return this.weekday();
            },
            E: function() {
                return this.isoWeekday();
            },
            a: function() {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A: function() {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H: function() {
                return this.hours();
            },
            h: function() {
                return this.hours() % 12 || 12;
            },
            m: function() {
                return this.minutes();
            },
            s: function() {
                return this.seconds();
            },
            S: function() {
                return toInt(this.milliseconds() / 100);
            },
            SS: function() {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS: function() {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS: function() {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z: function() {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ: function() {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(10 * a / 6), 4);
            },
            z: function() {
                return this.zoneAbbr();
            },
            zz: function() {
                return this.zoneName();
            },
            X: function() {
                return this.unix();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }

    function ordinalizeToken(func, period) {
        return function(a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object

    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // store reference to input for deterministic cloning
        this._input = duration;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison

    function leftZeroFill(number, targetLength) {
        var output = number + '';
        while (output.length < targetLength) {
            output = '0' + output;
        }
        return output;
    }

    // helper function for _.addTime and _.subtractTime

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop,
            index;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        } else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        } else {
            return;
        }

        moment[field] = function(format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function initializeParsingFlags(config) {
        config._pf = {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },

        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },

        monthsParse: function(monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse: function(weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat: {
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D YYYY",
            LLL: "MMMM D YYYY LT",
            LLLL: "dddd, MMMM D YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM: function(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        calendar: function(key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",

        preparse: function(string) {
            return string;
        },

        postformat: function(string) {
            return string;
        },

        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function() {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.

    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.

    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.

    function getLangDefinition(key) {
        var i = 0,
            j, lang, next, split,
            get = function(k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) {}
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object

    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token

    function getParseRegexForToken(token, config) {
        var a;
        switch (token) {
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return parseTokenFourDigits;
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return parseTokenSixDigits;
            case 'S':
            case 'SS':
            case 'SSS':
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return getLangDefinition(config._l)._meridiemParse;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            default:
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
                return a;
        }
    }

    function timezoneMinutesFromString(string) {
        var tzchunk = (parseTokenTimezone.exec(string) || [])[0],
            parts = (tzchunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date

    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // MONTH
            case 'M': // fall through to MM
            case 'MM':
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM': // fall through to MMMM
            case 'MMMM':
                a = getLangDefinition(config._l).monthsParse(input);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
                // DAY OF MONTH
            case 'D': // fall through to DD
            case 'DD':
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
                // DAY OF YEAR
            case 'DDD': // fall through to DDDD
            case 'DDDD':
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
                // YEAR
            case 'YY':
                datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
                break;
            case 'YYYY':
            case 'YYYYY':
                datePartArray[YEAR] = toInt(input);
                break;
                // AM / PM
            case 'a': // fall through to A
            case 'A':
                config._isPm = getLangDefinition(config._l).isPM(input);
                break;
                // 24 HOUR
            case 'H': // fall through to hh
            case 'HH': // fall through to hh
            case 'h': // fall through to hh
            case 'hh':
                datePartArray[HOUR] = toInt(input);
                break;
                // MINUTE
            case 'm': // fall through to mm
            case 'mm':
                datePartArray[MINUTE] = toInt(input);
                break;
                // SECOND
            case 's': // fall through to ss
            case 'ss':
                datePartArray[SECOND] = toInt(input);
                break;
                // MILLISECOND
            case 'S':
            case 'SS':
            case 'SSS':
            case 'SSSS':
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
                // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
                // TIMEZONE
            case 'Z': // fall through to ZZ
            case 'ZZ':
                config._useUTC = true;
                config._tzm = timezoneMinutesFromString(input);
                break;
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'dd':
            case 'ddd':
            case 'dddd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
                /* falls through */
            case 'gg':
            case 'gggg':
            case 'GG':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = input;
                }
                break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]

    function dateFromConfig(config) {
        var i, date, input = [],
            currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function(val) {
                return val ?
                    (val.length < 3 ? (parseInt(val, 10) > 68 ? '19' + val : '20' + val) : val) :
                    (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            } else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ? parseWeekday(w.d, lang) :
                    (w.e != null ? parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string

    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                } else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript

    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings

    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            initializeParsingFlags(tempConfig);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format

    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 4; i > 0; i--) {
                if (match[i]) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i - 1] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (parseTokenTimezone.exec(string)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else {
            config._d = new Date(input);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !! withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))

    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday

    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = new Date(Date.UTC(year, 0)).getUTCDay(),
            daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (typeof config._pf === 'undefined') {
            initializeParsingFlags(config);
        }

        if (input === null) {
            return moment.invalid({
                nullInput: true
            });
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function(input, format, lang, strict) {
        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        return makeMoment({
            _i: input,
            _f: format,
            _l: lang,
            _strict: strict,
            _isUTC: false
        });
    };

    // creating with utc
    moment.utc = function(input, format, lang, strict) {
        var m;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        m = makeMoment({
            _useUTC: true,
            _isUTC: true,
            _l: lang,
            _i: input,
            _f: format,
            _strict: strict
        }).utc();

        return m;
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function(input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function(input, key) {
        var isDuration = moment.isDuration(input),
            isNumber = (typeof input === 'number'),
            duration = (isDuration ? input._input : (isNumber ? {} : input)),
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            timeEmpty,
            dateTimeEmpty;

        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if ( !! (match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if ( !! (match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function(inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (isDuration && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function() {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function(key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function(key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function(obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    };

    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        } else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function(input) {
        return moment(input).parseZone();
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone: function() {
            return moment(this);
        },

        valueOf: function() {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix: function() {
            return Math.floor(+this / 1000);
        },

        toString: function() {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString: function() {
            return formatMoment(moment(this).utc(), 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        },

        toArray: function() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid: function() {
            return isValid(this);
        },

        isDSTShifted: function() {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags: function() {
            return extend({}, this._pf);
        },

        invalidAt: function() {
            return this._pf.overflow;
        },

        utc: function() {
            return this.zone(0);
        },

        local: function() {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add: function(input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract: function(input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff: function(input, units, asFloat) {
            var that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                    (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                units === 'minute' ? diff / 6e4 : // 1000 * 60
                units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                diff;
            }
            return asFloat ? output : absRound(output);
        },

        from: function(time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar: function() {
            var diff = this.diff(moment().zone(this.zone()).startOf('day'), 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear: function() {
            return isLeapYear(this.year());
        },

        isDST: function() {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({
                    d: input - day
                });
            } else {
                return day;
            }
        },

        month: function(input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function(units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                    /* falls through */
                case 'month':
                    this.date(1);
                    /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                    /* falls through */
                case 'hour':
                    this.minutes(0);
                    /* falls through */
                case 'minute':
                    this.seconds(0);
                    /* falls through */
                case 'second':
                    this.milliseconds(0);
                    /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            return this;
        },

        endOf: function(units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function(input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function(input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function(input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) === +moment(input).startOf(units);
        },

        min: function(other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone: function(input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },

        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone: function() {
            if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset: function(input) {
            if (!input) {
                input = 0;
            } else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        weekYear: function(input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week: function(input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday: function(input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday: function(input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        get: function(units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set: function(units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang: function(key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    // helper for adding shortcuts

    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function(input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble: function() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks: function() {
            return absRound(this.days() / 7);
        },

        valueOf: function() {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize: function(withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add: function(input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract: function(input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as: function(units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang: moment.fn.lang,

        toIsoString: function() {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function() {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function() {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal: function(number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                    (b === 2) ? 'nd' :
                    (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // moment.js language configuration
    // language : australian english (en-au)

    (function(factory) {
        factory(moment);
    }(function(moment) {
        return moment.lang('en-au', {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L'
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinal: function(number) {
                var b = number % 10,
                    output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4 // The week that contains Jan 4th is the first week of the year.
            }
        });
    }));
    // moment.js language configuration
    // language : canadian english (en-ca)
    // author : Jonathan Abourbih : https://github.com/jonbca

    (function(factory) {
        factory(moment);
    }(function(moment) {
        return moment.lang('en-ca', {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                L: "YYYY-MM-DD",
                LL: "D MMMM, YYYY",
                LLL: "D MMMM, YYYY LT",
                LLLL: "dddd, D MMMM, YYYY LT"
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L'
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinal: function(number) {
                var b = number % 10,
                    output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                return number + output;
            }
        });
    }));
    // moment.js language configuration
    // language : great britain english (en-gb)
    // author : Chris Gedrim : https://github.com/chrisgedrim

    (function(factory) {
        factory(moment);
    }(function(moment) {
        return moment.lang('en-gb', {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY LT",
                LLLL: "dddd, D MMMM YYYY LT"
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L'
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            ordinal: function(number) {
                var b = number % 10,
                    output = (~~(number % 100 / 10) === 1) ? 'th' :
                        (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                        (b === 3) ? 'rd' : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4 // The week that contains Jan 4th is the first week of the year.
            }
        });
    }));


    // moment.js language configuration
    // language : french (fr)
    // author : John Fischer : https://github.com/jfroffice

    (function (factory) {
        factory(moment);
    }(function (moment) {
        return moment.lang('fr', {
            months : "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
            monthsShort : "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
            weekdays : "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort : "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin : "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
            longDateFormat : {
                LT : "HH:mm",
                L : "DD/MM/YYYY",
                LL : "D MMMM YYYY",
                LLL : "D MMMM YYYY LT",
                LLLL : "dddd D MMMM YYYY LT"
            },
            calendar : {
                sameDay: "[Aujourd'hui  ] LT",
                nextDay: '[Demain  ] LT',
                nextWeek: 'dddd [ ] LT',
                lastDay: '[Hier  ] LT',
                lastWeek: 'dddd [dernier  ] LT',
                sameElse: 'L'
            },
            relativeTime : {
                future : "dans %s",
                past : "il y a %s",
                s : "quelques secondes",
                m : "une minute",
                mm : "%d minutes",
                h : "une heure",
                hh : "%d heures",
                d : "un jour",
                dd : "%d jours",
                M : "un mois",
                MM : "%d mois",
                y : "un an",
                yy : "%d ans"
            },
            ordinal : function (number) {
                return number + (number === 1 ? 'er' : '');
            },
            week : {
                dow : 1, // Monday is the first day of the week.
                doy : 4  // The week that contains Jan 4th is the first week of the year.
            }
        });
    }));

    // moment.js locale configuration
    // locale : german (de)
    // author : lluchs : https://github.com/lluchs
    // author: Menelion Elensle: https://github.com/Oire

    (function (factory) {
        factory(moment);
    }(function (moment) {
        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                'm': ['eine Minute', 'einer Minute'],
                'h': ['eine Stunde', 'einer Stunde'],
                'd': ['ein Tag', 'einem Tag'],
                'dd': [number + ' Tage', number + ' Tagen'],
                'M': ['ein Monat', 'einem Monat'],
                'MM': [number + ' Monate', number + ' Monaten'],
                'y': ['ein Jahr', 'einem Jahr'],
                'yy': [number + ' Jahre', number + ' Jahren']
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }

        return moment.lang('de', {
            months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
            monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
            weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
            weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
            weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
            longDateFormat : {
                LT: 'HH:mm [Uhr]',
                L : 'DD.MM.YYYY',
                LL : 'D. MMMM YYYY',
                LLL : 'D. MMMM YYYY LT',
                LLLL : 'dddd, D. MMMM YYYY LT'
            },
            calendar : {
                sameDay: '[Heute um] LT',
                sameElse: 'L',
                nextDay: '[Morgen um] LT',
                nextWeek: 'dddd [um] LT',
                lastDay: '[Gestern um] LT',
                lastWeek: '[letzten] dddd [um] LT'
            },
            relativeTime : {
                future : 'in %s',
                past : 'vor %s',
                s : 'ein paar Sekunden',
                m : processRelativeTime,
                mm : '%d Minuten',
                h : processRelativeTime,
                hh : '%d Stunden',
                d : processRelativeTime,
                dd : processRelativeTime,
                M : processRelativeTime,
                MM : processRelativeTime,
                y : processRelativeTime,
                yy : processRelativeTime
            },
            ordinal : '%d.',
            week : {
                dow : 1, // Monday is the first day of the week.
                doy : 4  // The week that contains Jan 4th is the first week of the year.
            }
        });
    }));

    moment.lang('en');

    return moment;
});
/* jshint ignore:end */;
/**
 * The utility for cache. It can generate a cache from an old cache(if it has) with a size limitation and a purging time for each object.
 * The default setting for the cache is to purge the object after 5mins the object being created/refreshed, and the size is limited to 100.
 * For the details in architecture, please check the wiki page on https://accedobroadband.jira.com/wiki/display/TVE/Caching
 * @name CacheHelper
 * @memberof tve/util
 * @class tve/util/CacheHelper
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/util/CacheHelper", [
    "xdk-base/class", "xdk-base/core", "xdk-base/promise",
    "xdk-base/console", "xdk-base/util"
], function (klass, core, promise,
    console, util) {

    var CacheHelper = klass.create({

            /**
             * Available codes of cache TTL setting
             * @name TTL
             * @type {object}
             * @public
             * @memberof tve/util/CacheHelper
             * @static
             */
            TTL: {

                NO_CACHE: -2,

                FOREVER: -1,

                DEFAULT: 0
            }

        },

        {

            /**
             * The time of how long will the cached object be valid
             * @member __ttl
             * @memberof tve/util/CacheHelper
             * @private
             */
            __ttl: null,

            /**
             * The maximum of the objects for the cache
             * @member __size
             * @memberof tve/util/CacheHelper
             * @private
             */
            __size: null,

            /**
             * The live time for the cache objects.
             * @member __cache
             * @memberof tve/util/CacheHelper
             * @private
             */
            __cache: null,
            /**
             * whether to enable cache expire check or not
             * @member __enableCacheExpireCheck
             * @memberOf tve/util/CacheHelper
             * @private
             */
            __enableCacheExpireCheck: false,
            /**
             * Time for each cache check interval
             * @member __cacheCheckIntervalTime
             * @memberOf tve/util/CacheHelper
             * @private
             */
            __cacheCheckIntervalTime: null,
            /**
             * Init the cache helper, set the cache, and time of purging
             * @method init
             * @param {Object} [opts] Object to be set by using the different attributes
             * @param {String} [opts.ttl]  The live time for the cache object. The default time is 5 mins(5*60s).
             * @param {String} [opts.cache] Set the cache based on another one
             * @param {Object} [opts.size]  The maximum of the objects for the cache. The default size is 100.
             * @memberof tve/util/CacheHelper
             * @private
             */
            init: function (opts) {
                opts = opts || {};
                this.__ttl = opts.ttl || 20 * 60; // default 20 mins Expire Time
                this.__size = opts.size || 100;
                this.__cacheReference = [];
                
                this.__enableCacheExpireCheck = !!opts.enableCacheExpireCheck; // disable cache expire check for the moment.
                this.__cacheCheckIntervalTime = opts.cacheCheckIntervalTime || 5 * 60 * 1000; // default 5 min cache check.

                if (opts.cache) {
                    this.__cache = util.clone(opts.cache, true);

                    var cache = this.__cache,
                        cacheReference = this.__cacheReference,
                        limitedSize = this.__size,
                        importSize,
                        key,
                        i;

                    for (key in cache) {
                        if (cache.hasOwnProperty(key)) {
                            cacheReference.push(key);
                        }
                    }

                    importSize = util.size(cacheReference);

                    if (importSize > limitedSize) {
                        for (i = limitedSize; i < importSize; i++) {
                            delete cache[cacheReference[i]];
                        }
                        util.remove(cacheReference, limitedSize, importSize - 1);
                    }
                } else {
                    this.__cache = {};
                }

                if (this.__enableCacheExpireCheck && !this.__cacheCheckInterval) {
                    this.__cacheCheckInterval = setInterval(util.bind(this.__checkCache, this), this.__cacheCheckIntervalTime);
                }
            },
            /**
             * To check if each key in the cache is expired and remove from cache
             * @memberOf tve/util/CacheHelper
             * @private
             */
            __checkCache: function() {
                var cacheRef = this.__cacheReference;

                util.each(cacheRef, util.bind(function(key, idx) {
                    if (this.isExpired(key)) {
                        delete this.__cache[key];
                        util.remove(cacheRef, idx);
                    }
                }, this));
            },
            /**
             * Save obj to cache with a key, and set the timeout for purging.
             * @method setObject
             * @param {String} key the unique key for this cache
             * @param {Object} obj the actual data to be cached
             * @param {String} timestamp the time of calling sever to get the data or generating the cache object
             * @memberof tve/util/CacheHelper
             * @public
             */
            setObject: function (key, obj, timestamp, customTTL) {
                //if the object is set to no cache, then return without saving
                if (customTTL && customTTL === CacheHelper.TTL.NO_CACHE) {
                    return;
                }

                timestamp = timestamp || (new Date()).getTime();

                var cacheRef = this.__cacheReference,
                    currentSize = util.size(cacheRef),
                    index = util.indexOf(cacheRef, key),
                    ttl = customTTL || this.__ttl;

                if (index > -1) {
                    util.remove(cacheRef, index);
                } else if (currentSize && currentSize === this.__size) {
                    delete this.__cache[cacheRef[0]];
                    util.remove(cacheRef, 0);
                }
                cacheRef.push(key);

                this.__cache[key] = {
                    data: obj,
                    timestamp: timestamp,
                    expiration: timestamp + ttl * 1000
                };

                if (customTTL) {
                    this.__cache[key].customTTL = customTTL;
                }
            },

            /**
             * Set the timestamp of the cached object to the current time
             * @method renewTimestamp
             * @param {String} key the unique key for this cache
             * @memberof tve/util/CacheHelper
             * @public
             */
            renewTimestamp: function (key) {
                var obj = this.__cache[key],
                    ttl = obj.customTTL || this.__ttl,
                    time = (new Date()).getTime();

                obj.timestamp = time;
                obj.expiration = time + ttl;
            },

            /**
             * Check if the cache is expired
             * @method isExpired
             * @param {String} key the unique key for this cache
             * @return {Bool} whether it's expired
             * @memberof tve/util/CacheHelper
             * @public
             */
            isExpired: function (key) {
                var obj = this.__cache[key];

                //if the cache is set to "forever", then return false directly.
                if (obj.customTTL && obj.customTTL === CacheHelper.TTL.FOREVER) {
                    return false;
                }

                if ((new Date()).getTime() > obj.expiration) {
                    return true;
                }

                return false;
            },

            /**
             * Get cache for key
             * @method getCache
             * @param {String} key the unique key for this cache
             * @return {Object|undefined} the data in the cache object
             * @memberof tve/util/CacheHelper
             * @public
             */
            getCache: function (key) {
                if (this.__cache.hasOwnProperty(key)) {
                    return this.__cache[key].data;
                }

                return undefined;
            },

            /**
             * Get timestamp for key
             * @method getTimestamp
             * @param {String} key the unique key for this cache
             * @return {string} the timestamp in the cache object
             * @memberof tve/util/CacheHelper
             * @public
             */
            getTimestamp: function (key) {
                if (this.__cache.hasOwnProperty(key)) {
                    return this.__cache[key].timestamp;
                }

                return undefined;
            },
            /**
             * Destructor method. Should be called to ensure cache is no longer needed
             * @memberOf tve/util/CacheHelper
             */
            deinit: function() {
                if (this.__cacheCheckInterval) {
                    clearInterval(this.__cacheCheckInterval);
                }
            }

        });

    return CacheHelper;
});
/* jshint ignore:start */
/*
Cache key generation should be both smart enough to take the parameters into account and efficient. 
It may be tempting for developers to use MD5 or SHA1 
but these hashing algorithms try to ensure a lot of security and avoid any type of hash-collisions. 
Considering the type of data that will be hashed, 
the collisions and security are not of a concern and only the speed of hashing is important. 
Developers have to realise that the hashing will be done on every single HTTP request
which can greatly slow things down and on devices with low computing power, 
even MD5 generation may take long time (relatively speaking). 
Therefore a simple Base64 encoding algorithm is more than enough.
*/

/*
Copyright Vassilis Petroulias [DRDigit]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

define("lib/base64", [], function(){
    var B64 = {
        alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
        lookup: null,
        ie: /MSIE /.test(navigator.userAgent),
        ieo: /MSIE [67]/.test(navigator.userAgent),
        encode: function (s) {
            var buffer = B64.toUtf8(s),
                position = -1,
                len = buffer.length,
                nan0, nan1, nan2, enc = [, , , ];
            if (B64.ie) {
                var result = [];
                while (++position < len) {
                    nan0 = buffer[position];
                    nan1 = buffer[++position];
                    enc[0] = nan0 >> 2;
                    enc[1] = ((nan0 & 3) << 4) | (nan1 >> 4);
                    if (isNaN(nan1))
                        enc[2] = enc[3] = 64;
                    else {
                        nan2 = buffer[++position];
                        enc[2] = ((nan1 & 15) << 2) | (nan2 >> 6);
                        enc[3] = (isNaN(nan2)) ? 64 : nan2 & 63;
                    }
                    result.push(B64.alphabet.charAt(enc[0]), B64.alphabet.charAt(enc[1]), B64.alphabet.charAt(enc[2]), B64.alphabet.charAt(enc[3]));
                }
                return result.join('');
            } else {
                var result = '';
                while (++position < len) {
                    nan0 = buffer[position];
                    nan1 = buffer[++position];
                    enc[0] = nan0 >> 2;
                    enc[1] = ((nan0 & 3) << 4) | (nan1 >> 4);
                    if (isNaN(nan1))
                        enc[2] = enc[3] = 64;
                    else {
                        nan2 = buffer[++position];
                        enc[2] = ((nan1 & 15) << 2) | (nan2 >> 6);
                        enc[3] = (isNaN(nan2)) ? 64 : nan2 & 63;
                    }
                    result += B64.alphabet[enc[0]] + B64.alphabet[enc[1]] + B64.alphabet[enc[2]] + B64.alphabet[enc[3]];
                }
                return result;
            }
        },
        decode: function (s) {
            if (s.length % 4)
                throw new Error("InvalidCharacterError: 'B64.decode' failed: The string to be decoded is not correctly encoded.");
            var buffer = B64.fromUtf8(s),
                position = 0,
                len = buffer.length;
            if (B64.ieo) {
                var result = [];
                while (position < len) {
                    if (buffer[position] < 128) 
                        result.push(String.fromCharCode(buffer[position++]));
                    else if (buffer[position] > 191 && buffer[position] < 224) 
                        result.push(String.fromCharCode(((buffer[position++] & 31) << 6) | (buffer[position++] & 63)));
                    else 
                        result.push(String.fromCharCode(((buffer[position++] & 15) << 12) | ((buffer[position++] & 63) << 6) | (buffer[position++] & 63)));
                }
                return result.join('');
            } else {
                var result = '';
                while (position < len) {
                    if (buffer[position] < 128) 
                        result += String.fromCharCode(buffer[position++]);
                    else if (buffer[position] > 191 && buffer[position] < 224) 
                        result += String.fromCharCode(((buffer[position++] & 31) << 6) | (buffer[position++] & 63));
                    else 
                        result += String.fromCharCode(((buffer[position++] & 15) << 12) | ((buffer[position++] & 63) << 6) | (buffer[position++] & 63));
                }
                return result;
            }
        },
        toUtf8: function (s) {
            var position = -1,
                len = s.length,
                chr, buffer = [];
            if (/^[\x00-\x7f]*$/.test(s)) while (++position < len)
                buffer.push(s.charCodeAt(position));
            else while (++position < len) {
                chr = s.charCodeAt(position);
                if (chr < 128) 
                    buffer.push(chr);
                else if (chr < 2048) 
                    buffer.push((chr >> 6) | 192, (chr & 63) | 128);
                else 
                    buffer.push((chr >> 12) | 224, ((chr >> 6) & 63) | 128, (chr & 63) | 128);
            }
            return buffer;
        },
        fromUtf8: function (s) {
            var position = -1,
                len, buffer = [],
                enc = [, , , ];
            if (!B64.lookup) {
                len = B64.alphabet.length;
                B64.lookup = {};
                while (++position < len)
                    B64.lookup[B64.alphabet.charAt(position)] = position;
                position = -1;
            }
            len = s.length;
            while (++position < len) {
                enc[0] = B64.lookup[s.charAt(position)];
                enc[1] = B64.lookup[s.charAt(++position)];
                buffer.push((enc[0] << 2) | (enc[1] >> 4));
                enc[2] = B64.lookup[s.charAt(++position)];
                if (enc[2] == 64) 
                    break;
                buffer.push(((enc[1] & 15) << 4) | (enc[2] >> 2));
                enc[3] = B64.lookup[s.charAt(++position)];
                if (enc[3] == 64) 
                    break;
                buffer.push(((enc[2] & 3) << 6) | enc[3]);
            }
            return buffer;
        }
    };

    return B64;
});
/* jshint ignore:end */;
/**
 * Intercept calls to moment() to apply the correct offset in the case of incorrect DST. (2013 Samsung)
 */
define("tvedemo/helper/sMoment", ["lib/moment", "xdk-base/device"], function (Moment, device) {
    var moment, offset;

    // Calculate offset.
    var getOffset = function() {
        var timePlugin = document.getElementById('TimePlugin'),
            epochTime;
        if (timePlugin) {
            epochTime = timePlugin.GetEpochTime();
            if (epochTime > 0) {
                var nowSecs = new Date().getTime();
                epochTime = epochTime * 1000;

                offset = ((nowSecs - epochTime) / 1000) / 60; // Get offset in mins.
                offset = Math.round(offset / 10) * 10; // Round it to whole hours.
            }
        }
    };

    moment = function(input, format, lang, strict) {
        var offsetMoment = new Moment(input, format, lang, strict);

        if (device.platform === "playstation" && offset === undefined) { 
            // check if date is British Summer Time
            // British Summer Time starts: Last Sunday in March
            // British Summer Time ends: Last Sunday in October
            try {
                year = date.getYear();
                month = date.getMonth() + 1;
                // if Apr, May, Jun, Jul, Avg, Sep then is DST
                if (month > 3 && month < 10) {
                    offset = -1;
                }
                // if Mar, Oct
                day = date.getDate();
                weekday = date.getDay(); // get day of the week
                daysInMonth = new Date(year, month, 0).getDate(); // get number of days in the current month

                if (day + (7 - weekday) <= daysInMonth) {
                    if (month == 10) { // If Oct then is still DST
                        offset = -1;
                    }
                } else {
                    if (month == 3) { // if Mar then is already DST
                        offset = -1
                    }
                }
            } catch (e) {}
        }
        if (device.platform === "samsung"&& offset === undefined) { getOffset(); }
        if (offset) { offsetMoment.zone(offset); }
        
        return offsetMoment;
    };

    return moment;
});
/**
 * ConfigurationService Interface
 * @name ConfigurationService
 * @memberof tve
 * @class tve/interface/ConfigurationService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/ConfigurationService", ["xdk-base/Interface"], function(Interface) {
    return Interface.create("ConfigurationService", {
        /**
         * Get the config in app config file on AppGrid by the given key.
         * @method getConfig
         * @public
         * @param {String} key
         * @param {String} defaultValue (optional) it fails to get the data, it will return the default value
         * @returns {Promise.<String>} Configuration value by key
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/ConfigurationService#
         */
        getConfig: ["key", "defaultValue"],
        /**
         * Get the configs in app config file on AppGrid by the given keys.
         * @method getConfigs
         * @public
         * @param {Array} keys
         * @param {Object} defaultValues (optional) it fails to get the data, it will return the default values
         * If it only gets parts of the data, the new data will merge into default values and return the merged data.
         * @returns {Promise.<Object>} Configuration value map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/ConfigurationService#
         */
        getConfigs: ["keys", "defaultValues"],
        /**
         * Get all the config in app config file on AppGrid.
         * @method getAllConfigs
         * @public
         * @returns {Promise.<Object>} Configuration value map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/ConfigurationService#
         */
        getAllConfigs: []
    });
});
/**
 * AnalyticsService Interface
 * @name LogService
 * @memberof tve
 * @class tve/interface/LogService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/LogService", ["xdk-base/Interface"], function (Interface) {
    return Interface.create("LogService", {
        /**
         * Get the level of the log service.
         * @method getLevel
         * @public
         * @returns {Promise.<String>} Returns log level for application. 'error', 'warn', 'debug' or 'off' if log disabled
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/LogService#
         */
        getLevel: [],
        /**
         * Send a debugging log message to log service
         * @method debug
         * @public
         * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
         * @param {String} msg A text message for this log event
         * @param {Object} [dimensions] (optional) Custom dimentions
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/LogService#
         */
        debug: ["code", "msg", "dimensions"],
        /**
         * Send a warning log message to log service
         * @method warn
         * @public
         * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
         * @param {String} msg A text message for this log event
         * @param {Object} [dimensions] (optional) Custom dimentions
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/LogService#
         */
        warn: ["code", "msg", "dimensions"],
        /**
         * Send a error log message to log service
         * @method error
         * @public
         * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
         * @param {String} msg A text message for this log event
         * @param {Object} [dimensions] (optional) Custom dimentions
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/LogService#
         */
        error: ["code", "msg", "dimensions"]
    });
});
/**
 * ResourceService Interface
 * @name ResourceService
 * @memberof tve
 * @class tve/interface/ResourceService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/ResourceService", ["xdk-base/Interface"], function(Interface) {
    return Interface.create("ResourceService", {
        /**
         * Get the resource on AppGrid by the given key.
         * @method getResource
         * @public
         * @param {String} key
         * @returns {Promise.<String>} Resource value by key
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/ResourceService#
         */
        getResource: ["key"],
        /**
         * Get all the resources on AppGrid.
         * @method getAllResources
         * @public
         * @returns {Promise.<Object>} Resource values map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/ResourceService#
         */
        getAllResources: []
    });
});
/**
 * StatusService Interface
 * @name StatusService
 * @memberof tve
 * @class tve/interface/StatusService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/StatusService", ["xdk-base/Interface"], function(Interface) {
    return Interface.create("StatusService", {
        /**
         * Get the status of the app to check if the app is in maintaince mode.
         * @method getStatus
         * @public
         * @returns {Promise.<String>} Status (e.g. Active)
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/StatusService#
         */
        getStatus: [],
        /**
         * Get the message of the app from AppGrid.
         * @method getMessage
         * @public
         * @returns {Promise.<String>} Status Message
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/StatusService#
         */
        getMessage: []
    });
});
/**
 * UserSettingsService Interface
 * @name UserSettingsService
 * @memberof tve
 * @class tve/interface/UserSettingsService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/UserSettingsService", ["xdk-base/Interface"], function(Interface) {
    return Interface.create("UserSettingsService", {
        /**
         * Get the setting of the user in an application scope on AppGrid by the given key.
         * @method getSetting
         * @public
         * @param {String} key the key of the requested object
         * @param {String} [defaultValue] (optional) if it fails to get the data, it will return the default values
         * @returns {Promise.<String>} User setting value by key
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        getSetting: ["key", "defaultValue"],
        /**
         * Get the setting of the user in a group scope on AppGrid by the given key.
         * @method getSharedSetting
         * @public
         * @param {String} key the key of the requested object
         * @param {String} [defaultValue] (optional) if it fails to get the data, it will return the default values
         * @returns {Promise.<String>} User group setting value by key
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        getSharedSetting: ["key", "defaultValue"],
        /**
         * Get more the one settings of the user in an application scope on AppGrid by given keys.
         * @method getSettings
         * @public
         * @param {Array} keys the keys of the requested objects
         * @param {Object} [defaultValues] (optional) if it fails to get the data, it will return the default values.
         * If it only gets parts of the data, the new data will merge into default values and return the merged data.
         * @returns {Promise.<Object>} User settings values map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        getSettings: ["keys", "defaultValues"],
        /**
         * Get more the one settings of the user in a group scope on AppGrid by given keys.
         * @method getSharedSettings
         * @public
         * @param {Array} keys the keys of the requested objects
         * @param {Object} [defaultValues] (optional) if it fails to get the data, it will return the default values.
         * If it only gets parts of the data, the new data will merge into default values and return the merged data.
         * @returns {Promise.<Object>} User group settings values map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        getSharedSettings: ["keys", "defaultValues"],
        /**
         * Get all the settings of the user in an application scope on AppGrid.
         * @method getAllSettings
         * @public
         * @returns {Promise.<Object>} User settings values map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        getAllSettings: [],
        /**
         * Get all the settings of the user in a group scope on AppGrid.
         * @method getAllSharedSettings
         * @public
         * @returns {Promise.<Object>} User group settings values map by keys
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        getAllSharedSettings: [],
        /**
         * Set the setting of the user in an application scope on AppGrid by the given key and value.
         * @method setSetting
         * @public
         * @param {String} key the key of the object to be set
         * @param {String} value the value to set to the key
         * @returns {Promise.<Undefined>} fulfilled with no return value
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        setSetting: ["key", "value"],
        /**
         * Set the setting of the user in a group scope on AppGrid by the given key and value.
         * @method getSharedSetting
         * @public
         * @param {String} key the key of the object to be set
         * @param {String} value the value to set to the key
         * @returns {Promise.<Undefined>} fulfilled with no return value
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        setSharedSetting: ["key", "value"],
        /**
         * Set more than one settings of the user in an application scope on AppGrid by the given keys and their values.
         * @method getAllSettings
         * @public
         * @param {Object} object keys and the value to set to the key
         * @returns {Promise.<Undefined>} fulfilled with no return value
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        setAllSettings: ["data"],
        /**
         * Set the setting of the user in a group scope on AppGrid by the given keys and their values.
         * @method getAllSharedSettings
         * @public
         * @param {Object} object keys and the value to set to the key
         * @returns {Promise.<Undefined>} fulfilled with no return value
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/interface/UserSettingsService#
         */
        setAllSharedSettings: ["data"]
    });
});
/**
 * the AppGrid service layer, implements all AppGrid related services
 * which contain StatusService ConfigurationService LogService
 * @name AppGridService
 * @memberof tve
 * @class tve/AppGridService
 * @augments tve/interface/ConfigurationService
 * @augments tve/interface/LogService
 * @augments tve/interface/ResourceService
 * @augments tve/interface/StatusService
 * @augments tve/interface/UserSettingsService
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/AppGridService", [
    "xdk-base/class", "xdk-base/core", "xdk-base/util",
    "xdk-base/config", "xdk-base/promise", "xdk-base/ajax", "xdk-base/console",
    "xdk-base/device", "tve/util/CacheHelper", "lib/base64",
    "tvedemo/helper/sMoment", "tve/TVEError",
    "tve/interface/ConfigurationService", "tve/interface/LogService", "tve/interface/ResourceService",
    "tve/interface/StatusService", "tve/interface/UserSettingsService"
], function (klass, core, util,
    config, promise, ajax, console,
    device, CacheHelper, base64,
    moment, TVEError,
    ConfigurationService, LogService, ResourceService,
    StatusService, UserSettingsService) {

    "use strict";

    var FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,

        AppGridService = klass.create([ConfigurationService, LogService, ResourceService, StatusService, UserSettingsService], {}, {

            /**
             * The session key for the app in AppGrid
             * @member __sessionKey
             * @memberof tve/AppGridService#
             * @private
             */
            __sessionKey: null,

            /**
             * The universally unique identifier of the app in AppGrid.
             * @member __uuid
             * @memberof tve/AppGridService#
             * @private
             */
            __uuid: null,

            /**
             * Set the sequence for all types of log levels
             * @member __logLevels
             * @memberof tve/AppGridService#
             * @private
             */
            __logLevels: ["off", "error", "warn", "debug"],


            /**
             * The expiration time of the current session which is retrieved from AppGrid
             * @member __sessionExpiration
             * @memberof tve/AppGridService#
             * @private
             */
            __sessionExpiration: null,

            /**
             * AppGridService
             * Initialize a session. On successful initialization, set the sessionKey and sessionExpiration properties and the X-Session header.
             * If the session key failed to initialize, the current service method which depends on session will return reject through promise.
             * @method __getSessionKey
             * @return {Promise.<String>} Session Key
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @private
             */
            __getSessionKey: function () {
                if (this.__isSessionValid()) {
                    //when there is already a valid session, return the promise resolve with session key directly.
                    return promise.resolve(this.__sessionKey);
                }

                if (this.__getSessionPromise) {
                    //when there is already a promise for getting session, return the promise.
                    return this.__getSessionPromise;
                }

                var url = this.__baseURL + "/session",
                    options = {};

                options.requestHeaders = {};
                options.requestHeaders["X-Application-Key"] = this.__appKey;
                options.requestHeaders["X-User-Id"] = this.__uuid;

                console.warn("AppGrid session being requested"); // See SKYSTORM-585.

                this.__getSessionPromise = this.__sendRequest(url, options).then(util.bind(function (transport) {
                    var responseJSON = transport.responseJSON || null;

                    if (responseJSON && responseJSON.sessionKey && responseJSON.expiration) {
                        this.__sessionKey = responseJSON.sessionKey;
                        this.__sessionExpiration = moment(responseJSON.expiration, "YYYYMMDD HH:mm:SS Z").valueOf();

                        if (this.__sessionExpiration < (new Date()).getTime()) {
                            throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "GetSession: Unable to get the correct expiration.");
                        }

                        this.__getSessionPromise = null;

                        return this.__sessionKey;
                    }
                    this.__getSessionPromise = null;
                    throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "GetSession: Unable to get the session. Cannot get the sessionKey or expiration.");
                }, this), util.bind(function (reason) {
                    this.__getSessionPromise = null;
                    throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.NOT_FOUND, "GetSession: Unable to get the session.", reason);
                }, this));

                return this.__getSessionPromise;
            },

            /**
             * AppGridService
             * To check if the session is still valid. The expiration time is get from the last call of getSessionKey.
             * @method __isSessionValid
             * @return {Bool} If the session is valid
             * @memberof tve/AppGridService#
             * @private
             */
            __isSessionValid: function () {
                return (this.__sessionKey && this.__sessionExpiration > (new Date()).getTime() + 300000);
            },

            /**
             * AppGridService
             * Send a get request to AppGrid server, all the GET HTTP request to AppGrid should be sent here.
             * @method __setGetRequest
             * @param {String} url the URL to be sent
             * @param {Object} (optional) options the options passed into request function in ax/ajax
             * @param {Object} (optional) customTTL the custom setting of ttl(time to live) for the cache
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @private
             */
            __sendGetRequest: function (url, options, customTTL) {
                options = options || {};
                options.parameters = options.parameters || ""; //the request parameters

                var key = this.__generateCacheKey(url, options.parameters),
                    timestamp = (new Date()).getTime(),
                    cacheHelper = this.__cacheHelper,
                    cacheObj = cacheHelper.getCache(key),

                    doNoCacheAction = util.bind(function () {

                        return this.__getSessionKey().then(util.bind(function (sessionKey) {
                            return this.__sendRequest(url, options, sessionKey).then(function (transport) {
                                cacheHelper.setObject(key, transport, timestamp, customTTL || CacheHelper.TTL.DEFAULT);
                                return transport;
                            });
                        }, this));
                    }, this);

                if (cacheObj !== undefined && !cacheHelper.isExpired(key)) {
                    return promise.resolve(cacheObj);
                } else if (cacheObj !== undefined) {
                    //this "If-Modified-Since" currently always returns a failure -15.11.2013
                    return this.__getSessionKey().then(util.bind(function (sessionKey) {
                        return this.__sendRequest(url, {
                            requestHeaders: {
                                "If-Modified-Since": (new Date(cacheHelper.getTimestamp(key))).toUTCString()
                            }
                        }, sessionKey).then(function (transport) {
                            if (transport.status === 304) {
                                cacheHelper.renewTimestamp(key);
                                return cacheObj;
                            } else if (transport.status === 200) {
                                cacheHelper.setObject(key, transport, timestamp);
                                return transport;
                            }
                        }, function () {
                            //Currently the appgrid doesn"t accept a "If-Modeified-Since" header, which means it will always go to the onFailure block.
                            //A JIRA issue APPGRID-769 has been raised for this.
                            //Once this issue is resolved, the code in this function can be removed.
                            return doNoCacheAction();
                        });
                    }, this));
                } else {
                    return doNoCacheAction();
                }
            },

            /**
             * AppGridService
             * Send a post request to AppGrid server, all the POST HTTP request to AppGrid should be sent here.
             * @method __sendPostRequest
             * @param {String} url the URL to be sent
             * @param {Object} options the options passed into request function in ax/ajax
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @private
             */
            __sendPostRequest: function (url, options) {
                options = options || {};
                options.method = "post";
                options.requestHeaders = options.requestHeaders || {
                    "content-type": "application/json"
                };

                return this.__getSessionKey().then(util.bind(function (sessionKey) {
                    // return the request through promise
                    return this.__sendRequest(url, options, sessionKey);
                }, this));
            },

            /**
             * Generate a cache key based on request information
             * @method __generateCacheKey
             * @param {String} path the URL for the request
             * @param {Object} parameters Request parameters, object containing key-value pairs that are convertible into key1=value1&key2=value2 format with e.g toQueryString() method
             * @param {String} requestBody Request Body object (usually present only with POST & PUT calls)
             * @return {String} the string for the cache key
             * @memberof tve/AppGridService#
             * @private
             */
            __generateCacheKey: function (path, parameters, requestBody) {
                var body = requestBody ? "__body[" + requestBody.toString() + "]" : "",
                    queryString = util.isString(parameters) ? parameters : util.toQueryString(parameters),
                    str = path + "?" + queryString + "&" + body;

                if (window.btoa) {
                    return window.btoa(str);
                } else {
                    return base64.encode(str);
                }
            },

            /**
             * AppGridService - StatusService
             * Get the status of the app to check if the app is in maintaince mode.
             * @method getStatus
             * @return {Promise.<String>} Status (e.g. Active)
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getStatus: function () {
                var url = this.__baseURL + "/status";

                return this.__sendGetRequest(url).then(function (transport) {
                    if (transport.responseJSON && transport.responseJSON.status) {
                        return transport.responseJSON.status;
                    }
                    throw new TVEError(FACILITY.STATUS_SERVICE, ERROR.INVALID, "Cannot get the status");
                }, function (reason) {
                    throw new TVEError(FACILITY.STATUS_SERVICE, ERROR.NETWORK, "Cannot get the status", reason);
                });
            },

            /**
             * AppGridService - StatusService
             * Get the message of the app from AppGrid.
             * @method getMessage
             * @returns {Promise.<String>} Status Message
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getMessage: function () {
                var url = this.__baseURL + "/status";

                return this.__sendGetRequest(url).then(function (transport) {
                    if (transport.responseJSON && transport.responseJSON.message) {
                        return transport.responseJSON.message;
                    }
                    //
                    // Note that this will be the case if the status in NOT currently in maintenance.
                    // When AppGrid has the service flagged 'Active' there's no message to accompany that state.
                    //
                    throw new TVEError(FACILITY.STATUS_SERVICE, ERROR.INVALID, "Cannot get the message through status service");
                }, function (reason) {
                    throw new TVEError(FACILITY.STATUS_SERVICE, ERROR.NETWORK, "Cannot get the message through status service", reason);
                });
            },

            /**
             * AppGridService
             * Send the application start event log to analytics service on AppGrid.
             * @method applicationStart
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            applicationStart: function () {
                return this.__sendApplicationEvent("START");
            },

            /**
             * AppGridService
             * Send the application stop event log to analytics service on AppGrid.
             * @method applicationStop
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            applicationStop: function () {
                return this.__sendApplicationEvent("QUIT");
            },

            /**
             * AppGridService - ConfigurationService
             * Get the config in app config file on AppGrid by the given key.
             * @method getConfig
             * @param {String} key
             * @param {String} defaultValue (optional) it fails to get the data, it will return the default value
             * @returns {Promise.<String>} Configuration value by key
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getConfig: function (key, defaultValue) {
                var url = this.__baseURL + "/metadata/" + key;

                return this.__sendGetRequest(url).then(function (transport) {
                    if (transport.responseJSON && transport.responseJSON[key]) {
                        return transport.responseJSON[key];
                    } else if (defaultValue) {
                        return defaultValue;
                    }
                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "cannot get the config value");
                }, function (reason) {
                    if (defaultValue) {
                        return promise.resolve(defaultValue);
                    }
                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.NETWORK, "cannot get the config value", reason);
                });
            },

            /**
             * AppGridService - ConfigurationService
             * Get the configs in app config file on AppGrid by the given keys.
             * @method getConfigs
             * @param {Array} keys
             * @param {Object} defaultValues (optional) it fails to get the data, it will return the default values
             * If it only gets parts of the data, the new data will merge into default values and return the merged data.
             * @returns {Promise.<Object>} Configuration value map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getConfigs: function (keys, defaultValues) {
                var url = this.__baseURL + "/metadata/" + keys.join(",");

                return this.__sendGetRequest(url, null, CacheHelper.TTL.FOREVER).then(function(transport) {
                    if (transport.responseJSON) {
                        if (defaultValues) {
                            return util.extend(defaultValues, transport.responseJSON);
                        }
                        return transport.responseJSON;
                    }

                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "cannot get values of configs");
                }, function (reason) {
                    if (defaultValues) {
                        return promise.resolve(defaultValues);
                    }
                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.NETWORK, "cannot get values of configs", reason);
                });
            },

            /**
             * AppGridService - ConfigurationService
             * Get all the config in app config file on AppGrid.
             * @method getAllConfigs
             * @returns {Promise.<Object>} Configuration value map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getAllConfigs: function () {
                var url = this.__baseURL + "/metadata";

                return this.__sendGetRequest(url).then(function (transport) {
                    if (transport.responseJSON) {
                        return transport.responseJSON;
                    }
                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "cannot get all configs");
                }, function (reason) {
                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.NETWORK, "cannot get all configs", reason);
                });
            },

            /**
             * AppGridService - ResourceService
             * Get the resource on AppGrid by the given key.
             * @method getResource
             * @param {String} key
             * @returns {Promise.<String>} Resource value by key
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getResource: function (key) {
                return this.getAllResources().then(util.bind(function (transport) {
                    if (transport[key]) {
                        var url = transport[key];

                        if (url.indexOf("/") === 0) {
                            return this.__baseURL + url;
                        }
                        return url;
                    } else {
                        throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "cannot get the requested resource " + key);
                    }
                }, this), function (reason) {
                    throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.NETWORK, "cannot get the requested resource", reason);
                });
            },

            /**
             * AppGridService - ResourceService
             * Get all the resources on AppGrid.
             * @method getAllResources
             * @returns {Promise.<Object>} Resource values map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getAllResources: function () {
                // Always cache the all resources promise; no expectation that this will change on the fly in normal use.
                if (!this.__getAllResourcesPromise) {
                    var url = this.__baseURL + "/asset";

                    this.__getAllResourcesPromise = this.__sendGetRequest(url).then(function (transport) {
                        if (transport.responseJSON) {
                            return transport.responseJSON;
                        }
                        throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "cannot get all resources");
                    }, function (reason) {
                        throw new TVEError(FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.NETWORK, "cannot get all resources " + reason);
                    });
                }

                return this.__getAllResourcesPromise;
            },

            /**
             * AppGridService - LogService
             * Get the level of the log service.
             * @method getLevel
             * @returns {Promise.<String>} Returns log level for application. 'error', 'warn', 'debug' or 'off' if log disabled
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getLevel: function () {
                //If there"s already a promise to get the level, then return this promise directly.
                if (this.__getLevelPromise) {
                    return this.__getLevelPromise;
                }

                var url = this.__baseURL + "/application/log/level";

                this.__getLevelPromise = this.__sendGetRequest(url).then(util.bind(function (transport) {
                    if (transport.responseJSON && transport.responseJSON.logLevel) {
                        this.__getLevelPromise = null;
                        return transport.responseJSON.logLevel;
                    }
                    this.__getLevelPromise = null;
                    throw new TVEError(FACILITY.LOG_SERVICE, ERROR.INVALID, "Cannot get the log level");
                }, this), util.bind(function (reason) {
                    this.__getLevelPromise = null;
                    throw new TVEError(FACILITY.LOG_SERVICE, ERROR.NETWORK, "Cannot get the log level", reason);
                }, this));

                return this.__getLevelPromise;
            },

            /**
             * AppGridService - LogService
             * Send a debugging log message to log service
             * @method debug
             * @memberof tve/AppGridService#
             * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
             * @param {String} msg A text message for this log event
             * @param {Object} [dimensions] (optional) Custom dimentions
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @public
             */
            debug: function (code, msg, dimensions) {
                this.__sendLog("debug", code, msg, dimensions);
            },

            /**
             * AppGridService - LogService
             * Send a warning log message to log service
             * @method warn
             * @memberof tve/AppGridService#
             * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
             * @param {String} msg A text message for this log event
             * @param {Object} [dimensions] (optional) Custom dimentions
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @public
             */
            warn: function (code, msg, dimensions) {
                this.__sendLog("warn", code, msg, dimensions);
            },

            /**
             * AppGridService - LogService
             * Send a error log message to log service
             * @method error
             * @memberof tve/AppGridService#
             * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
             * @param {String} msg A text message for this log event
             * @param {Object} [dimensions] (optional) Custom dimentions
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @public
             */
            error: function (code, msg, dimensions) {
                this.__sendLog("error", code, msg, dimensions);
            },

            /**
             * Get the setting of user on AppGrid by the given key or get all settings directly. Helper method for the public functions.
             * @method __getSettingHelper
             * @param {String} scope should be "user" or "group"
             * @param {Array} keys the key(s) of the requested objects
             * @param {Object|String} [defaultValue] (optional) if it fails to get the data, it will return the default values
             * @returns {Promise.<Object>} JSON object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @private
             */
            __getSettingHelper: function (scope, keys, defaultValue) {
                var url = this.__baseURL + "/" + scope + "/" + this.__uuid,
                    length = 0;

                if (keys) {
                    length = keys.length;
                    if (length === 1) {
                        url += "/" + keys[0];
                    }
                }

                return this.__sendGetRequest(url, null, CacheHelper.TTL.NO_CACHE).then(function (transport) {
                    if (!length && transport.responseJSON) {
                        return transport.responseJSON;
                    }

                    if (length === 1 && transport.responseJSON) {
                        return transport.responseJSON;
                    }

                    if (length > 1 && transport.responseJSON) {

                        var ret = transport.responseJSON,
                            matchKey;

                        for (var i in ret) {
                            matchKey = false;

                            for (var j = 0, l = keys.length; j < l; j++) {
                                if (i === keys[j]) {
                                    matchKey = true;
                                    break;
                                }
                            }

                            if (!matchKey) {
                                delete ret[i];
                            }
                        }

                        if (defaultValue) {
                            return util.extend(defaultValue, ret);
                        }
                        return ret;
                    }

                    if (defaultValue) {
                        return defaultValue;
                    }

                    throw new TVEError(FACILITY.USER_SETTINGS_SERVICE, ERROR.INVALID, "cannot get requested setting");
                }, function (reason) {
                    if (defaultValue && length) {
                        return promise.resolve(defaultValue);
                    }
                    throw new TVEError(FACILITY.USER_SETTINGS_SERVICE, ERROR.NETWORK, "cannot get requested setting", reason);
                });
            },

            /**
             * Get the setting of the user in an application scope on AppGrid by the given key.
             * @method getSetting
             * @param {String} key the key of the requested object
             * @param {String} [defaultValue] (optional) if it fails to get the data, it will return the default values
             * @returns {Promise.<String>} User setting value by key
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getSetting: function (key, defaultValue) {
                return this.__getSettingHelper("user", [key], defaultValue);
            },

            /**
             * Get the setting of the user in a group scope on AppGrid by the given key.
             * @method getSharedSetting
             * @param {String} key the key of the requested object
             * @param {String} [defaultValue] (optional) if it fails to get the data, it will return the default values
             * @returns {Promise.<String>} User group setting value by key
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getSharedSetting: function (key, defaultValue) {
                return this.__getSettingHelper("group", [key], defaultValue);
            },

            /**
             * Get more the one settings of the user in an application scope on AppGrid by given keys.
             * @method getSettings
             * @param {Array} keys the keys of the requested objects
             * @param {Object} [defaultValues] (optional) if it fails to get the data, it will return the default values.
             * If it only gets parts of the data, the new data will merge into default values and return the merged data.
             * @returns {Promise.<Object>} User settings values map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getSettings: function (keys, defaultValues) {
                return this.__getSettingHelper("user", keys, defaultValues);
            },

            /**
             * Get more the one settings of the user in a group scope on AppGrid by given keys.
             * @method getSharedSetting
             * @param {Array} keys the keys of the requested objects
             * @param {Object} [defaultValues] (optional) if it fails to get the data, it will return the default values
             * If it only gets parts of the data, the new data will merge into default values and return the merged data.
             * @returns {Promise.<Object>} User group settings values map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getSharedSettings: function (keys, defaultValues) {
                return this.__getSettingHelper("group", keys, defaultValues);
            },

            /**
             * Get all the settings of the user in an application scope on AppGrid.
             * @method getAllSettings
             * @returns {Promise.<Object>} User settings values map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getAllSettings: function () {
                return this.__getSettingHelper("user");
            },

            /**
             * Get all the settings of the user in a group scope on AppGrid.
             * @method getAllSharedSettings
             * @returns {Promise.<Object>} User group settings values map by keys
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            getAllSharedSettings: function () {
                return this.__getSettingHelper("group");
            },

            /**
             * Set the setting of the user on AppGrid by the given key and value. Helper method for the public functions.
             * @method __setSettingHelper
             * @param {String} scope should be "user" or "group"
             * @param {Object} data the key and value to be set
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @private
             */
            __setSettingHelper: function (scope, data) {
                var options = {},
                    keys = util.keys(data),
                    count = keys.length,
                    url = this.__baseURL + "/" + scope + "/" + this.__uuid;

                if (count === 1) {
                    url += "/" + keys[0];
                    options.postBody = data[keys[0]];
                } else {
                    options.postBody = JSON.stringify(data);
                }

                return this.__sendPostRequest(url, options).then(function () {
                    return;
                }, function (reason) {
                    throw new TVEError(FACILITY.USER_SETTINGS_SERVICE, ERROR.NETWORK, "cannot set the setting", reason);
                });
            },

            /**
             * Set the setting of the user in an application scope on AppGrid by the given key and value.
             * @method setSetting
             * @param {String} key the key of the object to be set
             * @param {String} value the value to set to the key
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            setSetting: function (key, value) {
                var data = {};
                data[key] = value;
                return this.__setSettingHelper("user", data);
            },

            /**
             * Set the setting of the user in a group scope on AppGrid by the given key and value.
             * @method setSharedSetting
             * @param {String} key the key of the object to be set
             * @param {String} value the value to set to the key
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            setSharedSetting: function (key, value) {
                var data = {};
                data[key] = value;
                return this.__setSettingHelper("group", data);
            },

            /**
             * Set more than one settings of the user in an application scope on AppGrid by the given keys and their values.
             * Please note it will rewrite the settings
             * @method setSettings
             * @param {Object} object keys and the value to set to the key
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            setAllSettings: function (data) {
                return this.__setSettingHelper("user", data);
            },

            /**
             * Set the setting of the user in a group scope on AppGrid by the given keys and their values.
             * Please note it will rewrite the settings
             * @method setSharedSettings
             * @param {Object} object keys and the value to set to the key
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AppGridService#
             * @public
             */
            setAllSharedSettings: function (data) {
                return this.__setSettingHelper("group", data);
            },

            /**
             * Init the AppGridService moudle
             * @method init
             * @param {String} api the base URL for the AppGrid server
             * @param {String} appKey the app key for the app
             * @param {String} uuid Universally unique identifier of the device.
             * @memberof tve/AppGridService#
             * @private
             */
            init: function (api, appKey, uuid) {
                this.__baseURL = api;
                this.__appKey = appKey;
                this.__uuid = uuid;
                this.__cacheHelper = new CacheHelper();
            },

            /**
             * Send ajax request, all http requests of AppGridService should be sent here.
             * @method __sendRequest
             * @param {String} url the URL to be sent
             * @param {Object} options the options passed into request function in ax/ajax
             * @param {String} sessionKey "X-Session" in the header
             * @memberof tve/AppGridService#
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @private
             */
            __sendRequest: function (url, options, sessionKey) {
                options = options || {};
                options.requestHeaders = options.requestHeaders || {};
                if (sessionKey) {
                    options.requestHeaders["X-Session"] = sessionKey;
                }
                return ajax.request(url, options);
            },

            /**
             * For usage tracking, send the application event to analytics service on AppGrid.
             * @method __sendApplicationEvent
             * @memberof tve/AppGridService#
             * @param {String} message the predefined events have: START, QUIT
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @private
             */
            __sendApplicationEvent: function (message) {
                var url = this.__baseURL + "/event/log",
                    postBody = {},
                    options = {};

                postBody.eventType = message;
                options.postBody = JSON.stringify(postBody);

                return this.__sendPostRequest(url, options).then(function () {
                    return;
                }, function (reason) {
                    throw new TVEError(FACILITY.ANALYTICS_SERVICE, ERROR.NETWORK, "Cannot send the application event", reason);
                });
            },

            /**
             * Send log to AppGrid, such as error, warn and debug.
             * If the log level is in a lower priority than the current level get from the AppGrid, it will not sent the request.
             * @method __sendLog
             * @memberof tve/AppGridService#
             * @param {String} logType the log type which should be "debug, "error" or "warn"
             * @param {Number} code An internal code that is meaningful for developers. Usually a generic error code. Max 5 digits
             * @param {String} msg A text message for this log event
             * @param {Object} [dimensions] (optional) Custom dimentions
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @private
             */
            __sendLog: function (logType, code, msg, dimensions) {
                if (!(code > -1 && code < 100000 && code.toString().indexOf(".") === -1)) {
                    throw new TVEError(FACILITY.LOG_SERVICE, ERROR.INVALID, "LogService: Invalid code.");
                }

                var levels = this.__logLevels;

                this.getLevel().then(util.bind(function (level) {
                    if (util.indexOf(levels, logType) <= util.indexOf(levels, level)) {
                        var options = {},
                            postBody = {},
                            url = this.__baseURL + "/application/log/" + logType;

                        postBody.code = code;
                        postBody.message = msg;

                        if (dimensions && util.isObject(dimensions)) {
                            util.extend(postBody, dimensions);
                        }

                        options.postBody = JSON.stringify(postBody);

                        this.__sendPostRequest(url, options);
                    }
                }, this), function (reason) {
                    throw new TVEError(FACILITY.LOG_SERVICE, ERROR.NETWORK, "Cannot send the log", reason);
                }).done();
            }

        });

    return AppGridService;
});
/**
 * @name tve/sAppGridServiceHolder
 * @memberof tve
 * @class Returns a singleton responsible for providing the remote services public interfaces.
 */
define("tve/sAppGridServiceHolder", [
    "tve/AppGridService",
    "tve/TVEError",
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/promise",
    "xdk-base/console",
    "xdk-base/device",
    "xdk-base/Env"
], function(
    AppGridService,
    TVEError,
    klass,
    util,
    config,
    promise,
    console,
    device,
    Env
    ) {

    "use strict";

    var sEnv = Env.singleton();

    var AppGridServiceHolder = klass.create({}, {

        __appGridService: null,

        __createAppGridService: function() {
            var appGridConfig = config.get("tve.appgrid");

            if (appGridConfig && appGridConfig.api && appGridConfig.appKey) {
                var appKey = appGridConfig.appKey,
                    api = appGridConfig.api,
                    uuid = device.id.getUniqueID();

                this.__appGridService = new AppGridService(api, appKey, uuid);
            } else {
                console.error("Unable to initialize the AppGrid Service, can not find the API or app key");
            }
        },

        getAppGridService: function() {
            if (!this.__appGridService) {
                this.__createAppGridService();
            }
            return this.__appGridService;
        },

        getAppGridServicePromise: function() {
            var appGridServiceDefer = promise.defer();

            if (sEnv.isLoaded() && !this.__appGridService) {
                this.__createAppGridService();
            }

            if (this.__appGridService) {
                appGridServiceDefer.resolve(this.__appGridService);
            } else {
                sEnv.addEventListener(sEnv.EVT_ONLOAD, util.bind(function (theDefer) {
                    if (!this.__appGridService) {
                        this.__createAppGridService();
                    }
                    theDefer.resolve(this.__appGridService);
                }, this, appGridServiceDefer));
            }

            return appGridServiceDefer.promise;
        }
    });

    return new AppGridServiceHolder();
});
/**
 * An Immutable Model used for building TVE VOD and Linear models
 * @class tve/model/ImmutableModel
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/ImmutableModel", ["xdk-base/class", "xdk-ax/mvc/Model"], function (klass, Model) {

    var ImmutableModel = klass.create(Model, {}, {


        /**
         * Override the unset function to make the model immutable
         * @return {tve/model/ImmutableModel} the current model for chaining
         * @public
         * @method
         * @memberof tve/model/ImmutableModel#
         */
        unset: function(){
            return this;
        },

        /**
         * Override the clear function to make the model immutable
         * @return {tve/model/ImmutableModel} the current model for chaining
         * @public
         * @method
         * @memberof tve/model/ImmutableModel#
         */
        clear: function(){
            return this;
        }
    });

	return ImmutableModel;
});
/**
 * DRMSettings Model
 * @class storm/model/DRMSettings
 */
define("storm/model/DRMSettings", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member root - The URL of the licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "root": "",

            /**
             * @member platformId - value to pass to the Player / licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "platformId": "",

            /**
             * @member product - value to pass to the Player / licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "product": "",

            /**
             * @member serviceId - value to pass to the Player / licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "serviceId": "",

            /**
             * @member denseServiceId - value to pass to the Player / licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "denseServiceId": "",

            /**
             * @member serviceIdFormat - value to pass to the Player / licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "serviceIdFormat": "",

            /**
             * @member platformId - value to pass to the Player / licensing server
             * @memberof storm/model/DRMSettings#
             * @public
             * @type {String}
             */
            "deviceFriendlyName": ""

        }
    }, {});
});
/**
 * DRMSettings Builder, for building the DRMSettings model
 * @class storm/model/DRMSettingsBuilder
 */
define("storm/model/DRMSettingsBuilder", [
    "xdk-base/class",
    "storm/model/DRMSettings"
], function (
    klass,
    DRMSettings
    ) {

    "use strict";

    var DRMSettingsBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/DRMSettingsBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the root for building the model.
         * @param {String} root
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setRoot: function (root) {
            this._attrs.root = root;
            return this;
        },

        /**
         * Set the platformId for building the model.
         * @param {String} platformId
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setPlatformId: function (platformId) {
            this._attrs.platformId = platformId;
            return this;
        },

        /**
         * Set the product for building the model.
         * @param {String} product
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setProduct: function (product) {
            this._attrs.product = product;
            return this;
        },

        /**
         * Set the serviceId for building the model.
         * @param {String} serviceId
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setServiceId: function (serviceId) {
            this._attrs.serviceId = serviceId;
            return this;
        },

        /**
         * Set the denseServiceId for building the model.
         * @param {String} denseServiceId
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setDenseServiceId: function (denseServiceId) {
            this._attrs.denseServiceId = denseServiceId;
            return this;
        },

        /**
         * Set the serviceIdFormat for building the model.
         * @param {String} serviceIdFormat
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setServiceIdFormat: function (serviceIdFormat) {
            this._attrs.serviceIdFormat = serviceIdFormat;
            return this;
        },

        /**
         * Set the deviceFriendlyName for building the model.
         * @param {String} deviceFriendlyName
         * @returns {storm/model/DRMSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        setDeviceFriendlyName: function (deviceFriendlyName) {
            this._attrs.deviceFriendlyName = deviceFriendlyName;
            return this;
        },

        /**
         * Build the DRMSettings model.
         * @returns {storm/model/DRMSettings} the DRMSettings model
         * @public
         * @method
         * @memberof storm/model/DRMSettingsBuilder#
         */
        build: function () {
            return new DRMSettings(this._attrs);
        }
    });

    return DRMSettingsBuilder;
});
/**
 * GeolocationSettings Model
 * @class storm/model/GeolocationSettings
 */
define("storm/model/GeolocationSettings", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member root - The URL of the licensing server
             * @memberof storm/model/GeolocationSettings#
             * @public
             * @type {String}
             */
            "root": "",

            /**
             * @member mapping - Allowing us to pretend that one location is another
             * @memberof storm/model/GeolocationSettings#
             * @public
             * @type {Object}
             */
            "mapping": ""

        }
    }, {});
});
/**
 * GeolocationSettings Builder, for building the GeolocationSettings model
 * @class storm/model/GeolocationSettingsBuilder
 */
define("storm/model/GeolocationSettingsBuilder", [
    "xdk-base/class",
    "storm/model/GeolocationSettings"
], function (
    klass,
    GeolocationSettings
    ) {

    "use strict";

    var GeolocationSettingsBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/GeolocationSettingsBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the root for building the model.
         * @param {String} root
         * @returns {storm/model/GeolocationSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/GeolocationSettingsBuilder#
         */
        setRoot: function (root) {
            this._attrs.root = root;
            return this;
        },

        /**
         * Set the mapping for building the model.
         * @param {Object} mapping
         * @returns {storm/model/GeolocationSettingsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/GeolocationSettingsBuilder#
         */
        setMapping: function (mapping) {
            this._attrs.mapping = mapping;
            return this;
        },

        /**
         * Build the GeolocationSettings model.
         * @returns {storm/model/GeolocationSettings} the GeolocationSettings model
         * @public
         * @method
         * @memberof storm/model/GeolocationSettingsBuilder#
         */
        build: function () {
            return new GeolocationSettings(this._attrs);
        }
    });

    return GeolocationSettingsBuilder;
});
/**
 * Returns a singleton to provide most AppGrid related methods in business layer.
 * @name sAppConfigManager
 * @memberof storm/mgr
 * @class storm/mgr/sAppConfigManager
 */
define("storm/mgr/sAppConfigManager", [
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/ajax",
    "tve/TVEError",
    "tve/sAppGridServiceHolder",
    "storm/model/DRMSettingsBuilder",
    "storm/model/GeolocationSettingsBuilder"
], function (
    klass,
    config,
    util,
    promise,
    ajax,
    TVEError,
    sAppGridServiceHolder,
    DRMSettingsBuilder,
    GeolocationSettingsBuilder
    ) {

    "use strict";

    var APPGRID_KEY =
        {
            RESOURCE : {
                LOGO : "asset.img.logo",
                PLACEHOLDER_LANDSCAPE : "asset.img.placeholder.landscape",
                PLACEHOLDER_PORTRAIT : "asset.img.placeholder.portrait"
            },

            FIELD : {
                // Core Sky config...
                SKY: {
                    EHUB: "config.sky.ehub",
                    SILK: "config.sky.silk",
                    CMS: "config.sky.cms",
                    SEARCH: "config.sky.search", // At first glance search looks like part of SILK, but really it's not!
                    LICENCING: "config.sky.licencing",
                    GEOLOCATION: "config.sky.geolocation"
                },

                // Additional config we need to supplement what Sky can provide...
                EHUB: {
                    PERMITTED_CHANNELS: "config.ehub.permittedChannels"
                },

                // General UI config...
                UI: {
                    EPG_EXTENT: "config.ui.epg.daysForwards",
                    DEFAULT_AUDIO: "config.ui.video.defaultAudioTrack",
                    NECESSARY_VERSION: "config.ui.necessaryVersion"
                },

                LIVE: {
                    SUPPORT: "config.livefeature.disable"
                },

                // Platform-specific config...
                PLATFORM: {
                    SAMSUNG: "config.samsung",
                    PLAYSTATION: "config.playstation"
                },

                VIDEO: {
                    DEFAULT_AUDIO: "config.video.defaultAudioTrack"
                }
            }

        },

        AppConfigManager = klass.create({
            STATUS: {
                ACTIVE: "Active"
            }

        }, {

            init: function () {
            },

            /**
             * Get the app status through status service.
             * @method getStatus
             * @public
             * @returns {Promise.<String>} a string to tell the status
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getStatus: function () {
                return sAppGridServiceHolder.getAppGridService().getStatus();
            },

            /**
             * Get the app message through status service.
             * @method getMessage
             * @public
             * @returns {Promise.<String>} the message
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getMessage: function () {
                return sAppGridServiceHolder.getAppGridService().getMessage();
            },

            /**
             * Get the app's logo from AppGrid through resource service
             * @method getLogo
             * @public
             * @returns {Promise.<String>} the logo image url
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getLogo: function () {
                return sAppGridServiceHolder.getAppGridService().getResource(APPGRID_KEY.RESOURCE.LOGO);
            },

            /**
             * Get the placeholder image for dvd covers, and other portrait-shaped images, from AppGrid through resource service
             * @method getPlaceholderPortrait
             * @public
             * @returns {Promise.<String>} the placeholder image url
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getPlaceholderPortrait: function () {
                return sAppGridServiceHolder.getAppGridService().getResource(APPGRID_KEY.RESOURCE.PLACEHOLDER_PORTRAIT);
            },

            /**
             * Get the placeholder image for dvd covers, and other portrait-shaped images, from AppGrid through resource service
             * @method getPlaceholderLandscape
             * @public
             * @returns {Promise.<String>} the placeholder image url
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getPlaceholderLandscape: function () {
                return sAppGridServiceHolder.getAppGridService().getResource(APPGRID_KEY.RESOURCE.PLACEHOLDER_LANDSCAPE);
            },

            /**
             * Retrieve language mapping information from AppGrid
             * @method getLanguageStrings
             * @public
             * @returns {Promise.<Object>} A structure mapping languages and keys to human-friendly display strings
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getLanguageStrings: function() {
                //cache
                if (this._getLanguageStringsPromise) {
                    return this._getLanguageStringsPromise;
                }

                this._getLanguageStringsPromise = this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport["config.language"]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse config.language");
                    }
                });

                return this._getLanguageStringsPromise;
            },

            /**
             * Determine how many days' worth of future EPG data we expect to be able to show
             * @method getEpgDaysForwards
             * @public
             * @returns {Promise.<Integer>} The number of future days to show in the EPG grid (and elsewhere, perhaps)
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getEpgDaysForwards: function () {
                return this.__getAllAppConfigs().then(function (transport) {
                    return transport[APPGRID_KEY.FIELD.UI.EPG_EXTENT];
                });
            },

            /**
             * Identify the default audio track to try and play when some audio tracks have been detected
             * @method getVideoDefaultAudioTrack
             * @public
             * @returns {Promise.<String>} The number of future days to show in the EPG grid (and elsewhere, perhaps)
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getVideoDefaultAudioTrack: function () {
                return this.__getAllAppConfigs().then(function (transport) {
                    return transport[APPGRID_KEY.FIELD.UI.DEFAULT_AUDIO];
                });
            },

            /** Audio Language and Audio Codec mapping that can be used during manual parsing of manifest.
            *
            */
            getDefaultAudioTrackMapping: function() {
                return this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.VIDEO.DEFAULT_AUDIO]);
                    } catch(e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.VIDEO.DEFAULT_AUDIO);
                    }
                });
            },

            /**
             * Retrieve some platform-specific configuration from AppGrid
             * @method getSamsungSpecificConfig
             * @public
             * @returns {Promise.<Object>} A dictionary of configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getSamsungSpecificConfig: function () {
                return this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.PLATFORM.SAMSUNG]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.PLATFORM.SAMSUNG);
                    }
                });
            },

            /**
             * Retrieve some platform-specific configuration from AppGrid
             * @method getPlaystationSpecificConfig
             * @public
             * @returns {Promise.<Object>} A dictionary of configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getPlaystationSpecificConfig: function () {
                return this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.PLATFORM.PLAYSTATION]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.PLATFORM.PLAYSTATION);
                    }
                });
            },


            /**
             * Retrieve some platform-specific configuration from AppGrid
             * @method getLgSpecificConfig
             * @public
             * @returns {Promise.<Object>} A dictionary of configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getLgSpecificConfig: function () {
                return this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.PLATFORM.LG]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.PLATFORM.LG);
                    }
                });
            },

            /**
             * Identify the logged-in session keep alive period
             * @method getSessionKeepAlivePeriod
             * @public
             * @returns {Promise.<Number>} The number of milliseconds ot wait between session keep alive calls to the back end
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getSessionKeepAlivePeriod: function () {
                //cache
                if (!this._getSessionKeepAlivePeriodPromise) {
                    this._getSessionKeepAlivePeriodPromise = this.__getAllAppConfigs().then(function (transport) {
                        return transport["config.sky.sessionKeepAlivePeriod"];
                    });
                }

                return this._getSessionKeepAlivePeriodPromise;
            },

            /**
             * Return the (possibly cached) EHUB server configuration
             * @method getEhubConfig
             * @public
             * @returns {Promise.<Object>} A dictionary describing the EHUB server configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getEhubConfig: function () {
                //cache
                if (this._getEhubConfigPromise) {
                    return this._getEhubConfigPromise;
                }

                this._getEhubConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.SKY.EHUB]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.EHUB);
                    }
                });

                return this._getEhubConfigPromise;
            },

            /**
             * Return the (possibly cached) SILK server configuration
             * @method getSilkConfig
             * @public
             * @returns {Promise.<Object>} A dictionary describing the SILK server configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getSilkConfig: function () {
                //cache
                if (this._getSilkConfigPromise) {
                    return this._getSilkConfigPromise;
                }

                this._getSilkConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.SKY.SILK]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.SILK);
                    }
                });

                return this._getSilkConfigPromise;
            },

            /**
             * Return the (possibly cached) CMS server configuration
             * @method getCmsConfig
             * @public
             * @returns {Promise.<Object>} A dictionary describing the CMS server configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getCmsConfig: function () {
                //cache
                if (this._getCmsConfigPromise) {
                    return this._getCmsConfigPromise;
                }

                this._getCmsConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.SKY.CMS]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.CMS);
                    }
                });

                return this._getCmsConfigPromise;
            },

            getSearchConfig: function () {
                //cache
                if (this._getSearchConfigPromise) {
                    return this._getSearchConfigPromise;
                }

                this._getSearchConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.SKY.SEARCH]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.SEARCH);
                    }
                });

                return this._getSearchConfigPromise;
            },
            
            /**
            * Returns AppMeasurement config (omniture) for the current environment
             * @method getOmnitureConfig
             * @public
             * @returns {Promise.<Object>} A DRMSettings model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getAnalyticsConfig: function () {
                //cache
                if (this._getAnalyticsConfigPromise) {
                    return this._getAnalyticsConfigPromise;
                }

                this._getAnalyticsConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                    try {
                        var environment = config.get("environment"); // eg "test", "production";
                        return JSON.parse(transport["config.analytics.omniture"])[environment];
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.CMS);
                    }
                });

                return this._getAnalyticsConfigPromise;
            },

            /**
             * Return a DRMSettings model, built from AppGrid-supplied settings
             * @method getCmsConfig
             * @public
             * @returns {Promise.<Object>} A DRMSettings model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getDRMSettings: function () {
                //cache
                if (!this._getLicencingConfigPromise) {
                    this._getLicencingConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                        try {
                            return JSON.parse(transport[APPGRID_KEY.FIELD.SKY.LICENCING]);
                        } catch (e) {
                            throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.LICENCING);
                        }
                    });
                }

                return this._getLicencingConfigPromise.then(function(inputJson) {
                    var environment = config.get("environment"); // eg "test", "production";

                    return new DRMSettingsBuilder()
                        .setRoot(inputJson.root[environment])
                        .setPlatformId(inputJson.platformId[environment])
                        .setProduct(inputJson.product[environment])
                        .setServiceId(inputJson.serviceId[environment])
                        .setDenseServiceId(inputJson.denseServiceId[environment])
                        .setServiceIdFormat(inputJson.serviceIdFormatter[environment])
                        .setDeviceFriendlyName(inputJson.deviceFriendlyName[environment])
                        .build();
                });
            },

            /**
             * Return an array of 'permitted' linear channels, re SKYSTORM-423, retrieved from AppGrid-supplied settings
             * @method getPermittedLinearChannels
             * @public
             * @returns {Promise.<Array>} An array of permitted linear channels ids
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getPermittedLinearChannels: function () {
                //cache
                if (!this._getPermittedLinearChannelsPromise) {
                    this._getPermittedLinearChannelsPromise = this.__getAllAppConfigs().then(function (transport) {
                        try {
                            return JSON.parse(transport[APPGRID_KEY.FIELD.EHUB.PERMITTED_CHANNELS]);
                        } catch (e) {
                            throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.EHUB.PERMITTED_CHANNELS);
                        }
                    });
                }

                return this._getPermittedLinearChannelsPromise.then(function(inputJson) {
                    var environment = config.get("environment"); // eg "test", "production";

                    return inputJson.ids[environment];
                });
            },

            /**
             * Return a GeolocationSettings model, built from AppGrid-supplied settings
             * @method getGeolocationSettings
             * @public
             * @returns {Promise.<Object>} A GeolocationSettings model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getGeolocationSettings: function () {
                //cache
                if (!this._getGeolocationConfigPromise) {
                    this._getGeolocationConfigPromise = this.__getAllAppConfigs().then(function (transport) {
                        try {
                            return JSON.parse(transport[APPGRID_KEY.FIELD.SKY.GEOLOCATION]);
                        } catch (e) {
                            throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.SKY.GEOLOCATION);
                        }
                    });
                }

                return this._getGeolocationConfigPromise.then(function(inputJson) {
                    var environment = config.get("environment"); // eg "test", "production";

                    return new GeolocationSettingsBuilder()
                        .setRoot(inputJson.root[environment])
                        .setMapping(inputJson.mapping[environment])
                        .build();
                });
            },

            /**
             * Retrieve the package colour for the specified asset.
             * Make sure we're going to get the colour mapping...
             * @param  {String} packageCode Code of the package to retrieve package colour for.
             * @return {Promise}            Package colour (Hex string) when fulfilled.
             */
            _ensurePackageColourMappingPromise: function() {
                if (!this._getPackageColourMappingPromise) {
                    this._getPackageColourMappingPromise = this.__getAllAppConfigs().then(function (transport) {
                        try {
                            return JSON.parse(transport["config.cms.colours"]);
                        } catch (e) {
                            throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse config.cms.colours");
                        }
                    });
                }
            },

            /**
             * Retrieve the package image URL for the specified asset.
             * @param  {String} packageCode Code of the package to retrieve package colour for.
             * @return {Promise} Package image URL when fulfilled.
             */
            getPackageImageForCode: function (packageCode) {
                // Cache.
                this._ensurePackageColourMappingPromise();

                return this._getPackageColourMappingPromise.then(function (result) {
                    var colourCodeToName = result && result.colourCodeToName,
                        colourNameToImage = result && result.colourNameToImage,
                        packageColour = colourCodeToName && colourCodeToName[packageCode],
                        packageColourImage = colourNameToImage && colourNameToImage[packageColour];

                    if (packageColourImage) {
                        return sAppGridServiceHolder.getAppGridService().getResource(packageColourImage);
                    } else {
                        return promise.reject("No package image mapped to code " + packageCode);
                    }
                });
            },

            /**
             * Retrieve the package colour for the specified asset.
             * @param  {String} packageCode Code of the package to retrieve package colour for.
             * @return {Promise} Package colour (Hex string) when fulfilled.
             */
            getPackageColourForCode: function (packageCode) {
                // Cache.
                this._ensurePackageColourMappingPromise();

                return this._getPackageColourMappingPromise.then(function (result) {
                    var colourCodeToName = result && result.colourCodeToName,
                        colourNameToHex = result && result.colourNameToHex,
                        defaultColour = result && result.defaultColour,
                        packageColour = colourCodeToName && colourCodeToName[packageCode],
                        packageColourHex = colourNameToHex && colourNameToHex[packageColour];

                    return packageColourHex || defaultColour;
                });
            },

            /**
             * Retrieve information if live feature should be disabled or not.
             * @method getLiveFeatureStatus
             * @public
             * @returns {Promise.<Object>} A dictionary of configuration
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getLiveFeatureStatus: function () {
                return this.__getAllAppConfigs().then(function (transport) {
                    try {
                        return JSON.parse(transport[APPGRID_KEY.FIELD.LIVE.SUPPORT]);
                    } catch (e) {
                        throw new TVEError(TVEError.FACILITY.CONFIGURATION_SERVICE, TVEError.ERROR.INVALID, "Cannot parse " + APPGRID_KEY.FIELD.LIVE.SUPPORT);
                    }
                });
            },

            /**
             * Get the latest valid version from AppGrid
             * @method getLatestValidVersion
             * @public
             * @returns {Promise.<String>} the latest valid version
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof storm/mgr/sAppConfigManager#
             */
            getLatestValidVersion: function () {
                return this.__getAllAppConfigs().then(function (configs) {
                    try {
                        return JSON.parse(configs[APPGRID_KEY.FIELD.UI.NECESSARY_VERSION]);
                    } catch (e) {
                        return promise.reject("Cannot parse " + APPGRID_KEY.FIELD.UI.NECESSARY_VERSION);
                    }
                });
            },

            __getAllAppConfigs: function () {
                if (this.__getAllAppConfigsPromise) {
                    return this.__getAllAppConfigsPromise;
                }

                this.__getAllAppConfigsPromise = sAppGridServiceHolder.getAppGridService().getConfigs(["config.*"]).complete(util.bind(function () {
                    this.__getAllAppConfigsPromise = null;
                }, this));

                return this.__getAllAppConfigsPromise;
            }
        });

    return new AppConfigManager();
});
/**
 * Module that returns an editorial CMS content class
 * @name sEditorialManager
 * @memberof storm/mgr
 * @module storm/mgr/sEditorialManager
 * @author Jason Newman<jason.newman@ext.accedo.tv>
 */
define("storm/mgr/sEditorialManager", [
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/ajax",
    "xdk-base/promise",
    "xdk-base/config",
    "xdk-base/console",
    "tve/TVEError",
    "tve/sAppGridServiceHolder",
    "storm/mgr/sAppConfigManager"
], function (
    core,
    klass,
    util,
    ajax,
    promise,
    config,
    console,
    TVEError,
    sAppGridServiceHolder,
    sAppConfigManager
    ) {

    "use strict";

    var production = (config.get("environment") === "production");

    var EditorialManager = klass.create({}, {

        CONTENT : {
            //
            // Note that mapping here is from a tidy internal reference...
            // ... to a key into an AppGrid JSON object containing actual URLs.
            //

            // Navigation and data sources for 'Highlights' which are not supported by the CMS structure. See SKYSTORM-643 and much history behind it.
            HOMEPAGE_HIGHLIGHTS: "homepageHighlights",
            NAVIGATION_OVERRIDES: "navigationOverrides",

            // Complex structures, documented 'by example' (or by inspection).
            TEXT_MESSAGES: "textMessages",
            SILK_MESSAGES: "silkMessage",
            DAYPASS_DETAILS: "daypassDetails",
            PRODUCT_DETAILS: "subscriptionDetails", // Note, also includes some static / CMS-supplied daypass information; key name misleading :(

            // Terms, impressum, privacy, etc may also be complex structures...
            TERMS_DE: "termsDe",
            TERMS_AT: "termsAt",
            IMPRESSUM_DE: "impressumDe",
            IMPRESSUM_AT: "impressumAt",
            PRIVACY_DE: "privacyDe",
            PRIVACY_AT: "privacyAt",
            FAQ: "faq",
            EULA: "eula",
            PLATFORM_LICENSES: "platformLicenses",

            // This appears to have a useful image in it...
            IMAGES: "imageResources"
        },

        _initDefer: promise.defer(),
        _promisesPromises: {},

        /**
         * Initialize the editorial manager
         * @override
         * @protected
         * @name init
         * @memberof storm/mgr/sEditorialManager#
         */
        init: function () {
            sAppGridServiceHolder.getAppGridServicePromise().then(util.bind(function() {
                sAppConfigManager.getCmsConfig().then(util.bind(function (cmsConfig) {
                    try {
                        var rootUrl     = cmsConfig.root[production ? "production" : "test"];
                        
                        // DEV:
                        var proxy       = config.get("dev.proxy",false);
                        var proxyHosts  = config.get("dev.proxyHosts",[]);

                        for (var propertyName in this.CONTENT) {
                            if (this.CONTENT.hasOwnProperty(propertyName)) {
                                var branchUrl = cmsConfig.editorial[this.CONTENT[propertyName]],
                                    combinedUrl = (branchUrl.indexOf("http") === 0) ? branchUrl : (rootUrl + branchUrl);
                                    
                                if (!production && config.get("dev.replaceHost",false))
                                {
                                    // Look for hosts to replace if this is test environment
                                    var findHosts  = config.get("dev.findHosts",[]);
                                    var replaceHosts  = config.get("dev.replaceHosts",[]);
                                    
                                    var foundHostIndex = -1;
                                    for (var i=0; i<findHosts.length; i++)
                                    {
                                        if (combinedUrl.indexOf(findHosts[i]) > 0)
                                        {
                                            foundHostIndex = i;
                                            break;
                                        }
                                    }
                                    if (foundHostIndex > -1)
                                    {
                                        combinedUrl = combinedUrl.replace(findHosts[foundHostIndex], replaceHosts[foundHostIndex]);
                                    }
                                }
                                
                                if(proxy && proxyHosts.length) 
                                {
                                    // If the url host matches one of the predefined proxy hosts we strip away the host part and let apache rewrite do the job
                                    var proxyHost = null;
                                    for (var j=0; j<proxyHosts.length; j++)
                                    {
                                        if (combinedUrl.indexOf(proxyHosts[j]) > 0)
                                        {
                                            proxyHost = proxyHosts[j];
                                            break;
                                        }
                                    }
                                    if (proxyHost)
                                    {
                                        var proxyServer = config.get("dev.proxyPath");
                                        combinedUrl = proxyServer+encodeURIComponent(combinedUrl);
                                    }
                                }
                                
                                console.log("URL: "+combinedUrl);
                                
                                this._promisesPromises[this.CONTENT[propertyName]] = ajax.request(combinedUrl, {method: "get"});
                            }
                        }

                        this._initDefer.resolve(); // This will allow any requests to proceed that have been blocked waiting on this config.
                    } catch(e) {
                        this._initDefer.reject(new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "sEditorialManager init: " + e));
                    }
                }, this));
            }, this));
        },

        /**
         * Get the promise that will resolve to a specific piece of editorial content.
         * @name getEditorialContent
         * @memberof storm/mgr/sEditorialManager#
         * @function
         * @param {String} stringKey the key used to interrogate our internal list of available editorial content
         * @returns {Promise.<Object>} The retrieved editorial content object
         * @throws {TVEError} if stringKey is not passed, or is somehow unusable
         * @public
         */
        getEditorialContent: function (stringKey) {
            console.log("sEditorialManager::getEditorialContent("+stringKey+")");
            if (!util.isString(stringKey)) {
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "getEditorialContent: Key was not a string");
            }
            if (stringKey.length < 1) {
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "getEditorialContent: Key was too short");
            }

            return this._initDefer.promise.then(util.bind(function() {
                if (util.isUndefined(this._promisesPromises[stringKey])) {
                    throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "getEditorialContent: Key " + stringKey + " unavailable");
                } else {
                    return this._promisesPromises[stringKey];
                }
            }, this));
        }

    });

    return new EditorialManager();
});
/**
 * Module that returns an singleton language (string literals / i18n) class
 * @name sLanguageManager
 * @memberof storm/mgr
 * @module storm/mgr/sLanguageManager
 * @author Jason Newman<jason.newman@ext.accedo.tv>
 */
define("storm/mgr/sLanguageManager", [
    "xdk-base/ax",
    "xdk-base/util",
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/console",
    "tve/TVEError",
    "lib/moment",
    "tve/sAppGridServiceHolder",
    "storm/mgr/sAppConfigManager",
    "storm/mgr/sEditorialManager"
], function (
    ax,
    util,
    core,
    klass,
    config,
    console,
    TVEError,
    moment,
    sAppGridServiceHolder,
    sAppConfigManager,
    sEditorialManager
    ) {

    "use strict";

    var SOURCE = {
        LOCAL: "Local",
        CMS: "CMS",
        APPGRID: "AppGrid"
    };

    var LANGUAGE = {
        MIRROR: "mirror",
        UNIVERSAL: "ALL"
    };

    var LanguageManager = klass.create({}, {

        _currentLanguage: LANGUAGE.MIRROR,

        //
        // Magic language 'mirror' causes the key passed to the string getter
        // to be returned (instead of a mapped language string), with some debug.
        // This is to assist with development.
        //
        // Note that unmappable requests are returned untranslated.
        //

        _availableLanguages: ["en", "de", LANGUAGE.MIRROR],

        // Note that the available sources are listed in INCREASING order of preference...

        _sourcePreferenceOrder: [SOURCE.LOCAL, SOURCE.CMS, SOURCE.APPGRID],

        // Allow other UI to pend this being completely initialised (which is asynchronously)...

        _initDefer: ax.promise.defer(),

        //
        // For Storm in production we only use German for UI labelling (no Austrian).
        // During development and testing English may be useful, which is why it features in the code / data.
        //

        /**
         * Language string mappings
         */
        _mappings: {
        },

        /**
         * Initialize the language manager
         * @override
         * @protected
         * @name init
         * @memberof storm/mgr/sLanguageManager#
         */
        init: function () {
            // We prefer to take text from AppGrid, as it's easiest to update and control.
            // If no translation appears there, we'd prefer to take text from CMS, as it's at least relative dynamic.
            // As a fall-back some strings can be defined (maybe given safe default values) locally in the UI.
            // If we can't find a mapping for a requested key in any of those place, we will 'mirror' the key back.

            ax.promise.all([
                this._populateLocalStrings(),
                this._populateCmsStrings(),
                this._populateAppGridStrings()
            ]).then(ax.util.bind(function(){
                this._initDefer.resolve("Retrieved all language texts");
            }, this), ax.util.bind(function(e){
                this._initDefer.reject("Couldn't get all language texts: " + e);
            }, this));
        },

        /**
         * Merge some new languages into an existing set.
         * @method _mergeMappingsFromTo
         * @param {String} mergeFrom the newly-suggested mappings from one key to some languages
         * @param {String} mergeTo an existing set of such mappings
         * @param {String} sourceType the source of the new mappings, for preference purposes
         * @throws {TVEError} if an unrecognised source is specified
         * @memberof storm/mgr/sLanguageManager#
         * @private
         */
        _mergeMappingsFromTo: function(mergeFrom, mergeTo, sourceType)
        {
            if (!sourceType || this._sourcePreferenceOrder.indexOf(sourceType) === -1) {
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "_mergeMappingsFromTo: No usable source type");
            }

            for (var mapLang in mergeFrom) {
                if (mergeFrom.hasOwnProperty(mapLang)) {
                    var existingMapping = mergeTo[mapLang];

                    if (ax.util.isUndefined(existingMapping)) {
                        var newMapping = {};
                        newMapping.source = sourceType;
                        newMapping.string = mergeFrom[mapLang];
                        mergeTo[mapLang] = newMapping;
                    } else {
                        var existingPrecedence = this._sourcePreferenceOrder.indexOf(existingMapping.source);
                        var proposedPrecedence = this._sourcePreferenceOrder.indexOf(sourceType);

                        if (existingPrecedence === proposedPrecedence) {
                            //
                            // This is moderately serious; mapping the same key twice from the same
                            // source will lead to confusing issues with on-screen text not updating as expected.
                            //
                            console.warn("_mergeMappingsFromTo: Overwrite at same precedence level");
                        }

                        if (existingPrecedence <= proposedPrecedence) {
                            existingMapping.source = sourceType;
                            existingMapping.string = mergeFrom[mapLang];
                        }
                    }
                }
            }
        },

        /**
         * Populate the memoised string repository from a source, using our hardcoded preferences.
         * @method _populateStringsFromSource
         * @param {String} theSource where the strings came from
         * @param {String} theStrings the strings themselves, in a standard format
         * @throws {TVEError} if an unrecognised source is specified
         * @memberof storm/mgr/sLanguageManager#
         * @private
         */
        _populateStringsFromSource: function(theSource, theStrings)
        {
            if (!theStrings) {
                // Nothing to do if no string-carrying object provided...
                return;
            }

            if (!theSource || this._sourcePreferenceOrder.indexOf(theSource) === -1) {
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "_populateStringsFromSource: No usable source type");
            }

            for (var key in theStrings) {
                if (theStrings.hasOwnProperty(key)) {
                    // Are there are mapping already? If so we must merge with them carefully...
                    var mappingsToMergeFrom = theStrings[key];
                    var mappingsToMergeTo = this._mappings[key];

                    if (ax.util.isUndefined(mappingsToMergeTo)) {
                        mappingsToMergeTo = {};
                        this._mappings[key] = mappingsToMergeTo;
                    }

                    this._mergeMappingsFromTo(mappingsToMergeFrom, mappingsToMergeTo, theSource);
                }
            }
        },

        /**
         * Populate any mappings that are given locally.
         * @method _populateLocalStrings
         * @return {Promise} Promise that this population is complete.
         * @memberof storm/mgr/sLanguageManager#
         * @private
         */
        _populateLocalStrings: function() {
            var _source = {};

            if (window._language_config) {
                _source = window._language_config;
                delete window._language_config;
            } else {
                console.warn("No locally-configured language strings found");
            }

            this._populateStringsFromSource(SOURCE.LOCAL, _source);

            return ax.promise.resolve("_populateLocalStrings complete"); // This can't really fail. Not like the CMS and AppGrid ones!
        },

        /**
         * Populate the mappings that are given on Sky's CMS.
         * @method _populateCmsStrings
         * @memberof storm/mgr/sLanguageManager#
         * @private
         */
        _populateCmsStrings: function() {
            return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.TEXT_MESSAGES).then(ax.util.bind(function(transport){

                //
                // We allow this to fail hard (no checks or catching), as partial success is not significantly better than a complete failure
                //

                var _source = {};

                ax.util.each(transport.responseJSON.sections.section, function (languageSection) {
                    ax.util.each(languageSection.item, function (languageItem) {
                        _source[languageSection.name + "." + languageItem.key] = {"de": languageItem.content};
                    });
                });

                this._populateStringsFromSource(SOURCE.CMS, _source);
            }, this), function(e){
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "_populateCmsStrings failed: " + e);
            });
        },

        /**
         * Populate the mappings that are given on AppGrid.
         * @method _populateAppGridStrings
         * @memberof storm/mgr/sLanguageManager#
         * @private
         */
        _populateAppGridStrings: function() {
            return sAppGridServiceHolder.getAppGridServicePromise().then(ax.util.bind(function(){
                return sAppConfigManager.getLanguageStrings().then(ax.util.bind(function(languageMap){
                    this._populateStringsFromSource(SOURCE.APPGRID, languageMap);
                }, this),
                function(e) {
                    throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "_populateAppGridStrings failed: " + e);
                });
            }, this));
        },

        /**
         * Select a language to start mapping to.
         * @name setLanguage
         * @memberof storm/mgr/sLanguageManager#
         * @function
         * @param {String} languageName the name of the desired language
         * @throws {TVEError} if the languageName is not supplied, or is not an available one
         * @public
         */
        setLanguage: function (languageName) {
            if (languageName) {
                if (this._availableLanguages.indexOf(languageName) !== -1) {
                    this._currentLanguage = languageName;
                    moment.lang(languageName); // See SKYSTORM-297.
                } else {
                    throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "setLanguage: The requested language (" + languageName + ") is not available");
                }
            } else {
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "setLanguage: No language was requested");
            }
        },

        /**
         * Merge some new languages into an existing set.
         * @method getCurrentLanguage
         * @return {Promise} Promise that the initialisation is complete.
         * @memberof storm/mgr/sLanguageManager#
         */
        getInitPromise: function () {
            return this._initDefer.promise;
        },

        /**
         * Get language that is currently used for mapping.
         * @return {String} Language identifier of currently used language.
         */
        getCurrentLanguage: function () {
            return this._currentLanguage;
        },

        /**
         * Get the results of a string mapping for the current language.
         * @name _getString
         * @memberof storm/mgr/sLanguageManager#
         * @function
         * @param {String} stringKey the key used to interrogate the mappings 'database'
         * @throws {TVEError} if stringKey is not passed, or is somehow unusable
         * @private
         */
        _getString: function (stringKey) {
            if (!ax.util.isString(stringKey)) {
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "getString: Key was not a string");
            }
            if (stringKey.length < 1) {
                // There's no way to map such a thing, so it's probably an intentionally empty string requiring no mapping.
                return stringKey;
            }

            var keyMapping = this._mappings[stringKey];

            if (ax.util.isUndefined(keyMapping)) {
                return (stringKey);
            }

            if (this._currentLanguage === LANGUAGE.MIRROR) {
                return ("[" + stringKey + "] maps ok");
            } else {
                var langMapping = keyMapping[this._currentLanguage];

                // If no mapping found specific to the current language, look for a universally-applicable mapping.

                if (ax.util.isUndefined(langMapping)) {
                    langMapping = keyMapping[LANGUAGE.UNIVERSAL];
                }

                if (ax.util.isUndefined(langMapping)) {
                    return ("[" + stringKey + "] mapped, but not to language " + this._currentLanguage);
                }

                //
                // If no translation supplied (in test) try to give Sky a 'leg up' by echoing back the key...
                //
                // @TODO: Remove once language strings are supplied, see SKYSTORM-265.
                //

                if (config.get("environment") === "test") {
                    if ((langMapping.string === "NEW_LABEL_SMARTV") || (langMapping.string === "NEW") || (util.isUndefined((langMapping.string)))) {
                        return stringKey;
                    }
                }

                // If no translation is supplied (in productionenvironment) display an empty string.
                if (config.get("environment") === "production") {

                    if (!util.isString(langMapping.string)) {
                        return "";
                    }
                }

                return langMapping.string;
            }
        },

        /**
         * Get the results of a string mapping for the current language. Replace text inside keyPair if any.
         * @name getString
         * @memberof storm/mgr/sLanguageManager#
         * @function
         * @param {String} stringKey the key used to interrogate the mappings 'database'
         * @param [optional] {Array/Object} keyPair that is used to replace the text from _getString result
         * @throws {TVEError} if stringKey is not passed, or is somehow unusable
         * @public
         *
         * Example:
         * _getString(x)
         *  => "Fr '{search term}' in Sky Online({amounts results})"
         * getString(x, {
         *  "search term": "REPLACE1",
         *  "amounts results": "REPLACE2"
         * })
         *  => "Fr 'REPLACE1' in Sky Online(REPLACE2)"
         */
        getString: function (stringKey, keyPair) {
            if (!keyPair) {
                return this._getString(stringKey);
            }
            var replacer = function (match) {
                var keyValue = keyPair[match.slice(1,-1)];
                return keyValue !== undefined ? keyValue : match;
            };
            return this._getString(stringKey).replace(/(\{.*?\})/g, replacer);
        }


    });

    return new LanguageManager();
});
/**
 * TermsAndConditionsDialog is a dialog that prompts the user to accept the terms and conditions.
 *
 * @name TermsAndConditionsDialog
 * @memberof storm/wgt
 * @class storm/wgt/TermsAndConditionsDialog
 */
define("storm/wgt/FullscreenTextDialog", [
    "xdk-base/class",
    "fix/Dialog",
    "xdk-base/util",
    "xdk-ax/Container",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/ScrollLabel",
    "storm/mgr/sLanguageManager"
], function (
    klass,
    Dialog,
    util,
    Container,
    focusManager,
    evtType,
    Layout,
    Button,
    Label,
    ScrollLabel,
    sLanguageManager
    ) {

    "use strict";

    return klass.create(Dialog, {
    }, {

        init: function (options) {
            options = options || {};

            options.title = options.title || "";
            options.message = options.message || "";

            this._cancelButton = new Button({
                id: "cancelButton",
                css: "cancel-button",
                text: options.cancelButtonText || sLanguageManager.getString("Global.Global_buttonBack_button"),
                nextUp: "info-message"
            });

            this._scrollingLabel = new ScrollLabel({
                id: 'info-message',
                css: "wgt-dialog-message",
                nextDown: 'cancelButton',
                scrollStep: 150
            });

            options.content = new Container({
                children: [
                    new Container({
                        css: 'scrolling-label-container',
                        children: [
                            this._scrollingLabel
                        ]
                    }),
                    new Layout({
                        id: 'bottomContainer',
                        forwardFocus: true,
                        children: [
                            this._cancelButton
                        ]
                    })
                ]
            });

            this._super(options);

            this.addClass("wgt-fullscreen-text-dialog");

            this._cancelButtonAction = util.bind(function () {
                this.close();
            }, this);

            this._cancelButton.addEventListener(evtType.CLICK, this._cancelButtonAction);

            this.setOption("forwardFocus", this._scrollingLabel);

            this._scrollingLabel.setText(options.message);

            // remember the last focus, that can be resumed after the dialog is closed
            this._lastFocus = focusManager.getCurFocus();

            // No need to set focus to scrollable label if it's not scrollable
            if (this._scrollingLabel.__scrollable) {
                focusManager.focus(this._scrollingLabel);
            } else {
                this._scrollingLabel.setOption('focusable', false);
                focusManager.focus(this._cancelButton);
            }


        },

        close: function () {
            this._cancelButton.removeEventListener(evtType.CLICK, this._cancelButtonAction);

            this._super();
            this.deinit();
        }
    });
});
/**
 * TermsAndConditionsDialog is a dialog that prompts the user to accept the terms and conditions.
 *
 * @name TermsAndConditionsDialog
 * @memberof storm/wgt
 * @class storm/wgt/TermsAndConditionsDialog
 */
define("storm/wgt/TermsAndConditionsDialog", [
    "xdk-base/class",
    "fix/Dialog",
    "xdk-base/util",
    "xdk-ax/Container",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/ScrollLabel",
    "xdk-ui-basic/Checkbox",
    "storm/wgt/FullscreenTextDialog"
], function (
    klass,
    Dialog,
    util,
    Container,
    focusManager,
    evtType,
    Layout,
    Button,
    Label,
    ScrollLabel,
    Checkbox,
    FullscreenTextDialog
    ) {

    "use strict";

    return klass.create(Dialog, {
    }, {

        init: function (options) {
            options = options || {};

            options.title = options.title || "";
            options.message = options.message || "";

            options.firstCheckboxLabel = options.firstCheckboxLabel || "";
            options.secondCheckboxLabel = options.secondCheckboxLabel || "";

            options.confirmButtonText = options.confirmButtonText || "";

            options.marketingTitle = options.marketingTitle || "";
            options.marketingBody = options.marketingBody || "";

            options.AGBTitle = options.AGBTitle || "";
            options.AGBBody = options.AGBBody || "";

            this._firstCheckbox = new Checkbox({
                id: "firstCheckbox",
                nextRight: "marketingButton",
                nextDown: "secondCheckbox"
            });

            this._secondCheckbox = new Checkbox({
                id: "secondCheckbox",
                nextRight: "AGBButton",
                nextUp: "firstCheckbox",
                nextDown: "bottomContainer",
                nextLeft: "secondCheckbox"
            });

            this._confirmButton = new Button({
                id: "confirmButton",
                css: "confirm-button",
                text: options.confirmButtonText,
                nextUp: "secondCheckbox",
                nextRight: "cancelButton"
            });

            this._cancelButton = new Button({
                id: "cancelButton",
                css: "cancel-button",
                text: options.cancelButtonText,
                nextUp: "secondCheckbox",
                nextLeft: "confirmButton"
            });

            this._marketingButton = new Button({
                id: "marketingButton",
                css: "marketing-button",
                text: options.showMarketingButton,
                nextUp: "",
                nextDown: "AGBButton",
                nextLeft: "firstCheckbox"
            });

            this._AGBButton = new Button({
                id: "AGBButton",
                css: "agb-button",
                text: options.showAGBButton,
                nextUp: "marketingButton",
                nextDown: 'cancelButton',
                nextLeft: "secondCheckbox"
            });

            options.content = new Container({
                children: [
                    new Layout({
                        css: "left-container",
                        nextUp: null,
                        children: [
                            new Label({
                                css: "title",
                                text: options.title
                            }),
                            new Label({
                                css: "message",
                                text: options.message
                            }),
                            new Layout({
                                css: "checkbox-container",
                                children: [
                                    this._firstCheckbox,
                                    new Label({
                                        css: "checkbox-label",
                                        text: options.firstCheckboxLabel
                                    }),
                                    this._secondCheckbox,
                                    new Label({
                                        css: "checkbox-label",
                                        text: options.secondCheckboxLabel
                                    })
                                ]
                            }),
                            new Layout({
                                id: 'bottomContainer',
                                css: 'bottomContainer',
                                forwardFocus: true,
                                children: [
                                    this._confirmButton,
                                    this._cancelButton
                                ]
                            })
                        ]
                    }),
                    new Layout({
                        css: "right-container",
                        nextUp: null,
                        children: [
                            this._marketingButton,
                            this._AGBButton
                        ]
                    })
                ]
            });

            this._super(options);

            this.addClass("wgt-terms-and-conditions-dialog");

            this.agbValueChanged = util.bind(this._agbValueChanged, this);

            this._confirmButtonAction = util.bind(function () {
                var firstCheckboxValue = this._firstCheckbox.getValue(),
                    secondCheckboxValue = this._secondCheckbox.getValue();

                this.close();
                options.confirmAction && options.confirmAction(firstCheckboxValue, secondCheckboxValue);
            }, this);

            this._cancelButtonAction = util.bind(function () {
                this.close();
                options.cancelAction && options.cancelAction();
            }, this);

            this._openMarketingInfo = util.bind(this._openInfoTextDialog, this, options.marketingTitle, options.marketingBody);
            this._openAGBInfo = util.bind(this._openInfoTextDialog, this, options.AGBTitle, options.AGBBody);

            this._confirmButton.addEventListener(evtType.CLICK, this._confirmButtonAction);
            this._cancelButton.addEventListener(evtType.CLICK, this._cancelButtonAction);

            this._marketingButton.addEventListener(evtType.CLICK, this._openMarketingInfo);
            this._AGBButton.addEventListener(evtType.CLICK, this._openAGBInfo);

            this._secondCheckbox.addEventListener(evtType.VALUE_CHANGED, this.agbValueChanged);

            this.setOption("forwardFocus", this._firstCheckbox);

            this._firstCheckbox.check(false);
            this._secondCheckbox.check(false);

            // remember the last focus, that can be resumed after the dialog is closed
            this._lastFocus = focusManager.getCurFocus();

            // set focus on the dialog
            focusManager.focus(this._firstCheckbox);
        },

        _openInfoTextDialog: function(title, message) {
            new FullscreenTextDialog({
                title: title,
                message: message
            });

        },

        _agbValueChanged: function(checkValue) {
            if (checkValue === true) {
                this._confirmButton.show();
            } else {
                this._confirmButton.hide();
            }
        },

        close: function () {
            this._confirmButton.removeEventListener(evtType.CLICK, this._confirmButtonAction);
            this._cancelButton.removeEventListener(evtType.CLICK, this._cancelButtonAction);

            this._marketingButton.removeEventListener(evtType.CLICK, this._openMarketingInfo);
            this._AGBButton.removeEventListener(evtType.CLICK, this._openAGBInfo);

            this._secondCheckbox.removeEventListener(evtType.VALUE_CHANGED, this.agbValueChanged);

            this._super();
            this.deinit();
        }
    });
});
/**
 * EulaAcceptDialog is a dialog that prompts the user to accept the terms and conditions.
 *
 * @name EulaAcceptDialog
 * @memberof storm/wgt
 * @class storm/wgt/EulaAcceptDialog
 */
define("storm/wgt/EulaAcceptDialog", [
    "xdk-base/class",
    "fix/Dialog",
    "xdk-base/util",
    "xdk-ax/Container",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/ScrollLabel"
], function (
    klass,
    Dialog,
    util,
    Container,
    focusManager,
    evtType,
    Layout,
    Button,
    Label,
    ScrollLabel
    ) {

    "use strict";

    return klass.create(Dialog, {
    }, {

        init: function (options) {
            options = options || {};

            options.title = options.title || "";
            options.hint = options.hint || "";
            options.body = options.body || "";

            options.confirmButtonText = options.confirmButtonText || "";
            options.cancelButtonText = options.cancelButtonText || "";

            this._bodyLabel = new ScrollLabel({
                id: "bodyLabel",
                scrollStep: 220, // This is a very long block of text. Scroll faster!
                nextDown: "confirmButton"
            });

            this._confirmButton = new Button({
                id: "confirmButton",
                css: "confirm-button",
                text: options.confirmButtonText,
                nextUp: "bodyLabel",
                nextRight: "cancelButton"
            });

            this._cancelButton = new Button({
                id: "cancelButton",
                css: "cancel-button",
                text: options.cancelButtonText,
                nextUp: "bodyLabel",
                nextLeft: "confirmButton"
            });

            options.content = new Container({
                forwardFocus: this._bodyLabel,
                children: [
                    new Label({
                        css: "title",
                        text: options.title
                    }),
                    new Label({
                        css: "message",
                        text: options.hint
                    }),
                    this._bodyLabel,
                    this._confirmButton,
                    this._cancelButton
                ]
            });

            this._super(options);

            this.addClass("wgt-eula-accept-dialog");

            this._confirmButtonAction = util.bind(function () {
                try {
                    this.close();
                } catch (e) {}
                if (util.isFunction(options.confirmAction)) {
                    options.confirmAction();
                }
            }, this);

            this._cancelButtonAction = util.bind(function () {
                try {
                    this.close();
                } catch (e) {}
                if (util.isFunction(options.cancelAction)) {
                    options.cancelAction();
                }
            }, this);

            this._confirmButton.addEventListener(evtType.CLICK, this._confirmButtonAction);
            this._cancelButton.addEventListener(evtType.CLICK, this._cancelButtonAction);

            this.setOption("forwardFocus", this._bodyLabel);

            this._bodyLabel.setText(options.body);

            // remember the last focus, that can be resumed after the dialog is closed
            this._lastFocus = focusManager.getCurFocus();

            // set focus on the dialog
            focusManager.focus(this._bodyLabel);
        },

        close: function () {
            this._confirmButton.removeEventListener(evtType.CLICK, this._confirmButtonAction);
            this._cancelButton.removeEventListener(evtType.CLICK, this._cancelButtonAction);

            this._super();
            this.deinit();
        }
    });
});
/**
 * Some helper functions for different types of dialog.
 * @module tvedemo/helper/dialogHelper
 * @name dialogHelper
 * @memberof tvedemo/helper
 */
define("tvedemo/helper/dialogHelper", [
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/promise",
    "xdk-ax/mediator",
    "tve/TVEError",
    "xdk-ui-basic/Dialog",
    "tvedemo/wgt/AlertDialog",
    "tvedemo/wgt/ConfirmDialog",
    "tvedemo/wgt/InputDialog",
    "tvedemo/mgr/sHistoryManager",
    "storm/wgt/TermsAndConditionsDialog",
    "storm/wgt/EulaAcceptDialog",
    "storm/mgr/sLanguageManager"
], function (
    util,
    evtType,
    focusManager,
    promise,
    mediator,
    TVEError,
    Dialog,
    AlertDialog,
    ConfirmDialog,
    InputDialog,
    sHistoryManager,
    TermsAndConditionsDialog,
    EulaAcceptDialog,
    sLanguageManager
    ) {

    "use strict";

    var DialogHelper = {

        VERTICAL_BUTTON_LAYOUT: 0x01,
        HORIZONTAL_BUTTON_LAYOUT: 0x02,

        fromSilkMessagePromise: function(silkMessagePromise) {

            if (promise.isPromise(silkMessagePromise)) {

                silkMessagePromise.then(function(silkMessage) {
                    DialogHelper.error({
                        title: silkMessage.get("title"),
                        reason: silkMessage.get("description")
                    });
                });
            }

        },
        /**
         * Open an AlertDialog to show the reason.
         * @method
         * @public
         * @param {Object} opts The options
         * @param {String} opts.title The dialog title
         * @param {TVEError|String} opts.reason The reason of the error
         * @param {Function} opts.closeAction The action to perform when the dialog is closed
         * @param {Container} opts.viewParent The view component that the dialog attachs to
         * @param {String} opts.buttonText The text shown in the button
         * @memberOf tvedemo/helper/dialogHelper#
         */
        error: function (opts) {
            var dialog,
                defaultOpts = {
                    title: sLanguageManager.getString("Errormessages.Errormessages_GenericErrorMessageHeadline"),
                    reason: sLanguageManager.getString("Global.Global_generalError"),
                    buttonText: sLanguageManager.getString("Global.Global_Continue")
                };

            opts = util.extend(defaultOpts, opts || {});

            dialog = new AlertDialog({
                title: opts.title,
                message: (opts.reason instanceof TVEError) ? opts.reason.getMessage() : opts.reason,
                buttonText: opts.buttonText
            });

            if (util.isFunction(opts.closeAction)) {
                dialog.addEventListener(evtType.CLOSE, opts.closeAction);
            }

            return dialog;
        },

        success: function (opts){

            opts.buttonText = sLanguageManager.getString("Global.Global_Continue");

            var dialog = new AlertDialog({
                title: opts.title,
                message: opts.message,
                buttonText: opts.buttonText
            });

            if (util.isFunction(opts.closeAction)) {
                dialog.addEventListener(evtType.CLOSE, opts.closeAction);
            }

            return dialog;
        },

        /**
         * Open an InputDialog to prompt the user for input.
         * @method
         * @public
         * @param {Object} options Options for the dialog.
         * @param {String} options.title Dialog title.
         * @param {String} options.message Dialog message.
         * @param {Function} options.finishedTextInput Action to perform when user has finished text input.
         * @param {Function} options.canceledTextInput Action to perform if user cancels the dialog.
         * @memberOf tvedemo/helper/dialogHelper#
         */
        input: function (options) {
            var dialog = new InputDialog(options);
            return dialog;
        },

        confirm: function (options) {
            return new ConfirmDialog(options);

        },

        termsAndConditions: function (options) {
            var dialog;
            dialog = new TermsAndConditionsDialog(options);
            return dialog;
        },

        eulaAccept: function (options) {
            var dialog;
            dialog = new EulaAcceptDialog(options);
            return dialog;
        },

        /**
         * Check if any dialog is currently opened.
         * @return {Boolean} True if any dialog is currently open, otherwise false.
         */
        isAnyDialogOpen: function () {
            var component = focusManager.getCurFocus();

            // Loop through component and it's parents to see if it's part of a Dialog.
            while (component) {

                if (component instanceof Dialog) {
                    return true;
                }

                component = component.getParent();
            }

            // Default return value.
            return false;
        }
    };

    return DialogHelper;
});
/**
 * VODContentService Interface
 * @name VODContentService
 * @memberof tve
 * @class tve/interface/VODContentService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/VODContentService", ["xdk-base/Interface"], function(Interface) {
    return Interface.create("VODContentService", {
        /**
         * Get all Movies
         * @method getAllMovies
         * @public
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/VODContentService#
         */
        getAllMovies: ["opts"],
        /**
         * Get Movie by Id
         * @method getMovieById
         * @public
         * @param {String} id MovieID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @returns {Promise.<tve/model/Asset>} Asset object
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/VODContentService#
         */
        getMovieById: ["id", "opts"],
        /**
         * Get Movies by Ids
         * @method getMoviesByIds
         * @public
         * @param {String[]} ids MovieIDs
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/VODContentService#
         */
        getMoviesByIds: ["ids", "opts"],
        /**
         * Get Movies by category
         * @method getMoviesByCategoryId
         * @public
         * @param {String} categoryId CategoryID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/VODContentService#
         */
        getMoviesByCategoryId: ["categoryId", "opts"],
        /**
         * Get all TV Shows
         * @method getAllTVShows
         * @public
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @param {String} [opts.showEpisodes] flag to show episodes in return
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/VODContentService#
         */
        getAllTVShows: ["opts"],
        /**
         * Get TV Show by Id
         * @method getTVShowById
         * @public
         * @param {String} id TVShowID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @param {String} [opts.showEpisodes] flag to show episodes in return
         * @returns {Promise.<tve/model/Asset>} Asset object
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/VODContentService#
         */
        getTVShowById: ["id", "opts"],
        /**
         * Get TV Shows by Ids
         * @method getTVShowsByIds
         * @public
         * @param {String[]} ids TVShowIDs
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @param {String} [opts.showEpisodes] flag to show episodes in return
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/VODContentService#
         */
        getTVShowsByIds: ["ids", "opts"],
        /**
         * Get TV Shows by category
         * @method getTVShowsByCategoryId
         * @public
         * @param {String} categoryId CategoryID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate
         * @param {String} [opts.showEpisodes] flag to show episodes in return
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/VODContentService#
         */
        getTVShowsByCategoryId: ["categoryId", "opts"],
        /**
         * Get all Episodes
         * @method getAllEpisodes
         * @public
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/VODContentService#
         */
        getAllEpisodes: ["opts"],
        /**
         * Get Episodes by Id
         * @method getEpisodeById
         * @public
         * @param {String} id EpisodeID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
         * @returns {Promise.<tve/model/Asset>} Asset object
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/VODContentService#
         */
        getEpisodeById: ["id", "opts"],
        /**
         * Get Episode by TVShow Id
         * @method getEpisodeByTVShowId
         * @public
         * @param {String} showId showID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/VODContentService#
         */
        getEpisodesByTVShowId: ["showId", "opts"]

    });
});
/**
 * LinearContentService Interface
 * @name LinearContentService
 * @memberof tve
 * @class tve/interface/LinearContentService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/interface/LinearContentService", ["xdk-base/Interface"], function(Interface) {
    return Interface.create("LinearContentService", {
        /**
         * Get all Channels
         * @method getAllChannels
         * @public
         * @param {Object} opts The options object
         * @param {String} [opts.sortBy] sort by id/channelNumber/title
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/LinearContentService#
         */
        getAllChannels: ["opts"],
        /**
         * Get all permitted Channels
         * @method getPermittedChannels
         * @public
         * @param {Object} opts The options object
         * @param {String} [opts.sortBy] sort by id/channelNumber/title
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/LinearContentService#
         */
        getPermittedChannels: ["opts"],
        /**
         * Get Channel by Id
         * @method getChannelById
         * @public
         * @param {String} id ChannelID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/channelNumber/title
         * @returns {Promise.<tve/model/Channel>} Channel object
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/LinearContentService#
         */
        getChannelById: ["id", "opts"],
        /**
         * Get Channels by Ids
         * @method getChannelsByIds
         * @public
         * @param {String[]} ids ChannelIDs
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/channelNumber/title
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/LinearContentService#
         */
        getChannelsByIds: ["ids", "opts"],
        /**
         * Get Channels by Category
         * @method getChannelsByCategoryId
         * @public
         * @param {String} categoryId CategoryID
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/channelNumber/title
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/LinearContentService#
         */
        getChannelsByCategoryId: ["categoryId", "opts"],
        /**
         * Get all ChannelListings
         * @method getAllChannelListings
         * @public
         * @param {String} startTime startTime
         * @param {String} endTime endTime
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/channelId
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/LinearContentService#
         */
        getAllChannelListings: ["startTime", "endTime", "opts"],
        /**
         * Get ChannelListing by channel Id
         * @method getChannelListingByChannelId
         * @public
         * @param {String} channelId ChannelID
         * @param {String} startTime startTime
         * @param {String} endTime endTime
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/channelId
         * @returns {Promise.<tve/model/ChannelListing>} ChannelListing object
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/interface/LinearContentService#
         */
        getChannelListingByChannelId: ["channelId", "startTime", "endTime", "opts"],
        /**
         * Get ChannelListing by channel Ids
         * @method getChannelListingsByChannelIds
         * @public
         * @param {String[]} channelIds ChannelIDs
         * @param {String} startTime startTime
         * @param {String} endTime endTime
         * @param {Object} [opts] The options object
         * @param {String} [opts.sortBy] sort by id/channelId
         * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
         * @throws {Promise.<tve/TVEError>} Internal error object 
         * @memberof tve/interface/LinearContentService#
         */
        getChannelListingsByChannelIds: ["channelIds", "startTime", "endTime", "opts"]
    });
});
/**
 * The OVP service layer (mockup), implements all OVP related services
 * which contain LinearContentService VODContentService
 * @name AccedoOvpService
 * @memberof tve
 * @class tve/AccedoOvpService
 * @augments tve/interface/LinearContentService
 * @augments tve/interface/VODContentService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/AccedoOvpService", [
    "xdk-base/ax", "tve/util/CacheHelper", "tve/TVEError",
    "tve/interface/VODContentService", "tve/interface/LinearContentService"
], function (ax, CacheHelper, TVEError,
    VODContentService, LinearContentService) {

    var FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,
        SORTING = {
            DESC: "desc",
            ASC: "asc"
        },

        /**
         * private API functions for OVP related service.
         * @member ovpServiceApi
         * @memberof tve/AccedoOvpService#
         * @private
         */
        ovpServiceApi = {
            cacheHelper: null,
            baseURL: "",
            init: function (url, cacheHelper) {
                this.baseURL = url;
                this.cacheHelper = cacheHelper;
            },
            categoryRequest: function (opts) {
                opts = opts || {};


                var url = this.baseURL + "/category",
                    ids = opts.id,
                    objType = opts.objType,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                if (ax.util.isBoolean(opts.showEpisodes)) {
                    parameters.episodes = opts.showEpisodes;
                }

                if (ax.util.isBoolean(opts.showTVSeasons)) {
                    parameters.seasons = opts.showTVSeasons;
                }

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.id;
                }

                if (objType) {
                    url += "/" + objType;
                    delete opts.objType;
                }

                return this.request(url, opts, parameters);
            },

            // ==== ILinearContentService ====
            channelRequest: function (opts) {
                opts = opts || {};

                var url = this.baseURL + "/channel",
                    ids = opts.id,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.id;
                }

                return this.request(url, opts, parameters);
            },
            // a little bit different handling to standard channel
            channelByCategoryRequest: function (opts) {
                opts = opts || {};

                if (!opts.id) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided in OVP API"));
                }
                ax.util.extend(opts, {
                    objType: "channel"
                });
                return this.categoryRequest(opts);
            },
            channelListingRequest: function (opts) {
                opts = opts || {};

                var url = this.baseURL + "/tvlisting",
                    ids = opts.channelId,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                if (!opts.startTime || !opts.endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided in OVP API"));
                }

                // put parameters
                parameters.startTime = opts.startTime;
                parameters.endTime = opts.endTime;

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.channelId;
                }

                return this.request(url, opts, parameters);
            },
            // ==== IVODContentService ====
            movieRequest: function (opts) {
                opts = opts || {};

                var url = this.baseURL + "/movie",
                    ids = opts.id,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.id;
                }

                return this.request(url, opts, parameters);
            },
            movieByCategoryRequest: function (opts) {
                opts = opts || {};
                if (!opts.id) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided in OVP API"));
                }

                ax.util.extend(opts, {
                    objType: "movie"
                });
                return this.categoryRequest(opts);
            },
            tvShowRequest: function (opts) {
                opts = opts || {};
                var url = this.baseURL + "/tvshow",
                    ids = opts.id,
                    objType = opts.objType,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                if (ax.util.isBoolean(opts.showEpisodes)) {
                    parameters.episodes = opts.showEpisodes;
                }

                if (ax.util.isBoolean(opts.showTVSeasons)) {
                    parameters.seasons = opts.showTVSeasons;
                }

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.id;
                }

                if (objType) {
                    url += "/" + objType;
                    delete opts.objType;
                }

                return this.request(url, opts, parameters);
            },
            tvShowByCategoryRequest: function (opts) {
                opts = opts || {};
                if (!opts.id) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided in OVP API"));
                }
                ax.util.extend(opts, {
                    objType: "tvshow"
                });
                return this.categoryRequest(opts);
            },
            tvSeasonRequest: function (opts) {
                opts = opts || {};
                var url = this.baseURL + "/tvseason",
                    ids = opts.id,
                    objType = opts.objType,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                if (ax.util.isBoolean(opts.showEpisodes)) {
                    parameters.episodes = opts.showEpisodes;
                }

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.id;
                }

                if (objType) {
                    url += "/" + objType;
                    delete opts.objType;
                }

                return this.request(url, opts, parameters);
            },
            tvSeasonByTVShowRequest: function (opts) {
                ax.util.extend(opts, {
                    objType: "tvseason"
                });
                return this.tvShowRequest(opts);
            },
            episodeRequest: function (opts) {
                opts = opts || {};
                var url = this.baseURL + "/episode",
                    ids = opts.id,
                    // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                // by Ids
                if (ids) {
                    url += "/" + ids;
                    delete opts.id;
                }

                return this.request(url, opts, parameters);
            },
            episodeByTVShowRequest: function (opts) {
                ax.util.extend(opts, {
                    objType: "episode"
                });
                return this.tvShowRequest(opts);
            },
            episodeByTVSeasonRequest: function (opts) {
                ax.util.extend(opts, {
                    objType: "episode"
                });
                return this.tvSeasonRequest(opts);
            },
            vodSearchRequest: function (opts) {
                var url = this.baseURL + "/search",
                    type = opts.type,
                    parameters = parameters || {};

                url += "/" + type + "/" + opts.key;

                if (ax.util.isBoolean(opts.showEpisodes)) {
                    parameters.episodes = opts.showEpisodes;
                }

                if (ax.util.isBoolean(opts.showTVSeasons)) {
                    parameters.seasons = opts.showTVSeasons;
                }

                return this.request(url, opts, parameters);
            },
            request: function (url, opts, param) {
                opts = opts || {};
                param = param || {};

                var __opts,
                    __cacheHelper = this.cacheHelper,
                    cached_key = JSON.stringify({
                        "url": url,
                        "opts": opts,
                        "param": param
                    }),
                    cached_data = __cacheHelper.getCache(cached_key),
                    cached_since = 0;

                if (!ax.util.isUndefined(cached_data)) {
                    // if not expired, resolve with cache data
                    if (!__cacheHelper.isExpired(cached_key)) {
                        ax.promise.resolve(cached_data);
                    } else {
                        cached_since = __cacheHelper.getTimestamp(cached_key);
                    }
                }

                // put sortBy
                if (opts.sortingKey) {
                    param.sortBy = opts.sortingKey + "|" + (opts.sortingOrder ? opts.sortingOrder : SORTING.DESC);
                }

                // put pagination
                param.pageSize = opts.pageSize || 100;
                param.pageNumber = opts.pageNumber || 1;



                __opts = {
                    method: "get",
                    parameters: param
                };

                return ax.ajax.request(url, __opts).then(
                    function (transport) {
                        var responseJSON = null;

                        responseJSON = transport.responseJSON || JSON.parse(transport.responseText);
                        // save to cache
                        __cacheHelper.setObject(cached_key, responseJSON, +new Date());
                        return responseJSON;

                    },
                    function (reason) {
                        throw new TVEError(FACILITY.GENERAL, ERROR.NETWORK, reason.transport ? reason.transport.statusText : "network issue", reason);
                    });
            }
        },

        OvpService = ax.klass.create([VODContentService, LinearContentService], {
            /**
             * Sorting order
             * @name SORTING
             * @typedef {Object}
             * @property {String} ASC - sort ascending
             * @property {String} DESC - sort descending
             * @public
             * @memberof tve/AccedoOvpService
             * @static
             */
            SORTING: SORTING
        }, {
            /**
             * CachingHelper Instance, may be used for any OVP related service.
             * @member __cache
             * @memberof tve/AccedoOvpService#
             * @private
             */
            __cache: null,

            /**
             * Init the AccedoOvpService moudle
             * @method init
             * @memeberof tve/AccedoOvpService#
             * @private
             */
            init: function (opts) {
                if (opts && opts.baseURL) {
                    this.__cache = new CacheHelper();
                    ovpServiceApi.init(opts.baseURL, this.__cache);
                } else {
                    throw new TVEError(FACILITY.GENERAL, ERROR.INTERNAL, "no baseURL is provided, cannot init service");
                }
            },

            // ==== Impliment Interfaces ====

            // Private function

            /**
             * Get all Categories
             * @method getCategories
             * @public
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/name
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */

            getAllCategories: function (opts) {

                return ovpServiceApi.categoryRequest(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get Category By Id
             * @method getCategoryById
             * @public
             * @param {String} id CategoryID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/name
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} MediaCategory object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getCategoryById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.GENERAL, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return ovpServiceApi.categoryRequest(opts);
            },

            /**
             * Get Categories By Ids
             * @method getCategoriesByIds
             * @public
             * @param {String[]} ids CategoryIDs
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/name
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getCategoriesByIds: function (ids, opts) {
                if (!ids || !ax.util.isArray(ids)) {
                    return ax.promise.reject(new TVEError(FACILITY.GENERAL, ERROR.INTERNAL, "incorrect parameter type"));
                }
                opts = opts || {};
                opts.id = ids;

                return ovpServiceApi.categoryRequest(opts).then(function (json) {

                    return {
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },


            // ==== ILinearContentService ====

            // Private function
            __getChannel: function (opts) {

                if (opts && opts.categoryId) {
                    opts.id = opts.categoryId;
                    delete opts.categoryId;
                    return ovpServiceApi.channelByCategoryRequest(opts);
                } else {
                    return ovpServiceApi.channelRequest(opts);
                }

            },

            /**
             * Get all Channels
             * @method getAllChannels
             * @public
             * @param {Object} opts The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllChannels: function (opts) {
                return this.__getChannel(opts).then(function (json) {
                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get all permitted Channels
             * @method getPermittedChannels
             * @public
             * @param {Object} opts The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getPermittedChannels: function (opts) {
                return this.__getChannel(opts).then(function (json) {
                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get Channel by Id
             * @method getChannelById
             * @public
             * @param {String} id ChannelID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Channel object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getChannelById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return this.__getChannel(opts);
            },

            /**
             * Get Channels by Ids
             * @method getChannelsByIds
             * @public
             * @param {String[]} ids ChannelIDs
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getChannelsByIds: function (ids, opts) {
                if (!ids || !ax.util.isArray(ids)) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "incorrect parameter type"));
                }
                opts = opts || {};
                opts.id = ids;

                return this.__getChannel(opts).then(function (json) {
                    return {
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },

            /**
             * Get Channels by Category
             * @method getChannelsByCategoryId
             * @public
             * @param {String} categoryId CategoryID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getChannelsByCategoryId: function (categoryId, opts) {
                if (!categoryId) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no categoryId is provided"));
                }
                opts = opts || {};
                opts.categoryId = categoryId;

                return this.__getChannel(opts).then(function (json) {
                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get all ChannelListings
             * @method getAllChannelListings
             * @public
             * @param {String} startTime startTime
             * @param {String} endTime endTime
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelId
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllChannelListings: function (startTime, endTime, opts) {

                if (!startTime || !endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided"));
                }
                opts = opts || {};
                opts.startTime = startTime;
                opts.endTime = endTime;

                return ovpServiceApi.channelListingRequest(opts).then(function (json) {
                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get ChannelListing by channel Id
             * @method getChannelListingByChannelId
             * @public
             * @param {String} channelId ChannelID
             * @param {String} startTime startTime
             * @param {String} endTime endTime
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelId
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} ChannelListing object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getChannelListingByChannelId: function (channelId, startTime, endTime, opts) {
                if (!channelId) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no channelId is provided"));
                }
                if (!startTime || !endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided"));
                }
                opts = opts || {};
                opts.channelId = channelId;
                opts.startTime = startTime;
                opts.endTime = endTime;

                return ovpServiceApi.channelListingRequest(opts);
            },

            /**
             * Get ChannelListing by channel Ids
             * @method getChannelListingsByChannelIds
             * @public
             * @param {String[]} channelIds ChannelIDs
             * @param {String} startTime startTime
             * @param {String} endTime endTime
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelId
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getChannelListingsByChannelIds: function (channelIds, startTime, endTime, opts) {
                if (!channelIds) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no channelIds are provided"));
                }
                if (!startTime || !endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided"));
                }
                opts = opts || {};
                opts.channelId = channelIds;
                opts.startTime = startTime;
                opts.endTime = endTime;

                return ovpServiceApi.channelListingRequest(opts).then(function (json) {
                    return {
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },

            // ==== IVODContentService ====

            // Private functions
            __getMovie: function (opts) {

                if (opts && opts.categoryId) {
                    opts.id = opts.categoryId;
                    delete opts.categoryId;
                    return ovpServiceApi.movieByCategoryRequest(opts);
                } else {
                    return ovpServiceApi.movieRequest(opts);
                }

            },

            __getTVShow: function (opts) {
                var __opts = {
                    showTVSeasons: true,
                    showEpisodes: true
                };

                __opts = ax.util.extend(__opts, opts, true);

                if (__opts && __opts.categoryId) {
                    __opts.id = __opts.categoryId;
                    delete __opts.categoryId;
                    return ovpServiceApi.tvShowByCategoryRequest(__opts);
                } else {
                    return ovpServiceApi.tvShowRequest(__opts);
                }

            },

            __getTVSeason: function (opts) {
                var __opts = {
                    showEpisodes: true
                };

                __opts = ax.util.extend(__opts, opts, true);

                if (__opts && __opts.showId) {
                    __opts.id = __opts.showId;
                    delete __opts.showId;
                    return ovpServiceApi.tvSeasonByTVShowRequest(__opts);
                } else {
                    return ovpServiceApi.tvSeasonRequest(__opts);
                }

            },

            __getEpisode: function (opts) {

                if (opts && opts.showId) {
                    opts.id = opts.showId;
                    delete opts.showId;
                    return ovpServiceApi.episodeByTVShowRequest(opts);
                } else if (opts && opts.seasonId) {
                    opts.id = opts.seasonId;
                    delete opts.seasonId;
                    return ovpServiceApi.episodeByTVSeasonRequest(opts);
                } else {
                    return ovpServiceApi.episodeRequest(opts);
                }
            },

            /**
             * Get all Movies
             * @method getAllMovies
             * @public
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllMovies: function (opts) {

                return this.__getMovie(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get Movie by Id
             * @method getMovieById
             * @public
             * @param {String} id MovieID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Asset object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getMovieById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return this.__getMovie(opts);
            },

            /**
             * Get Movies by Ids
             * @method getMoviesByIds
             * @public
             * @param {String[]} ids MovieIDs
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getMoviesByIds: function (ids, opts) {
                if (!ids || !ax.util.isArray(ids)) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "incorrect parameter type"));
                }
                opts = opts || {};
                opts.id = ids;

                return this.__getMovie(opts).then(function (json) {

                    return {
                        // in case of only one object, set all other attribues as 1
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },


            /**
             * Get Movies by category
             * @method getMoviesByCategoryId
             * @public
             * @param {String} categoryId CategoryID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getMoviesByCategoryId: function (categoryId, opts) {
                if (!categoryId) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no categoryId is provided"));
                }
                opts = opts || {};
                opts.categoryId = categoryId;

                return this.__getMovie(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Search movies by keyword
             * @method searchMovies
             * @public
             * @param {String[]} key the keyword
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            searchMovies: function (key, opts) {
                if (!key) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no keyword is provided"));
                }
                opts = opts || {};
                opts.type = "movie";
                opts.key = key;

                return ovpServiceApi.vodSearchRequest(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get all TV Shows
             * @method getAllTVShows
             * @public
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @param {String} [opts.showTVSeasons] flag to show tv seasons in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllTVShows: function (opts) {

                return this.__getTVShow(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get TV Show by Id
             * @method getTVShowById
             * @public
             * @param {String} id TVShowID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @param {String} [opts.showTVSeasons] flag to show tv seasons in return
             * @returns {Promise.<Object>} Asset object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getTVShowById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return this.__getTVShow(opts);
            },

            /**
             * Get TV Shows by Ids
             * @method getTVShowsByIds
             * @public
             * @param {String[]} ids TVShowIDs
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @param {String} [opts.showTVSeasons] flag to show tv seasons in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getTVShowsByIds: function (ids, opts) {
                if (!ids || !ax.util.isArray(ids)) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "incorrect parameter type"));
                }
                opts = opts || {};
                opts.id = ids;

                return this.__getTVShow(opts).then(function (json) {

                    return {
                        // in case of only one object, set all other attribues as 1
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },

            /**
             * Get TV Shows by category
             * @method getTVShowsByCategoryId
             * @public
             * @param {String} categoryId CategoryID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @param {String} [opts.showTVSeasons] flag to show tv seasons in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getTVShowsByCategoryId: function (categoryId, opts) {
                if (!categoryId) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no categoryId is provided"));
                }
                opts = opts || {};
                opts.categoryId = categoryId;

                return this.__getTVShow(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Search TV shows by keyword
             * @method searchTVShows
             * @public
             * @param {String[]} key the keyword
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @param {String} [opts.showTVSeasons] flag to show tv seasons in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            searchTVShows: function (key, opts) {
                if (!key) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no keyword is provided"));
                }
                opts = opts || {};
                opts.showTVSeasons = true;
                opts.showEpisodes = true;
                opts.type = "tvshow";
                opts.key = key;

                return ovpServiceApi.vodSearchRequest(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get all TV Seasons
             * @method getAllTVSeasons
             * @public
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllTVSeasons: function (opts) {

                return this.__getTVSeason(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get TV season by Id
             * @method getTVSeasonById
             * @public
             * @param {String} id TV Season ID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @returns {Promise.<Object>} Asset object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getTVSeasonById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return this.__getTVSeason(opts);
            },

            /**
             * Get TV Seasons by Ids
             * @method getTVSeasonsByIds
             * @public
             * @param {String[]} ids TV Season IDs
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getTVSeasonsByIds: function (ids, opts) {
                if (!ids || !ax.util.isArray(ids)) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "incorrect parameter type"));
                }
                opts = opts || {};
                opts.id = ids;

                return this.__getTVSeason(opts).then(function (json) {

                    return {
                        // in case of only one object, set all other attribues as 1
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },

            /**
             * Get TV seasons by TV show Id
             * @method getTVSeasonsByTVShowId
             * @public
             * @param {String} showId TV Show ID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @returns {Promise.<Object>} Asset object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getTVSeasonsByTVShowId: function (showId, opts) {
                if (!showId) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no showId is provided"));
                }
                opts = opts || {};
                opts.showId = showId;

                return this.__getTVSeason(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Search TV seasons by keyword
             * @method searchTVSeasons
             * @public
             * @param {String[]} key the keyword
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @param {String} [opts.showEpisodes] flag to show episodes in return
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            searchTVSeasons: function (key, opts) {
                if (!key) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no keyword is provided"));
                }
                opts = opts || {};
                opts.type = "tvseason";
                opts.key = key;

                return ovpServiceApi.vodSearchRequest(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get all Episodes
             * @method getAllEpisodes
             * @public
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllEpisodes: function (opts) {

                return this.__getEpisode(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get Episodes by Id
             * @method getEpisodeById
             * @public
             * @param {String} id EpisodeID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Asset object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getEpisodeById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return this.__getEpisode(opts);
            },

            /**
             * Get Episodes by TVShow Id
             * @method getEpisodesByTVShowId
             * @public
             * @param {String} showId showID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getEpisodesByTVShowId: function (showId, opts) {
                if (!showId) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no showId is provided"));
                }
                opts = opts || {};
                opts.showId = showId;

                return this.__getEpisode(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get Episodes by TVSeason Id
             * @method getEpisodesByTVSeasonId
             * @public
             * @param {String} seasonId seasonId
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate/tvShowId/tvShowTitle
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getEpisodesByTVSeasonId: function (seasonId, opts) {
                if (!seasonId) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no seasonId is provided"));
                }
                opts = opts || {};
                opts.seasonId = seasonId;

                return this.__getEpisode(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Search episodes by keyword
             * @method searchEpisodes
             * @public
             * @param {String[]} key the keyword
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/title/publishedDate/availableDate
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            searchEpisodes: function (key, opts) {
                if (!key) {
                    return ax.promise.reject(new TVEError(FACILITY.VOD_CONTENT_SERVICE, ERROR.INTERNAL, "no keyword is provided"));
                }
                opts = opts || {};
                opts.type = "episode";
                opts.key = key;

                return ovpServiceApi.vodSearchRequest(opts).then(function (json) {

                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            }
        });

    return OvpService;
});
/**
 * Datasouce class, acts as an abstraction of back-end data.
/**
 * @class xdk-ax/data/interface/Datasource
 */
define("xdk-ax/data/interface/Datasource", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    var IDatasource = Interface.create("Datasource", {
        /**
         * Return the total count of the back-end data. It will be -1 before setTotalCount.
         * @method
         * @returns {Number} total count of the data
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        getTotalCount: [],
        /**
         * Set the total count of the back-end data.
         * @method
         * @param {Number} count total count of the data
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        setTotalCount: ["count"],
        /**
         * Checks if data of specific index exists
         * @method
         * @param {Number} from index of the data to check
         * @param {Number} [to] the end index of the data to check exclusively
         * @returns {Boolean} if it exists
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        hasData: ["from", "to"],
        /**
         * Get a range of data.
         * @method
         * @param {Number} from from index
         * @param {Number} to toindex exclusively.
         * @returns {Promise.<Object[]>} the data in range
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        getRange: ["from", "to"],
        /**
         * Data loader function provided by developer
         * @method loaderFn
         * @param {Number} from the from index that want to be laoded
         * @param {Number} size the length of the data to be loaded from the start index
         * @returns {Promise} Return a promise object. Return resolved promise with the data when the data is ready.
         * @memberof xdk-ax/data/interface/Datasource
         * @protected
         */
        /**
         * Sets the data loader function. Must be called before any data can retrieved.
         * @method setDataLoader
         * @see {@link xdk-ax/data/interface/Datasource.loaderFn}
         * @param {Function} loaderFn the data loader function.
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        setDataLoader: ["loaderFn"],
        /**
         * Data updater function provided by developer
         * @method updaterFn
         * @param {String} action Action: insert|remove
         * @param {Object} [opts] Optional data
         * @param {Number} [opts.from] retrieve data from this index
         * @param {Number} [opts.to] retrieve data to this index
         * @param {Object[]} [opts.newData] new Data object array
         * @param {Number} [opts.size] data size to retrieve.
         *    It is ok to provide data amount less than this number.
         * @returns {Promise} Return a promise object
         *    takes parameters of reteived data in array, and an optional total data count
         * @memberof xdk-ax/data/interface/Datasource
         */
        /**
         * Sets the data loader function. Must be called before any data can retrieved.
         * @method setDataUpdater
         * @see {@link xdk-ax/data/interface/Datasource.updaterFn}
         * @param {Function} updaterFn the data loader function.
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        setDataUpdater: ["updaterFn"],
        /**
         * Fetch a number of data into datasource, regardless whether data is loaded before
         * Emits an update event with "action" property equals to IDatasource.ACTION.FETCH
         * @method
         * @param {Number} [from] the index to start fetching
         * @param {Number} [size] the size to fetch
         * @public
         * @memberof xdk-ax/data/interface/Datasource
         */
        fetch: ["from", "size"],
        /**
         * Remove a range of items from the current data fetched. If the totalcount is not set, it is unable to remove.
         * Emits an update event with "action" property equals to IDatasource.ACTION.REMOVE
         * @method
         * @param {Number} from starting index of items to be removed (0-th indexed)
         * @param {Number} [to] end index of items to be removed, removes only one item is not provided
         * @memberof xdk-ax/data/interface/Datasource
         * @returns {Promise.<Undefined>} no actual return value
         * @throws {Promise.<Object>} XDK custom exception
         * @public
         */
        remove: ["from", "to"],
        /**
         * Insert an array of data into currently fetch data. If the totalcount is not set, it is unable to insert.
         * Emits an update event with "action" property equals to IDatasource.ACTION.INSERT
         * @method
         * @param {Array} newData An array of items to be inserted
         * @param {Number} [index] position of the insertion
         * @returns {Promise.<Undefined>} no actual return value
         * @throws {Promise.<Object>} XDK custom exception
         * @memberof xdk-ax/data/interface/Datasource
         * @public
         */
        insert: ["newData", "index"],
        /**
         * Removes all data and resets this datasource.
         * Emits an update event with "action" property equals to IDatasource.ACTION.RESET
         * @method
         * @memberof xdk-ax/data/interface/Datasource
         */
        reset: []
    });

    /**
     * Collection of the datasource update action
     * To provide the possible action for the datasource event udpate
     * @enum {String}
     * @memberof xdk-ax/data/interface/Datasource
     */
    IDatasource.ACTION = {
        /** Data insert */
        INSERT: "insert",
        /** Data remove */
        REMOVE: "remove",
        /** Data fetch */
        FETCH: "fetch",
        /** Data reset */
        RESET: "reset"
    };

    return IDatasource;
});
/**
 * Datasouce class, acts as an abstraction of back-end data.
 *
 * __Data loader__
 * To fetch the data, a data loader should be set in prior.
 * Data loader is basically a function that converts the response from the back-end API to a set of application data that will be used by the front-end.
 * A valid data loader accepts 2 numeric arguments (from, size), and returns a promise, which will return a {@link LoadedData} object when resolved.
 * The data loader is designed to fit the API with interfaces like (using RESTful API as an example) /movies?startIndex=0&endIndex=19 or /movies?from=0&to=19 or equivalent, where the range can be determined by _from_ and _size_ using simple arithmetic.
 * For API that applies pagination (e.g. /movies?page=1&pageSize=50), you are suggested to use {@link xdk-ax/data/PaginatedDatasource|PaginatedDatasource}.
 *
 *
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @class xdk-ax/data/Datasource
 * @param {Object} [opts] Options object
 * @example
 * var ds = new Datasource(),
 *     dataLoader = function(from, size) { // a data loader example
 *         // send ajax request to the back-end API
 *         return ajax.request("http://back-end.api/data?startIndex=" + from + "&endIndex=" + (from + size))
 *             .then(function (transport) {
 *                 // parse the response object, return the LoadedData
 *                 var response = transport.responseJSON,
 *                     dataArr = response.entries,
 *                     totalCount = response.totalCount;
 *
 *                 return {
 *                     data: dataArr,
 *                     total: totalCount
 *                 };
 *             });
 *     };
 *
 * ds.setDataLoader(dataLoader);
 *
 * // fetch data
 * ds.getRange(0, 19)
 *     .then(function (data) {
 *         console.log(data);
 *     }).done();
 */
/**
 * The return type of the data loader.
 * @typedef {Object} LoadedData
 * @property {Object[]} data The actual data entries
 * @property {Number} total The total number of items available in the DS
 */
define("xdk-ax/data/Datasource", ["xdk-base/class", "xdk-base/EventDispatcher", "xdk-base/core", "xdk-base/util", "xdk-base/promise", "xdk-base/console", "xdk-base/exception", "xdk-ax/data/interface/Datasource"], function (klass, EvtDisp, core, util, promise, console, exception, IDatasource) {
    "use strict";
    return klass.create(EvtDisp, [IDatasource], {
        /**
         * Dispatched when datasource update
         * @event
         * @type {Object}
         * @property {String} action which dispatch
         * @memberof xdk-ax/data/Datasource
         */
        EVT_UPDATED: "ui:ds:updated"
    }, {
        /**
         * Minimun size of each data fetch
         * @memberof xdk-ax/data/Datasource#
         * @private
         * @deprecated since 2.2
         */
        __minFetchSize: 1,
        /**
         * Total number of items available.
         * @memberof xdk-ax/data/Datasource#
         * @protected
         */
        _totalCount: -1,
        /**
         * Data loader function provided by developer
         * @param {Number} from the from index that want to be laoded
         * @param {Number} size the length of the data to be loaded from the start index
         * @returns {Promise} Return a promise object. Return resolved promise with the data when the data is ready.
         * @memberof xdk-ax/data/Datasource#
         * @protected
         */
        _dataLoader: null,
        /**
         * Data updater function provided by developer
         * @param {String} action Action:  xdk-ax/data/interface/Datasource.ACTION.INSERT | xdk-ax/data/interface/Datasource.ACTION.REMOVE
         * @param {Object} [opts] Optional data
         * @param {Number} [opts.from] retrieve data from this index
         * @param {Number} [opts.to] retrieve data to this index
         * @param {Object[]} [opts.newData] new Data object array
         * @param {Number} [opts.size] data size to retrieve.
         *    It is ok to provide data amount less than this number.
         * @returns {Promise} Return a promise object
         *    takes parameters of reteived data in array, and an optional total data count
         * @memberof xdk-ax/data/Datasource#
         * @protected
         * @example
         * //action remove should return removedData and optional totalCount
         *      deferred.resolve({
         *            removedData: removedData,
         *             totalCount: self._totalCount - removedData.length
         *      });
         *
         * //action insert should return optional totalCount
         *      deferred.resolve({
         *           totalCount: self._totalCount + newData.length
         *      });
         */
        _dataUpdater: null,

        /**
         * Already fetched data
         * @memberof xdk-ax/data/Datasource#
         * @protected
         */
        _data: [],
        /**
         * Keep tracking on the current data inside the _data. It will store the start and end index (range) that current obtained.
         * @memberof xdk-ax/data/Datasource#
         * @example
         * //a sample with size 100 and 3 fragments of data
         * //each fragment will have four properties
         * //start - the start dsIndex in the this._data array of the current fragment
         * //end   - the end dsIndex in the this._data array of the current fragment inclusively
         * //prev  - the previous fragment end Index, -1 when it is the first one
         * //next  - the next fragment start index when it is last one
         * [
         *      {
         *          start:10,
         *           end: 20,
         *           prev:-1,
         *           next:35
         *       },{
         *          start:35,
         *          end:50,
         *          prev:20,
         *          next:80
         *       },{
         *          start:80,
         *          end:99,
         *          prev:50,
         *          next:-1
         *       }
         * ]
         * @protected
         */
        __dataObjArray: [],
        /**
         * Return the total count of the back-end data. It will be -1 before setTotalCount manually.
         * @method
         * @returns {Number} total count of the data
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        getTotalCount: function () {
            return this._totalCount;
        },
        /**
         * Set the total count of the back-end data.
         * @method
         * @param {Number} count total count of the data
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        setTotalCount: function (count) {

            var totalCount = this._totalCount;

            this._totalCount = count;

            //to create when the count is not initialized
            if (totalCount === -1) {
                this._data = new Array(count);
                return;
            }

            //XDK-1953 change total count
            //to add more data if there is not enough space in data array
            if (totalCount < count) {
                //to add new array item at the end
                this._data = this._data.concat(new Array(count - totalCount));
                return;
            }

            //to splice the extra data
            if (this._data.length > count) {
                this._data.splice(count, this._data.length - count);
                return;
            }


        },
        /**
         * Set minimun fetch size. This size is the minimun amount of data any load will get.
         * @method
         * @param {Number} size the minimun fetch size
         * @public
         * @deprecated since 2.2
         * @memberof xdk-ax/data/Datasource#
         */
        setMinFetchSize: function (size) {
            this.__minFetchSize = size;
        },
        /**
         * Get minimun fetch size. This size is the minimun amount of data any fetch will get.
         * @method
         * @returns {Number} the minimun fetch size
         * @public
         * @deprecated since 2.2
         * @memberof xdk-ax/data/Datasource#
         */
        getMinFetchSize: function () {
            return this.__minFetchSize;
        },
        /**
         * Checks if data of specific index exists
         * @method
         * @param {Number} from index of the data to check
         * @param {Number} [to] the end index of the data to check exclusively
         * @returns {Boolean} if it exists
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        hasData: function (from, to) {
            var ret = true;

            if (from < 0 || from >= this.getTotalCount() || to < 0 || to > this.getTotalCount()) {
                ret = false;
            }

            ret = this.__hasFetchedData(from, to);

            return ret;
        },
        /**
         * Get a range of data.
         * @method
         * @param {Number} from from index
         * @param {Number} to to index exclusively. If it is undefined and total count is set, all the data from index will be obtained.
         * @returns {Promise.<Object[]>} the data in range
         * @throws {Promise.<exception>} Incorrect Param from/to . From index should be less than the to index. And when total count is not set, only from index 0 is allowed.
         * @throws {Promise.<exception>} Incorrect State when total count is not set.
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        getRange: function (from, to) {
            var totalCount = this.getTotalCount(),
                self = this,
                newRange = [],
                i, getRangePromise;

            if (util.isUndefined(to)) {
                to = this.getTotalCount();
            }

            //if the from is larger than 0, the total count should set at the beginning.
            if (from < 0 || from >= to || (from > 0 && to === -1)) {
                return promise.reject(core.createException("IncorrectParam", "Incorrect \"from\" or \"to\" parameter!"));
            }

            //if the from is larger than the total count where no more data is available
            if (totalCount !== -1 && from >= totalCount) {
                return promise.reject(core.createException("IncorrectState", "No more data available!"));
            }

            //the first checking

            newRange = this.__checkFetchedData(from, to);

            //if all the data are existed then return directly
            if (newRange.length === 0) {
                return promise.resolve(this.__getFetchedData(from, to));
            }

            //create a promise which store for each range, it will fetch range by range
            getRangePromise = promise.resolve();

            for (i = 0; i < newRange.length; i++) {

                getRangePromise = getRangePromise.then(util.bind(function (fromIndex, toIndex) {
                    var actualFrom, fetchSize;

                    //to prevent the data is already included into previous load
                    if (self.hasData(fromIndex, toIndex)) {
                        return promise.resolve();
                    }

                    actualFrom = fromIndex;
                    fetchSize = toIndex - actualFrom;

                    //to load the data
                    return self._load(actualFrom, fetchSize);

                }, null, newRange[i].from, newRange[i].to));

            }

            return getRangePromise.then(function () {
                //after loaded all data, get back all the data
                return self.__getFetchedData(from, to);
            });

        },
        /**
         * Sets the data loader function. Must be called before any data can retrieved.
         * @method
         * @see {@link xdk-ax/data/Datasource#_dataLoader}
         * @param {Function} loaderFn the data loader function.
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        setDataLoader: function (loaderFn) {
            this._dataLoader = loaderFn;
        },

        /**
         * Sets the data loader function. Must be called before any data can retrieved.
         * @method
         * @see {@link xdk-ax/data/Datasource#_dataLoader}
         * @param {Function} loaderFn the data loader function.
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        setDataUpdater: function (updaterFn) {
            this._dataUpdater = updaterFn;
        },
        /**
         * Fetch a number of data into datasource, regardless whether data is loaded before
         * Emits an update event with "action" property equals to xdk-ax/data/interface/Datasource.ACTION.FETCH
         * @method
         * @param {Number} [from] the index to start fetching
         * @param {Number} [size] the size to fetch
         * @public
         * @memberof xdk-ax/data/Datasource#
         */
        fetch: function (from, size) {

            return this._load(from, size).then(util.bind(function (dataArray) {
                //dispatches updated assuming data is updated from source
                this.dispatchEvent(this.constructor.EVT_UPDATED, {
                    action: IDatasource.ACTION.FETCH,
                    newData: dataArray,
                    index: from,
                    length: dataArray.length
                });
            }, this));

        },
        /**
         * Internal method to load data into datasource using data loader.
         * @method
         * @param {Number} startIndex the start index of fetching
         * @param {Number} requestedSize the original size to requested fetch
         * @param {Array} dataArray the fecthed data in an array
         * @param {Number} totalCount total count of the back-end data
         * @returns {Promise.<Object[]>} the data array
         * @throws {Promise.<Mixed>} the reason why the dataLoader fails. The actual type is defined in the user-defined dataLoader.
         * @protected
         * @memberof xdk-ax/data/Datasource#
         */
        _load: function (from, size) {
            var originalSize = size,
                totalCount = this.getTotalCount(),
                fetchOpts;

            from = from || 0;

            size = size || 0;

            //update the size
            if (size < this.__minFetchSize) {

                size = this.__minFetchSize;

                //to prevent the size is over the total count
                if (totalCount !== -1 && from + size > totalCount) {
                    size = totalCount - from;
                }


                //to prevent the additional data is already loaded after updated the size, so keep the original size
                if (this.hasData(from + originalSize, from + size)) {
                    size = originalSize;
                }
            }


            fetchOpts = {
                from: from,
                size: size
            };

            return this._dataLoader(from, size)
                .then(util.bind(this._processFetchedData, this, fetchOpts));
        },
        /**
         * Process the data fetched by the data loader.
         * This includes setting the DS total count, setting the data into the internal data array.
         * Finally the required data will be returned.
         * @method
         * @protected
         * @param {Object} fetchOpts The options for the fetch operation
         * @param {Number} fetchOpts.from The from index of the data fetched
         * @param {Number} fetchOpts.size The expected number of items fetched
         * @param {Object} loadedObj The object consists of the loaded data, total count, and the optional from index
         * @returns {Object[]} The required data
         * @memberof xdk-ax/data/Datasource#
         */
        _processFetchedData: function (fetchOpts, loadedObj) {
            var dataArray = loadedObj.data,
                totalCount = loadedObj.total,
                from = fetchOpts.from,
                newFrom = from;

            // set the total count if available
            if (util.isNumber(totalCount)) {
                this.setTotalCount(totalCount);
            }

            // set the new from index
            if (util.isNumber(loadedObj.from)) {
                newFrom = loadedObj.from;
            }

            // ensure we have an array as argument
            if (!dataArray) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "Data is missing");
            }

            if (!util.isArray(dataArray)) {
                dataArray = [dataArray];
            }

            // save the data
            this.__setFetchedData(newFrom, dataArray);

            // return the dataArray
            return this.__getFetchedData(from, from + fetchOpts.size);
        },

        /**
         * Remove a range of items from the current data fetched. If the totalcount is not set, it is unable to remove.
         * Emits an update event with "action" property equals to xdk-ax/data/interface/Datasource.ACTION.REMOVE
         * @method
         * @param {Number} from starting index of items to be removed (0-th indexed)
         * @param {Number} [to] end index of items to be removed, removes only one item is not provided
         * @memberof xdk-ax/data/Datasource#
         * @returns {Promise.<Undefined>} no actual return value
         * @throws {Promise.<Object>} XDK custom exception
         * @public
         */
        remove: function (from, to) {

            if (!util.isNumber(from)) {
                return promise.reject(core.createException("Invalid param"));
            }

            if (!util.isNumber(to)) {
                to = from + 1;
            }

            if (!util.isFunction(this._dataUpdater)) {
                return promise.reject(core.createException("Datasource: invalid data updater function."));
            }

            return this._dataUpdater(IDatasource.ACTION.REMOVE, {
                from: from,
                to: to
            }).then(util.bind(function (removedObj) {

                if (!removedObj) {
                    return promise.reject(core.createException("Datasource: invalid data update via remove: no removed data received"));
                }

                var updatedFrom = removedObj.from,
                    updatedTo = removedObj.to,
                    removedData = [];


                if (util.isNumber(updatedFrom)) {
                    removedData = this.__removeFetchedData(updatedFrom, updatedTo);
                }

                //emit event
                this.dispatchEvent(this.constructor.EVT_UPDATED, {
                    action: IDatasource.ACTION.REMOVE,
                    index: updatedFrom,
                    length: removedData.length,
                    removedData: removedData
                });

            }, this));

        },
        /**
         * Insert an array of data into currently fetch data. If the totalcount is not set, it is unable to insert.
         * Emits an update event with "action" property equals to xdk-ax/data/interface/Datasource.ACTION.INSERT
         * @method
         * @param {Array} newData An array of items to be inserted
         * @param {Number} [index] position of the insertion
         * @returns {Promise.<Undefined>} no actual return value
         * @throws {Promise.<Object>} XDK custom exception
         * @memberof xdk-ax/data/Datasource#
         * @public
         */
        insert: function (newData, index) {

            if (!util.isArray(newData)) {
                newData = [newData];
            }

            if (!util.isNumber(index)) {
                index = this.getTotalCount();
            }

            if (!util.isFunction(this._dataUpdater)) {
                return promise.reject(core.createException("Datasource: invalid data updater function."));
            }

            return this._dataUpdater(IDatasource.ACTION.INSERT, {
                newData: newData,
                from: index
            }).then(util.bind(function (insertedObj) {

                if (!insertedObj) {
                    throw core.createException("Datasource: invalid data update via insert: no new data received");
                }

                var updatedData = insertedObj.newData,
                    updatedIndex = insertedObj.index;

                if (util.isArray(updatedData)) {
                    this.__insertFetchedData(updatedIndex, updatedData);
                }

                // emit event
                this.dispatchEvent(this.constructor.EVT_UPDATED, {
                    action: IDatasource.ACTION.INSERT,
                    index: updatedIndex,
                    length: updatedData.length,
                    newData: updatedData
                });

            }, this));

        },
        /**
         * Return the number of elements currently in the datasource
         * @method
         * @returns {Number} Current fetched size
         * @memberof xdk-ax/data/Datasource#
         * @depracted The latest version support fragments in datasource which may contain fragments (undefined items)
         * so it will return an array with respect to the datasource total count.
         * If developer want to keep track on the fetched count in datasource with fragments,
         * developers are suggested to count the size in the dataloader on the number of fetched items.
         */
        getFetchedCount: function () {
            return this._data.length;
        },
        /**
         * Return object of fetched data in the datasource
         * @method getFetchedData
         * @param {Number} index the index of data
         * @returns {Object} required data object
         * @memberof xdk-ax/data/Datasource#
         * @depracted The latest version support fragments in datasource which may contain fragments (undefined items)
         * so it may return an array that data between fragments with undefined value. Developer are suggested to use the getRange to obtain
         * the data. It will return the fetched Data directly if they are existed and send message to dataLoader if the current data is not enough.
         * @public
         */
        getFetchedData: function (index) {
            if (index < 0 || index >= this._data.length) {
                return null;
            }

            return this._data[index];
        },
        /**
         * Return array of fetched data in the datasource
         * @method getAllFetchedData
         * @returns {Array} object array of the data
         * @memberof xdk-ax/data/Datasource#
         * @deprecated since developers are suggested to use the getRange function to obtain the data.
         * It will return the fetched Data directly and send message to dataLoader if the specific data is not enough.
         * Now it will return the whole array that may contain undefined if items are between the fragments.
         * @public
         */
        getAllFetchedData: function () {
            return this._data;
        },
        /**
         * Removes all data and resets this datasource.
         * Emits an update event with "action" property equals to xdk-ax/data/interface/Datasource.ACTION.RESET
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        reset: function () {
            this.__minFetchSize = 1;

            this._data.length = 0; //Array of loaded data objects

            this.__dataObjArray.length = 0; //Array of dataset objects 

            this._totalCount = -1; //to reset the total Count

            //to notify 3rd party the ds is emptied,

            this.dispatchEvent(this.constructor.EVT_UPDATED, {
                action: IDatasource.ACTION.RESET
            });
        },
        /**
         * remove the from into the datasource
         * @private
         * @param {Number} from the startIndex to insert or update to the datasource
         * @param {Number} [to] the endIndex exclusively. Default will be the index of (from + 1) and assume one data is removed.
         * @returns {Array} the removed item
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        __removeFetchedData: function (from, to) {

            var removeList = [], //to store the dataset which will be delete soon
                removeStart = from,
                removeEnd = from, //inclusively,that it may equal with start
                removeSize,
                updatedNextDataObj = false,
                removedData = false,
                totalDataSet = this.__dataObjArray.length;

            //to set back to be from  and to should be larger than 0
            if (util.isNumber(removeEnd) && to > 0) {
                removeEnd = to - 1;
            }

            //removeSize 
            removeSize = removeEnd - removeStart + 1;

            util.each(this.__dataObjArray, util.bind(function (curDataSet, curArrIndex) {

                //just update the offset for the data behind
                //remove range is completely before the current range
                if ((removedData && removeEnd < curDataSet.start) || (removeEnd < curDataSet.start && removeStart < curDataSet.start)) {

                    curDataSet.start -= removeSize;
                    curDataSet.end -= removeSize;

                    if (curArrIndex < totalDataSet - 1) {
                        curDataSet.next -= removeSize;
                    } else {
                        curDataSet.next = -1;
                    }

                    //no need to update the prev index since there is no change
                    if (!updatedNextDataObj) {
                        updatedNextDataObj = true;
                        return;
                    }

                    if (curArrIndex > 0) {
                        curDataSet.prev -= removeSize;
                    } else {
                        curDataSet.prev = -1;
                    }

                    return;
                }

                //do nothing since not in the range and then continue with the next one
                if (removeStart > curDataSet.end) {

                    //if it is inside the gap between the fragments, the current dataset next is needed to update.
                    if (curDataSet.next > removeEnd) {
                        curDataSet.next -= removeSize;
                    }
                    return;
                }

                //the remove range is completely inside the cur data set 
                if (removeStart >= curDataSet.start && removeStart <= curDataSet.end && removeEnd >= curDataSet.start && removeEnd <= curDataSet.end) {
                    curDataSet.end -= removeSize;
                    removedData = true;
                    console.debug("remove dataset completely inside the cur data set " + removeStart);
                    return;
                }

                //the whole range is inside the remove range and then those data are put in the removeList
                if (removeStart <= curDataSet.start && curDataSet.end <= removeEnd) {

                    removeList.push(curArrIndex);

                    //update the relationship
                    if (curArrIndex > 0) {
                        this.__dataObjArray[curArrIndex - 1].next = curDataSet.next - removeSize;
                    } else {
                        this.__dataObjArray[curArrIndex].next = -1;
                    }

                    if (curArrIndex < totalDataSet - 1) {
                        this.__dataObjArray[curArrIndex + 1].prev = curDataSet.prev;
                    } else {
                        this.__dataObjArray[curArrIndex].prev = -1;
                    }

                    removedData = true;
                    console.debug("remove dataset completely cover the cur data set " + removeStart);
                    return;
                }

                //if only startIndex inside the range, then update the size of start
                if (removeStart < curDataSet.start && curDataSet.start <= removeEnd) {

                    curDataSet.start = removeStart;
                    curDataSet.end -= removeSize;

                    if (curArrIndex > 0) {
                        this.__dataObjArray[curArrIndex - 1].next = curDataSet.start;
                    } else {
                        curDataSet.prev = -1;
                    }

                    if (curArrIndex < totalDataSet - 1) {
                        this.__dataObjArray[curArrIndex + 1].prev = curDataSet.end;
                    } else {
                        curDataSet.next = -1;
                    }

                    removedData = true;

                    //check if need to merge them together
                    if (curArrIndex > 0 && curDataSet.prev !== -1 && curDataSet.prev + 1 === curDataSet.start) {

                        this.__dataObjArray[curArrIndex - 1].end = curDataSet.end;
                        this.__dataObjArray[curArrIndex - 1].next = curDataSet.next;

                        removeList.push(curArrIndex);
                    }

                    console.debug("remove dataset overlap with the cur data set startIndex " + removeStart);
                    return;
                }

                //if only endIndex inside the range, then update the size of end to "from"
                if (removeStart > curDataSet.start && curDataSet.end <= removeEnd) {

                    curDataSet.end = removeStart - 1;

                    if (curArrIndex < totalDataSet - 1) {
                        this.__dataObjArray[curArrIndex + 1].prev = curDataSet.end;
                    } else {
                        this.__dataObjArray[curArrIndex].prev = -1;
                    }

                    removedData = true;

                    console.debug("remove dataset overlap with the cur data set endIndex" + removeStart);
                    return;
                }

            }, this));

            //remove the item from list
            util.each(removeList, util.bind(function (targetIndex, removeArrIndex) {
                this.__dataObjArray.splice(targetIndex - removeArrIndex, 1);
            }, this));

            //udpate the totalcount by remove directly
            this._totalCount -= removeSize;

            //remove the data from the array
            return this._data.splice(removeStart, removeSize);
        },
        /**
         * insert the data into the datasource
         * @private
         * @param {Number} index the startIndex to insert or update to the datasource
         * @param {Array} data the data needed to insert
         * @returns {xdk-ax/data/Datasource} datasource itself
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        __insertFetchedData: function (index, data) {

            var insertPos = -1, //to store the dataset which will be delete soon
                insertStart = index,
                insertSize = data.length,
                insertEnd = insertStart + insertSize - 1, //inclusively,that it may equal with start
                updatedNextDataObj = false,
                insertedData = false,
                totalDataSet = this.__dataObjArray.length,
                newDataSet;

            //first case
            if (this.__dataObjArray.length === 0) {
                newDataSet = {
                    prev: -1,
                    next: -1,
                    start: insertStart,
                    end: insertEnd
                };

                this.__dataObjArray.push(newDataSet);
                this._totalCount += insertSize;

                this._data.splice.apply(this._data, [newDataSet.start, 0].concat(data));

                return this;
            }

            util.each(this.__dataObjArray, util.bind(function (curDataSet, curArrIndex) {

                //just update the offset for the data behind

                if (insertedData) {

                    curDataSet.start += insertSize;
                    curDataSet.end += insertSize;

                    if (curArrIndex < totalDataSet - 1) {
                        curDataSet.next += insertSize;
                    } else {
                        curDataSet.next = -1;
                    }

                    //no need to update the prev index since there is no change
                    if (!updatedNextDataObj) {
                        updatedNextDataObj = true;
                        return;
                    }

                    if (curArrIndex > 0) {
                        curDataSet.prev += insertSize;
                    } else {
                        curDataSet.prev = -1;
                    }

                    return;
                }


                //the insert range is before the cur data set 
                if (insertStart < curDataSet.start && insertStart > curDataSet.prev) {
                    insertPos = curArrIndex;

                    insertedData = true;

                    newDataSet = {
                        prev: curDataSet.prev,
                        next: curDataSet.start + insertSize,
                        start: insertStart,
                        end: insertEnd
                    };

                    curDataSet.prev = insertEnd;
                    curDataSet.end += insertSize;
                    curDataSet.start += insertSize;

                    return;
                }

                if (insertStart > curDataSet.end && (curDataSet.next > insertEnd || curDataSet.next === -1)) {

                    //if it is inside the gap between the fragments, the current dataset next is needed to update.
                    insertPos = curArrIndex + 1;

                    insertedData = true;

                    newDataSet = {
                        prev: curDataSet.end,
                        next: (curDataSet.next !== -1) ? (curDataSet.next + insertSize) : -1,
                        start: insertStart,
                        end: insertEnd
                    };

                    curDataSet.next = insertStart;

                    if (curArrIndex < this.__dataObjArray.length - 1) {
                        this.__dataObjArray[curArrIndex + 1].prev = insertEnd;
                    }

                    return;
                }

                //the insert range is inside the cur data set 
                if (insertStart >= curDataSet.start && insertStart <= curDataSet.end) {

                    curDataSet.end += insertSize;

                    insertedData = true;

                    console.debug("insert dataset completely inside the cur data set " + insertStart);
                    return;
                }

            }, this));

            if (insertPos > -1 && newDataSet) {
                this.__dataObjArray.splice(insertPos, 0, newDataSet);
            }

            //udpate the totalcount by add the size directly
            this._totalCount += insertSize;

            //insert the data into the array
            this._data.splice.apply(this._data, [insertStart, 0].concat(data));

            return this;
        },
        /**
         * Set the data into the datasource
         * @private
         * @param {Number} index the startIndex to insert or update to the datasource
         * @param {Array} data the data array
         * @returns {xdk-ax/data/Datasource} the datasource instance itself
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        __setFetchedData: function (index, data) {
            //default value of data set

            var newDataSet = {
                    start: index,
                    prev: -1,
                    next: -1,
                    end: index + data.length - 1
                },
                addNewDataSet = false,
                dstArrIndex = 0,
                targetDataSet, totalDataSet;

            if (this.getTotalCount() !== -1 && newDataSet.end >= this.getTotalCount()) {
                console.warn(index + data.length + "the size is over the total available size" + this.getTotalCount());
                return this;
            }

            //first case
            if (this.__dataObjArray.length === 0) {
                this.__dataObjArray.push(newDataSet);
                this._data.splice.apply(this._data, [newDataSet.start, data.length].concat(data));
                return this;
            }

            util.each(this.__dataObjArray, util.bind(function (curDataSet, curArrIndex) {

                //the ongoing new data set information
                totalDataSet = this.__dataObjArray.length;

                //search for the next item if this is not the last item which should be added at the end
                //and it should be looked for the next one and check whether add later
                if (curArrIndex !== totalDataSet - 1 && newDataSet.start > curDataSet.end + 1) { //+1 is to prevent overlap case
                    return;
                }

                //completely before the data set and add directly
                if ((curDataSet.prev === -1 || curDataSet.prev < newDataSet.start) && newDataSet.end + 1 < curDataSet.start) {

                    dstArrIndex = curArrIndex;

                    newDataSet.next = curDataSet.start;
                    newDataSet.prev = curDataSet.prev;

                    addNewDataSet = true;

                    console.debug("complete before the data set with startIndex " + curDataSet.start);

                    return util.breaker;
                }

                //completely after the data set and add directly.
                if ((curDataSet.next === -1 || curDataSet.next > newDataSet.end) && newDataSet.start > curDataSet.end + 1) {

                    dstArrIndex = curArrIndex + 1;

                    newDataSet.prev = curDataSet.end;
                    newDataSet.next = curDataSet.next;

                    addNewDataSet = true;

                    console.debug("complete after the data set with startIndex " + curDataSet.start);

                    return util.breaker;
                }

                //only overlap with one range change the current data set and no need to add a new dataset
                if (newDataSet.start > curDataSet.prev && (curDataSet.next === -1 || newDataSet.end < curDataSet.next)) {

                    if (newDataSet.start < curDataSet.start) {

                        curDataSet.start = newDataSet.start;

                        //change the relationship
                        if (curArrIndex > 0) {
                            this.__dataObjArray[curArrIndex - 1].next = curDataSet.start;
                        }
                    }

                    if (newDataSet.end > curDataSet.end) {

                        curDataSet.end = newDataSet.end;

                        //change the relationship
                        if (curArrIndex < totalDataSet - 1) {

                            //if they are connected, remove the next one
                            if (curDataSet.end + 1 === this.__dataObjArray[curArrIndex + 1].start) {

                                curDataSet.end = this.__dataObjArray[curArrIndex + 1].end;
                                curDataSet.next = this.__dataObjArray[curArrIndex + 1].next;

                                //remove the next one
                                this.__dataObjArray.splice(curArrIndex + 1, 1);
                            } else {
                                this.__dataObjArray[curArrIndex + 1].prev = curDataSet.end;
                            }

                        }

                    }

                    addNewDataSet = false;

                    console.debug("overlapped and update the data set" + curDataSet.start);

                    this._data.splice.apply(this._data, [newDataSet.start, data.length].concat(data));

                    return util.breaker;
                }

                //overlap with multiple ranges
                //remove the old dataset that cover by the new dataset
                targetDataSet = curDataSet;

                dstArrIndex = curArrIndex;

                while (curArrIndex < totalDataSet && newDataSet.end > targetDataSet.start) {

                    newDataSet.next = targetDataSet.next;
                    newDataSet.prev = targetDataSet.prev;

                    //update the front start
                    if (targetDataSet.start < newDataSet.start) {
                        newDataSet.start = targetDataSet.start;
                    }

                    //update the end
                    if (targetDataSet.end > newDataSet.end) {
                        newDataSet.end = targetDataSet.end;
                    }

                    //remove the current one
                    this.__dataObjArray.splice(curArrIndex, 1);

                    //update the total length 
                    totalDataSet = this.__dataObjArray.length;

                    //obtain the next one to be the current one
                    targetDataSet = this.__dataObjArray[curArrIndex];
                }

                addNewDataSet = true;
                console.debug("overlap with multiple range of dataset");

                return util.breaker;

            }, this));



            if (addNewDataSet) {

                this._data.splice.apply(this._data, [index, data.length].concat(data));

                this.__dataObjArray.splice(dstArrIndex, 0, newDataSet);

                totalDataSet = this.__dataObjArray.length;

                //update the relationship
                if (dstArrIndex < totalDataSet - 1) {
                    this.__dataObjArray[dstArrIndex + 1].prev = newDataSet.end;
                } else {
                    newDataSet.next = -1;
                }

                if (dstArrIndex > 0) {
                    this.__dataObjArray[dstArrIndex - 1].next = newDataSet.start;
                } else {
                    newDataSet.prev = -1;
                }

            }

            return this;

        },
        /**
         * Get the data from the datasource
         * @private
         * @param {Number} from the startIndex
         * @param {Number} [to] the end Index exclusively. default will be the index that from+1.
         * @returns {Array} the requested data
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        __getFetchedData: function (from, to) {
            if (util.isUndefined(to)) {
                to = from + 1;
            }
            //no checking on the data array list if the data is already exist
            return this._data.slice(from, to);
        },
        /**
         * To check if currently data is(are) included. If it doesn't include, it will return the new range
         * @private
         * @param {Number} from the start index
         * @param {Number} [to] the end index exclusively. default will be the index that from+1
         * @returns {Object[]} Object Array which is the missing data inside the range. If the length is 0, no missing data.
         * In each object, from and to will indicate the missing range.
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        __checkFetchedData: function (from, to) {
            var result = [],
                targetFrom = from,
                targetTo = to,
                hasAllData = false;

            //to ensure all the data has fetched
            util.each(this.__dataObjArray, util.bind(function (curDataSet) {

                //no contain the data
                if (targetTo < curDataSet.start) {
                    return util.breaker;
                }

                //only contain later end data and need to fetch the previos one
                if (targetFrom < curDataSet.start) {

                    result.push({
                        from: targetFrom,
                        to: curDataSet.start
                    });

                    //more than the current range and then update the from
                    if (targetTo > curDataSet.end + 1) {
                        targetFrom = curDataSet.end + 1;
                    } else {
                        hasAllData = true;
                        return util.breaker;
                    }

                    return;
                }

                if (targetFrom <= curDataSet.end) {

                    //contain front part of the data
                    if (targetTo > curDataSet.end + 1) {
                        targetFrom = curDataSet.end + 1;
                    } else {
                        hasAllData = true;
                        return util.breaker;
                    }

                    return;
                }

            }, this));

            if (!hasAllData) {
                result.push({
                    from: targetFrom,
                    to: targetTo
                });
            }

            return result;
        },
        /**
         * To check if currently data is(are) included.
         * @private
         * @param {Number} from the start index
         * @param {Number} [to] the end index exclusively. default will be the index that from+1
         * @returns {Boolean} true if it contains all the requested data. false if it doesn't consist all the desired data.
         * @method
         * @memberof xdk-ax/data/Datasource#
         */
        __hasFetchedData: function (from, to) {
            var result = false;

            //to ensure all the data has fetched
            util.each(this.__dataObjArray, util.bind(function (curDataSet) {

                if (from >= curDataSet.start && from <= curDataSet.end) {

                    if (util.isUndefined(to) || (to - 1 <= curDataSet.end)) {
                        result = true;
                    }

                    console.info("[XDK] Datasource contains part of the target range of data.");
                    return util.breaker;
                }

            }, this));

            return result;
        }

    });
});
/**
 * Local DataSource which allow developer to update the datasource locally.
 * It provides the default updater and setDataUpdater when initialized.
 * when the data is inserted or removed from externally, it can amend or change the data before setting into the datasource.
 * @class xdk-ax/data/LocalDatasource
 *
 */
define("xdk-ax/data/LocalDatasource", ["xdk-base/class", "xdk-base/core", "xdk-base/promise", "xdk-ax/data/Datasource", "xdk-ax/data/interface/Datasource"], function (klass, core, promise, Datasource, IDatasource) {
    "use strict";
    return klass.create(Datasource, {


    }, {

        init: function () {

            var self = this;

            this.setDataUpdater(function (action, opts) {

                var deferred = promise.defer();

                switch (action) {
                case IDatasource.ACTION.REMOVE:
                    removeLocalData(opts.from, opts.to);
                    break;

                case IDatasource.ACTION.INSERT:
                    insertLocalData(opts.newData, opts.from);
                    break;
                }

                return deferred.promise;
                /**
                 * Internal method to remove local data
                 * @method
                 * @param {Number} from the startIndex to remove
                 * @param {Number} to the end index
                 * @returns {Promise.<Object[]>} from and to properties
                 * @private
                 * @memberof xdk-ax/data/LocalDatasource#
                 */
                function removeLocalData(from, to) {

                    var len = self.getTotalCount();

                    to = Math.min(to, len);

                    if (from >= to) {
                        deferred.reject(core.createException("Trying to remove self more local data then locally have"));
                        return;
                    }

                    //since at the beginning, the total count is -1 and need to update it when first insert
                    if (len === -1) {
                        deferred.reject(core.createException("ds incorrect total count", "Total Item should be set before insert the data"));
                        return;
                    }

                    deferred.resolve({
                        from: from,
                        to: to
                    });

                }
                /**
                 * Internal method to insert local data
                 * @method
                 * @param {Array} newData array object
                 * @param {Number} index the position to insert
                 * @returns {Promise.<Object[]>} newData which is the updated newData while index is the updated index
                 * @private
                 * @memberof xdk-ax/data/LocalDatasource#
                 */
                function insertLocalData(newData, index) {

                    //since at the beginning, the total count is -1 and need to update it when first insert
                    if (self.getTotalCount() === -1) {
                        deferred.reject(core.createException("ds incorrect total count", "Total Item should be set before insert the data"));
                        return;
                    }

                    deferred.resolve({
                        newData: newData,
                        index: index
                    });

                }
            });

        }

    });


});
/**
 * Asset Model
 * @class tve/model/Asset
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/Asset", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member id
             * @memberof tve/model/Asset#
             * @public
             * @type {String}
             */
            "id": null,

            /**
             * @member title
             * @memberof tve/model/Asset#
             * @public
             * @type {String}
             */
            "title": null,

            /**
             * @member description
             * @memberof tve/model/Asset#
             * @public
             * @type {String}
             */
            "description": null,

            /**
             * @member geoLock
             * @memberof tve/model/Asset#
             * @public
             * @type {Boolean}
             */
            "geoLock": null,

            /**
             * @member publishedDate
             * @memberof tve/model/Asset#
             * @public
             * @type {Date}
             */
            "publishedDate": null,

            /**
             * @member availableDate
             * @memberof tve/model/Asset#
             * @public
             * @type {Date}
             */
            "availableDate": null,

            /**
             * @member metadata
             * @memberof tve/model/Asset#
             * @public
             * @type {Object}
             */
            "metadata": {},

            /**
             * @member credits
             * @memberof tve/model/Asset#
             * @public
             * @type {Object}
             */
            "credits": {},

            /**
             * @member categories
             * @memberof tve/model/Asset#
             * @public
             * @type {tve/model/MediaCategory[]}
             */
            "categories": [],

            /**
             * @member parentalRatings
             * @memberof tve/model/Asset#
             * @public
             * @type {String[]}
             */
            "parentalRatings": [],

            /**
             * @member images
             * @memberof tve/model/Asset#
             * @public
             * @type {tve/model/Resource[]}
             */
            "images": [],

            /**
             * @member videos
             * @memberof tve/model/Asset#
             * @public
             * @type {tve/model/Resource[]}
             */
            "videos": []
        }
    }, {});
});
/**
 * TVShow Model
 * @class tve/model/TVShow
 * @augments tve/model/Asset
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/TVShow", ["xdk-base/class", "tve/model/Asset", "xdk-base/util"], function (klass, Asset, util) {
    return klass.create(Asset, {
        defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member episodeIds
             * @memberof tve/model/TVShow#
             * @public
             * @type {String[]}
             */
            "episodeIds": [],

            /**
             * @member seasonIds
             * @memberof tve/model/TVShow#
             * @public
             * @type {String[]}
             */
            "seasonIds": []
        }, true)
    }, {});
});
/**
 * Some utilities used in Storm.
 * @module storm/helper/util
 * @name util
 * @memberof storm/helper
 */

// @TODO: This was originally the TVE Demo helper/util file, so we should TIDY OUT any bits we don't (and won't) be using.

define("storm/helper/util", [
    "xdk-ax/data/LocalDatasource",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/device",
    "xdk-base/ajax",
    "tvedemo/helper/dialogHelper",
    "xdk-ax/focusManager",
    "tve/TVEError",
    "tve/model/Asset",
    "tve/model/TVShow",
    "storm/mgr/sLanguageManager",
    "tvedemo/helper/sMoment",
    "lib/moment"
], function (
    LocalDatasource,
    util,
    config,
    console,
    promise,
    device,
    ajax,
    dialogHelper,
    focusMgr,
    TVEError,
    Asset,
    TVShow,
    sLanguageManager,
    moment,
    momentMIT
    ) {

    "use strict";

    /**
     * The browser-wise transition end event name.
     * This will store the name of the event (as a string), or undefined if CSS3 transition is not supported.
     * @property transitionEndEventName
     * @private
     */
    var transitionEndEventName = null;

    function __parseSkyDateTimeToDate(date, time) {
        try {
            // Sky present the date in different formats, depending on which back end source we're touching
            var dateArray = (date.indexOf(".") !== -1)?date.split("."):date.split("/"),
                timeArray = time.split(":");
            // year has to be first param of Date(), so we swap elements if date is formatted like YYYY.MM.DD
            if (dateArray[2].length < dateArray[0].length) {
                return new Date(dateArray[0], dateArray[1] - 1, dateArray[2], timeArray[0], timeArray[1]); 
            }
            return new Date(dateArray[2], dateArray[1] - 1, dateArray[0], timeArray[0], timeArray[1]);
        } catch (e) {
            throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "parseSkyDateTimeToDate failed: " + e);
        }
    }

    return {

        isOnAir: function(onAir) {
            return amd.require("tve/sServiceHolder").getDateTimeService().getServerDateTime().then(function (dateTime) {
                var serverTime = dateTime.getTime(),
                    format = sLanguageManager.getString("ui.parsing.onAirStartDate") + sLanguageManager.getString("ui.parsing.epgEventTime"),
                    startTime = moment(onAir.start_date + onAir.start_time, format),
                    endTime = moment(onAir.end_date + onAir.end_time, format);
                return startTime.valueOf() < serverTime && serverTime < endTime.valueOf();
            });
        },

        /**
         * Returns the last value that is part of the object's hierarchical path provided
         *
         * For instance: getSanitizedValue(obj, "field.subfield.array[10].name")
         * will return the value held by obj.field.subfield.array[10].name
         * or undefined if part of the path is undefined/null
         *
         * Note: wont work if a function is part of the path
         */
        getSanitizedValue: function(object, path) {
            return (function f(obj, paths) {
                return (!obj || !paths || !paths.length) ? obj : f(obj[paths.shift()], paths);
            })(object, (path || "").replace(/\[/g,".").replace(/\]/g,"").split("."));
        },

        /**
         * For use during development, to verify broad behaviour of returned / exposed promises.
         *
         * @param promise
         */
        probePromise: function(promise) {
            promise.then(function(outcome){
                console.log("OK");
                console.log(outcome);
            }, function(e){
                console.log("KO");
                console.log(e);
            });
        },

        /**
         * Convert EHUB's stringy date and time into a Javascript Date().
         *
         * Note that the Date() will refer to server time; we have no concept of UTC or time zones in this app.
         */
        parseSkyDateTimeToDate: function(date, time) {
            return __parseSkyDateTimeToDate(date, time);
        },

        /**
         * Increase robustness in face of damaged or sparse EPG data.
         */
        sanitiseEpgEvents: function(startTime, endTime, eventArray) {
            var emptyTitle = sLanguageManager.getString("Epg.noDataFoundMessage"),
                startMoment = moment(Math.floor(startTime / 1000) * 1000),// Round the start down to a second.
                endMoment = moment(Math.ceil(endTime / 1000) * 1000),// Round the end up to a second; the UI uses 999 msecs of the last sec of the day (for historical / TVE Demo reasons).
                fEventMaker = function(eventStartMoment, eventEndMoment) {
                    var oNewEvent = {
                        id: 0,
                        title: emptyTitle ? emptyTitle : "&nbsp;", // Improve appearance of 'empty' cells at edge case (to make prod testing less unpleasant).
                        length: momentMIT.duration(eventEndMoment.diff(eventStartMoment)).asMinutes(),
                        startDate: eventStartMoment.format(sLanguageManager.getString("ui.parsing.epgEventDate")),
                        startTime: eventStartMoment.format(sLanguageManager.getString("ui.parsing.epgEventTime")),
                        endDate: eventEndMoment.format(sLanguageManager.getString("ui.parsing.epgEventDate")),
                        endTime: eventEndMoment.format(sLanguageManager.getString("ui.parsing.epgEventTime"))
                    };
                    return oNewEvent;
                };

            if (eventArray.length === 0) {
                eventArray.push(fEventMaker(startMoment, endMoment));
            } else {
                // Assume that the array is populated with events in chronological order, even if they're potentially sparse...
                var nIndexIntoEvents = 0;
                var lastEventEnd = startMoment,
                    oCurrentEventMoments;

                while (true) {
                    var oCurrentEvent = eventArray[nIndexIntoEvents];
                    if (util.isUndefined(oCurrentEvent)) {
                        break; // No more events for this day.
                    }
                    oCurrentEventMoments = {
                        start: moment(__parseSkyDateTimeToDate(oCurrentEvent.startDate, oCurrentEvent.startTime)),
                        end: moment(__parseSkyDateTimeToDate(oCurrentEvent.endDate, oCurrentEvent.endTime))
                    };
                    // If there's a gap before this event, let's fill it...
                    if (lastEventEnd.diff(oCurrentEventMoments.start) < 0) {
                        eventArray.splice(nIndexIntoEvents, 0, fEventMaker(lastEventEnd, oCurrentEventMoments.start));
                        nIndexIntoEvents++;
                    }

                    lastEventEnd = oCurrentEventMoments.end;
                    nIndexIntoEvents++;
                }
                // Is there a gap right at the end?
                if (lastEventEnd.diff(endMoment) < 0) {
                    eventArray.push(fEventMaker(lastEventEnd, endMoment));
                }
            }

            return eventArray;
        },

        /**
         * Regular expression token replacer.
         */
        tokenReplacer: function(template, func) {
            var format = /{([^:}]+)(?::([e0])?(\d+)?([dis]))?}/g;
            return template.replace(format, func);
        },

        /**
         * Compares a current version against a required version.
         * Version string should look like major.minor.patch.
         * As an example, 1.0.10 is newer (larger) than 1.0.9.
         *
         * @return true if the version is NOT compatible
         */
        versionNotCompatible: function(versionToCheck, requiredVersionInfo) {

            try {
                var specificRequirements = requiredVersionInfo[config.get("environment")],
                    versionArrayOld = versionToCheck.split("."),
                    versionArrayNew = specificRequirements.minimum.split(".");

                // 1.0.0 is older than 2.0.0
                // 2.0.0 is older than 2.1.0, etc
                for (var index=0; index<versionArrayNew.length; index++) {
                    var numericOld = Number(versionArrayOld[index]),
                        numericNew = Number(versionArrayNew[index]);

                    if(numericOld < numericNew) {
                        console.warn(versionToCheck + " looks older than the required minimum " + specificRequirements.minimum);
                        // The old version is obviously too old, look no further. But wait..!
                        if (specificRequirements.exceptions.indexOf(versionToCheck) !== -1) {
                            console.warn("... but it's on the exceptions list :)");
                            return false;
                        } else {
                            return true;
                        }
                    }
                    if(numericOld > numericNew) {
                        return false; // The old version is new enough, look no further.
                    }
                }

                return false; // The versions were the same, to the last index of the required one anyway.
            } catch (e) {
                console.warn("Exception trying to check version number: " + e);
                return true; // Assume not compatible. It's the only way to be sure.
            }
        },

        /**
         * Convert array to datasorce
         * @method arrayToDs
         * @param {Array} the array for ds
         * @memberof storm/helper/util#
         * @returns {Object} a DS of the given array
         * @public
         */
        arrayToDs: function (array) {
            var ds = new LocalDatasource();

            ds.setDataLoader(function () {
                var defer = promise.defer();
                defer.resolve({
                    data: array,
                    total: array.length
                });
                return defer.promise;
            });

            return ds;
        },

        /**
         * Get the root folder of current platform.
         * @method getRootFolder
         * @memberof storm/helper/util#
         * @returns {String} the root folder
         * @public
         */
        getRootFolder: function (relativeUrl) {
            var videoUrl,
                deferred;

            if (device.platform === "workstation") {
                videoUrl = window.location.href.split("/index.html")[0];
            } else if (device.platform === "samsung") {

                var getAbsPath = function (linkString) {
                    // For the 2015 Tizen platform and later years, no special hacks are required
                    if (device.id && device.id.getFirmwareYear() >= 2015) {
                        return window.location.href.split("/index.html")[0];
                    }

                    linkString = linkString || "";

                    var Abs_path = "",
                        rootPath = window.location.href.substring(0, location.href.lastIndexOf("/") + 1);
                    
                    // For 2012 platform
                    if (decodeURIComponent(window.location.toString()).indexOf("localhost") === -1) {
                        if (decodeURIComponent(window.location.toString()).indexOf("file://C") !== -1) { // For PC-SDK
                            Abs_path = decodeURIComponent(rootPath).split("file://")[1].replace("C/", "C:/") + linkString;
                        } else { // For Real-Device
                            Abs_path = decodeURIComponent(rootPath).split("file://")[1] + linkString;
                        }
                    } else // For 2010, 2011 platform
                    {
                        if (decodeURIComponent(window.location.toString()).indexOf("C:") !== -1) {
                            // For PC-SDK
                            Abs_path = "/" + decodeURIComponent(rootPath).split("file://localhost/C:\\")[1].replace(/\\/g, "/") + linkString;
                        } else {
                            // For Real-Device
                            Abs_path = "/" + decodeURIComponent(rootPath).split("file://localhost/")[1] + linkString;
                        }
                    }
                    return Abs_path;
                };

                videoUrl = getAbsPath();
            } else if (device.platform === "tizen") {
                // This is needed when using local files for playback.
                // Because how files are stored when installed from samsung servers compared to SDK.

                deferred = promise.defer();

                tizen.filesystem.resolve("wgt-package" + relativeUrl, function(file) {
                        deferred.resolve(file.toURI());
                    },
                    function(e) {
                        console.log("file.toURI() error: " + e.message);
                        deferred.resolve("");
                    },
                    "r"
                );

                return deferred.promise;
            } else {
                videoUrl = window.location.href.split("/index.html")[0];
            }

            return promise.resolve(videoUrl + relativeUrl);
        },

        /**
         * To check is the focus is lost.
         * @method isFocusLost
         * @memberof storm/helper/util#
         * @returns {BOOL} if the focus is lost
         * @public
         */
        isFocusLost: function () {

            var curFocus = focusMgr.getCurFocus();

            return !(curFocus && curFocus.getRoot() && curFocus.getRoot().isInDOMTree());
        },

        /**
         * To preload one image.
         * @method preloadImage
         * @memberof storm/helper/util#
         * @param {String} url the url of the image
         * @public
         */
        preloadImage: function (url) {
            var image = new Image();
            image.src = url;
        },

        /**
         * To preload images
         * @method preloadImages
         * @memberof storm/helper/util#
         * @param {Array} urls the urls of the images
         * @public
         */
        preloadImages: function (arr) {
            var images = [];
            for (var i = 0, l = arr.length; i < l; i++) {
                images[i] = new Image();
                images[i].src = arr[i];
            }
        },

        /**
         * Get the CSS3 transition end event name.
         * @method
         * @returns {String} event name, undefined if CSS3 transition is not supported
         * @memberOf storm/helper/util
         */
        getTransitionEndEventName: function () {
            // transitionEndEventName is a local variable within this util class storing the value
            // since the event name is browser-wise which won't change through out the runtime, it is save to store it to avoid further checking
            if (transitionEndEventName !== null) {
                return transitionEndEventName;
            }

            if ("ontransitionend" in window) {
                transitionEndEventName = "transitionend";
            } else if ("onwebkittransitionend" in window) {
                transitionEndEventName = "webkitTransitionEnd";
            } else {
                transitionEndEventName = undefined;
            }

            return transitionEndEventName;
        },

        /**
         * Format a time from number of seconds to hh:mm:ss string format.
         * @method
         * @param {Number} time The number of seconds
         * @returns {String} The formatted string
         * @memberOf storm/helper/util
         */
        formatTime: function (time) {
            // double tilde converts floating point number to integer
            time = ~~time % (99 * 60 * 60);

            var h = ~~ (time / 3600),
                m = ~~ (time % 3600 / 60),
                s = time % 60;

            return (h < 10 ? "0" : "") + h + ":" + (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
        },

        /**
         * Works like promise.all, BUT If any of the promises gets rejected, the operation will continue anyway.
         * @method
         * @param {Array} promises an array of promises
         * @param [optional] {boolean} ignoreNullResults set to true to remove all undefined/null results
         * @returns {Promise} a promise for an array of the corresponding values, with null as value for rejected promises
         * @memberOf storm/helper/util
         */
        allPromises: function(arrayPromises, ignoreNullResults) {
            var defer = promise.defer(),
                results = [],
                total = arrayPromises.length;
                
            if (!total) {
                defer.resolve([]);
                return defer.promise;
            }

            var actionFct = function(result, index) {
                results[index] = result;
                total--;
                if (!total) {
                    if (ignoreNullResults) {
                        results = util.filter(results, function(i) {
                            return i !== undefined && i !== null;
                        });
                    }
                    defer.resolve(results);
                }
            };

            for (var o=0; o<arrayPromises.length; o++) {
                (function(index) {
                    arrayPromises[o].then(function(result) {
                        actionFct(result, index);
                    },
                    function(error) {
                        actionFct(new Error(error), index);
                    });
                })(o);
            }
            return defer.promise;
        },

        isoDate: function(string) {
            var D = new Date(string);
            if (isNaN(D)){
                var day, tz,
                rx=/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*)?)([zZ]|([+\-])(\d\d):(\d\d))?$/,
                p= rx.exec(string) || [];
                if (p[1]) {
                    day = p[1].split(/\D/);
                    for (var i= 0, L= day.length; i<L; i++){
                        day[i]= parseInt(day[i], 10) || 0;
                    }
                    day[1]-= 1;
                    day = new Date(Date.UTC.apply(Date, day));
                    if (!day.getDate()) { return NaN; }
                    if (p[5]){
                        tz = (parseInt(p[5], 10)*60);
                        if(p[6]) { tz+= parseInt(p[6], 10); }
                        if(p[4] === "+") { tz*= -1; }
                        if(tz) { day.setUTCMinutes(day.getUTCMinutes()+ tz); }
                    }
                    return day;
                }
                return NaN;
            }
            return D;
        },
    
        // returns an array of the results of the function call, iterated from 0 until count
        // the current index is passed to the function called
        // ex: repeater(function(index) {
        //    return index;
        //}, 5);
        // will return [0, 1, 2, 3, 4]
        repeater: function(fct, count) {
            var arr = [];
            for (var i=0; i<count; i++) {
                arr.push(fct(i));
            }
            return arr;
        },
        
        /**
        * Outputs an object's properties to the log
        */
        traceObject: function(object, label, logtype, followLevels, indent) {
/*
            
            logtype = logtype || "log";
            label   = label || "";
            followLevels  = followLevels || 1;
            indent = indent || 0;
            if (followLevels > 0)
            {
                if (typeof(object) === "array" || typeof(object) === "object")
                {
                    if (logtype === "log")
                    {
                        var logfunc = console.log;
                    }
                    else if (logtype === "info")
                    {
                        logfunc = console.info;
                    }
                    else if (logtype === "warn")
                    {
                        logfunc = console.warn;
                    }
                    else if (logtype === "error")
                    {
                        logfunc = console.error;
                    }
                    
                    if (label !== "") logfunc.apply(console, ["====== "+label+" ======"]);
                    for (var i in object) {
                        var distance = Array(indent).join("\t");
                        logfunc.apply(console, [distance+"- "+i+": "+object[i]]);
                        if ((typeof(object[i]) === "array" || typeof(object[i]) === "object") && followLevels > 1) {
                            // Check if it's a simple object. We don't want to trace classes
                            var theclass = {}.toString.apply(object[i]);
                            if (theclass === "[object Array]" || theclass === "[object Object]")
                            {
                                // Last check
                                if(typeof object[i].constructor === 'function') continue;
                                // We're sorta safe
                                this.traceObject(object[i], "", logtype, followLevels-1, indent+1);
                            }
                        }
                    }
                }
                else
                {
                    console.error(object+" is not an array or an object");
                }
            }
*/
        },

        transcodeDateString: function(dateString, srcFormatStr, dstFormatStr) {
            return moment(dateString, srcFormatStr).format(dstFormatStr);
        },

        areAssetIdsEqual: function(a, b) {
            var aNormalised = parseInt(a, 10),
                bNormalised = parseInt(b, 10);

            return (!isNaN(aNormalised) && (aNormalised === bNormalised));
        },

        /**
         * Blocking previous function calls with wait delay
         * e.g. debounce(func, 100);
         */
        debounce: function(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                }, wait);
                if (immediate && !timeout) func.apply(context, args);
            };
        }
    };
});
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=l.WordArray=t.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=p?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,e=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var k=0;k<a;k++)c[j+k>>>2]|=(e[k>>>2]>>>24-8*(k%4)&255)<<24-8*((j+k)%4);else if(65535<e.length)for(k=0;k<a;k+=4)c[j+k>>>2]=e[k>>>2];else c.push.apply(c,e);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e<a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++){var k=c[j>>>2]>>>24-8*(j%4)&255;e.push((k>>>4).toString(16));e.push((k&15).toString(16))}return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j+=2)e[j>>>3]|=parseInt(a.substr(j,
2),16)<<24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++)e.push(String.fromCharCode(c[j>>>2]>>>24-8*(j%4)&255));return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j++)e[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q<a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();

define("lib/aes", function(){});

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(g,j){var e={},d=e.lib={},m=function(){},n=d.Base={extend:function(a){m.prototype=this;var c=new m;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=d.WordArray=n.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=j?c:4*a.length},toString:function(a){return(a||l).stringify(this)},concat:function(a){var c=this.words,p=a.words,f=this.sigBytes;a=a.sigBytes;this.clamp();if(f%4)for(var b=0;b<a;b++)c[f+b>>>2]|=(p[b>>>2]>>>24-8*(b%4)&255)<<24-8*((f+b)%4);else if(65535<p.length)for(b=0;b<a;b+=4)c[f+b>>>2]=p[b>>>2];else c.push.apply(c,p);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=n.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),b=e.enc={},l=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++){var d=c[f>>>2]>>>24-8*(f%4)&255;b.push((d>>>4).toString(16));b.push((d&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f+=2)b[f>>>3]|=parseInt(a.substr(f,
2),16)<<24-4*(f%8);return new q.init(b,c/2)}},k=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++)b.push(String.fromCharCode(c[f>>>2]>>>24-8*(f%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f++)b[f>>>2]|=(a.charCodeAt(f)&255)<<24-8*(f%4);return new q.init(b,c)}},h=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},
u=d.BufferedBlockAlgorithm=n.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=h.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,f=b.sigBytes,l=this.blockSize,e=f/(4*l),e=a?g.ceil(e):g.max((e|0)-this._minBufferSize,0);a=e*l;f=g.min(4*a,f);if(a){for(var h=0;h<a;h+=l)this._doProcessBlock(d,h);h=d.splice(0,a);b.sigBytes-=f}return new q.init(h,f)},clone:function(){var a=n.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});d.Hasher=u.extend({cfg:n.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new w.HMAC.init(a,
d)).finalize(b)}}});var w=e.algo={};return e}(Math);
(function(){var g=CryptoJS,j=g.lib,e=j.WordArray,d=j.Hasher,m=[],j=g.algo.SHA1=d.extend({_doReset:function(){this._hash=new e.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(d,e){for(var b=this._hash.words,l=b[0],k=b[1],h=b[2],g=b[3],j=b[4],a=0;80>a;a++){if(16>a)m[a]=d[e+a]|0;else{var c=m[a-3]^m[a-8]^m[a-14]^m[a-16];m[a]=c<<1|c>>>31}c=(l<<5|l>>>27)+j+m[a];c=20>a?c+((k&h|~k&g)+1518500249):40>a?c+((k^h^g)+1859775393):60>a?c+((k&h|k&g|h&g)-1894007588):c+((k^h^
g)-899497514);j=g;g=h;h=k<<30|k>>>2;k=l;l=c}b[0]=b[0]+l|0;b[1]=b[1]+k|0;b[2]=b[2]+h|0;b[3]=b[3]+g|0;b[4]=b[4]+j|0},_doFinalize:function(){var d=this._data,e=d.words,b=8*this._nDataBytes,l=8*d.sigBytes;e[l>>>5]|=128<<24-l%32;e[(l+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(l+64>>>9<<4)+15]=b;d.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=d.clone.call(this);e._hash=this._hash.clone();return e}});g.SHA1=d._createHelper(j);g.HmacSHA1=d._createHmacHelper(j)})();
(function(){var g=CryptoJS,j=g.enc.Utf8;g.algo.HMAC=g.lib.Base.extend({init:function(e,d){e=this._hasher=new e.init;"string"==typeof d&&(d=j.parse(d));var g=e.blockSize,n=4*g;d.sigBytes>n&&(d=e.finalize(d));d.clamp();for(var q=this._oKey=d.clone(),b=this._iKey=d.clone(),l=q.words,k=b.words,h=0;h<g;h++)l[h]^=1549556828,k[h]^=909522486;q.sigBytes=b.sigBytes=n;this.reset()},reset:function(){var e=this._hasher;e.reset();e.update(this._iKey)},update:function(e){this._hasher.update(e);return this},finalize:function(e){var d=
this._hasher;e=d.finalize(e);d.reset();return d.finalize(this._oKey.clone().concat(e))}})})();
(function(){var g=CryptoJS,j=g.lib,e=j.Base,d=j.WordArray,j=g.algo,m=j.HMAC,n=j.PBKDF2=e.extend({cfg:e.extend({keySize:4,hasher:j.SHA1,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(e,b){for(var g=this.cfg,k=m.create(g.hasher,e),h=d.create(),j=d.create([1]),n=h.words,a=j.words,c=g.keySize,g=g.iterations;n.length<c;){var p=k.update(b).finalize(j);k.reset();for(var f=p.words,v=f.length,s=p,t=1;t<g;t++){s=k.finalize(s);k.reset();for(var x=s.words,r=0;r<v;r++)f[r]^=x[r]}h.concat(p);
a[0]++}h.sigBytes=4*c;return h}});g.PBKDF2=function(d,b,e){return n.create(e).compute(d,b)}})();

define("lib/pbkdf2", function(){});

/* global CryptoJS */

// Note use of CryptoJS 3.1.2, see https://code.google.com/p/crypto-js/#AES

/**
 * Module that returns an singleton language (string literals / i18n) class
 * @name sTokenManager
 * @memberof storm/mgr
 * @module storm/mgr/sTokenManager
 * @author Jason Newman<jason.newman@ext.accedo.tv>
 */
define("storm/mgr/sTokenManager", [
    "xdk-base/ax",
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/console",
    "lib/aes",
    "lib/pbkdf2",
    "lib/base64",
    "tve/TVEError"
], function (
    ax,
    core,
    klass,
    console,
    aes,
    pbkdf2,
    base64,
    TVEError
    ) {

    "use strict";

    //
    // @TODO: Get an answer on SKYSTORM-288 re whether these are ok to leave here; if not here, where?
    // Until we get at a response (currently nothing back) it's probably best we don't include these in the code...
    //
    
    var SECRET = {
        FREE: "STUBBED-OUT", // See JIRA for the true values, as provided by Sky at October 2014.
        NOTFREE: "STUBBED-OUT"
    };

    var TokenManager = klass.create({}, {

        TYPE: {
            FREE: "free",
            NOTFREE: "notfree"
        },

        /**
         * Initialize the language manager
         * @override
         * @protected
         * @name init
         * @memberof storm/mgr/sTokenManager#
         */
        init: function () {
            // TBC
        },

        /**
         * Get the token information relating to that clip item.
         * @return {Promise.<Object>} An object containing the name, value, and type of the relevant token.
         * @throws {Promise.<ax/TVEError>} Internal error object
         */
        getDecryptedToken: function (encryptedToken) {
            try {
                var password = (encryptedToken.type === this.TYPE.FREE)?SECRET.FREE:SECRET.NOTFREE,

                //
                // Refer to the CryptoJS documentation for additional background.
                // https://code.google.com/p/crypto-js/#Quick-start_Guide
                //
                // Password stretching using PBKDF2 requires a password and a salt.
                // Sky have advised that they're to be based on the same source data, so...
                //

                    salt = CryptoJS.enc.Utf8.parse(password),

                //
                // The reference C# implementation invoked getBytes twice on a Rfc2898DeriveBytes object:
                //     First to retrieve the 128 bit key for decryption.
                //     Then to retrieve the 128 bit initial vector (iv) for decryption.
                //
                // Microsoft's documentation states that for their Rfc2898DeriveBytes, successive requests are
                // identical with making a single large request, and chunking the response.
                //
                // CryptoJS.PBKDF2 does not allow successive requests in this way, so we make a single request for 256 bits.
                //
                // Iteration count 1000 as mandated in reference C# implementation (and is minimum best practice, fwiw).
                //
                // Note that the keySize is specified as a number of 4-byte words (hence /32 ).
                //

                    keyAndIV = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 1000 }),

                //
                // We then split that response into two chunks.
                //
                // As described above, the first 128 bits are the key, the second 128 are the iv.
                //

                    hexToSplit   = CryptoJS.enc.Hex.stringify(keyAndIV),
                    key = CryptoJS.enc.Hex.parse(hexToSplit.substr(0, 32)),
                    iv = CryptoJS.enc.Hex.parse(hexToSplit.substr(32, 32)),

                //
                // The C# AesManaged implementation defaults to PKCS7 padding, CBC mode.
                // CryptoJS documentation says these are the defaults there too,
                // so we take no explicit action to set padding or mode.
                //

                    objectToDecrypt = {
                        ciphertext: CryptoJS.enc.Base64.parse(encryptedToken.value),
                        salt: ""
                    },

                    aesOutput = CryptoJS.AES.decrypt(objectToDecrypt, key, { iv: iv });

                // @TODO: Detect failure; AES will fail silently here, returning some nonsense, if the password was wrong.

                return {
                    name: encryptedToken.name, // The name is passed through, 'in the clear'.
                    value: CryptoJS.enc.Utf8.stringify(aesOutput)
                };

            } catch (e) {
                console.log(e);
                throw new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INTERNAL, "Decryption failed " + e);
            }
        }

    });

    return new TokenManager();
});
/**
 * Returns a singleton responsible Storm-specific linear channel behaviours.
 * @name sLinearChannelManager
 * @memberof storm/mgr
 * @class storm/mgr/sLinearChannelManager
 */
define("storm/mgr/sLinearChannelManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "storm/mgr/sAppConfigManager",
    "storm/helper/util"
], function (
    klass,
    util,
    promise,
    console,
    sAppConfigManager,
    stormHelper
    ) {

    "use strict";

    var LinearChannelManager = klass.create({
    }, {

        checkIfChannelIdPermitted: function(prospectiveChannelId) {
            return sAppConfigManager.getPermittedLinearChannels().then(function (permittedChannelsArray) {
                var deferred = promise.defer();

                if (permittedChannelsArray) {

                    util.each(permittedChannelsArray, function (permittedChannel) {

                        if (stormHelper.areAssetIdsEqual(permittedChannel, prospectiveChannelId)) {
                            deferred.resolve("Channel id " + prospectiveChannelId + " is permitted");
                            return util.breaker;
                        }
                    });

                    // This will have no effect if the promise has been resolved before this point.
                    // Since a promise that has been resolved/rejected is immutable.
                    deferred.reject("Channel id " + prospectiveChannelId + " is NOT permitted");

                } else {

                    // For security we don't permit any channel unless it has been verified as permitted.
                    deferred.reject("Channel id " + prospectiveChannelId + " is NOT permitted");
                }

                return deferred.promise;
            });
        },

        /**
         * Filter supplied channels for EPG
         * @method filterEPGChannels
         * @param {Array} [tvChannels] A list if the TVChannel assets to filter
         * @public
         * @returns {Promise.<Array>} an array of channels
         * @throws {Promise.<tve/TVEError>} Internal error object
         * @memberof tve/mgr/sLinearManager#
         */
        filterPermittedChannels: function (tvChannels) {
            
            console.log("Filter channels");
            
            var filteredChannels = [];
            
            var promiseArray = [];
            util.each(tvChannels, function(channel) {
                promiseArray.push(this.checkIfChannelIdPermitted(channel.get("id")).then(function(res){
                    console.log(res);
                    filteredChannels.push(channel);
                    return res;   
                }, 
                function(e) {
                    console.warn(e);
                }));
            }, this);

            //var tvChannels = [];
            return promise.all(promiseArray).then(function(res) 
            {
                console.log("All channels resolved");
                return filteredChannels;
            });
        }

    });

    return new LinearChannelManager();
});
/**
 * SilkMessage Model
 * @class storm/model/SilkMessage
 */
define("storm/model/SilkMessage", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member code - The SILK response code that this message corresponds to
             * @memberof storm/model/SilkMessage#
             * @public
             * @type {String}
             */
            "code": null,

            /**
             * @member title
             * @memberof storm/model/SilkMessage#
             * @public
             * @type {String}
             */
            "title": "",

            /**
             * @member description
             * @memberof storm/model/SilkMessage#
             * @public
             * @type {String}
             */
            "description": ""
        }
    }, {});
});
/**
 * SilkMessage Builder, for building the SilkMessage model
 * @class storm/model/SilkMessageBuilder
 */
define("storm/model/SilkMessageBuilder", [
    "xdk-base/class",
    "storm/model/SilkMessage"
], function (
    klass,
    SilkMessage
    ) {

    "use strict";

    var SilkMessageBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/SilkMessageBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the code for building the model.
         * @param {String} code
         * @returns {storm/model/SilkMessageBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/SilkMessageBuilder#
         */
        setCode: function (code) {
            this._attrs.code = code;
            return this;
        },

        /**
         * Set the title for building this model.
         * @param {String} title
         * @returns {storm/model/SilkMessageBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/SilkMessageBuilder#
         */
        setTitle: function (title) {
            this._attrs.title = title;
            return this;
        },

        /**
         * Set the description for building this model.
         * @param {String} description
         * @returns {storm/model/SilkMessageBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/SilkMessageBuilder#
         */
        setDescription: function (description) {
            this._attrs.description = description;
            return this;
        },


        /**
         * Build the SilkMessage model.
         * @returns {storm/model/SilkMessage} the SilkMessage model
         * @public
         * @method
         * @memberof storm/model/SilkMessageBuilder#
         */
        build: function () {
            return new SilkMessage(this._attrs);
        }
    });

    return SilkMessageBuilder;
});
/**
 * Returns a singleton responsible for mapping SILK error conditions (possibly other status information) to human-readable.
 * @name sSilkMessagesManager
 * @memberof storm/mgr
 * @class storm/mgr/sSilkMessagesManager
 */
define("storm/mgr/sSilkMessagesManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "tve/TVEError",
    "storm/mgr/sEditorialManager",
    "storm/mgr/sLanguageManager",
    "storm/model/SilkMessageBuilder"
], function (
    klass,
    util,
    promise,
    console,
    TVEError,
    sEditorialManager,
    sLanguageManager,
    SilkMessageBuilder
    ) {

    "use strict";

    var SilkMessagesManager = klass.create({
    }, {

        //
        // A single editorial source provides information about two distinct types of product:
        //     Day passes
        //     Subscriptions (giving access to one or more packages)
        //
        // Note that a user can have at most ONE subscription at any given time.
        //

        getSilkMessageForCode: function(providedCode) {
            return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.SILK_MESSAGES).then(function(response){
                try {
                    var messages = response.responseJSON.messageList.messageItem,
                        builtMessage;

                    util.each(messages, function(oneMessage) {
                        if (oneMessage.code === providedCode) {
                            builtMessage = new SilkMessageBuilder()
                                .setCode(providedCode)
                                .setTitle(oneMessage.title)
                                .setDescription(oneMessage.description && oneMessage.description.length ? oneMessage.description : oneMessage.short_description) // There's also a 'short_description' but it's very short!
                                .build();

                            return util.breaker;
                        }
                    });

                    if (builtMessage) {
                        return promise.resolve(builtMessage);
                    }
                } catch (e) {
                    console.warn("Unable to map error code " + providedCode + ": " + e);
                }

                // As a last resort, return a generic / default message.

                return sLanguageManager.getInitPromise().then(function() {
                    return promise.resolve(new SilkMessageBuilder()
                        .setCode(providedCode)
                        .setTitle(sLanguageManager.getString("Errormessages.Errormessages_GenericErrorMessageHeadline"))
                        .setDescription(sLanguageManager.getString("Errormessages.Errormessages_labelErrorMessage"))
                        .build());
                });
            });
        }

    });

    return new SilkMessagesManager();
});
/**
 * UserEvent is an enumeration of the events used to notify the UI that a particular user event has occurred.
 * @readonly
 * @enum {String}
 * @name UserEvent
 */
define("storm/event/UserEvent", {
    /**
     * User data requires update.
     */
    UserDataRequireUpdate: "UserEvent:UserDataRequireUpdate",
    /**
     * User data has been updated.
     */
    UserDataUpdated: "UserEvent:UserDataUpdated",
    /**
     * User has been logged out.
     */
    UserHasBeenLoggedOut: "UserEvent:UserHasBeenLoggedOut",
    /**
     * User session is kicked out.
     */
    UserSessionKickedOut: "UserEvent:UserSessionKickedOut"
});
/**
 * SILK responses all need some generic processing, and many can return the same kinds of error conditions.
 * @module storm/helper/silkResponseHelper
 * @name silkResponseHelper
 * @memberof storm/helper
 */
define("storm/helper/silkResponseHelper", [
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/promise",
    "xdk-ax/mediator",
    "tve/TVEError",
    "storm/mgr/sSilkMessagesManager",
    "tvedemo/helper/dialogHelper",
    "storm/event/UserEvent"
], function (
    util,
    evtType,
    focusManager,
    promise,
    mediator,
    TVEError,
    sSilkMessagesManager,
    dialogHelper,
    UserEvent
    ) {

    "use strict";

    var SILK_OUTCOME_MESSAGE = {
            SUCCESS: "OK",
            FAILURE: "KO"
        };

    return {

        SILK_CODE : {
            NO_ERRORS: "S_100",
            NULL_SESSION_ID: "S_217",
            USER_NOT_FOUND_ON_SILK_CACHE: "S_218",
            NO_DATA_FOUND: "S_232",
            ALREADY_LOGGED_IN: "T_206",
            NO_ACTIVE_SESSION: "T_208",
            PLAY_SESSION_TOKEN_LIFESPAN_REACHED: "S_230",
            NO_ASSET_ID: "S_226",
            INVALID_PLAY_SESSION_TOKEN: "S_229",
            DOMAIN_NOT_EXISTING: "T_402", // According to the SILK documentation this means no devices (ever?) registered.
            USER_HAS_TOO_MANY_DEVICES_REGISTERED: "T_403"
        },

        MODE: {
            NOISY: undefined,
            SILENT: "silent",
            BLOCK_EVENTS: "block_events"
        },

        /**
         * Inspect a SILK response, and take some basic / generic actions, based on it.
         *
         * @memberOf storm/helper/silkResponseHelper#
         */
        skimSilkResponse: function (responseObject, bMode, eventMode) {
            var deferredResult = promise.defer();

            try {
                if (responseObject.resultMessage !== SILK_OUTCOME_MESSAGE.SUCCESS) {
                    //
                    // Certain error codes may trigger specific action...
                    //
                    switch(responseObject.resultCode) {
                        case this.SILK_CODE.NO_ERRORS:
                            break;

                        // Already logged in is handled by EndUserManager.
                        case this.SILK_CODE.ALREADY_LOGGED_IN:
                            deferredResult.resolve(responseObject);
                            break;

                        case this.SILK_CODE.USER_NOT_FOUND_ON_SILK_CACHE:

                            if (eventMode !== this.MODE.BLOCK_EVENTS) {
                                mediator.publish(UserEvent.UserSessionKickedOut);
                            }

                            deferredResult.resolve(responseObject);
                            break;
                    }
                    //
                    // In 'noisy' mode we can centralise error popup display...
                    //
                    sSilkMessagesManager.getSilkMessageForCode(responseObject.resultCode).then(util.bind(function(silkMessage) {

                        if (bMode !== this.MODE.SILENT) {
                            //
                            // @TODO: In 'noisy' mode, don't resolve the promise at all, until the popup has been viewed and closed.
                            // This works best if the popup is truly modal, so we're not doing that yet.
                            //

                            // Note that we have Global.Global_genericBackendError language string available to us.

                            dialogHelper.error({
                                title: silkMessage.get("title"),
                                reason: silkMessage.get("description")
                            });
                        }
                    }, this));

                    deferredResult.reject(responseObject);
                } else {

                    if (responseObject.reloadUserData && (eventMode !== this.MODE.BLOCK_EVENTS)) {
                        mediator.publish(UserEvent.UserDataRequireUpdate);
                    }

                    deferredResult.resolve(responseObject);
                }

            } catch (e) {
                deferredResult.reject("Unable to skim SILK response: " + e);
            }

            return deferredResult.promise;
        }

    };
});
/**
 * The StormService provides some services previously provided, in TVE Demo, by AccedoOvpService.
 * That means including some or all of LinearContentService and VODContentService.
 * @name StormService
 * @memberof tve
 * @class tve/StormService
 * @augments tve/interface/LinearContentService
 * @augments tve/interface/VODContentService
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/StormService", [
    "xdk-base/ax",
    "xdk-base/console",
    "xdk-base/promise",
    "tve/util/CacheHelper",
    "tve/TVEError",
    "tve/interface/LinearContentService",
    "tve/sAppGridServiceHolder",
    "storm/mgr/sAppConfigManager",
    "tvedemo/helper/sMoment",
    "storm/helper/util",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sTokenManager",
    "storm/mgr/sEditorialManager",
    "storm/mgr/sLinearChannelManager",
    "storm/helper/silkResponseHelper"
], function (
    ax,
    console,
    promise,
    CacheHelper,
    TVEError,
    LinearContentService,
    sAppGridServiceHolder,
    sAppConfigManager,
    moment,
    stormUtil,
    sLanguageManager,
    sTokenManager,
    sEditorialManager,
    sLinearChannelManager,
    silkResponseHelper
    ) {

    "use strict";

    var FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,
        DATETIME_FAILURE_PERIOD = 10,// In SECONDS; if we can't synchronise even once after this long let's give up.
        DATETIME_RESYNCH_PERIOD = 15 * 60 * 1000,// In milliseconds; don't pester the server too much.
        DATETIME_ADVANCE_PERIOD = 30 * 1000,// In milliseconds; keep UI idea of current time moving > once per minute.
        SORTING = {
            DESC: "desc",
            ASC: "asc"
        },

        // Mapping product/catalog identifiers that have been found during development
        // against catalog identifiers recognized by the backend.
        CATALOGS = {
            STORM: ["ST", "skygo", "sg"],
            SNAP: ["HE", "snap", "sn"]
        },
        CATALOG_MAPPING = {
            STORM: "sg",
            SNAP: "sn"
        },

        getCatalogIdentifier = function (catalog) {

            if (CATALOGS.STORM.indexOf(catalog) !== -1) {
                return CATALOG_MAPPING.STORM;

            } else if (CATALOGS.SNAP.indexOf(catalog) !== -1) {
                return CATALOG_MAPPING.SNAP;
            }
        },

        /**
         * private API functions for OVP related service.
         * @member stormService
         * @memberof tve/StormService#
         * @private
         */
        stormService = {
            initDefer: ax.promise.defer(),
            cacheHelper: null,
            roots: {}, // To allow CMS, EHUB, SILK, etc to be hosted more independently.
            paths: {},
            product: {},
            platform: {},

            proxy: null,
            proxyHosts: null,
            __serverDateTime: undefined,
            __serverDateTimeDefer: ax.promise.defer(),
            __channelIds: [],

            version: ax.config.get("version"),

            init: function (cacheHelper, proxy, proxyHosts, production) {

                this.isProduction = production;
                this.cacheHelper = cacheHelper;

                //
                // The proxy parameter to init will be populated only if not on actual device.
                // See this.__opts.proxy in init().
                //

                this.proxy = proxy;
                this.proxyHosts = proxyHosts;

                //
                // StormService lies within the ServiceHolder, which is required very early on.
                // This means the AppGridService may not be ready yet (since it needs sEnv to be
                // in place to acquire the unique device ID passed to the AppGrid back end).
                //
                // We therefore complete our configuration on a promise that the AppGrid service is up...
                //

                sAppGridServiceHolder.getAppGridServicePromise().then(ax.util.bind(function(){
                    var _promises = [];

                    _promises.push(sAppConfigManager.getEhubConfig());
                    _promises.push(sAppConfigManager.getCmsConfig());
                    _promises.push(sAppConfigManager.getSilkConfig());
                    _promises.push(sAppConfigManager.getSearchConfig());

                    ax.promise.all(_promises).then(
                        ax.util.bind(function(responses) {
                            var environmentName = this.isProduction?"production":"test";

                            this.roots.ehub = responses[0].root[environmentName];
                            this.paths.ehub = responses[0].paths;

                            // Manually add onair path, because we don't have access to changing AppGrid right now
                            // !@TODO: Add to appgrid
                            this.paths.ehub.onair = "/epgd/st/onAir/{channel_id}/";

                            this.roots.cms = responses[1].root[environmentName];
                            this.paths.cms = responses[1].paths;

                            this.roots.silk = responses[2].root[environmentName];
                            this.product.silk = responses[2].product[environmentName];
                            this.platform.silk = responses[2].platform[environmentName];
                            this.paths.silk = responses[2].paths;

                            this.roots.search = responses[3].root[environmentName];
                            this.product.search = responses[3].product[environmentName];
                            this.platform.search = responses[3].platform[environmentName];
                            this.paths.search = responses[3].paths;

                            this.initDefer.resolve(); // This will allow any requests to proceed that have been blocked waiting on this config.

                            this.__synchroniseServerDateTime();
                        }, this),
                        ax.util.bind(function(reason) {
                            this.initDefer.reject("StormService init not completed: " + reason);

                            // Make sure UI isn't blocked on the date/time server promise...
                            this.__serverDateTimeDefer.reject("Date/time sync impossible: " + reason);
                        }, this)
                    );
                }, this));

                //sEditorialManager.initRequestPromises(this.request);
            },

            /**
             * Allow callers to wait for this component to be guaranteed initialised in full.
             * Some of that initialisation is asynchronous, dependent on sEnv up, then AppGrid accessed.
             * @param opts
             * @returns {*}
             */
            initialisedPromise: function() {
                return this.initDefer.promise;
            },

            /**
             * Function to supplement available CMS navigation.xml
             * @method getNavigationOverrides
             */
            getNavigationOverrides: function() {
                return this.initialisedPromise().then(ax.util.bind(function(){
                    return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.NAVIGATION_OVERRIDES).then(ax.util.bind(function (transport) {
                        return JSON.parse(transport.response)[this.isProduction?"production":"test"];
                    }, this));
                }, this));
            },

            /**
             * Function to supplement available CMS navigation.xml
             * @method getHomePageHighlights
             */
            getHomePageHighlights: function() {
                return this.initialisedPromise().then(ax.util.bind(function(){
                    return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.HOMEPAGE_HIGHLIGHTS).then(ax.util.bind(function (transport) {
                        return JSON.parse(transport.response)[this.isProduction?"production":"test"];
                    }, this));
                }, this));
            },

            /**
             * Obtain the clipToken for this item, if we can.
             * @method getClipToken
             * @param {clipItem} Object describing the clip items for which we need a token.
             * @returns
             */
            getClipToken: function(clipItem) {
                return this.initialisedPromise().then(ax.util.bind(function() {
                    var clipTokenApiUrl = this.roots.silk + this.paths.silk.clipToken;

                    // TODO: Determine params based on login state, flavour of clipItem etc!

                    clipTokenApiUrl = this.__completeSilkUrl(clipTokenApiUrl + "?clipType=FREE");

                    var requestOpts = {};
                    requestOpts.method = "post";

                    return this.request(clipTokenApiUrl, requestOpts).then(function(outcome) {
                        return silkResponseHelper.skimSilkResponse(outcome, silkResponseHelper.MODE.SILENT).then(function() {

                            // @TODO: Pass free / not free type based on clipType parameter passed above (once it's not hardcoded as free).
                            var encryptedToken = {name: outcome.tokenName, value: outcome.tokenValue, type: sTokenManager.TYPE.FREE},
                                decryptedToken = sTokenManager.getDecryptedToken(encryptedToken);

                            return decryptedToken;
                        }, function() {
                            // Return a more specific rejection; we could have omitted this fail function completely to let the skim reject fall through.
                            return ax.promise.reject("Clip token request failed " + outcome.resultCode);
                        });
                    });
                }, this));
            },

            /**
             * Function to support login
             * @method loginUser
             * @param {opts} [username] username/email
             * @param {opts} [password] password
             */
                loginUser: function(opts) {
                return this.initialisedPromise().then(ax.util.bind(function() {
                    opts = opts || {};

                    var loginApiUrl = this.roots.silk + this.paths.silk.login;

                    //The customer email address, if left empty the customerCode parameter should be verified or vice versa
                    if (opts.username && opts.username.indexOf("@") > 0) {
                        loginApiUrl = this.__completeSilkUrl(loginApiUrl + "?email=" + opts.username + "&password=" + opts.password);
                    } else {
                        loginApiUrl = this.__completeSilkUrl(loginApiUrl + "?customerCode=" + opts.username + "&password=" + opts.password);
                    }

                    var requestOpts = {};
                    requestOpts.method = "post";
                    // Not use cache to store user response
                    return this.request(loginApiUrl, requestOpts, opts, true);
                }, this));
            },

            /**
             * Function to support logout
             * @method logoutUser
             * @param {opts} [skygoSessionId] sessionId
             */
            logoutUser: function(opts) {
                return this.initialisedPromise().then(ax.util.bind(function(){
                    var url = this.roots.silk + this.paths.silk.logout;
                    url = this.__completeSilkUrl(url + "?skygoSessionId=" + opts.sessionId);
                    opts.method = "delete";

                    // Not use cache to store user response
                    return this.request(url, opts, null, true);
                }, this));
            },


            /**
             * Kill the current session if user is already logged in and trying to login again.
             * @method killSession
             * @param {opts} [skygoSessionId] sessionId
             */
            killSession: function(opts) {
                return this.initialisedPromise().then(ax.util.bind(function(){
                    opts = opts || {};
                    var url = this.roots.silk + this.paths.silk.kill;
                    url = this.__completeSilkUrl(url + "?skygoSessionId=" + opts.sessionId);
                    opts.method = "post";

                    // Not use cache to store user response
                    return this.request(url, opts, null, true);
                }, this));
            },

            userDataRequest: function (options) {
                options = options || {};

                var url = this.roots.silk + this.paths.silk.userData;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + options.sessionId);

                options.method = "get";
                // Not use cache to store user response
                return this.request(url, options, null, true);
            },

            getCustomerBookmarks: function(options) {
                options = options || {};

                var url = this.roots.silk + this.paths.silk.bookmark;

                url = this.__completeSilkUrl(url + "?skygoSessionId=" + options.sessionId + "&assetId=" + options.assetId);

                options.method = "get";

                return this.request(url, options, {}, true);
            },

            toggleBookmarkRequest: function (options) {
                options = options || {};

                var url = this.roots.silk + this.paths.silk.bookmark;

                url = this.__completeSilkUrl(url + "?skygoSessionId=" + options.sessionId + "&bookmarkFlag=" + options.bookmark);

                options.method = "put";
                return this.request(url, options, {}, true);
            },

            acceptTermsAndConditionsRequest: function (options) {
                options = options || {};

                var url = this.roots.silk + this.paths.silk.acceptTerms;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + options.sessionId+ "&termsAndConditionsFlag=" + options.acceptTermsAndConditions + "&privacyFlag=" + options.privacyFlag);

                options.method = "put";
                return this.request(url, options);
            },

            fskPinCheckRequest: function (options) {
                options = options || {};

                var url = this.roots.silk + this.paths.silk.checkMpPin;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + options.sessionId + "&password=" + options.fskPin);

                options.method = "get";
                // Not use cache to store user response
                return this.request(url, options, null, true);

            },

            getDeviceDetails: function(opts) {
                opts = opts || {};

                var url = this.roots.silk + this.paths.silk.device;
                url = this.__completeSilkUrl(url + (opts.sessionId ? "?skygoSessionId=" + opts.sessionId : "?"));

                // Not use cache to store response
                return this.request(url, opts, null, true);
            },

            resetDeviceList: function(opts) {
                opts = opts || {};

                var url = this.roots.silk + this.paths.silk.device;
                url = this.__completeSilkUrl(url + (opts.sessionId ? "?skygoSessionId=" + opts.sessionId : "?"));

                opts.method = "delete";
                // Not use cache to store response
                return this.request(url, opts, null, true);
            },

            /**
             * get watchlist for the logged in User.
             * @method getUserWatchList
             * @memberOf tve/StormService#
             */
            getUserWatchList: function(opts) {
                opts = opts || {};

                var url = this.roots.silk + this.paths.silk.watchlist;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + opts.sessionId);

                // Not use cache to store user response
                return this.request(url, opts, null, true);
            },

            /**
             * add asset to the logged in User watchlist.
             * @method addAssetToUserWatchList
             * @param {opts} sessionId
             * @param {opts} assetId
             * @return {opts} assetType
             * @memberOf tve/StormService#
             */
            addAssetToUserWatchList: function(opts, sessionId) {
                opts = opts || {};

                var catalogIdentifier = getCatalogIdentifier(opts.catalog),
                    url = this.roots.silk + this.paths.silk.watchlist;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + sessionId + "&assetId=" + opts.assetId + "&type=" + opts.assetType + "&catalog=" + catalogIdentifier);

                opts.method = "post";
                // Not use cache to store user response
                return this.request(url, opts, null, true);
            },
            /**
             * remove asset from the loggedin User watchlist.
             * @method removeAssetFromWatchList
             * @param {opts} sessionId
             * @param {opts} assetId
             * @memberOf tve/StormService#
             */
            removeAssetFromWatchList: function(opts, sessionId) {
                opts = opts || {};

                var url = this.roots.silk + this.paths.silk.watchlist;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + sessionId + "&assetId=" + opts.assetId);

                // Note: SILK API doc v1.10 incorrectly states that POST should be used as method.
                opts.method = "delete";
                // Not use cache to store user response
                return this.request(url, opts, null, true);
            },

            /**
             * fetch recently watched items by User
             * @method getRecentlyWatched
             * @memberOf tve/StormService#
             */
            getRecentlyWatched: function(opts) {
                opts = opts || {};

                var url = this.roots.silk + this.paths.silk.lastWatched;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + opts.sessionId);

                // Not use cache to store user response
                return this.request(url, opts, null, true);
            },

            /**
             * add item to recently watched List
             * @method addAssetToRecentlyWatched
             * @memberOf tve/StormService#
             */
            addAssetToRecentlyWatched: function(options) {
                options = options || {};

                var url = this.roots.silk + this.paths.silk.lastWatched;
                url = this.__completeSilkUrl(url + "?skygoSessionId=" + options.sessionId + "&assetId=" + options.assetId + "&title=" + options.title + "&color=" + options.color + "&isHD=" + (options.isHD ? "Y" : "N") + "&fsk=" + options.fsk + "&imageUrl=" + options.imageUrl+ "&type=" + options.type);
                if (options.apixId && options.apixId.length > 0) {
                    url = url + "&id=" + options.apixId;
                }
                options.method = "post";
                // Not use cache to store user response
                return this.request(url, options, null, true);
            },

            cmsRequest: function(path, opts) {
                return this.initialisedPromise().then(ax.util.bind(function() {
                    return this.__simpleRequest(this.roots.cms, path, opts);
                }, this));
            },

            epgRequest: function(opts) {
                return this.initialisedPromise().then(ax.util.bind(function(){
                    return this.__simpleRequest(this.roots.ehub, this.paths.ehub.excerpt, opts);
                }, this));
            },

            onAirRequest: function(opts, parameters) {
                opts = opts || {};

                // to be put as ajax parameters, should not be accessed directly from out of module
                var parameters = parameters || {},
                    url = this.roots.ehub + this.paths.ehub.onair;

                url = stormUtil.tokenReplacer(url, function (match, key) {
                    if (key === "channel_id") {
                        return opts.channelId;
                    } else {
                        return "";
                    }
                });

                return this.request(url, parameters, undefined, true);
            },

            navigationRequest: function(opts) {
                // @TODO: Cache this?
                return this.initialisedPromise().then(ax.util.bind(function(){
                    // return this.__simpleRequest(this.roots.cms, this.paths.cms.navigation, opts);
                    return this.__simpleRequest('http://skystorm-test.ocs.demo.accedo.tv/', 'sky_nav.php', opts);
                }, this));
            },

            __advanceServerDateTime: function() {
                if (!ax.util.isUndefined(this.__serverDateTime)) {
                    this.__serverDateTime.setMilliseconds(this.__serverDateTime.getMilliseconds() + DATETIME_ADVANCE_PERIOD);
                }
            },

            __synchroniseServerDateTime: function() {
                this.__dateTimeSyncHandle = undefined; // The timeout has fired; a fresh one may not be set up.

                this.dateTimeRequest().then(ax.util.bind(function(response){
                    // Example raw response:
                    // {"date":"15.09.2014","time":"16:35"}
                    try {
                        var sourceDateTime = response.date + " " + response.time,
                        resultingMoment = moment(sourceDateTime, "DD.MM.YYYY HH:mm");

                        if (resultingMoment.isValid()) {
                            this.__serverDateTime = resultingMoment.toDate();
                            if (ax.promise.isFulfilled(this.__serverDateTimeDefer.promise)) {
                                this.__serverDateTimeDefer = ax.promise.defer();
                            }
                            this.__serverDateTimeDefer.resolve(this.__serverDateTime);

                            // If this is the first time we've managed to synchronise, we start our local tick now...
                            if (ax.util.isUndefined(this.__dateTimeAdvanceHandle)) {
                                this.__dateTimeAdvanceHandle = setInterval(ax.util.bind(function () {
                                    this.__advanceServerDateTime();
                                }, this), DATETIME_ADVANCE_PERIOD);
                            }

                            //
                            // Resynchronise with back end from time to time, to correct drift, and to handle DST changes (rather crudely).
                            // We don't use the returned value yet, but it may come in handy for unit tests at some point...
                            // ... and in any case, timeouts that are left completely dangling are bad practice.
                            //
                            this.__dateTimeSyncHandle = setTimeout(ax.util.bind(function(){this.__synchroniseServerDateTime();}, this), DATETIME_RESYNCH_PERIOD);

                        } else {
                            console.warn("Date/time synchronisation failed, due to invalid " + sourceDateTime);
                            if (ax.util.isUndefined(this.__serverDateTime)) {
                                this.__serverDateTimeDefer.reject(new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "Invalid date/time: " + sourceDateTime));
                                // If it's been resolved before, this reject should have no effect since it's become immutable.
                            }
                        }
                    } catch(e) {
                        console.warn("Date/time synchronisation failed, due to " + e);
                        if (ax.util.isUndefined(this.__serverDateTime)) {
                            this.__serverDateTimeDefer.reject(e);
                        }
                    }
                }, this), ax.util.bind(function(e){
                    if (!ax.util.isUndefined(this.__serverDateTime)) {
                        console.error("Date and time may slip out of sync, due to " + e);
                    } else {
                        console.error("Date and time may be presented incorrectly in UI, due to " + e);
                        this.__serverDateTimeDefer.reject(e);
                    }
                }, this));
            },

            /**
             * Function to tack on parameters required for all SILK API calls
             * @method __completeSilkUrl
             * @param {string} [path] the url which should have bse url as prefix and query parameters as suffix.
             */
            __completeSilkUrl: function(path) {
                return path + "&product=" + this.product.silk +"&platform=" + this.platform.silk + "&version=" + this.version;
            },

            /**
             * Function to tack on parameters required for all Search-related API calls
             * @method __completeSearchUrl
             * @param {string} [path] the url which should have bse url as prefix and query parameters as suffix.
             */
            __completeSearchUrl: function(path) {
                return path + "&product=" + this.product.search +"&platform=" + this.platform.search + "&version=" + this.version;
            },

            __simpleRequest: function(root, path, opts) {
                if (!root || !root.length) {
                    return ax.promise.reject("Request root is empty");
                }
                if (!path || !path.length) {
                    return ax.promise.reject("Request path is empty");
                }
                opts = opts || {};
                return this.request(root + path, opts);
            },

            heartbeatRequest: function (param) {
                return this.initialisedPromise().then(ax.util.bind(function() {
                    var opts = {
                        method: "put"
                    },
                    url = this.roots.silk + this.paths.silk.heartbeat,
                    playSessionToken = "";

                    if (param.playSessionToken) {
                        playSessionToken = "&playSessionToken=" + param.playSessionToken;
                    }

                    url = url + "?skygoSessionId=" + param.skygoSessionId + "&assetId=" + param.assetId + playSessionToken;

                    if (param.playedTime && param.duration) {
                        url = url + "&bookmark=" + (param.playedTime >> 0) + "&duration=" + (param.duration >> 0)
                    }

                    url = this.__completeSilkUrl(url);

                    return this.request(url, opts, null, true);
                }, this));
            },

            searchRequest: function (keyword, opts) {
                opts = opts || {};

                return this.initialisedPromise().then(ax.util.bind(function() {
                    var url = this.roots.search + this.paths.search.search,
                        parameters = "?searchKey=" + encodeURIComponent(keyword) + (opts.catalog ?  "&catalog=" + opts.catalog : "");

                    url = this.__completeSearchUrl(url + parameters);
                    return this.request(url, opts);
                }, this));
            },

            serverDateTimePromise: function() {
                return this.__serverDateTimeDefer.promise;
            },

            dateTimeRequest: function() {
                return this.initialisedPromise().then(ax.util.bind(function() {
                    var url = this.roots.ehub + this.paths.ehub.datetime + "?" + Math.random(); // Thwart any kind of caching.
                    return this.request(url, {timeOut: DATETIME_FAILURE_PERIOD});
                }, this));
            },

            // ==== ILinearContentService ====
            channelRequest: function (opts) {
                opts = opts || {};

                var url = this.roots.ehub + this.paths.ehub.channels,
                    ids = opts.id,
                // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    url += "/" + ids;
                    delete opts.id;
                }

                return this.request(url, opts, parameters);
            },

            // a little bit different handling to standard channel
            channelByCategoryRequest: function (opts) {
                opts = opts || {};

                if (!opts.id) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided in OVP API"));
                }
                ax.util.extend(opts, {
                    objType: "channel"
                });
                return this.categoryRequest(opts);
            },

            channelListingRequest: function (opts) {
                opts = opts || {};

                var url = this.roots.ehub + this.paths.ehub.events,
                    ids = opts.channelId,
                // to be put as ajax parameters, should not be accessed directly from out of module
                    parameters = parameters || {};

                if (!opts.startTime || !opts.endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided in OVP API"));
                }

                var formatDate = function(date) {
                    var dd = date.getDate(),
                        mm = date.getMonth() + 1, //January is 0!
                        yyyy = date.getFullYear();
                    dd = dd < 10 ? "0" + dd : dd;
                    mm = mm < 10 ? "0" + mm : mm;

                    return dd + "." + mm + "." + yyyy;
                };

                url += "/"+formatDate(new Date(opts.startTime));

                // by Ids
                if (ids) {
                    ids = ids.join ? ids.join() : ids;
                    delete opts.channelId;
                } else {
                    ids = this.__channelIds.join(",");
                }
                url += "/" + ids + "/";

                return this.request(url, opts, parameters);
            },

            eventDetailsRequest: function (opts) {
                opts = opts || {};

                // to be put as ajax parameters, should not be accessed directly from out of module
                var parameters = parameters || {},
                    url = this.roots.ehub + this.paths.ehub.eventDetail;

                url = stormUtil.tokenReplacer(url, function (match, key) {
                    if (key === "event_id") {
                        return opts.programId;
                    } else if (key === "channel_id") {
                        return opts.channelId;
                    } else {
                        return "";
                    }
                });

                return this.request(url, opts, parameters);
            },

            assetDetailRequest: function (assetId, catalog) {

                if (!assetId || !catalog) {
                    return ax.promise.reject("Incorrect assetId or catalog");
                }

                var catalogIdentifier = getCatalogIdentifier(catalog),
                    url = this.roots.cms + ((catalogIdentifier === CATALOG_MAPPING.STORM) ? this.paths.cms.stormAsset : this.paths.cms.snapAsset);

                url = stormUtil.tokenReplacer(url, function (match, key) {
                    if (key === "assetId") {
                        return assetId;
                    } else {
                        return "";
                    }
                });

                return this.request(url);
            },

            serieAssetDetailRequest: function (serieAssetId, catalog) {
                if (!serieAssetId) {
                    return ax.promise.reject("Incorrect serieAssetId");
                }

                var cataLogIdentifier = getCatalogIdentifier(catalog),
                    url = this.roots.cms + ((cataLogIdentifier === CATALOG_MAPPING.STORM) ? this.paths.cms.stormSeriesGlobal : this.paths.cms.snapSeriesGlobal);

                url = stormUtil.tokenReplacer(url, function (match, key) {
                    if (key === "serieAssetId") {
                        return serieAssetId;
                    } else {
                        return "";
                    }
                });

                return this.request(url);
            },

            seasonAssetDetailRequest: function (seasonAssetId, catalog) {
                if (!seasonAssetId) {
                    return ax.promise.reject("Incorrect seasonAssetId");
                }

                var cataLogIdentifier = getCatalogIdentifier(catalog),
                    url = this.roots.cms + ((cataLogIdentifier === CATALOG_MAPPING.STORM) ? this.paths.cms.stormSeason : this.paths.cms.snapSeason);

                url = stormUtil.tokenReplacer(url, function (match, key) {
                    if (key === "seasonId") {
                        return seasonAssetId;
                    } else {
                        return "";
                    }
                });

                return this.request(url);
            },

            keepAlive: function(skygoSessionId) {
                var opts = {
                        method: "put"
                    },
                    url = this.roots.silk + this.paths.silk.keepAlive;

                url = this.__completeSilkUrl(url + "?skygoSessionId=" + skygoSessionId);
                // Not use cache to store response
                return this.request(url, opts, null, true);
            },

            sportNewsByCategoryRequest: function (categoryId) {
                var url = this.roots.cms + this.paths.cms.sportNewsCategory;

                url = stormUtil.tokenReplacer(url, function (match, key) {
                    if (key === "categoryId") {
                        return categoryId;
                    } else {
                        return "";
                    }
                });

                return this.request(url);
            },

            /**
             * @param {String} url Absolute location to be request
             * @param {Object} [opts = {}] Optional rules to send and cache the request
             * @param {String} [opts.method = get] Request method, get | post | put | delete
             * @param {String} [opts.timeOut] Timeout of the request
             * @param {Object} [opts.requestHeaders = {"Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}] Headers to send the request
             * @param {Object} [param = {}] Parameters in the request
             * @param {Boolean} [disableCache = false] Cache requests as default, but can be disabled by setting to true.
             */
            request: function (url, opts, param, disableCache) {
                opts = opts || {};
                param = param || {};

                var __opts,
                    __cacheHelper = this.cacheHelper,
                    cached_key = JSON.stringify({
                        "url": url,
                        "opts": opts,
                        "param": param
                    }),
                    cached_data = __cacheHelper.getCache(cached_key),
                    cached_since = 0;

                if (!ax.util.isUndefined(cached_data)) {
                    // if not expired, resolve with cache data
                    if (!__cacheHelper.isExpired(cached_key)) {
                        return ax.promise.resolve(cached_data);
                    } else {
                        cached_since = __cacheHelper.getTimestamp(cached_key);
                    }
                }

                // This request will fail with http error code 411 when app is running on Samsung 2012 and 2013,
                // unless this header is present within this request.
                opts.requestHeaders = ax.util.extend(opts.requestHeaders || {}, {
                    "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
                });

                __opts = {
                    method: opts.method || "get",
                    timeOut: opts.timeOut, // Possibly undefined, which means use default (within ax/ajax).
                    parameters: param,
                    requestHeaders: opts.requestHeaders
                };

                if (ax.config.get("environment") === "test" && ax.config.get("dev.replaceHost",false))
                {
                    // Look for hosts to replace if this is test environment
                    var findHosts       = ax.config.get("dev.findHosts",[]);
                    var replaceHosts    = ax.config.get("dev.replaceHosts",[]);

                    var foundHostIndex = -1;
                    for (var i=0; i<findHosts.length; i++)
                    {
                        if (url.indexOf(findHosts[i]) > 0)
                        {
                            foundHostIndex = i;
                            break;
                        }
                    }
                    if (foundHostIndex > -1)
                    {
                        url = url.replace(findHosts[foundHostIndex], replaceHosts[foundHostIndex]);
                    }
                }


                if(this.proxy && this.proxyHosts.length)
                {
                     // If the url host matches one of the predefined proxy hosts we strip away the host part and let apache rewrite do the job
                    var proxyHost = null;
                    for (var j=0; j<this.proxyHosts.length; j++)
                    {
                        if (url.indexOf(this.proxyHosts[j]) > 0)
                        {
                            proxyHost = this.proxyHosts[j];
                            break;
                        }
                    }
                    if (proxyHost)
                    {
                        var proxyServer = ax.config.get("dev.proxyPath");
                        url = proxyServer+encodeURIComponent(url);
                    }
                }

                return ax.ajax.request(url, __opts).then(
                    function (transport) {
                        var responseJSON = transport.responseJSON;
                        if (!responseJSON) {
                            try {
                                responseJSON = JSON.parse(transport.responseText);
                            } catch (e) {
                                if (!transport.responseXML || !transport.responseXML.childNodes.length) {
                                    throw console.error(e);
                                }
                                responseJSON = transport.responseXML.childNodes[0];
                            }
                        }
                        // save to cache
                        if (!disableCache) {
                            __cacheHelper.setObject(cached_key, responseJSON, +new Date());
                        }
                        return responseJSON;

                    },
                    function (reason) {
                        throw new TVEError(FACILITY.GENERAL, ERROR.NETWORK, reason.transport ? reason.transport.statusText : "network issue", reason);
                    });
            }
        },

    // @TODO: Refactor here, with better naming and correct interfaces.
        OvpService = ax.klass.create([LinearContentService], {
            /**
             * Sorting order
             * @name SORTING
             * @typedef {Object}
             * @property {String} ASC - sort ascending
             * @property {String} DESC - sort descending
             * @public
             * @memberof tve/StormService
             * @static
             */
            SORTING: SORTING

        }, {
            /**
             * CachingHelper Instance, may be used for any OVP related service.
             * @member __cache
             * @memberof tve/StormService#
             * @private
             */
            __cache: null,

            __opts: null,

            /**
             * Init the StormService module
             * @method init
             * @memeberof tve/StormService#
             * @private
             */
            init: function (opts) {
                this.__cache = new CacheHelper();
                this.__opts = opts;
                var proxy;
                var proxyHosts;

                //
                // opts.proxy will be false on Samsung devices; see __getStormService.
                //

                if (this.__opts.proxy) {
                    proxy = this.__opts.proxy; //"proxy.php?url=";
                    proxyHosts = this.__opts.proxyHosts;
                }

                stormService.init(this.__cache, proxy, proxyHosts, opts.production);
            },

            acquireCMSRoot: function () {
                return stormService.initialisedPromise().then(function() {
                    return stormService.roots.cms;
                });
            },

            cmsRequest: function(path, opts) {
                return stormService.cmsRequest(path, opts);
            },

            // ==== Impliment Interfaces ====

            /**
             * Function to supplement available CMS navigation.xml
             * @method getHomePageHighlights
             */
            getNavigationOverrides: function() {
                return stormService.getNavigationOverrides();
            },

            /**
             * Function to supplement available CMS navigation.xml
             * @method getHomePageHighlights
             */
            getHomePageHighlights: function() {
                return stormService.getHomePageHighlights();
            },

            /**
             * Obtain the clipToken for this item, if we can.
             * @method getClipToken
             * @param {clipItem} Object describing the clip items for which we need a token.
             */
            getClipToken: function (clipItem) {
                return stormService.getClipToken(clipItem);
            },

            /**
             * Login user
             * @method loginUser
             * @param {opts} [username] username/email
             * @param {opts} [password] password
             */
            loginUser: function (opts) {
                return stormService.loginUser(opts);
            },

            /**
             * Logout user
             * @method logoutUser
             * @param {opts} [skygoSessionId] sessionId
             */
            logoutUser: function (opts) {
                return stormService.logoutUser(opts);
            },

            acceptTermsAndConditions: function (options) {
                return stormService.acceptTermsAndConditionsRequest(options);
            },

            toggleBookmarkRequest: function (options) {
                return stormService.toggleBookmarkRequest(options);
            },

            getUserData: function (options) {
                return stormService.userDataRequest(options);
            },

            getCustomerBookmarks: function(options) {
                return stormService.getCustomerBookmarks(options);
            },

            /**
             * killSession
             * @method killSession
             * @param {opts} [sessionId] sessionId
             */
            killSession: function(opts) {
                return stormService.killSession(opts);
            },

            checkFskPin: function (options) {
                return stormService.fskPinCheckRequest(options);
            },

            getDeviceDetails: function(opts) {
                return stormService.getDeviceDetails(opts);
            },

            resetDeviceList: function(opts) {
                return stormService.resetDeviceList(opts);
            },

            /**
             * get watchlist for the logged in User.
             * @method getUserWatchList
             */
            getUserWatchList: function(sessionId) {
                var opts = {
                    sessionId : sessionId
                };
                return stormService.getUserWatchList(opts);
            },

            /**
             * add asset to the logged in User watchlist.
             * @method addAssetToUserWatchList
             * @param {opts} sessionId
             * @param {opts} assetId
             * @return {opts} assetType
             */
            addAssetToUserWatchList: function(opts, sessionId) {
                return stormService.addAssetToUserWatchList(opts, sessionId);
            },

            /**
             * remove asset from the loggedin User watchlist.
             * @method removeAssetFromWatchList
             * @param {opts} sessionId
             * @param {opts} assetId
             */
            removeAssetFromWatchList: function(opts, sessionId) {
                return stormService.removeAssetFromWatchList(opts, sessionId);
            },

            /**
             * fetch recently watched items by User
             * @method getRecentlyWatched
             */
            getRecentlyWatched: function(sessionId) {

                var opts = {
                    sessionId : sessionId
                };

                return stormService.getRecentlyWatched(opts);
            },

            /**
             * add asset to recently watchedList
             * @method addAssetToRecentlyWatched
             */
            addAssetToRecentlyWatched: function(opts) {

                return stormService.addAssetToRecentlyWatched(opts);
            },

            /**
             * Get currently running program
             * @method addAssetToRecentlyWatched
             */
            onAirRequest: function(opts, parameters) {
                return stormService.onAirRequest(opts, parameters, undefined, true);
            },

            // ==== ILinearContentService ====

            // Private function
            __getChannel: function (opts) {

                if (opts && opts.categoryId) {
                    opts.id = opts.categoryId;
                    delete opts.categoryId;
                    return stormService.channelByCategoryRequest(opts);
                } else {
                    return stormService.channelRequest(opts);
                }

            },

            /**
             * Get all Channels
             * @method getAllChannels
             * @public
             * @param {Object} opts The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properties: entries, totalCount, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            getAllChannels: function (opts) {
                return this.__getChannel(opts).then(function (json) {
                    if(stormService.__channelIds.length === 0) {
                        ax.util.each(json.channelList, function (channel) {
                            stormService.__channelIds.push(channel.id);
                        });
                    }
                    return {
                        entries: json.channelList,
                        totalCount: json.channelList.length,
                        pageSize: json.channelList.length,
                        pageNumber: 1
                    };
                });
            },

            /**
             * Get all Channels permitted according to the IDs set in config.ehub.permittedChannels
             * @method getPermittedChannels
             * @public
             * @param {Object} opts The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properties: entries, totalCount, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            getPermittedChannels: function (opts) {
                console.log("getPermittedChannels()");
                console.log(opts);
                return this.__getChannel(opts).then(function (json) {

                    var ret = {
                                entries: [],
                                totalCount: 0,
                                pageSize: 0,
                                pageNumber: 1
                            };

                    var promiseArray = [];
                    ax.util.each(json.channelList, function (channel) {
                        console.log("Checking "+channel.id);
                        promiseArray.push(sLinearChannelManager.checkIfChannelIdPermitted(channel.id).then(function(res){
                            console.log(res);
                            ret.entries.push(channel);
                            return res;
                        },
                        function(e) {
                            console.warn(e);
                        }));
                    });
                    return promise.all(promiseArray).then(function(res)
                    {
                        console.log("All channels resolved");
                        ret.totalCount = ret.pageSize = ret.entries.length;
                        console.log(ret);
                        return ret;
                    });
                });
            },

            /**
             * Get all Channels
             * @method getAllChannelIds
             * @public
             * @param {Object} opts The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/AccedoOvpService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Array>} Array of sorted channel ids
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/AccedoOvpService#
             */
            getAllChannelIds: function (opts) {
                return this.__getChannel(opts).then(function (json) {
                    if(stormService.__channelIds.length === 0) {
                        ax.util.each(json.channelList, function (channel) {
                                stormService.__channelIds.push(channel.id);
                        });
                    }
                    return stormService.__channelIds;
                });
            },

            /**
             * Get Channel by Id
             * @method getChannelById
             * @public
             * @param {String} id ChannelID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Channel object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            getChannelById: function (id, opts) {
                if (!id) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no id is provided"));
                }
                opts = opts || {};
                opts.id = id;
                return this.__getChannel(opts);
            },

            /**
             * Get Channels by Ids
             * @method getChannelsByIds
             * @public
             * @param {String[]} ids ChannelIDs
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            getChannelsByIds: function (ids, opts) {
                if (!ids || !ax.util.isArray(ids)) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "incorrect parameter type"));
                }
                opts = opts || {};
                opts.id = ids;

                return this.__getChannel(opts).then(function (json) {
                    return {
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },

            /**
             * Get Channels by Category
             * @method getChannelsByCategoryId
             * @public
             * @param {String} categoryId CategoryID
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelNumber/title
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            getChannelsByCategoryId: function (categoryId, opts) {
                if (!categoryId) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no categoryId is provided"));
                }
                opts = opts || {};
                opts.categoryId = categoryId;

                return this.__getChannel(opts).then(function (json) {
                    return {
                        entries: json.entries,
                        totalCount: json.totalCount,
                        pageSize: json.pageSize,
                        pageNumber: json.pageNumber
                    };
                });
            },

            /**
             * Get all ChannelListings
             * @method getAllChannelListings
             * @public
             * @param {String} startTime startTime
             * @param {String} endTime endTime
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelId
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            getAllChannelListings: function (startTime, endTime, opts) {

                if (!startTime || !endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided"));
                }
                var channelIds = opts.channelId;
                opts = opts || {};
                opts.startTime = startTime;
                opts.endTime = endTime;
                opts.timeOut = 60;

                return stormService.channelListingRequest(opts).then(function (json) {
                    var result = [];

                    //
                    // The listing seems to be naturally returned in channel id order.
                    // We want a known order, captured in __channelIds.
                    //

                    for (var key in channelIds) {
                        if (channelIds.hasOwnProperty(key)) {
                            result.push({
                                channelId: channelIds[key],
                                programs: stormUtil.sanitiseEpgEvents(startTime, endTime, json[channelIds[key]])
                            });
                        }
                    }
                    return {
                        entries: result,
                        totalCount: result.length,
                        pageSize: result.length,
                        pageNumber: 1
                    };
                });
            },

            /**
             * Get ChannelListing by channel Id
             * @method getChannelListingByChannelId
             * @public
             * @param {String} channelId ChannelID
             * @param {String} startTime startTime
             * @param {String} endTime endTime
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelId
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} ChannelListing object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            // @TODO: This not likely to be working, and likely unused. Remove?
            getChannelListingByChannelId: function (channelId, startTime, endTime, opts) {
                if (!channelId) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no channelId is provided"));
                }
                if (!startTime || !endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided"));
                }
                opts = opts || {};
                opts.channelId = channelId;
                opts.startTime = startTime;
                opts.endTime = endTime;

                return stormService.channelListingRequest(opts);
            },

            /**
             * Get ChannelListing by channel Ids
             * @method getChannelListingsByChannelIds
             * @public
             * @param {String[]} channelIds ChannelIDs
             * @param {String} startTime startTime
             * @param {String} endTime endTime
             * @param {Object} [opts] The options object
             * @param {String} [opts.sortingKey] sort by id/channelId
             * @param {tve/StormService.SORTING} [opts.sortingOrder] sorting order. Default is descending
             * @param {Integer} [opts.pageSize] page size. Default is 100
             * @param {Integer} [opts.pageNumber] page number. Default is 1
             * @returns {Promise.<Object>} Object with 4 properites: entries, totalConut, pageSize, pageNumber
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/StormService#
             */
            // @TODO: This not likely to be working, and likely unused. Remove?
            getChannelListingsByChannelIds: function (channelIds, startTime, endTime, opts) {
                if (!channelIds) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no channelIds are provided"));
                }
                if (!startTime || !endTime) {
                    return ax.promise.reject(new TVEError(FACILITY.LINEAR_CONTENT_SERVICE, ERROR.INTERNAL, "no startTime or endTime is provided"));
                }
                opts = opts || {};
                opts.channelId = channelIds;
                opts.startTime = startTime;
                opts.endTime = endTime;

                return stormService.channelListingRequest(opts).then(function (json) {
                    return {
                        entries: ax.util.isArray(json.entries) ? json.entries : [json],
                        totalCount: json.totalCount || 1,
                        pageSize: json.pageSize || 1,
                        pageNumber: json.pageNumber || 1
                    };
                });
            },

            getEventDetails: function (programId, channelId, opts) {
                if (programId === 0) {
                    return ax.promise.resolve({"title1":sLanguageManager.getString("Epg.noDataFoundMessage"), "title2": ""});
                } else {
                    opts = opts || {};
                    opts.programId = programId;
                    opts.channelId = channelId;
                    return stormService.eventDetailsRequest(opts).then(function (program) {
                        return program;
                    });
                }
            },

            getServerDateTime: function() {
                return stormService.serverDateTimePromise();
            },

            getNavigation: function(opts) {
                return stormService.navigationRequest(opts);
            },

            getFirstChildSectionNodeList: function(opts) {
                return stormService.navigationRequest(opts).then(function (data) {
                    var sectionArray = data.querySelectorAll("navigation > section[displayFirstChild=true]");
                    return sectionArray;
                });
            },

            getHighlightsMenu: function(opts) {
                return this.getFirstChildSectionNodeList(opts).then(ax.util.bind(function (sectionArray) {
                    var highlightItem, resultArray = [];
                    for (var i=0,len=sectionArray.length;i<len;i++) {
                        highlightItem = this.__findNodeWithAttribute(sectionArray[i].childNodes, "structureType", "LandingPageHighlights");
                        if (!highlightItem) {
                            continue;
                        }
                        resultArray.push({
                            title: sectionArray[i].getAttribute("label"),
                            path: highlightItem.getAttribute("path")
                        });
                    }
                    return resultArray;
                }, this));
            },

            getHighlightsMenuContentPromise: function(path, structureType, opts) {
                if (!structureType) {
                    structureType = "MostWatchedFilm";  // @TODO: define fallback structureType
                }
                return stormService.cmsRequest(path, opts).then(function (jsonObj) {
                    if (!jsonObj || !jsonObj.listing || !jsonObj.listing.listing || !jsonObj.listing.listing.item) {
                        throw console.error("Highlights jsonObject format incorrect!");
                    }
                    if (!jsonObj.listing.listing.item.length) {
                        return console.info("Highlights content empty");
                    }
                    var listingList = jsonObj.listing.listing.item;
                    for (var i=0,len=listingList.length;i<len;i++) {

                        if (!listingList[i].path) {
                            continue;
                        }
                        if (listingList[i].structureType === structureType) {
                            return stormService.cmsRequest(listingList[i].path, opts);
                        }
                    }
                    return ax.promise.resolve({});
                });
            },

            getCurrentlyRunningEvents: function(opts) {
                return stormService.navigationRequest(opts).then(ax.util.bind(function (data) {
                    var epgOrderNode = this.__findNodeWithAttribute(data.childNodes, "structureType", "LandingPageStartScreen");
                    if (!epgOrderNode) {
                        return;
                    }
                    var path = epgOrderNode.getAttribute("path");
                    return ax.promise.all([
                        stormService.cmsRequest(path),
                        stormService.epgRequest()
                    ]).then(function(responses) {
                        var epgTabDescription,
                            epgSource = responses[1],
                            includedTabs = [],
                            events = [];

                        // retrieve EPG tab information
                        if (!responses[0].listing || !responses[0].listing.info ||
                            !responses[0].listing.info.EPGEexcerpt || !responses[0].listing.info.EPGEexcerpt.tab) {
                            throw console.error("No EPG tab information found");
                        }
                        epgTabDescription = responses[0].listing.info.EPGEexcerpt.tab;
                        for (var nTabIndex=0; nTabIndex<epgTabDescription.length; nTabIndex++) {
                            includedTabs.push(epgTabDescription[nTabIndex].ccode);
                        }

                        //
                        // According to SKYSTORM-212 we only use the tab information to specify inclusion / exclusion...
                        //
                        for (var nSourceIndex=0; nSourceIndex<epgSource.length; nSourceIndex++) {
                            if (includedTabs.indexOf(epgSource[nSourceIndex].tabName) !== -1) {
                                events = events.concat(epgSource[nSourceIndex].eventList);
                            }
                        }

                        return events;
                    });
                }, this));
            },

            /**
             * JSON structure: listing->listing->item[]
             * @method getListingItem
             * @returns {Object / Object[]} Object (Array) of item(s)
             * @throws {Promise.reject} invalid parameters
             * @throws {Promise.reject} server CMS structure im-parse-able
             */
            getListingItem: function(path, opts) {
                if (!path || !path.length) {
                    return ax.promise.reject("path is empty");
                }
                return stormService.cmsRequest(path, opts).then(function (jsonObj) {
                    if (!jsonObj || !jsonObj.listing || !jsonObj.listing.listing || !jsonObj.listing.listing.item) {
                        throw console.error("getListingItem: jsonObject format incorrect!");
                    }
                    return jsonObj.listing.listing.item;
                });
            },

            /**
             * JSON structure: listing->items[]
             * @method getListingItem
             * @returns {Object / Object[]} Object (Array) of item(s)
             * @throws {Promise.reject} invalid parameters
             * @throws {Promise.reject} server CMS structure im-parse-able
             */
            getSnapListingItems: function(path, opts) {
                if (!path || !path.length) {
                    return ax.promise.reject("path is empty");
                }
                return stormService.cmsRequest(path, opts).then(function (jsonObj) {
                    if (!jsonObj || !jsonObj.listing || !jsonObj.listing.items) {
                        throw console.error("getSnapListingItems: jsonObject format incorrect!");
                    }
                    return jsonObj.listing.items;
                });
            },

            /**
             * JSON structure: Listing->Asset_Listing->Asset[]
             * @method getAssetList
             * @returns {Object / Object[]} Object (Array) of asset(s)
             * @throws {Promise.reject} invalid parameters
             * @throws {Promise.reject} server CMS structure im-parse-able
             */
            getAssetList: function(path, opts) {
                if (!path || !path.length) {
                    return ax.promise.reject("path is empty");
                }
                return stormService.cmsRequest(path, opts).then(function (jsonObj) {
                    var foundListing = stormUtil.getSanitizedValue(jsonObj, "listing.listing") || stormUtil.getSanitizedValue(jsonObj, "listing.asset_listing");

                    if (!foundListing) {
                        throw console.error("getAssetList: jsonObject format incorrect, no listing");
                    }

                    var foundListingArray = foundListing.asset || foundListing.item;

                    if (!foundListingArray) {
                        throw console.error("getAssetList: jsonObject format incorrect, no listing array");
                    }

                    return {
                        listing: foundListingArray,
                        catalog: jsonObj.product
                    };
                });
            },

            getLetterList: function(path, opts) {
                if (!path || !path.length) {
                    return ax.promise.reject("path is empty");
                }
                return stormService.cmsRequest(path, opts).then(function (jsonObj) {
                    if (!jsonObj || !jsonObj.letters || !jsonObj.letters.letter) {
                        throw console.error("getLetterList: jsonObject format incorrect!");
                    }
                    return jsonObj.letters.letter;
                });
            },
            __findNodeWithAttribute: function(nodeList, attribute, attributeValue, alternative) {
                if (!nodeList || !nodeList.length || !attribute || !attributeValue) {
                    return false;
                }

                for (var i=0,len=nodeList.length;i<len;i++) {
                    if (nodeList[i].getAttribute(attribute) === attributeValue) {
                        return nodeList[i];
                    }
                    if (alternative && nodeList[i].getAttribute(attribute) === alternative) {
                        return nodeList[i];
                    }
                }
                return false;
            },

            getSportLivePlannerPromise: function(sportSectionNode) {
                if (!sportSectionNode || !sportSectionNode.childNodes.length ||
                    !sportSectionNode.getAttribute || sportSectionNode.getAttribute("structureType") !== "SportSection") {
                    return ax.promise.reject("invalid node");
                }
                var defer = ax.promise.defer(),
                    j = 0,
                    subNode,
                    path;
                while ((subNode = sportSectionNode.childNodes[j++])) {
                    if (subNode.getAttribute("structureType") === "LiveplannerSection") {
                        subNode = subNode.firstChild;
                        if (!subNode || !(path = subNode.getAttribute("path"))) {
                            break;
                        }
                        stormService.cmsRequest(path).then(function (jsonObj) {
                            if (!jsonObj.listing || !jsonObj.listing.listing || !jsonObj.listing.listing.item || jsonObj.listing.listing.item.structureType !== "LiveplannerListing") {
                                return defer.reject("invalid node");
                            }
                            stormService.cmsRequest(jsonObj.listing.listing.item.path).then(function (listing) {
                                defer.resolve(listing);
                            });
                        });
                        return defer.promise;
                    }
                }
                return defer.reject("invalid node");
            },

            getSportHighlightSections: function(sportSectionNode) {
                if (!sportSectionNode || !sportSectionNode.childNodes.length ||
                    !sportSectionNode.getAttribute || sportSectionNode.getAttribute("structureType") !== "SportSection") {
                    throw console.error("invalid node");
                }

                var results = [],
                    j = 0,
                    subNode;
                while ((subNode = sportSectionNode.childNodes[j++])) {
                    if (/Section$/.test(subNode.getAttribute("structureType")) && subNode.getAttribute("hide") === "false") {
                        results.push({
                            structureType: subNode.getAttribute("structureType"),
                            text: subNode.getAttribute("label"),
                            displayFirstChild: subNode.getAttribute("displayFirstChild") === "true"
                        });
                    }
                }
                return results;
            },

            getSportHighlightPromise: function(sportSectionNode, sectionName) {
                if (!sportSectionNode || !sportSectionNode.childNodes.length ||
                    !sportSectionNode.getAttribute || sportSectionNode.getAttribute("structureType") !== "SportSection") {
                    return ax.promise.reject("invalid node");
                }

                var defer = ax.promise.defer(),
                    j = 0,
                    subNode,
                    data = [],
                    promises = [];

                while ((subNode = sportSectionNode.childNodes[j++])) {
                    if (sectionName === subNode.getAttribute("structureType")) {
                        for (var k=0; k<subNode.childNodes.length; k++) {
                            if (subNode.childNodes[k].getAttribute("hide") === "false") {
                                promises.push(stormService.cmsRequest(subNode.childNodes[k].getAttribute("path")));
                            }
                        }
                        // first level, get the correct json urls
                        stormUtil.allPromises(promises).then(function(results) {
                            promises = [];
                            for (var i=0; i<results.length; i++) {
                                if (Error.prototype.isPrototypeOf(results[i])) {
                                    continue;
                                }
                                if (results[i]) {
                                    // @TODO: More safety
                                    promises.push(stormService.cmsRequest(results[i].listing.listing.item.path));
                                }
                            }
                            // second level, for each json get the assets list
                            stormUtil.allPromises(promises).then(function(listings) {
                                for (var l=0; l<listings.length; l++) {
                                    if (Error.prototype.isPrototypeOf(listings[l])) {
                                        continue;
                                    }
                                    // @TODO: More checks
                                    var list = listings[l] ? listings[l].listing.listing.item || listings[l].listing.listing.asset : null;
                                    if (list && list.length > 0) {
                                        data.push({
                                            category: listings[l].listing.info.category,
                                            catalog: listings[l].product,
                                            items: list
                                        });
                                    }
                                }
                                defer.resolve({
                                    sportSectionLabel: sportSectionNode.getAttribute("label"),
                                    label: subNode.getAttribute("label"),
                                    section: sectionName,
                                    data: data,
                                    displayFirstChild: subNode.getAttribute("displayFirstChild") === "true"
                                });
                            });
                        });
                        break;
                    }
                }

                return defer.promise;
            },

            /**
             * Retrieve sport news for a certain category.
             * @param  {Number} categoryId Id of the category to retrieve sport news for.
             * @return {Promise<Object[]>} Sport news for the specified category.
             */
            getSportNewsByCategory: function (categoryId) {
                return stormService.sportNewsByCategoryRequest(categoryId);
            },

            /**
             * Retrieve the sports news for use in the Homepage Highlights grid
             * @param url - The URL to load the assets from.
             * @returns {Object[]} List of assets for display.
             */
            getHomepageSportHighlights: function (url) {
                return stormService.cmsRequest(url).then(function(json) {
                    var listings = json.listing.listing.item,
                        data = [];
                    for (var i=0; i<listings.length;i++) {
                        data.push({
                            title: listings[i].item_title,
                            image: listings[i].item_image,
                            category: listings[i].item_category_name,
                            id: listings[i].item_id,
                            category_id: listings[i].item_category_id,
                            type: "sportsNews",
                            package_code: listings[i].category_key_color // Required to populate line next to metadata with correct colour...
                            // But note that Sky have not fully described the required colour mappings, so this may end up grey on screen.
                        });
                    }
                    return {
                        listing: data,
                        catalog: json.product
                    };
                });
            },

            // =============== Asset ==============

            /**
             * Retrieves detail information about a certain asset.
             * @param  {Number} assetId Id of the specified asset.
             * @return {Promise}        Movie information when fulfilled.
             */
            getAssetById: function (assetId, catalog) {
                return stormService.assetDetailRequest(assetId, catalog);
            },

            /**
             * Retrieves a dvd cover for the specified asset.
             * @param  {tvdedemo/model/Asset} asset     Asset to retrieve dvd cover for.
             * @return {Promise}                        Url to image when fulfilled.
             */
            getAssetDvdCover: function(asset) {
                var dvdCover = asset.get("dvdCover");

                if (!dvdCover) {
                    return sAppConfigManager.getPlaceholderPortrait().then(function(url) {
                        return {url: url};
                    });
                }

                return ax.promise.resolve({
                    url: stormService.roots.cms + dvdCover.path + "/" + dvdCover.file
                });
            },

            /**
             * Retrieve logo for the channel associated with the asset.
             * @param {tvedemo/model/Asset} asset Asset to retireve channel logo for.
             * @return {Promise} Associated channel logo when fulfilled.
             */
            getAssetChannelLogo: function (asset) {
                var logoUrl = asset.get("logoUrl");

                if (!logoUrl || logoUrl === "") {

                    return ax.promise.reject("No channel logo available");
                }

                return stormService.initialisedPromise().then(function() {
                    return {url: stormService.roots.cms + logoUrl};
                });
            },

            getAssetImageBySize: function (asset, imageWidth, imageHeight) {
                if (!asset || !imageWidth || !imageHeight) {
                    return ax.promise.reject("getAssetImageBySize, a parameter is missing");
                }

                //
                // We assume that the 'images' (main_picture / pictures in Storm) are all landscape,
                // and that the dvd_cover is the only portrait image available.
                //

                if (imageHeight > imageWidth) {
                    return this.getAssetDvdCover(asset);
                }

                var images = asset.get("images"),
                    imageToUse;

                if (images) {
                    ax.util.each(images, function (image) {
                        if ((image.width >= imageWidth) && (image.height >= imageHeight) && (image.path.length || image.file.length)) {
                            imageToUse = image;
                            return ax.util.breaker;
                        }
                    });
                }

                // We fail hard here; if no image large enough is supplied, we don't scale up a smaller one.

                if (!imageToUse) {
                    return sAppConfigManager.getPlaceholderLandscape().then(function(url) {
                        return {url: url};
                    });
                }

                return stormService.initialisedPromise().then(function() {
                    return {url: stormService.roots.cms + imageToUse.path + "/" + imageToUse.file};
                });
            },

            /**
             * Retrieve detail information about a certain serie.
             * @param  {Number} serieAssetId Id of the serie to retrieve detail informationa bout.
             * @return {Promise.<Object>}    Detail information about the serie
             */
            getSerieAssetById: function (serieAssetId, catalog) {
                return stormService.serieAssetDetailRequest(serieAssetId, catalog);
            },

            getSeasonAssetById: function (seasonAssetId, catalog) {
                return stormService.seasonAssetDetailRequest(seasonAssetId, catalog);
            },

            // ============ Session keep alive ============
            keepAlive: function(skygoSessionId) {
                return stormService.keepAlive(skygoSessionId);
            },

            // ============ Playback ============
            /**
             * Calls heartbeat api repeatedly to make sure video streaming is kept alive.
             * @param  {Number} options.assetId        Id of the asset that is played
             * @param  {String} options.skygoSessionId Session id of current user
             * @return {Promise}                       Heartbeat response.
             */
            heartbeat: function (options) {
                return stormService.heartbeatRequest(options);
            },

            // =============== Search ==============
            searchFor: function(keyword, opts) {
                return stormService.searchRequest(keyword, opts).then(function (jsonObj) {
                    return jsonObj && jsonObj.assetListResult;
                }, function (problem) {
                    console.warn("Search request failed due to " + problem);
                    return ax.promise.reject(problem);
                });
            }

        });

    return OvpService;
});

/**
 * Module that returns an singleton class for managing local storage of small amounts of data, globally, or per user
 * @name sLocalStorageManager
 * @memberof storm/mgr
 * @module storm/mgr/sLocalStorageManager
 * @author Jason Newman<jason.newman@ext.accedo.tv>
 */
define("storm/mgr/sLocalStorageManager", [
    "xdk-base/ax",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/class",
    "xdk-base/device",
    "xdk-base/console"
], function (
    ax,
    core,
    util,
    klass,
    device,
    console
    ) {

    "use strict";

    //
    // By default we use German as the user's language, but they may specify otherwise...
    //

    var _checkKeyValidity = function (possibleKey, keySet) {
            for (var key in keySet) {
                if (keySet.hasOwnProperty(key) && (keySet[key] === possibleKey)) {
                    return true;
                }
            }

            return false;
        },

        LocalStorageManager = klass.create({}, {

            KEYS : {
                PER_USER : "per_user", // Note this is RESERVED for the internal implementation!
                USERNAME : "username",
                EULA_TIMESTAMP : "eula_timestamp"
            },
    
            getStoredValue: function (itemKey, optionalUsername) {
                if (itemKey === this.KEYS.PER_USER) {
                    console.error("getStoredValue saw attempt to get all per-user data");
                }
                if (!util.isUndefined(optionalUsername)) {
                    console.warn("getStoredValue ignoring specific username; that's not yet supported");
                }
                if (!_checkKeyValidity(itemKey, this.KEYS)) {
                    console.warn("getStoredValue ignoring request for unknown key " + itemKey);
                } else {
                    try {
                        return (device.storage.get(itemKey));
                    } catch (e) {
                        console.warn("device.storage.get failed " + e); // See SKYSTORM-369
                        return undefined;
                    }
                }
            },
    
            setStoredValue: function (itemKey, itemValue, optionalUsername) {
                if (itemKey === this.KEYS.PER_USER) {
                    console.error("getStoredValue saw attempt to trash per-user data");
                }
                if (!util.isUndefined(optionalUsername)) {
                    console.warn("setStoredValue ignoring specific username; that's not yet supported");
                }
                if (!_checkKeyValidity(itemKey, this.KEYS)) {
                    console.warn("setStoredValue ignoring request for unknown key " + itemKey);
                }
                if (util.isUndefined(itemValue)) {
                    console.warn("setStoredValue is clearing one key " + itemKey);
                    try {
                        return device.storage.unset(itemKey);
                    } catch (e) {
                        console.warn("device.storage.unset failed " + e); // See SKYSTORM-369
                        return undefined;
                    }
                } else {
                    try {
                        return device.storage.set(itemKey, itemValue);
                    } catch (e) {
                        console.warn("device.storage.set failed " + e); // See SKYSTORM-369
                        return undefined;
                    }
    
                }
            }
        });

    return new LocalStorageManager();
});
/** The files in this directory form the Adobe Omniture analytics library
*  Some useful links from around the web that explain how to use the library:
*  Video player events explained:
*      https://marketing.adobe.com/resources/help/en_US/sc/appmeasurement/video/video_js_events.html
*  App measurement for Javascript
*      https://marketing.adobe.com/resources/help/en_US/sc/implement/appmeasure_mjs.html
*  All of this as a handy pdf
*      http://microsite.omniture.com/t2/help/en_US/sc/implement/oms_sc_implement.pdf
*
*  How to use Omniture's plugin system to reduce the ammount of application code required:
*      http://webanalyticsfordevelopers.com/2013/04/05/the-s_code-js-file-plugins/
*
*  The report interface, called Sitecat:
*      https://sitecatalyst.omniture.com/login/
*
*  How to test your stats implementation:
*      Bloodhound for mobile debugging - https://marketing.adobe.com/developer/gallery/bloodhound-app-measurement-qa-tool-1
*      Digital pulse bookmarklet debugger - http://blogs.adobe.com/digitalmarketing/analytics/meet-the-new-digitalpulse-debugger/
*      Omnibug Chrome Plugin - http://omnibug.rosssimpson.com/chrome.html
**/

var customConsole = window.console || null;
/* ============== DO NOT ALTER ANYTHING BELOW THIS LINE ! ===============

AppMeasurement for JavaScript version: 1.5.1
Copyright 1996-2015 Adobe, Inc. All Rights Reserved
More info available at http://www.omniture.com
*/
function AppMeasurement(){var a=this;a.version="1.5.1";var k=window;k.s_c_in||(k.s_c_il=[],k.s_c_in=0);a._il=k.s_c_il;a._in=k.s_c_in;a._il[a._in]=a;k.s_c_in++;a._c="s_c";var q=k.AppMeasurement.zb;q||(q=null);var r=k,n,t;try{for(n=r.parent,t=r.location;n&&n.location&&t&&""+n.location!=""+t&&r.location&&""+n.location!=""+r.location&&n.location.host==t.host;)r=n,n=r.parent}catch(u){}a.ob=function(a){try{console.log(a)}catch(b){}};a.za=function(a){return""+parseInt(a)==""+a};a.replace=function(a,b,d){return!a||
0>a.indexOf(b)?a:a.split(b).join(d)};a.escape=function(c){var b,d;if(!c)return c;c=encodeURIComponent(c);for(b=0;7>b;b++)d="+~!*()'".substring(b,b+1),0<=c.indexOf(d)&&(c=a.replace(c,d,"%"+d.charCodeAt(0).toString(16).toUpperCase()));return c};a.unescape=function(c){if(!c)return c;c=0<=c.indexOf("+")?a.replace(c,"+"," "):c;try{return decodeURIComponent(c)}catch(b){}return unescape(c)};a.fb=function(){var c=k.location.hostname,b=a.fpCookieDomainPeriods,d;b||(b=a.cookieDomainPeriods);if(c&&!a.cookieDomain&&
!/^[0-9.]+$/.test(c)&&(b=b?parseInt(b):2,b=2<b?b:2,d=c.lastIndexOf("."),0<=d)){for(;0<=d&&1<b;)d=c.lastIndexOf(".",d-1),b--;a.cookieDomain=0<d?c.substring(d):c}return a.cookieDomain};a.c_r=a.cookieRead=function(c){c=a.escape(c);var b=" "+a.d.cookie,d=b.indexOf(" "+c+"="),f=0>d?d:b.indexOf(";",d);c=0>d?"":a.unescape(b.substring(d+2+c.length,0>f?b.length:f));return"[[B]]"!=c?c:""};a.c_w=a.cookieWrite=function(c,b,d){var f=a.fb(),e=a.cookieLifetime,g;b=""+b;e=e?(""+e).toUpperCase():"";d&&"SESSION"!=
e&&"NONE"!=e&&((g=""!=b?parseInt(e?e:0):-60)?(d=new Date,d.setTime(d.getTime()+1E3*g)):1==d&&(d=new Date,g=d.getYear(),d.setYear(g+5+(1900>g?1900:0))));return c&&"NONE"!=e?(a.d.cookie=c+"="+a.escape(""!=b?b:"[[B]]")+"; path=/;"+(d&&"SESSION"!=e?" expires="+d.toGMTString()+";":"")+(f?" domain="+f+";":""),a.cookieRead(c)==b):0};a.G=[];a.ba=function(c,b,d){if(a.ta)return 0;a.maxDelay||(a.maxDelay=250);var f=0,e=(new Date).getTime()+a.maxDelay,g=a.d.visibilityState,m=["webkitvisibilitychange","visibilitychange"];
g||(g=a.d.webkitVisibilityState);if(g&&"prerender"==g){if(!a.ca)for(a.ca=1,d=0;d<m.length;d++)a.d.addEventListener(m[d],function(){var c=a.d.visibilityState;c||(c=a.d.webkitVisibilityState);"visible"==c&&(a.ca=0,a.delayReady())});f=1;e=0}else d||a.l("_d")&&(f=1);f&&(a.G.push({m:c,a:b,t:e}),a.ca||setTimeout(a.delayReady,a.maxDelay));return f};a.delayReady=function(){var c=(new Date).getTime(),b=0,d;for(a.l("_d")?b=1:a.na();0<a.G.length;){d=a.G.shift();if(b&&!d.t&&d.t>c){a.G.unshift(d);setTimeout(a.delayReady,
parseInt(a.maxDelay/2));break}a.ta=1;a[d.m].apply(a,d.a);a.ta=0}};a.setAccount=a.sa=function(c){var b,d;if(!a.ba("setAccount",arguments))if(a.account=c,a.allAccounts)for(b=a.allAccounts.concat(c.split(",")),a.allAccounts=[],b.sort(),d=0;d<b.length;d++)0!=d&&b[d-1]==b[d]||a.allAccounts.push(b[d]);else a.allAccounts=c.split(",")};a.foreachVar=function(c,b){var d,f,e,g,m="";e=f="";if(a.lightProfileID)d=a.K,(m=a.lightTrackVars)&&(m=","+m+","+a.ga.join(",")+",");else{d=a.c;if(a.pe||a.linkType)m=a.linkTrackVars,
f=a.linkTrackEvents,a.pe&&(e=a.pe.substring(0,1).toUpperCase()+a.pe.substring(1),a[e]&&(m=a[e].yb,f=a[e].xb));m&&(m=","+m+","+a.A.join(",")+",");f&&m&&(m+=",events,")}b&&(b=","+b+",");for(f=0;f<d.length;f++)e=d[f],(g=a[e])&&(!m||0<=m.indexOf(","+e+","))&&(!b||0<=b.indexOf(","+e+","))&&c(e,g)};a.B=function(c,b,d,f,e){var g="",m,p,k,w,n=0;"contextData"==c&&(c="c");if(b){for(m in b)if(!(Object.prototype[m]||e&&m.substring(0,e.length)!=e)&&b[m]&&(!d||0<=d.indexOf(","+(f?f+".":"")+m+","))){k=!1;if(n)for(p=
0;p<n.length;p++)m.substring(0,n[p].length)==n[p]&&(k=!0);if(!k&&(""==g&&(g+="&"+c+"."),p=b[m],e&&(m=m.substring(e.length)),0<m.length))if(k=m.indexOf("."),0<k)p=m.substring(0,k),k=(e?e:"")+p+".",n||(n=[]),n.push(k),g+=a.B(p,b,d,f,k);else if("boolean"==typeof p&&(p=p?"true":"false"),p){if("retrieveLightData"==f&&0>e.indexOf(".contextData."))switch(k=m.substring(0,4),w=m.substring(4),m){case "transactionID":m="xact";break;case "channel":m="ch";break;case "campaign":m="v0";break;default:a.za(w)&&("prop"==
k?m="c"+w:"eVar"==k?m="v"+w:"list"==k?m="l"+w:"hier"==k&&(m="h"+w,p=p.substring(0,255)))}g+="&"+a.escape(m)+"="+a.escape(p)}}""!=g&&(g+="&."+c)}return g};a.hb=function(){var c="",b,d,f,e,g,m,p,k,n="",r="",s=e="";if(a.lightProfileID)b=a.K,(n=a.lightTrackVars)&&(n=","+n+","+a.ga.join(",")+",");else{b=a.c;if(a.pe||a.linkType)n=a.linkTrackVars,r=a.linkTrackEvents,a.pe&&(e=a.pe.substring(0,1).toUpperCase()+a.pe.substring(1),a[e]&&(n=a[e].yb,r=a[e].xb));n&&(n=","+n+","+a.A.join(",")+",");r&&(r=","+r+",",
n&&(n+=",events,"));a.events2&&(s+=(""!=s?",":"")+a.events2)}if(a.visitor&&1.5<=parseFloat(a.visitor.version)&&a.visitor.getCustomerIDs){e=q;if(g=a.visitor.getCustomerIDs())for(d in g)Object.prototype[d]||(f=g[d],e||(e={}),f.id&&(e[d+".id"]=f.id),f.authState&&(e[d+".as"]=f.authState));e&&(c+=a.B("cid",e))}a.AudienceManagement&&a.AudienceManagement.isReady()&&(c+=a.B("d",a.AudienceManagement.getEventCallConfigParams()));for(d=0;d<b.length;d++){e=b[d];g=a[e];f=e.substring(0,4);m=e.substring(4);!g&&
"events"==e&&s&&(g=s,s="");if(g&&(!n||0<=n.indexOf(","+e+","))){switch(e){case "supplementalDataID":e="sdid";break;case "timestamp":e="ts";break;case "dynamicVariablePrefix":e="D";break;case "visitorID":e="vid";break;case "marketingCloudVisitorID":e="mid";break;case "analyticsVisitorID":e="aid";break;case "audienceManagerLocationHint":e="aamlh";break;case "audienceManagerBlob":e="aamb";break;case "authState":e="as";break;case "pageURL":e="g";255<g.length&&(a.pageURLRest=g.substring(255),g=g.substring(0,
255));break;case "pageURLRest":e="-g";break;case "referrer":e="r";break;case "vmk":case "visitorMigrationKey":e="vmt";break;case "visitorMigrationServer":e="vmf";a.ssl&&a.visitorMigrationServerSecure&&(g="");break;case "visitorMigrationServerSecure":e="vmf";!a.ssl&&a.visitorMigrationServer&&(g="");break;case "charSet":e="ce";break;case "visitorNamespace":e="ns";break;case "cookieDomainPeriods":e="cdp";break;case "cookieLifetime":e="cl";break;case "variableProvider":e="vvp";break;case "currencyCode":e=
"cc";break;case "channel":e="ch";break;case "transactionID":e="xact";break;case "campaign":e="v0";break;case "latitude":e="lat";break;case "longitude":e="lon";break;case "resolution":e="s";break;case "colorDepth":e="c";break;case "javascriptVersion":e="j";break;case "javaEnabled":e="v";break;case "cookiesEnabled":e="k";break;case "browserWidth":e="bw";break;case "browserHeight":e="bh";break;case "connectionType":e="ct";break;case "homepage":e="hp";break;case "events":s&&(g+=(""!=g?",":"")+s);if(r)for(m=
g.split(","),g="",f=0;f<m.length;f++)p=m[f],k=p.indexOf("="),0<=k&&(p=p.substring(0,k)),k=p.indexOf(":"),0<=k&&(p=p.substring(0,k)),0<=r.indexOf(","+p+",")&&(g+=(g?",":"")+m[f]);break;case "events2":g="";break;case "contextData":c+=a.B("c",a[e],n,e);g="";break;case "lightProfileID":e="mtp";break;case "lightStoreForSeconds":e="mtss";a.lightProfileID||(g="");break;case "lightIncrementBy":e="mti";a.lightProfileID||(g="");break;case "retrieveLightProfiles":e="mtsr";break;case "deleteLightProfiles":e=
"mtsd";break;case "retrieveLightData":a.retrieveLightProfiles&&(c+=a.B("mts",a[e],n,e));g="";break;default:a.za(m)&&("prop"==f?e="c"+m:"eVar"==f?e="v"+m:"list"==f?e="l"+m:"hier"==f&&(e="h"+m,g=g.substring(0,255)))}g&&(c+="&"+e+"="+("pev"!=e.substring(0,3)?a.escape(g):g))}"pev3"==e&&a.e&&(c+=a.e)}return c};a.u=function(a){var b=a.tagName;if("undefined"!=""+a.Cb||"undefined"!=""+a.sb&&"HTML"!=(""+a.sb).toUpperCase())return"";b=b&&b.toUpperCase?b.toUpperCase():"";"SHAPE"==b&&(b="");b&&(("INPUT"==b||
"BUTTON"==b)&&a.type&&a.type.toUpperCase?b=a.type.toUpperCase():!b&&a.href&&(b="A"));return b};a.va=function(a){var b=a.href?a.href:"",d,f,e;d=b.indexOf(":");f=b.indexOf("?");e=b.indexOf("/");b&&(0>d||0<=f&&d>f||0<=e&&d>e)&&(f=a.protocol&&1<a.protocol.length?a.protocol:l.protocol?l.protocol:"",d=l.pathname.lastIndexOf("/"),b=(f?f+"//":"")+(a.host?a.host:l.host?l.host:"")+("/"!=h.substring(0,1)?l.pathname.substring(0,0>d?0:d)+"/":"")+b);return b};a.H=function(c){var b=a.u(c),d,f,e="",g=0;return b&&
(d=c.protocol,f=c.onclick,!c.href||"A"!=b&&"AREA"!=b||f&&d&&!(0>d.toLowerCase().indexOf("javascript"))?f?(e=a.replace(a.replace(a.replace(a.replace(""+f,"\r",""),"\n",""),"\t","")," ",""),g=2):"INPUT"==b||"SUBMIT"==b?(c.value?e=c.value:c.innerText?e=c.innerText:c.textContent&&(e=c.textContent),g=3):c.src&&"IMAGE"==b&&(e=c.src):e=a.va(c),e)?{id:e.substring(0,100),type:g}:0};a.Ab=function(c){for(var b=a.u(c),d=a.H(c);c&&!d&&"BODY"!=b;)if(c=c.parentElement?c.parentElement:c.parentNode)b=a.u(c),d=a.H(c);
d&&"BODY"!=b||(c=0);c&&(b=c.onclick?""+c.onclick:"",0<=b.indexOf(".tl(")||0<=b.indexOf(".trackLink("))&&(c=0);return c};a.rb=function(){var c,b,d=a.linkObject,f=a.linkType,e=a.linkURL,g,m;a.ha=1;d||(a.ha=0,d=a.clickObject);if(d){c=a.u(d);for(b=a.H(d);d&&!b&&"BODY"!=c;)if(d=d.parentElement?d.parentElement:d.parentNode)c=a.u(d),b=a.H(d);b&&"BODY"!=c||(d=0);if(d){var p=d.onclick?""+d.onclick:"";if(0<=p.indexOf(".tl(")||0<=p.indexOf(".trackLink("))d=0}}else a.ha=1;!e&&d&&(e=a.va(d));e&&!a.linkLeaveQueryString&&
(g=e.indexOf("?"),0<=g&&(e=e.substring(0,g)));if(!f&&e){var n=0,r=0,q;if(a.trackDownloadLinks&&a.linkDownloadFileTypes)for(p=e.toLowerCase(),g=p.indexOf("?"),m=p.indexOf("#"),0<=g?0<=m&&m<g&&(g=m):g=m,0<=g&&(p=p.substring(0,g)),g=a.linkDownloadFileTypes.toLowerCase().split(","),m=0;m<g.length;m++)(q=g[m])&&p.substring(p.length-(q.length+1))=="."+q&&(f="d");if(a.trackExternalLinks&&!f&&(p=e.toLowerCase(),a.ya(p)&&(a.linkInternalFilters||(a.linkInternalFilters=k.location.hostname),g=0,a.linkExternalFilters?
(g=a.linkExternalFilters.toLowerCase().split(","),n=1):a.linkInternalFilters&&(g=a.linkInternalFilters.toLowerCase().split(",")),g))){for(m=0;m<g.length;m++)q=g[m],0<=p.indexOf(q)&&(r=1);r?n&&(f="e"):n||(f="e")}}a.linkObject=d;a.linkURL=e;a.linkType=f;if(a.trackClickMap||a.trackInlineStats)a.e="",d&&(f=a.pageName,e=1,d=d.sourceIndex,f||(f=a.pageURL,e=0),k.s_objectID&&(b.id=k.s_objectID,d=b.type=1),f&&b&&b.id&&c&&(a.e="&pid="+a.escape(f.substring(0,255))+(e?"&pidt="+e:"")+"&oid="+a.escape(b.id.substring(0,
100))+(b.type?"&oidt="+b.type:"")+"&ot="+c+(d?"&oi="+d:"")))};a.ib=function(){var c=a.ha,b=a.linkType,d=a.linkURL,f=a.linkName;b&&(d||f)&&(b=b.toLowerCase(),"d"!=b&&"e"!=b&&(b="o"),a.pe="lnk_"+b,a.pev1=d?a.escape(d):"",a.pev2=f?a.escape(f):"",c=1);a.abort&&(c=0);if(a.trackClickMap||a.trackInlineStats){var b={},d=0,e=a.cookieRead("s_sq"),g=e?e.split("&"):0,m,p,k,e=0;if(g)for(m=0;m<g.length;m++)p=g[m].split("="),f=a.unescape(p[0]).split(","),p=a.unescape(p[1]),b[p]=f;f=a.account.split(",");if(c||a.e){c&&
!a.e&&(e=1);for(p in b)if(!Object.prototype[p])for(m=0;m<f.length;m++)for(e&&(k=b[p].join(","),k==a.account&&(a.e+=("&"!=p.charAt(0)?"&":"")+p,b[p]=[],d=1)),g=0;g<b[p].length;g++)k=b[p][g],k==f[m]&&(e&&(a.e+="&u="+a.escape(k)+("&"!=p.charAt(0)?"&":"")+p+"&u=0"),b[p].splice(g,1),d=1);c||(d=1);if(d){e="";m=2;!c&&a.e&&(e=a.escape(f.join(","))+"="+a.escape(a.e),m=1);for(p in b)!Object.prototype[p]&&0<m&&0<b[p].length&&(e+=(e?"&":"")+a.escape(b[p].join(","))+"="+a.escape(p),m--);a.cookieWrite("s_sq",e)}}}return c};
a.jb=function(){if(!a.wb){var c=new Date,b=r.location,d,f,e=f=d="",g="",m="",k="1.2",n=a.cookieWrite("s_cc","true",0)?"Y":"N",q="",s="";if(c.setUTCDate&&(k="1.3",(0).toPrecision&&(k="1.5",c=[],c.forEach))){k="1.6";f=0;d={};try{f=new Iterator(d),f.next&&(k="1.7",c.reduce&&(k="1.8",k.trim&&(k="1.8.1",Date.parse&&(k="1.8.2",Object.create&&(k="1.8.5")))))}catch(t){}}d=screen.width+"x"+screen.height;e=navigator.javaEnabled()?"Y":"N";f=screen.pixelDepth?screen.pixelDepth:screen.colorDepth;g=a.w.innerWidth?
a.w.innerWidth:a.d.documentElement.offsetWidth;m=a.w.innerHeight?a.w.innerHeight:a.d.documentElement.offsetHeight;try{a.b.addBehavior("#default#homePage"),q=a.b.Bb(b)?"Y":"N"}catch(u){}try{a.b.addBehavior("#default#clientCaps"),s=a.b.connectionType}catch(x){}a.resolution=d;a.colorDepth=f;a.javascriptVersion=k;a.javaEnabled=e;a.cookiesEnabled=n;a.browserWidth=g;a.browserHeight=m;a.connectionType=s;a.homepage=q;a.wb=1}};a.L={};a.loadModule=function(c,b){var d=a.L[c];if(!d){d=k["AppMeasurement_Module_"+
c]?new k["AppMeasurement_Module_"+c](a):{};a.L[c]=a[c]=d;d.Na=function(){return d.Ra};d.Sa=function(b){if(d.Ra=b)a[c+"_onLoad"]=b,a.ba(c+"_onLoad",[a,d],1)||b(a,d)};try{Object.defineProperty?Object.defineProperty(d,"onLoad",{get:d.Na,set:d.Sa}):d._olc=1}catch(f){d._olc=1}}b&&(a[c+"_onLoad"]=b,a.ba(c+"_onLoad",[a,d],1)||b(a,d))};a.l=function(c){var b,d;for(b in a.L)if(!Object.prototype[b]&&(d=a.L[b])&&(d._olc&&d.onLoad&&(d._olc=0,d.onLoad(a,d)),d[c]&&d[c]()))return 1;return 0};a.mb=function(){var c=
Math.floor(1E13*Math.random()),b=a.visitorSampling,d=a.visitorSamplingGroup,d="s_vsn_"+(a.visitorNamespace?a.visitorNamespace:a.account)+(d?"_"+d:""),f=a.cookieRead(d);if(b){f&&(f=parseInt(f));if(!f){if(!a.cookieWrite(d,c))return 0;f=c}if(f%1E4>v)return 0}return 1};a.M=function(c,b){var d,f,e,g,m,k;for(d=0;2>d;d++)for(f=0<d?a.oa:a.c,e=0;e<f.length;e++)if(g=f[e],(m=c[g])||c["!"+g]){if(!b&&("contextData"==g||"retrieveLightData"==g)&&a[g])for(k in a[g])m[k]||(m[k]=a[g][k]);a[g]=m}};a.Ga=function(c,b){var d,
f,e,g;for(d=0;2>d;d++)for(f=0<d?a.oa:a.c,e=0;e<f.length;e++)g=f[e],c[g]=a[g],b||c[g]||(c["!"+g]=1)};a.cb=function(a){var b,d,f,e,g,m=0,k,n="",q="";if(a&&255<a.length&&(b=""+a,d=b.indexOf("?"),0<d&&(k=b.substring(d+1),b=b.substring(0,d),e=b.toLowerCase(),f=0,"http://"==e.substring(0,7)?f+=7:"https://"==e.substring(0,8)&&(f+=8),d=e.indexOf("/",f),0<d&&(e=e.substring(f,d),g=b.substring(d),b=b.substring(0,d),0<=e.indexOf("google")?m=",q,ie,start,search_key,word,kw,cd,":0<=e.indexOf("yahoo.co")&&(m=",p,ei,"),
m&&k)))){if((a=k.split("&"))&&1<a.length){for(f=0;f<a.length;f++)e=a[f],d=e.indexOf("="),0<d&&0<=m.indexOf(","+e.substring(0,d)+",")?n+=(n?"&":"")+e:q+=(q?"&":"")+e;n&&q?k=n+"&"+q:q=""}d=253-(k.length-q.length)-b.length;a=b+(0<d?g.substring(0,d):"")+"?"+k}return a};a.Ma=function(c){var b=a.d.visibilityState,d=["webkitvisibilitychange","visibilitychange"];b||(b=a.d.webkitVisibilityState);if(b&&"prerender"==b){if(c)for(b=0;b<d.length;b++)a.d.addEventListener(d[b],function(){var b=a.d.visibilityState;
b||(b=a.d.webkitVisibilityState);"visible"==b&&c()});return!1}return!0};a.Y=!1;a.D=!1;a.Ta=function(){a.D=!0;a.i()};a.W=!1;a.Q=!1;a.Qa=function(c){a.marketingCloudVisitorID=c;a.Q=!0;a.i()};a.T=!1;a.N=!1;a.Ia=function(c){a.analyticsVisitorID=c;a.N=!0;a.i()};a.V=!1;a.P=!1;a.Ka=function(c){a.audienceManagerLocationHint=c;a.P=!0;a.i()};a.U=!1;a.O=!1;a.Ja=function(c){a.audienceManagerBlob=c;a.O=!0;a.i()};a.La=function(c){a.maxDelay||(a.maxDelay=250);return a.l("_d")?(c&&setTimeout(function(){c()},a.maxDelay),
!1):!0};a.X=!1;a.C=!1;a.na=function(){a.C=!0;a.i()};a.isReadyToTrack=function(){var c=!0,b=a.visitor;a.Y||a.D||(a.Ma(a.Ta)?a.D=!0:a.Y=!0);if(a.Y&&!a.D)return!1;b&&b.isAllowed()&&(a.W||a.marketingCloudVisitorID||!b.getMarketingCloudVisitorID||(a.W=!0,a.marketingCloudVisitorID=b.getMarketingCloudVisitorID([a,a.Qa]),a.marketingCloudVisitorID&&(a.Q=!0)),a.T||a.analyticsVisitorID||!b.getAnalyticsVisitorID||(a.T=!0,a.analyticsVisitorID=b.getAnalyticsVisitorID([a,a.Ia]),a.analyticsVisitorID&&(a.N=!0)),a.V||
a.audienceManagerLocationHint||!b.getAudienceManagerLocationHint||(a.V=!0,a.audienceManagerLocationHint=b.getAudienceManagerLocationHint([a,a.Ka]),a.audienceManagerLocationHint&&(a.P=!0)),a.U||a.audienceManagerBlob||!b.getAudienceManagerBlob||(a.U=!0,a.audienceManagerBlob=b.getAudienceManagerBlob([a,a.Ja]),a.audienceManagerBlob&&(a.O=!0)),a.W&&!a.Q&&!a.marketingCloudVisitorID||a.T&&!a.N&&!a.analyticsVisitorID||a.V&&!a.P&&!a.audienceManagerLocationHint||a.U&&!a.O&&!a.audienceManagerBlob)&&(c=!1);a.X||
a.C||(a.La(a.na)?a.C=!0:a.X=!0);a.X&&!a.C&&(c=!1);return c};a.k=q;a.o=0;a.callbackWhenReadyToTrack=function(c,b,d){var f;f={};f.Xa=c;f.Wa=b;f.Ua=d;a.k==q&&(a.k=[]);a.k.push(f);0==a.o&&(a.o=setInterval(a.i,100))};a.i=function(){var c;if(a.isReadyToTrack()&&(a.o&&(clearInterval(a.o),a.o=0),a.k!=q))for(;0<a.k.length;)c=a.k.shift(),c.Wa.apply(c.Xa,c.Ua)};a.Oa=function(c){var b,d,f=q,e=q;if(!a.isReadyToTrack()){b=[];if(c!=q)for(d in f={},c)f[d]=c[d];e={};a.Ga(e,!0);b.push(f);b.push(e);a.callbackWhenReadyToTrack(a,
a.track,b);return!0}return!1};a.gb=function(){var c=a.cookieRead("s_fid"),b="",d="",f;f=8;var e=4;if(!c||0>c.indexOf("-")){for(c=0;16>c;c++)f=Math.floor(Math.random()*f),b+="0123456789ABCDEF".substring(f,f+1),f=Math.floor(Math.random()*e),d+="0123456789ABCDEF".substring(f,f+1),f=e=16;c=b+"-"+d}a.cookieWrite("s_fid",c,1)||(c=0);return c};a.t=a.track=function(c,b){var d,f=new Date,e="s"+Math.floor(f.getTime()/108E5)%10+Math.floor(1E13*Math.random()),g=f.getYear(),g="t="+a.escape(f.getDate()+"/"+f.getMonth()+
"/"+(1900>g?g+1900:g)+" "+f.getHours()+":"+f.getMinutes()+":"+f.getSeconds()+" "+f.getDay()+" "+f.getTimezoneOffset());a.visitor&&(a.visitor.eb&&(a.authState=a.visitor.eb()),!a.supplementalDataID&&a.visitor.getSupplementalDataID&&(a.supplementalDataID=a.visitor.getSupplementalDataID("AppMeasurement:"+a._in,a.expectSupplementalData?!1:!0)));a.l("_s");a.Oa(c)||(b&&a.M(b),c&&(d={},a.Ga(d,0),a.M(c)),a.mb()&&(a.analyticsVisitorID||a.marketingCloudVisitorID||(a.fid=a.gb()),a.rb(),a.usePlugins&&a.doPlugins&&
a.doPlugins(a),a.account&&(a.abort||(a.trackOffline&&!a.timestamp&&(a.timestamp=Math.floor(f.getTime()/1E3)),f=k.location,a.pageURL||(a.pageURL=f.href?f.href:f),a.referrer||a.Ha||(a.referrer=r.document.referrer),a.Ha=1,a.referrer=a.cb(a.referrer),a.l("_g")),a.ib()&&!a.abort&&(a.jb(),g+=a.hb(),a.qb(e,g),a.l("_t"),a.referrer=""))),c&&a.M(d,1));a.abort=a.supplementalDataID=a.timestamp=a.pageURLRest=a.linkObject=a.clickObject=a.linkURL=a.linkName=a.linkType=k.s_objectID=a.pe=a.pev1=a.pev2=a.pev3=a.e=
a.lightProfileID=0};a.tl=a.trackLink=function(c,b,d,f,e){a.linkObject=c;a.linkType=b;a.linkName=d;e&&(a.j=c,a.q=e);return a.track(f)};a.trackLight=function(c,b,d,f){a.lightProfileID=c;a.lightStoreForSeconds=b;a.lightIncrementBy=d;return a.track(f)};a.clearVars=function(){var c,b;for(c=0;c<a.c.length;c++)if(b=a.c[c],"prop"==b.substring(0,4)||"eVar"==b.substring(0,4)||"hier"==b.substring(0,4)||"list"==b.substring(0,4)||"channel"==b||"events"==b||"eventList"==b||"products"==b||"productList"==b||"purchaseID"==
b||"transactionID"==b||"state"==b||"zip"==b||"campaign"==b)a[b]=void 0};a.tagContainerMarker="";a.qb=function(c,b){var d,f=a.trackingServer;d="";var e=a.dc,g="sc.",k=a.visitorNamespace;f?a.trackingServerSecure&&a.ssl&&(f=a.trackingServerSecure):(k||(k=a.account,f=k.indexOf(","),0<=f&&(k=k.substring(0,f)),k=k.replace(/[^A-Za-z0-9]/g,"")),d||(d="2o7.net"),e=e?(""+e).toLowerCase():"d1","2o7.net"==d&&("d1"==e?e="112":"d2"==e&&(e="122"),g=""),f=k+"."+e+"."+g+d);d=a.ssl?"https://":"http://";e=a.AudienceManagement&&
a.AudienceManagement.isReady();d+=f+"/b/ss/"+a.account+"/"+(a.mobile?"5.":"")+(e?"10":"1")+"/JS-"+a.version+(a.vb?"T":"")+(a.tagContainerMarker?"-"+a.tagContainerMarker:"")+"/"+c+"?AQB=1&ndh=1&pf=1&"+(e?"callback=s_c_il["+a._in+"].AudienceManagement.passData&":"")+b+"&AQE=1";a.ab(d);a.da()};a.ab=function(c){a.g||a.kb();a.g.push(c);a.fa=a.r();a.Fa()};a.kb=function(){a.g=a.nb();a.g||(a.g=[])};a.nb=function(){var c,b;if(a.ka()){try{(b=k.localStorage.getItem(a.ia()))&&(c=k.JSON.parse(b))}catch(d){}return c}};
a.ka=function(){var c=!0;a.trackOffline&&a.offlineFilename&&k.localStorage&&k.JSON||(c=!1);return c};a.wa=function(){var c=0;a.g&&(c=a.g.length);a.v&&c++;return c};a.da=function(){if(!a.v)if(a.xa=q,a.ja)a.fa>a.J&&a.Da(a.g),a.ma(500);else{var c=a.Va();if(0<c)a.ma(c);else if(c=a.ua())a.v=1,a.pb(c),a.tb(c)}};a.ma=function(c){a.xa||(c||(c=0),a.xa=setTimeout(a.da,c))};a.Va=function(){var c;if(!a.trackOffline||0>=a.offlineThrottleDelay)return 0;c=a.r()-a.Ca;return a.offlineThrottleDelay<c?0:a.offlineThrottleDelay-
c};a.ua=function(){if(0<a.g.length)return a.g.shift()};a.pb=function(c){if(a.debugTracking){var b="AppMeasurement Debug: "+c;c=c.split("&");var d;for(d=0;d<c.length;d++)b+="\n\t"+a.unescape(c[d]);a.ob(b)}};a.Pa=function(){return a.marketingCloudVisitorID||a.analyticsVisitorID};a.S=!1;var s;try{s=JSON.parse('{"x":"y"}')}catch(x){s=null}s&&"y"==s.x?(a.S=!0,a.R=function(a){return JSON.parse(a)}):k.$&&k.$.parseJSON?(a.R=function(a){return k.$.parseJSON(a)},a.S=!0):a.R=function(){return null};a.tb=function(c){var b,
d,f;a.Pa()&&2047<c.length&&("undefined"!=typeof XMLHttpRequest&&(b=new XMLHttpRequest,"withCredentials"in b?d=1:b=0),b||"undefined"==typeof XDomainRequest||(b=new XDomainRequest,d=2),b&&a.AudienceManagement&&a.AudienceManagement.isReady()&&(a.S?b.pa=!0:b=0));!b&&a.lb&&(c=c.substring(0,2047));!b&&a.d.createElement&&a.AudienceManagement&&a.AudienceManagement.isReady()&&(b=a.d.createElement("SCRIPT"))&&"async"in b&&((f=(f=a.d.getElementsByTagName("HEAD"))&&f[0]?f[0]:a.d.body)?(b.type="text/javascript",
b.setAttribute("async","async"),d=3):b=0);b||(b=new Image,b.alt="");b.ra=function(){try{a.la&&(clearTimeout(a.la),a.la=0),b.timeout&&(clearTimeout(b.timeout),b.timeout=0)}catch(c){}};b.onload=b.ub=function(){b.ra();a.$a();a.Z();a.v=0;a.da();if(b.pa){b.pa=!1;try{var c=a.R(b.responseText);AudienceManagement.passData(c)}catch(d){}}};b.onabort=b.onerror=b.bb=function(){b.ra();(a.trackOffline||a.ja)&&a.v&&a.g.unshift(a.Za);a.v=0;a.fa>a.J&&a.Da(a.g);a.Z();a.ma(500)};b.onreadystatechange=function(){4==b.readyState&&
(200==b.status?b.ub():b.bb())};a.Ca=a.r();if(1==d||2==d){var e=c.indexOf("?");f=c.substring(0,e);e=c.substring(e+1);e=e.replace(/&callback=[a-zA-Z0-9_.\[\]]+/,"");1==d?(b.open("POST",f,!0),b.send(e)):2==d&&(b.open("POST",f),b.send(e))}else if(b.src=c,3==d){if(a.Aa)try{f.removeChild(a.Aa)}catch(g){}f.firstChild?f.insertBefore(b,f.firstChild):f.appendChild(b);a.Aa=a.Ya}b.abort&&(a.la=setTimeout(b.abort,5E3));a.Za=c;a.Ya=k["s_i_"+a.replace(a.account,",","_")]=b;if(a.useForcedLinkTracking&&a.F||a.q)a.forcedLinkTrackingTimeout||
(a.forcedLinkTrackingTimeout=250),a.aa=setTimeout(a.Z,a.forcedLinkTrackingTimeout)};a.$a=function(){if(a.ka()&&!(a.Ba>a.J))try{k.localStorage.removeItem(a.ia()),a.Ba=a.r()}catch(c){}};a.Da=function(c){if(a.ka()){a.Fa();try{k.localStorage.setItem(a.ia(),k.JSON.stringify(c)),a.J=a.r()}catch(b){}}};a.Fa=function(){if(a.trackOffline){if(!a.offlineLimit||0>=a.offlineLimit)a.offlineLimit=10;for(;a.g.length>a.offlineLimit;)a.ua()}};a.forceOffline=function(){a.ja=!0};a.forceOnline=function(){a.ja=!1};a.ia=
function(){return a.offlineFilename+"-"+a.visitorNamespace+a.account};a.r=function(){return(new Date).getTime()};a.ya=function(a){a=a.toLowerCase();return 0!=a.indexOf("#")&&0!=a.indexOf("about:")&&0!=a.indexOf("opera:")&&0!=a.indexOf("javascript:")?!0:!1};a.setTagContainer=function(c){var b,d,f;a.vb=c;for(b=0;b<a._il.length;b++)if((d=a._il[b])&&"s_l"==d._c&&d.tagContainerName==c){a.M(d);if(d.lmq)for(b=0;b<d.lmq.length;b++)f=d.lmq[b],a.loadModule(f.n);if(d.ml)for(f in d.ml)if(a[f])for(b in c=a[f],
f=d.ml[f],f)!Object.prototype[b]&&("function"!=typeof f[b]||0>(""+f[b]).indexOf("s_c_il"))&&(c[b]=f[b]);if(d.mmq)for(b=0;b<d.mmq.length;b++)f=d.mmq[b],a[f.m]&&(c=a[f.m],c[f.f]&&"function"==typeof c[f.f]&&(f.a?c[f.f].apply(c,f.a):c[f.f].apply(c)));if(d.tq)for(b=0;b<d.tq.length;b++)a.track(d.tq[b]);d.s=a;break}};a.Util={urlEncode:a.escape,urlDecode:a.unescape,cookieRead:a.cookieRead,cookieWrite:a.cookieWrite,getQueryParam:function(c,b,d){var f;b||(b=a.pageURL?a.pageURL:k.location);d||(d="&");return c&&
b&&(b=""+b,f=b.indexOf("?"),0<=f&&(b=d+b.substring(f+1)+d,f=b.indexOf(d+c+"="),0<=f&&(b=b.substring(f+d.length+c.length+1),f=b.indexOf(d),0<=f&&(b=b.substring(0,f)),0<b.length)))?a.unescape(b):""}};a.A="supplementalDataID timestamp dynamicVariablePrefix visitorID marketingCloudVisitorID analyticsVisitorID audienceManagerLocationHint authState fid vmk visitorMigrationKey visitorMigrationServer visitorMigrationServerSecure charSet visitorNamespace cookieDomainPeriods fpCookieDomainPeriods cookieLifetime pageName pageURL referrer contextData currencyCode lightProfileID lightStoreForSeconds lightIncrementBy retrieveLightProfiles deleteLightProfiles retrieveLightData pe pev1 pev2 pev3 pageURLRest".split(" ");
a.c=a.A.concat("purchaseID variableProvider channel server pageType transactionID campaign state zip events events2 products audienceManagerBlob tnt".split(" "));a.ga="timestamp charSet visitorNamespace cookieDomainPeriods cookieLifetime contextData lightProfileID lightStoreForSeconds lightIncrementBy".split(" ");a.K=a.ga.slice(0);a.oa="account allAccounts debugTracking visitor trackOffline offlineLimit offlineThrottleDelay offlineFilename usePlugins doPlugins configURL visitorSampling visitorSamplingGroup linkObject clickObject linkURL linkName linkType trackDownloadLinks trackExternalLinks trackClickMap trackInlineStats linkLeaveQueryString linkTrackVars linkTrackEvents linkDownloadFileTypes linkExternalFilters linkInternalFilters useForcedLinkTracking forcedLinkTrackingTimeout trackingServer trackingServerSecure ssl abort mobile dc lightTrackVars maxDelay expectSupplementalData AudienceManagement".split(" ");
for(n=0;250>=n;n++)76>n&&(a.c.push("prop"+n),a.K.push("prop"+n)),a.c.push("eVar"+n),a.K.push("eVar"+n),6>n&&a.c.push("hier"+n),4>n&&a.c.push("list"+n);n="latitude longitude resolution colorDepth javascriptVersion javaEnabled cookiesEnabled browserWidth browserHeight connectionType homepage".split(" ");a.c=a.c.concat(n);a.A=a.A.concat(n);a.ssl=0<=k.location.protocol.toLowerCase().indexOf("https");a.charSet="UTF-8";a.contextData={};a.offlineThrottleDelay=0;a.offlineFilename="AppMeasurement.offline";
a.Ca=0;a.fa=0;a.J=0;a.Ba=0;a.linkDownloadFileTypes="exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";a.w=k;a.d=k.document;try{a.lb="Microsoft Internet Explorer"==navigator.appName}catch(y){}a.Z=function(){a.aa&&(k.clearTimeout(a.aa),a.aa=q);a.j&&a.F&&a.j.dispatchEvent(a.F);a.q&&("function"==typeof a.q?a.q():a.j&&a.j.href&&(a.d.location=a.j.href));a.j=a.F=a.q=0};a.Ea=function(){a.b=a.d.body;a.b?(a.p=function(c){var b,d,f,e,g;if(!(a.d&&a.d.getElementById("cppXYctnr")||c&&c["s_fe_"+a._in])){if(a.qa)if(a.useForcedLinkTracking)a.b.removeEventListener("click",
a.p,!1);else{a.b.removeEventListener("click",a.p,!0);a.qa=a.useForcedLinkTracking=0;return}else a.useForcedLinkTracking=0;a.clickObject=c.srcElement?c.srcElement:c.target;try{if(!a.clickObject||a.I&&a.I==a.clickObject||!(a.clickObject.tagName||a.clickObject.parentElement||a.clickObject.parentNode))a.clickObject=0;else{var m=a.I=a.clickObject;a.ea&&(clearTimeout(a.ea),a.ea=0);a.ea=setTimeout(function(){a.I==m&&(a.I=0)},1E4);f=a.wa();a.track();if(f<a.wa()&&a.useForcedLinkTracking&&c.target){for(e=c.target;e&&
e!=a.b&&"A"!=e.tagName.toUpperCase()&&"AREA"!=e.tagName.toUpperCase();)e=e.parentNode;if(e&&(g=e.href,a.ya(g)||(g=0),d=e.target,c.target.dispatchEvent&&g&&(!d||"_self"==d||"_top"==d||"_parent"==d||k.name&&d==k.name))){try{b=a.d.createEvent("MouseEvents")}catch(n){b=new k.MouseEvent}if(b){try{b.initMouseEvent("click",c.bubbles,c.cancelable,c.view,c.detail,c.screenX,c.screenY,c.clientX,c.clientY,c.ctrlKey,c.altKey,c.shiftKey,c.metaKey,c.button,c.relatedTarget)}catch(q){b=0}b&&(b["s_fe_"+a._in]=b.s_fe=
1,c.stopPropagation(),c.stopImmediatePropagation&&c.stopImmediatePropagation(),c.preventDefault(),a.j=c.target,a.F=b)}}}}}catch(r){a.clickObject=0}}},a.b&&a.b.attachEvent?a.b.attachEvent("onclick",a.p):a.b&&a.b.addEventListener&&(navigator&&(0<=navigator.userAgent.indexOf("WebKit")&&a.d.createEvent||0<=navigator.userAgent.indexOf("Firefox/2")&&k.MouseEvent)&&(a.qa=1,a.useForcedLinkTracking=1,a.b.addEventListener("click",a.p,!0)),a.b.addEventListener("click",a.p,!1))):setTimeout(a.Ea,30);
/* Begin code added by Accedo to avoid a race condition when loading */
a.Media = a.Integrate = undefined;
a.loadModule("Media", a.Media);
a.loadModule("Integrate", a.Integrate);
/* End code added by Accedo */
};a.Ea()}
function s_gi(a){var k,q=window.s_c_il,r,n,t=a.split(","),u,s,x=0;if(q)for(r=0;!x&&r<q.length;){k=q[r];if("s_c"==k._c&&(k.account||k.oun))if(k.account&&k.account==a)x=1;else for(n=k.account?k.account:k.oun,n=k.allAccounts?k.allAccounts:n.split(","),u=0;u<t.length;u++)for(s=0;s<n.length;s++)t[u]==n[s]&&(x=1);r++}x||(k=new AppMeasurement);k.setAccount?k.setAccount(a):k.sa&&k.sa(a);return k}AppMeasurement.getInstance=s_gi;window.s_objectID||(window.s_objectID=0);
function s_pgicq(){var a=window,k=a.s_giq,q,r,n;if(k)for(q=0;q<k.length;q++)r=k[q],n=s_gi(r.oun),n.setAccount(r.un),n.setTagContainer(r.tagContainerName);a.s_giq=0}s_pgicq();

define("appmeasurement", function(){});

function AppMeasurement_Module_Media(q){var b=this;b.s=q;q=window;q.s_c_in||(q.s_c_il=[],q.s_c_in=0);b._il=q.s_c_il;b._in=q.s_c_in;b._il[b._in]=b;q.s_c_in++;b._c="s_m";b.list=[];b.open=function(d,c,e,k){var f={},a=new Date,l="",g;c||(c=-1);if(d&&e){b.list||(b.list={});b.list[d]&&b.close(d);k&&k.id&&(l=k.id);if(l)for(g in b.list)!Object.prototype[g]&&b.list[g]&&b.list[g].R==l&&b.close(b.list[g].name);f.name=d;f.length=c;f.offset=0;f.e=0;f.playerName=b.playerName?b.playerName:e;f.R=l;f.C=0;f.a=0;f.timestamp=
Math.floor(a.getTime()/1E3);f.k=0;f.u=f.timestamp;f.c=-1;f.n="";f.g=-1;f.D=0;f.I={};f.G=0;f.m=0;f.f="";f.B=0;f.L=0;f.A=0;f.F=0;f.l=!1;f.v="";f.J="";f.K=0;f.r=!1;f.H="";f.complete=0;f.Q=0;f.p=0;f.q=0;b.list[d]=f}};b.openAd=function(d,c,e,k,f,a,l,g){var h={};b.open(d,c,e,g);if(h=b.list[d])h.l=!0,h.v=k,h.J=f,h.K=a,h.H=l};b.M=function(d){var c=b.list[d];b.list[d]=0;c&&c.monitor&&clearTimeout(c.monitor.interval)};b.close=function(d){b.i(d,0,-1)};b.play=function(d,c,e,k){var f=b.i(d,1,c,e,k);f&&!f.monitor&&
(f.monitor={},f.monitor.update=function(){1==f.k&&b.i(f.name,3,-1);f.monitor.interval=setTimeout(f.monitor.update,1E3)},f.monitor.update())};b.click=function(d,c){b.i(d,7,c)};b.complete=function(d,c){b.i(d,5,c)};b.stop=function(d,c){b.i(d,2,c)};b.track=function(d){b.i(d,4,-1)};b.P=function(d,c){var e="a.media.",k=d.linkTrackVars,f=d.linkTrackEvents,a="m_i",l,g=d.contextData,h;c.l&&(e+="ad.",c.v&&(g["a.media.name"]=c.v,g[e+"pod"]=c.J,g[e+"podPosition"]=c.K),c.G||(g[e+"CPM"]=c.H));c.r&&(g[e+"clicked"]=
!0,c.r=!1);g["a.contentType"]="video"+(c.l?"Ad":"");g["a.media.channel"]=b.channel;g[e+"name"]=c.name;g[e+"playerName"]=c.playerName;0<c.length&&(g[e+"length"]=c.length);g[e+"timePlayed"]=Math.floor(c.a);0<Math.floor(c.a)&&(g[e+"timePlayed"]=Math.floor(c.a));c.G||(g[e+"view"]=!0,a="m_s",b.Heartbeat&&b.Heartbeat.enabled&&(a=c.l?b.__primetime?"mspa_s":"msa_s":b.__primetime?"msp_s":"ms_s"),c.G=1);c.f&&(g[e+"segmentNum"]=c.m,g[e+"segment"]=c.f,0<c.B&&(g[e+"segmentLength"]=c.B),c.A&&0<c.a&&(g[e+"segmentView"]=
!0));!c.Q&&c.complete&&(g[e+"complete"]=!0,c.S=1);0<c.p&&(g[e+"milestone"]=c.p);0<c.q&&(g[e+"offsetMilestone"]=c.q);if(k)for(h in g)Object.prototype[h]||(k+=",contextData."+h);l=g["a.contentType"];d.pe=a;d.pev3=l;var q,s;if(b.contextDataMapping)for(h in d.events2||(d.events2=""),k&&(k+=",events"),b.contextDataMapping)if(!Object.prototype[h]){a=h.length>e.length&&h.substring(0,e.length)==e?h.substring(e.length):"";l=b.contextDataMapping[h];if("string"==typeof l)for(q=l.split(","),s=0;s<q.length;s++)l=
q[s],"a.contentType"==h?(k&&(k+=","+l),d[l]=g[h]):"view"==a||"segmentView"==a||"clicked"==a||"complete"==a||"timePlayed"==a||"CPM"==a?(f&&(f+=","+l),"timePlayed"==a||"CPM"==a?g[h]&&(d.events2+=(d.events2?",":"")+l+"="+g[h]):g[h]&&(d.events2+=(d.events2?",":"")+l)):"segment"==a&&g[h+"Num"]?(k&&(k+=","+l),d[l]=g[h+"Num"]+":"+g[h]):(k&&(k+=","+l),d[l]=g[h]);else if("milestones"==a||"offsetMilestones"==a)h=h.substring(0,h.length-1),g[h]&&b.contextDataMapping[h+"s"][g[h]]&&(f&&(f+=","+b.contextDataMapping[h+
"s"][g[h]]),d.events2+=(d.events2?",":"")+b.contextDataMapping[h+"s"][g[h]]);g[h]&&(g[h]=0);"segment"==a&&g[h+"Num"]&&(g[h+"Num"]=0)}d.linkTrackVars=k;d.linkTrackEvents=f};b.i=function(d,c,e,k,f){var a={},l=(new Date).getTime()/1E3,g,h,q=b.trackVars,s=b.trackEvents,t=b.trackSeconds,u=b.trackMilestones,v=b.trackOffsetMilestones,w=b.segmentByMilestones,x=b.segmentByOffsetMilestones,p,n,r=1,m={},y;b.channel||(b.channel=b.s.w.location.hostname);if(a=d&&b.list&&b.list[d]?b.list[d]:0)if(a.l&&(t=b.adTrackSeconds,
u=b.adTrackMilestones,v=b.adTrackOffsetMilestones,w=b.adSegmentByMilestones,x=b.adSegmentByOffsetMilestones),0>e&&(e=1==a.k&&0<a.u?l-a.u+a.c:a.c),0<a.length&&(e=e<a.length?e:a.length),0>e&&(e=0),a.offset=e,0<a.length&&(a.e=a.offset/a.length*100,a.e=100<a.e?100:a.e),0>a.c&&(a.c=e),y=a.D,m.name=d,m.ad=a.l,m.length=a.length,m.openTime=new Date,m.openTime.setTime(1E3*a.timestamp),m.offset=a.offset,m.percent=a.e,m.playerName=a.playerName,m.mediaEvent=0>a.g?"OPEN":1==c?"PLAY":2==c?"STOP":3==c?"MONITOR":
4==c?"TRACK":5==c?"COMPLETE":7==c?"CLICK":"CLOSE",2<c||c!=a.k&&(2!=c||1==a.k)){f||(k=a.m,f=a.f);if(c){1==c&&(a.c=e);if((3>=c||5<=c)&&0<=a.g&&(r=!1,q=s="None",a.g!=e)){h=a.g;h>e&&(h=a.c,h>e&&(h=e));p=u?u.split(","):0;if(0<a.length&&p&&e>=h)for(n=0;n<p.length;n++)(g=p[n]?parseFloat(""+p[n]):0)&&h/a.length*100<g&&a.e>=g&&(r=!0,n=p.length,m.mediaEvent="MILESTONE",a.p=m.milestone=g);if((p=v?v.split(","):0)&&e>=h)for(n=0;n<p.length;n++)(g=p[n]?parseFloat(""+p[n]):0)&&h<g&&e>=g&&(r=!0,n=p.length,m.mediaEvent=
"OFFSET_MILESTONE",a.q=m.offsetMilestone=g)}if(a.L||!f){if(w&&u&&0<a.length){if(p=u.split(","))for(p.push("100"),n=h=0;n<p.length;n++)if(g=p[n]?parseFloat(""+p[n]):0)a.e<g&&(k=n+1,f="M:"+h+"-"+g,n=p.length),h=g}else if(x&&v&&(p=v.split(",")))for(p.push(""+(0<a.length?a.length:"E")),n=h=0;n<p.length;n++)if((g=p[n]?parseFloat(""+p[n]):0)||"E"==p[n]){if(e<g||"E"==p[n])k=n+1,f="O:"+h+"-"+g,n=p.length;h=g}f&&(a.L=!0)}(f||a.f)&&f!=a.f&&(a.F=!0,a.f||(a.m=k,a.f=f),0<=a.g&&(r=!0));(2<=c||100<=a.e)&&a.c<e&&
(a.C+=e-a.c,a.a+=e-a.c);if(2>=c||3==c&&!a.k)a.n+=(1==c||3==c?"S":"E")+Math.floor(e),a.k=3==c?1:c;!r&&0<=a.g&&3>=c&&(t=t?t:0)&&a.a>=t&&(r=!0,m.mediaEvent="SECONDS");a.u=l;a.c=e}if(!c||3>=c&&100<=a.e)2!=a.k&&(a.n+="E"+Math.floor(e)),c=0,q=s="None",m.mediaEvent="CLOSE";7==c&&(r=m.clicked=a.r=!0);if(5==c||b.completeByCloseOffset&&(!c||100<=a.e)&&0<a.length&&e>=a.length-b.completeCloseOffsetThreshold)r=m.complete=a.complete=!0;l=m.mediaEvent;"MILESTONE"==l?l+="_"+m.milestone:"OFFSET_MILESTONE"==l&&(l+=
"_"+m.offsetMilestone);a.I[l]?m.eventFirstTime=!1:(m.eventFirstTime=!0,a.I[l]=1);m.event=m.mediaEvent;m.timePlayed=a.C;m.segmentNum=a.m;m.segment=a.f;m.segmentLength=a.B;b.monitor&&4!=c&&b.monitor(b.s,m);b.Heartbeat&&b.Heartbeat.enabled&&0<=a.g&&(r=!1);0==c&&b.M(d);r&&a.D==y&&(d={contextData:{}},d.linkTrackVars=q,d.linkTrackEvents=s,d.linkTrackVars||(d.linkTrackVars=""),d.linkTrackEvents||(d.linkTrackEvents=""),b.P(d,a),d.linkTrackVars||(d["!linkTrackVars"]=1),d.linkTrackEvents||(d["!linkTrackEvents"]=
1),b.s.track(d),a.F?(a.m=k,a.f=f,a.A=!0,a.F=!1):0<a.a&&(a.A=!1),a.n="",a.p=a.q=0,a.a-=Math.floor(a.a),a.g=e,a.D++)}return a};b.O=function(d,c,e,k,f){var a=0;if(d&&(!b.autoTrackMediaLengthRequired||c&&0<c)){if(b.list&&b.list[d])a=1;else if(1==e||3==e)b.open(d,c,"HTML5 Video",f),a=1;a&&b.i(d,e,k,-1,0)}};b.attach=function(d){var c,e,k;d&&d.tagName&&"VIDEO"==d.tagName.toUpperCase()&&(b.o||(b.o=function(c,a,d){var e,h;b.autoTrack&&(e=c.currentSrc,(h=c.duration)||(h=-1),0>d&&(d=c.currentTime),b.O(e,h,a,
d,c))}),c=function(){b.o(d,1,-1)},e=function(){b.o(d,1,-1)},b.j(d,"play",c),b.j(d,"pause",e),b.j(d,"seeking",e),b.j(d,"seeked",c),b.j(d,"ended",function(){b.o(d,0,-1)}),b.j(d,"timeupdate",c),k=function(){d.paused||d.ended||d.seeking||b.o(d,3,-1);setTimeout(k,1E3)},k())};b.j=function(b,c,e){b.attachEvent?b.attachEvent("on"+c,e):b.addEventListener&&b.addEventListener(c,e,!1)};void 0==b.completeByCloseOffset&&(b.completeByCloseOffset=1);void 0==b.completeCloseOffsetThreshold&&(b.completeCloseOffsetThreshold=
1);b.Heartbeat={};b.N=function(){var d,c;if(b.autoTrack&&(d=b.s.d.getElementsByTagName("VIDEO")))for(c=0;c<d.length;c++)b.attach(d[c])};b.j(q,"load",b.N)}
;
define("appmeasurementMedia", function(){});

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
q=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},
x=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,
d)).finalize(c)}}});var w=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=
c[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);

define("cryptojs/sha256", function(){});

/*
This code has been developed in line with Sky's "JavaScript Measurement for Smart TV
Analytics Implementation Guide" version 0.2 - 31/07/2015.

Video tracking part: using milestones, tracking 3 parts
start of video (mediastart) which video is starting. Naming convention for page name: 
    ID 8*EV[0-9] Movie title Type (trailer, series, VOD)
Video.product: "online" except within snap, it's "snap" there
length of the video
number of seconds played
event trigger for media complete
scroll forwards or backwards: watch for 30s then jump to 10m: it should track to 1 minute total duration not 11 minutes. Total time spent watching the video.
live streams: playback milestones in minutes or seconds, every 30 minutes

For the stream video event which is currently being broadcast. That has an ID as a number. (CMS ID: event/APIX id) 8 or 9 digits for movies starts with an 8. 
CMS ID from fincons we don't know, not relevant
Trailer tammy movie, correct ID already there

Lifecycle events: for ipads, specialised message app version xyz, ping for app start, app end. Sent by the omniture library. Not 100% neccescery.
*/

/**
 * Returns a singleton responsible for handling media analytics calls.
 * @name OmnitureMedia
 * @memberof storm
 * @class storm/OmnitureMedia
 */
define("storm/OmnitureMedia", [
    "xdk-base/class",
    "xdk-base/util",
    "appmeasurement",
    "appmeasurementMedia",
    "cryptojs/sha256",
    "xdk-base/device"
], function (klass,
             util,
             appmeasurement,
             appmeasurementMedia,
             sha256,
             axDevice){
        "use strict";
        var omnitureMediaKlass;
        
        omnitureMediaKlass = klass.create({
            _monitorCounter: 0,
            _eventNames: {
                VIDEO_COMPLETE: "event16"
            },
            LIVE_PROGRAMCHECK_INTERVAL: 20
        },
        {
            s: null,
            __initialized: false,
            _device: "",
            _currentEvent: {id: null, title: null},
            stormService: null,
            _sessionActive: false,
            _currentPosition: 0,
            _playedDuration: 0,
            
            init: function(omnitureLibrary, device, stormService) {
                this.s = omnitureLibrary;
                this._device = device;
                this.stormService = stormService;
                
                this._initMediaAnalytics();
                this.__initialized = true;
            },
            /**
             * Returns true if the analytics engine has been initialized
             * @method isInitialized
             * @public
             * @returns {Boolean}
             * @memberOf storm/OmnitureMedia
             */
            isInitialized: function () {
                return this.__initialized;
            },
            _initMediaAnalytics: function () {
                /*Configure Media Module Functions */
                this.s.Media.autoTrack = false;
                this.s.Media.segmentByMilestones = true;
                this.s.Media.trackWhilePlaying = true;
                this.s.Media.playerName = this._device;
                this.s.Media.trackUsingContextData = true;
                this.s.Media.monitor = util.bind(this.mediaMonitor, this);
            },
            
            /**
             * Traces information about the tracking during playback
             * @method monitor
             * @public
             * @memberOf storm/OmnitureMedia
             */
            mediaMonitor: function (s, media) {
                if (s !== undefined) {
                    this.s = s;
                }
                
                
                var fireRequest = false;
                var position = {"current": 0, "target": 0, "unit": ''};
                
                var setupTrackVod = function(currentPosition, trackDuration, milestones, milestonesTracked, milestoneTrackingEnabled) {
                    var percentage = (currentPosition / trackDuration)*100;
                
                    var targetPercentage = NaN;
                    if (milestoneTrackingEnabled) {
                        targetPercentage = milestones[milestonesTracked];
                    }
                    return {"current": percentage, "target": targetPercentage, "unit": "%"};
                };
                
                var setupTrackLive = function(currentPosition, offsetMilestones, milestonesTracked, milestoneTrackingEnabled) {
                    var position = currentPosition;
                    
                    if (milestoneTrackingEnabled) {
                        var targetTimeMileStone = offsetMilestones[milestonesTracked];
                    }
                    
                    return {"current": position, "target": targetTimeMileStone, "unit": "s"};
                };
                
                if (this._live) {
                    this._playedDuration += 1;
                    this._currentPsition += 1;
                    position = setupTrackLive(this._currentPosition, this._offsetMilestones, this._milestonesTracked, this._milestoneTrackingEnabled);
                } else {
                    position = setupTrackVod(this._currentPosition, this._trackDuration, this._milestones, this._milestonesTracked, this._milestoneTrackingEnabled);
                }
                     
                if (media && (media.event == "MILESTONE" || media.event == "SECONDS") && this._milestoneTrackingEnabled) {
                    
                     fireRequest = true;
                     console.info("[OmnitureMedia] Monitor: Currently at: " + position.current + " and have played " + this._playedDuration + " seconds. Firing "+ position.target + position.unit + " event");
                     
                     this._milestonesTracked += 1;
                     
                     if (this._milestonesTracked >= this._milestones.length) {
                         this._milestoneTrackingEnabled = false;
                     }
                }
                if (fireRequest) {
                    console.log("Firing milestone: " + position.current + " with track name: " + this._trackName);
                    fireRequest = false;
                    this.setAnalyticsTags();
                    sendRequest(this._trackName, this.s.Media.track);
                    this.unsetAnalyticsTags();
                }
                //else {
                //    console.info("[OmnitureMedia] Monitor: Not firing");
                //}
                          
                function sendRequest(trackName, track) {
                    console.info("[OmnitureMedia] Monitor: Firing: "+trackName);
                    track(trackName);
                }
            },
            mediaSetDuration: function(duration) {
                this._trackDuration = duration;
            },
            mediaSetPosition: function(position) {
               var timeDifference = Math.abs(position-this._currentPosition),
                   videoHasSkipped = timeDifference > 5;
               if (videoHasSkipped == false) {
                   this._playedDuration += timeDifference;
               }
               
               if (!this._live) {
                    this._currentPosition = position;
                }
            },
                
                
            /**
             * Check the current event on the currently running channel
             * and track if it has changed
             * @method checkLiveEvent
             * @public
             * @memberOf storm/OmnitureMedia
             */
            checkLiveEvent: function () {
                return this.getCurrentChannelProgram(this._channelId).then(util.bind(function (result) {
                    //console.log("[omnitureMedia] checkLiveEvent: result = " + result);
                    //console.log(JSON.stringify(result, null, 4));
                    if (result && result.id) {
                        console.log("[omnitureMedia] checkLiveEvent: result ID= " + result.id + " TITLE="+result.title);
                        
                        if (this._currentEvent.id != result.id || this._currentEvent.title != result.title) {
                            this._currentEvent = {id: result.id, title: result.title};
                            console.log("[omnitureMedia] checkLiveEvent: Live event programme has changed, sending tracking event");
                            this.setAnalyticsTags();
                            this.s.Media.track(this._trackName);
                            this.unsetAnalyticsTags();
                        }
                    }
                    this.resolve();
                }, this), function (reason) {
                    // Checking live show failed
                    console.error(reason);
                    this.resolve();
                });
            },
            /**
             * Register a media load/open action
             * @method mediaOpen
             * @public
             * @param {Object} asset The media asset being opened
             * @param {String} mediaType The type of media being opened (movie/trailer/clip)
             * @param {Number} trackDuration The length of the video in seconds
             * @memberOf storm/OmnitureMedia
             */
            mediaOpen: function (asset, mediaType, trackDuration) {
                if (!this.isInitialized()) {
                    console.warn("[OmnitureMedia] Analytics hasn't been initialized yet");
                    return;
                }
                        
                var videoType = asset.get("type") || "live";
                videoType = videoType.toLowerCase();

                // Name
                this._trackName = this._getTrackNameFromAsset(asset, mediaType);

                this._asset = asset;
                this._mediaType = mediaType;
                this._trackDuration = trackDuration;

                // Set tracking data
                this._setTrackingTags(asset, mediaType);

                console.log("[OmnitureMedia] mediaOpen(" + this._trackName + ", " + trackDuration + ")");

                if (videoType === "live") {
                    this._live = true;
                    this._trackDuration = trackDuration = -1;
                }
                else {
                    this._live = false;
                }
                
                // check current program before tracking
                this._channelId = asset.get("id");
                this._currentEvent = {id: asset.get("id"), title: asset.get("title")};
                this._sessionActive = true;
                
                this.getCurrentChannelProgram(this._channelId).then(util.bind(function (result) {
                    if (result && result.id) {
                        this._currentEvent = {id: result.id, title: result.title};
                    }
                    this.setAnalyticsTags();

                    try {
                        this.s.Media.open(this._trackName, trackDuration, this._device);
                        this.s.Media.play(this._trackName, 0);
                    }
                    catch (e) {
                        console.error(e);
                    }
                    
                    this.unsetAnalyticsTags();
                }, this), function (reason) {
                    // Checking live show failed
                    console.error(reason);
                    this.setAnalyticsTags();

                    // Track the open action anyway
                    try {
                        this.s.Media.open(this._trackName, trackDuration, this._device); 
                        this.s.Media.play(this._trackName, 0);
                    }
                    catch (e) {
                        console.error(e);
                    }
                    
                    this.unsetAnalyticsTags();
                });
                
                
                this._milestoneTrackingEnabled = true;
                this._milestonesTracked = 0;
                this._milestones = [10, 30, 50, 80, 90];
                this._offsetMilestones = [10, 60, 300, 600, 1800, 3600, 5400, 7200, 9000, 10800, 12600, 14400, 
                                          16200, 18000, 19800, 21600, 23400, 25200, 27000, 28800, 30600, 32400, 
                                          34200, 36000, 37800, 39600, 41400, 43200];
                this._currentPosition = 0;
                this._playedDuration = 0;
                
                this._refreshMetadataTimer = setInterval(util.bind(function() {
                    if (this._live) {
                        this.checkLiveEvent();
                    }
                }, this), 1*60*1000); 
            },
            getCurrentChannelProgram: function (channelId) {
                console.log("[OmnitureMedia] Checking current program for channel " + channelId);
                return this.stormService.onAirRequest({channelId: channelId}).then(function (result) {
                    console.info("[OmnitureMedia] On Air:");
                    console.info("[OmnitureMedia] Event ID: " + result.id);
                    console.info("[OmnitureMedia] Event title: " + result.title);
                    return result;
                });
            },
            /**
             * Sky-specific method that takes info from the asset and builds a string to track, according to their documents
             * @method _getTrackNameFromAsset
             * @private
             * @param {Object} asset The asset to track
             * @param {String} mediaType The type of media being played. This comes from the player, because at this stage we can't determine if it was a movie or its trailer that was started.
             * @memberOf storm/AnalyticsService
             */
            _getTrackNameFromAsset: function (asset, mediaType) {
                var eventId = asset.get("eventId"), title = asset.get("title"),
                    videoType = (asset.get("type") || "live"),
                    trackName, suffix = "VOD";

                videoType = videoType.toLowerCase();

                if (videoType == "film") {
                    suffix = mediaType == "movie" ? "VOD" : "TRAILER";
                    trackName = "ev_" + eventId + "::" + title + "::" + suffix;
                }
                else if (videoType == "episode") {
                    suffix = "SERIES";
                    var episode = asset.get("episodeNumber");
                    var season = asset.get("seasonNumber");
                    var serie = asset.get("serieTitle");
                    trackName = "ev_" + eventId + "::S" + season + " E" + episode + ":" + serie + "::" + suffix;
                }
                else if (videoType == "live") {
                    suffix = "STREAM";
                    var channel = asset.get("id");
                    trackName = "ev_" + channel + "::" + title + "::" + suffix;
                }
                
                //console.log("--- OMNITURE TRACKING. Asset details: ---- ");
                //console.log(JSON.stringify(asset, null, 4));
                //console.log("--- OMNITURE mediaType: ---");
                //console.log(JSON.stringify(mediaType, null, 4));
                return trackName;
            },
            /**
             * Register a media play action
             * @method mediaPlay
             * @public
             * @param {Object} asset The media asset being played
             * @param {String} mediaType The type of media being played (movie/trailer/clip)
             * @param {Number} position The current playback position
             * @memberOf storm/OmnitureMedia
             */
            mediaPlay: function (asset, mediaType, position) {
                if (this.isInitialized()) {

                    position = position || this._currentPosition;
                    if (!this._live) {
                        this._currentPosition = position;
                    }
                    
                    console.log("[OmnitureMedia] mediaPlay(" + this._trackName + ", " + this._playedDuration + ")");
                    try {
                        this.setAnalyticsTags();
                        this.s.Media.play(this._trackName, this._playedDuration);
                    }
                    catch (e) {
                        console.error(e);
                    }
                    this.unsetAnalyticsTags();
                }
                else {
                    console.warn("[OmnitureMedia] Analytics hasn't been initialized yet");
                }
            },
            /**
             * Sky-specific method that takes info from the asset and sets some custom tracking tags
             * @method _setTrackingTags
             * @private
             * @param {Object} asset The asset to track
             * @param {String} mediaType The type of media being played. This comes from the player, because at this stage we can't determine if it was a movie or its trailer that was started.
             * @memberOf storm/AnalyticsService
             */
            _setTrackingTags: function (asset, mediaType) {
                var videoType = asset.get("type") || "live";
                videoType = videoType.toLowerCase();

                // Genre and series tags
                var genre = "";
                var series = "";
                if (videoType === "film" || videoType === "episode") {
                    var genreList = asset.get("genreList");
                    if (genreList) {
                        if (typeof(genreList.main) !== "undefined") {
                            if (typeof(genreList.main.content) !== "undefined") {
                                genre = genreList.main.content;
                            }
                        }
                    }

                    if (videoType === "episode") {
                        var episode = asset.get("episodeNumber");
                        var season = asset.get("seasonNumber");
                        series = "S" + season + ":E" + episode;
                    }
                    
                    this.s.movieID = null;
                    
                    this.s.Media.trackUsingContextData = true;
                    
                    this.s.Media.trackOffsetMilestones = null;
                    this.s.Media.trackSeconds = null;
                    this.s.Media.trackMilestones = "10,30,50,80,90";
                }
                else if (videoType === "live") {
                    this.s.Media.trackMilestones = null;
                    this.s.Media.trackOffsetMilestones = "10,60,300,600"; // send tracking events after 10 sec, 1 min, 5 min & 10 min on a live stream
                    this.s.Media.trackSeconds = 1800;                     // also send tracking every 30 minutes
                }
                
                this._genre = genre;
                this._series = series;
                if (this._live) {
                    this.s.contextData["video.program"] = this._currentEvent.title;
                    this.s.contextData["video.program.eventid"] = this._currentEvent.id;
                }
                var SNAP_CATALOGUE = ["HE", "snap", "sn"];
                if (SNAP_CATALOGUE.indexOf(asset.get("catalog")) !== -1) {
                    this._product = "snap";
                }
                else {
                    this._product = "online";
                }
                this.s.Media.length = this._trackDuration;
            },
            setAnalyticsTags: function() {
                this.s.contextData["video.genre"] = this._genre;
                this.s.contextData["video.series"] = this._series;
                if (this._live) {
                    this.s.contextData["video.program"] = this._currentEvent.title;
                    this.s.contextData["video.program.eventid"] = this._currentEvent.id;
                }
                this.s.contextData["video.product"] = this._product;
                if (this._previousProductValue == null || this._previousProductValue == undefined) {
                    this._previousProductValue = this.s.contextData["box.product"];
                    this.s.contextData["box.product"] = this._product;
                }
                console.log("[OmnitureMedia] setAnalyticsTags with values:");
                console.log("genre: " + this._genre + " series: " + this._series + " program title: " + 
                    this._currentEvent.title + " program id: " + this._currentEvent.id + " product: " + this._product);
            },
            unsetAnalyticsTags: function() {
                this.s.contextData["video.genre"] = null;
                this.s.contextData["video.series"] = null;
                this.s.contextData["video.program"] = null;
                this.s.contextData["video.program.eventid"] = null;
                this.s.contextData["video.product"] = null;
            },
            /**
             * Register a media stop/pause action
             * @method mediaStop
             * @public
             * @param {Object} asset The media asset being stopped
             * @param {String} mediaType The type of media being stopped (movie/trailer/clip)
             * @param {Number} position The current playback position
             * @memberOf storm/OmnitureMedia
             */
            mediaStop: function (asset, mediaType, position) {
                asset = asset || this._asset;
                mediaType = mediaType || this._mediaType;
                position = position || this._currentPosition;

                if (this.isInitialized()) {
                    // Set tracking data
                    this._setTrackingTags(asset, mediaType);

                    console.log("[OmnitureMedia] mediaStop(" + this._trackName + ", " + this._playedDuration + ")");

                    try {
                        this.setAnalyticsTags();
                        this.s.Media.stop(this._trackName, this._playedDuration);
                        
                        this.unsetAnalyticsTags();
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                else {
                    console.warn("[OmnitureMedia] Analytics hasn't been initialized yet");
                }
            },
            /**
             * Register a media close action
             * @method mediaClose
             * @public
             * @param {Object} asset The media asset being closed
             * @param {String} mediaType The type of media being closed (movie/trailer/clip)
             * @param {String} currentPlaybackPosition The current position of the video
             * @memberOf storm/OmnitureMedia
             */
            mediaClose: function (asset, mediaType, currentPlaybackPosition) {
                asset = asset || this._asset;
                mediaType = mediaType || this._mediaType;
                currentPlaybackPosition = currentPlaybackPosition || this._currentPosition;
                
                
                if (!this.isInitialized()) {
                    console.warn("[OmnitureMedia] Analytics hasn't been initialized yet");
                    return;
                }
                
                if (!this._sessionActive) {
                    console.warn("[OmnitureMedia] mediaClose called twice");
                    return;
                }
                this._sessionActive = false;
                this.mediaStop(asset, mediaType, currentPlaybackPosition);

                // Set tracking data
                this._setTrackingTags(asset, mediaType);
                this.setAnalyticsTags();
                console.log("[OmnitureMedia] mediaClose(" + this._trackName + ")");

                try {
                    this.setAnalyticsTags();
                    this.s.Media.close(this._trackName); 

                    // Reset options
                    this._genre = null;
                    this._series = null;
                    this._product = null;
                    this.s.contextData["box.product"] = this._previousProductValue;
                    this._previousProductValue = null;
                    this._currentEvent = {id: null, title: null};
                    this._live = false;
                    this._trackName = "";
                    this.s.Media.trackMilestones = null;
                    this.s.Media.trackOffsetMilestones = null
                    this.s.Media.trackSeconds = null;  
                    this.s.movieID = null;
                    this.unsetAnalyticsTags();
                    clearInterval(this._refreshMetadataTimer);
                }
                catch (e) {
                    console.error(e);
                }
            },
            
            _prepareTrackingObject: function (events, properties) {

                var property,
                    sProp,
                    platform = this._getAnalyticsPlatform(),
                    platformModel = this._getAnalyticsPlatformModel();
                
                properties.hier1 = properties.hierarchy;

                return properties;
            },


            _getAnalyticsPlatformModel: function () {

                // Use samsung by default (workstation)
                var platform = this._getAnalyticsPlatform(),
                    model = "";

                if (platform === "samsungtv") {
                    model = axDevice.id.getFirmwareYear();
                } else if (platform === "playstation") {
                    model = axDevice.platform;
                }

                return model;
            },
            _getAnalyticsPlatform: function () {

                // Use samsung by default (workstation)
                var platform = "samsungtv";

                if (axDevice.platform === "samsung") {
                    platform = "samsungtv";
                } else if (axDevice.platform === "ps3" || axDevice.platform === "ps4") {
                    platform = "playstation";
                }

                return platform;
            },
            mediaSetAsset: function(asset) {
                this._asset = asset;
                
                this._channelId = asset.get("id");
                this._currentEvent = {id: asset.get("id"), title: asset.get("title")};
            },
            mediaSetMediaType: function(mediaType) {
                this._mediaType = mediaType;
            }
        });
    return omnitureMediaKlass;
});

/*
This code has been developed in line with Sky's "JavaScript Measurement for Smart TV
Analytics Implementation Guide" version 0.2 - 31/07/2015.

Please reference the updated spec with any changes to this file.

Implementation notes: This is what Sky consider important for their tracking.

There are two tracking systems in this product.
omniture: used for tracking which user watches which video
conviva: used for quality assurance, overall time spent watching videos, and crash reporting

only track 2 levels
1st level navigation: categories on top bar 
2nd level hierarchy: only shows the guide
individual movie title: navigation to detail page not neccessary

After navigating through different cargories, snap back to home, home navigated to sevral detail onpageshow
the link was given as snap/movie-title that was incorrect.
*/

/**
 * Returns a singleton responsible for handling analytics calls.
 * @name AnalyticsService
 * @memberof storm
 * @class storm/AnalyticsService
 */
define("storm/OmnitureStats", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/promise",
    "xdk-base/console",
    "xdk-base/ajax",
    "tve/TVEError",
    "tve/sAppGridServiceHolder",
    "storm/mgr/sAppConfigManager",
    "storm/mgr/sLocalStorageManager",
    "xdk-base/device",
    "storm/OmnitureMedia",
    "appmeasurement",
    "appmeasurementMedia",
    "cryptojs/sha256"
], function (klass,
             util,
             config,
             promise,
             console,
             ajax,
             TVEError,
             sAppGridServiceHolder,
             sAppConfigManager,
             sLocalStorageManager,
             axDevice,
             OmnitureMedia) {

    "use strict";
    var AnalyticsService;
    AnalyticsService = klass.create({
            PLATFORM: {
                OMNITURE: "omniture"
            },
            TRACK_PAGE_LEVELS: 2
        },
        {
            __initialized: false,
            _live: false,
            _channelId: null,
            _trackName: "",
            _currentSection: "",
            _currentPage: "",
            _currentPath: "",
            _platformConfig: null,
            config: null,
            stormService: null,
            previousPageAnalytics: "",
            s_account: "",
            s: null,
            media: null,

            init: function (sStormService) {
                this.stormService = sStormService;
                
                this._platformConfig = config.get("analytics.platform", null);
                if (this._platformConfig) {
                    sAppGridServiceHolder.getAppGridServicePromise().then(util.bind(function () {
                        this._initDefer = promise.defer();
                        sAppConfigManager.getAnalyticsConfig().then(util.bind(this._getAnalyticsConfigCallback, this));
                    }, this));
                }
            },
            
            _getAnalyticsConfigCallback: function (analyticsConfig) {
                if (this.isInitialized()) {
                    this._initDefer.reject(new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "AnalyticsService init: Analytics has already been initialized"));
                }

                console.log("[OmnitureStats] Analytics platform used: " + this._platformConfig);

                if (this._platformConfig === AnalyticsService.PLATFORM.OMNITURE) {
                    try {
                        this.config = this._parseAnalyticsConfig(analyticsConfig);
                        var account = analyticsConfig.ACCOUNT;
                        var device = analyticsConfig.DEVICE;

                        console.log("[OmnitureStats] Analytics init:");
                        console.log("[OmnitureStats] Account: " + account);
                        console.log("[OmnitureStats] Device: " + device);

                        var appMeasurement = new AppMeasurement();
                        this.s = appMeasurement;
                        this.media = new OmnitureMedia(appMeasurement, device, this.stormService);
                        
                        this.s_account = appMeasurement.account = account;
                        //addChild(appMeasurement);
                        this._configureAnalytics(account);

                        /*********Media Module Calls**************/

                        /* Turn on and configure debugging here */
                        appMeasurement.debugTracking = config.get("analytics.debug", true);
                        // For local debugging
                        //appMeasurement.debugTracking = true;
                        appMeasurement.trackLocal = true;
                        appMeasurement.trackingServer = "omni.sky.de";
                        appMeasurement.trackingServerSecure = "somni.sky.de";

                        this._sAppMeasurement = appMeasurement;

                        // Set device, product & version
                        appMeasurement.contextData["box.device"] = this.config.DEVICE;
                        appMeasurement.contextData["box.product"] = "online";
                        appMeasurement.contextData["box.app.version"] = config.get("version");

                        this.__initialized = true;
                        this._initDefer.resolve(); // This will allow any requests to proceed that have been blocked waiting on this config.
                    } catch (e) {
                        this._initDefer.reject(new TVEError(TVEError.FACILITY.GENERAL, TVEError.ERROR.INVALID, "AnalyticsService init: " + e));
                    }
                }
            },

            _configureAnalytics: function (account) {
                this.s.account = account;
                /************************** CONFIG SECTION **************************/
                /* You may add or alter any code config here. */
                /* Link Tracking Config */
                this.s.charSet = "UTF-8";
                this.s.trackDownloadLinks = false;
                this.s.trackExternalLinks = false;
                this.s.trackInlineStats = false;
                this.s.linkDownloadFileTypes = "exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";
                this.s.linkInternalFilters = "javascript:"; //optional: add your internal domain here
                this.s.linkLeaveQueryString = false;
                this.s.linkTrackVars = "None";
                this.s.linkTrackEvents = "None";

                this.s.visitorNamespace = "st";
                this.s.dc = '122';

                // Get username from local storage
                var username = sLocalStorageManager.getStoredValue(sLocalStorageManager.KEYS.USERNAME);
                if (username && username !== "") {
                    this.s.visitorID = CryptoJS.SHA256(username);
                }
            },
                        
            _parseAnalyticsConfig: function (analyticsConfig) {
                /**
                 * This method accepts a structure like
                 {
                   "ACCOUNT": "skystorm-stv-live",
                   "DEVICE": "tvlg"
                 }
                 The DEVICE field is populated into the omniture library. This value
                 is a private agreement between us and Sky and should probably be updated
                 in the future to have a device name to tracking name mapping i.e.
                 "Samsung": "smarttv", "LG": "tvlg" and "Playstation": "playstation"
                 in AppGrid.
                 At the moment (17/06/15) if this is set to anything other than tvlg then Sky's stat tracking will
                 be unable to see the video tracking sessions.
                 */
                var config = {};
                if (analyticsConfig) {

                    if (analyticsConfig[axDevice.platform]) {
                        config.DEVICE = analyticsConfig[axDevice.platform];
                    }
                    else {
                        config.DEVICE = analyticsConfig.DEVICE;
                    }

                    config.ACCOUNT = analyticsConfig.ACCOUNT;
                }
                return config;
            },
            /**
             * Tracks a login action
             * @method login
             * @public
             * @param {String} username The username
             * @memberOf storm/AnalyticsService
             */
            login: function (username) {
                if (this.isInitialized()) {
                    console.log("[OmnitureStats] login(" + username + ")");

                    try {
                        /* Visitor identification is essential for tracking. Javascript Library stores the visitor identificator in a cookie.
                           As this technology is not available by Smart TV apps, the visitor ID has to be set manually and persistent
                           by Sky customer ID (SHA 256 hashed). */
                        var hashedUsername = CryptoJS.SHA256(username);
                        this.s.visitorID = hashedUsername;
                        this.s.contextData["user.hashedCID"] = hashedUsername;
                        this.s.contextData["action.login"] = 1;
                        var resultCode = this.s.t();
                        if (resultCode) {
                                console.log("[OmnitureStats] Error from Omniture analytics: " + resultCode);
                            }
                        this.s.contextData["action.login"] = "";
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                else {
                    console.warn("[OmnitureStats] Analytics hasn't been initialized yet");
                }
            },

            /**
             * Tracks a logout action
             * @method logout
             * @public
             * @memberOf storm/AnalyticsService
             */
            logout: function () {
                if (this.isInitialized()) {
                    console.log("[OmnitureStats] logout()");

                    try {
                        this.s.contextData["action.logout"] = 1;
                        var result = this.s.t();
                        console.log(result);
                        this.s.contextData["action.logout"] = "";
                        delete this.s.visitorID;
                        delete this.s.contextData["user.hashedCID"];
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                else {
                    console.warn("[OmnitureStats] Analytics hasn't been initialized yet");
                }
            },

            /**
             * Tracks a page load
             * @method trackLevel
             * @public
             * @param {int} level The level to track
             * @param {String} pageName The page of the interface
             * @param {Boolean} force Whether to force a track action
             * @memberOf storm/AnalyticsService
             */
            trackLevel: function (level, pageName, force) {
                if (!this.isInitialized()) {
                    console.warn("[OmnitureStats] Analytics hasn't been initialized yet");
                    return;
                }
                if (level > AnalyticsService.TRACK_PAGE_LEVELS) {
                    return;
                }
                
                var forceTracking = false;
                if (force === true) {
                    forceTracking = true;
                }
                
                if (pageName === undefined) {
                    pageName = this._currentPath;
                }
                
                if (pageName.length === 0) {
                    return;
                }
                    
                // Combine the  names for the first and second level menus in the UI into a single 'path' string 
                var trackingPath;
                console.log("[OmnitureStats] AnalyticsService::trackLevel(\"" + level + "\",\"" + pageName + "\")");
                if (level === 1) {
                    
                    if (pageName.toLowerCase() === "snap") {
                        this.s.contextData["box.product"] = "snap";
                    } else {
                        this.s.contextData["box.product"] = "online";
                    }
                    
                    trackingPath = this._currentSection = pageName;
                    delete this._currentPath;
                }
                else if (level === 2) {
                    // Ignore duplicate level 2 events
                    if (pageName === this._currentPath) {
                        return;
                    }
                        
                    // Home isn't ok to use as a level 1 menu
                    if (this._currentSection === "Home") {
                        delete this._currentSection;
                        trackingPath = pageName;
                    } else {
                        trackingPath = this._currentSection + "/" + pageName;
                    }
                    this._currentPath = pageName;
                }
                
                // And send the tracking event
                if (this._currentPage !== pageName || forceTracking) {
                    // Save the last tracked page, to avoid duplicates on next call
                    this._currentPage = pageName;
                    this.__setTracking({"pageName": trackingPath, "level1": this._currentSection, "level2": this._currentPath});
                }
            },
            
            /**
             * Tracks a page load for detail pages
             * @method trackPage
             * @public
             * @param {String} pageName The page of the interface
             * @param  {Boolean} force Whether to force a track action
             * @memberOf storm/AnalyticsService
             */
            trackPage: function (pageName, channel) {
                console.log("[OmnitureStats] AnalyticsService::trackPage(\"" + pageName + "\",\"" + channel + "\")");
                this.mediaClose();
                this.__setTracking({"pageName": pageName, "channel": channel, "level1": this._currentSection, "level2": this._currentPath});
            },
            
            /**
             * Resets the shared state used by omniture tracking and reports events
             * @method __setTracking
             * 
             * @param {Object} trackingOptions The tracking options
             *      pageName - name of the page 
             *      level    - level 1 menu (home, sky guide, settings etc.)
             *      level2   - level 2 menu (      heute, einstelligun etc.)
             *      channel  - Channel name (Sky Atlantic, Sky Sports HD etc.)
             */
            __setTracking: function(trackingOptions) {
                if (!this.isInitialized()) {
                    console.warn("[OmnitureStats] Analytics hasn't been initialized yet");
                    return;
                }
                
                if (trackingOptions.level1 === undefined) {
                    delete this.s.contextData["page.level1"];
                } else {
                    this.s.contextData["page.level1"] = trackingOptions.level1;
                }
                if (trackingOptions.level2 === undefined) {
                    delete this.s.contextData["page.level2"];
                } else {
                    this.s.contextData["page.level2"] = trackingOptions.level2;
                }
                if (trackingOptions.channel === undefined) {
                    delete this.s.channel;
                } else {
                    this.s.channel = trackingOptions.channel;
                }
                
                delete this.s.contextData["video.product"];
                this.s.pageName = trackingOptions.pageName;
                this.s.contextData["stv.page.pageName"] = trackingOptions.pageName;
                this.s.contextData["page.pageName"]  = trackingOptions.pageName;
                
                try {
                    var resultCode = this.s.t();
                    if (resultCode) {
                        console.warn("[OmnitureStats] Error from Omniture analytics: " + resultCode);
                    }
                } catch (e) {
                    console.error(e);
                }
                
                console.log("[OmnitureStats] AnalyticsService::setTracking(\"" + trackingOptions.pageName + "\")");                
            },
            
            trackSearch: function(searchTerm) {
                try {
                    this.s.contextData["page.search.term"] = searchTerm;
                    var resultCode = this.s.t();
                    if (resultCode) {
                        console.warn("[OmnitureStats] Error from Omniture analytics: " + resultCode);
                    }
                }
                catch (e) {
                    console.error(e);
                }
                
                delete this.s.contextData["page.search.term"]
            },

            /**
             * Returns true if the analytics engine has been initialized
             * @method isInitialized
             * @public
             * @returns {Boolean}
             * @memberOf storm/AnalyticsService
             */
            isInitialized: function () {
                return this.__initialized;
            },
            
            /* Below here is just passing through to the OmnitureMedia module */
            mediaOpen: function(asset, mediaType, trackDuration) {
                this.media.mediaOpen(asset, mediaType, trackDuration);
            },
            mediaStop: function(asset, mediaType, position) {
                this.media.mediaStop(asset, mediaType, position);
            },
            mediaPlay: function(asset, mediaType, position) {
                this.media.mediaPlay(asset, mediaType, position);
            },
            mediaClose: function(asset, mediaType, currentPlaybackPosition) {
                this.media.mediaClose(asset, mediaType, currentPlaybackPosition);
            },
            mediaSetDuration: function(duration) {
                this.media.mediaSetDuration(duration);
            },
            mediaSetPosition: function(position) {
                this.media.mediaSetPosition(position);
            },
            mediaMonitor: function(s, media) {
                this.media.mediaMonitor(s, media);
            },
            mediaSetAsset: function(asset) {
                this.media.mediaSetAsset(asset);
            },
            mediaSetMediaType: function(mediaType) {
                this.media.mediaMonitor(mediaType);
            },
            mediaCheckLiveEvent: function() {
                this.media.checkLiveEvent();
            }
        });

    return AnalyticsService;
});

/**
 * @name tve/sServiceHolder
 * @memberof tve
 * @class Returns a singleton responsible for providing the remote services public interfaces.
 */
define("tve/sServiceHolder", [
    "tve/AccedoOvpService",
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/promise",
    "xdk-base/console",
    "tve/StormService",
    "storm/OmnitureStats"
], function(
    AccedoOvpService,
    klass,
    util,
    config,
    promise,
    console,
    StormService,
    OmnitureStats
    ) {

    "use strict";

    var ServiceHolder = klass.create({}, {

        /**
         * Service holder for dateTimeService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __dateTimeService: null,

        /**
         * Service holder for configurationService which has a public getter function
         * @memberof tve/sgetLinear
         * @private
         */
        __configurationService: null,

        /**
         * Service holder for statusService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __statusService: null,

        /**
         * Service holder for loggingService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __loggingService: null,

        /**
         * Service holder for analyticsService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __analyticsService: null,

        /**
         * Service holder for vodContentService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __vodContentService: null,

        /**
         * Service holder for __stormAssetService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __stormAssetService: null,

        /**
         * Service holder for linearContentService which has a public getter function
         * @memberof tve/sServiceHolder
         * @private
         */
        __linearContentService: null,

        /**
         * Service holder for ovpService which is for setting the public service
         * @memberof tve/sServiceHolder
         * @private
         */
        __ovpService: null,

        /**
         * The Platform service 
         * @memberof tve/sServiceHolder
         * @private
         */
        __stormService: null,

        /**
         * Return the DateTimeService
         * @method getDateTimeService
         * @memberof tve/sServiceHolder
         * @public
         */
        getDateTimeService: function() {
            this.__dateTimeService = this.__dateTimeService || this.__getStormService();
            return this.__dateTimeService;
        },

        /**
         * Return the VODContentService
         * @method getVODContentService
         * @memberof tve/sServiceHolder
         * @public
         */
        getVODContentService: function() {
            this.__vodContentService = this.__vodContentService || this.__getAccedoOvpService();
            return this.__vodContentService;
        },

        /**
         * Return the LinearContentService
         * @method getLinearContentService
         * @memberof tve/sServiceHolder
         * @public
         */
        getLinearContentService: function() {
            this.__linearContentService = this.__linearContentService || this.__getStormService();
            return this.__linearContentService;
        },

        /**
         * Return the storm asset service.
         * @method getStormAssetService
         * @memberof tve/sServiceHolder
         * @public
         */
        getStormAssetService: function () {
            this.__stormAssetService = this.__stormAssetService || this.__getStormService();
            return this.__stormAssetService;
        },

        /**
         * Return the analytics service.
         * @method getAnalyticsService
         * @memberof tve/sServiceHolder
         * @public
         */
        getAnalyticsService: function () {
            this.__analyticsService = this.__analyticsService || this.__getAnalyticsService();
            return this.__analyticsService;
        },

        /**
         * Return the OvpService
         * @method __getAccedoOvpService
         * @memberof tve/sServiceHolder
         * @private
         */
        __getAccedoOvpService: function(){
            if (this.__ovpService) {
                return this.__ovpService;
            }

            var ovpConfig = config.get("tve.ovp");

            if (ovpConfig && ovpConfig.api) {
                this.__ovpService = new AccedoOvpService({
                    baseURL: ovpConfig.api
                });
                return this.__ovpService;
            }

            console.error("### Unable to initialize the Ovp Service, can not find the API end-point and keys from config");
        },

        /**
         * Return the AnalyticsService
         * @method __getAnalyticsService
         * @memberof tve/sServiceHolder
         * @private
         */
        __getAnalyticsService: function(){
            if (this.__analyticsService) {
                return this.__analyticsService;
            }
            this.__analyticsService = new OmnitureStats(this.__getStormService());
            return this.__analyticsService;
        },

        /**
         * Return the StormService
         * @method __getStormService
         * @memberof tve/sServiceHolder
         * @private
         */
        __getStormService: function(){
            if (this.__stormService) {
                return this.__stormService;
            }

            var opts = {
                proxy: false, // You can set to false here to turn the proxy off throughout (during development).
                production: (config.get("environment") === "production")
            };
            
            opts.proxy      = config.get("dev.proxy");
            opts.proxyHosts = config.get("dev.proxyHosts");

            var device = amd.require("xdk-base/device");

            if (device.platform === "samsung") {
                opts.proxy = false;
            } else if (device.platform === "webos" || device.platform === "lg") {
                //opts.proxy = true;
            } else {
                console.warn("Proxy option is " + opts.proxy + "; we don't seem to be on an actual device");
            }

            this.__stormService = new StormService(opts);
            return this.__stormService;
        },

        /**
         * Init the sServiceHolder module
         * @method init
         * @memberof tve/sServiceHolder
         * @private
         */
        init: function() {

        }
    });

    return new ServiceHolder();
});
define("tvedemo/mgr/sNavigationManager", [
    "tvedemo/helper/dialogHelper",
    "tvedemo/mgr/sHistoryManager",
    "storm/mgr/sLanguageManager",
    "tve/sServiceHolder",
    "xdk-ax/mediator",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/util",
    "xdk-base/ax",
    "tve/TVEError",
    "storm/helper/util"
], function(
    dialogHelper,
    sHistoryManager,
    sLanguageManager,
    sServiceHolder,
    mediator,
    console,
    promise,
    util,
    ax,
    TVEError,
    stormUtil
    ) {

    "use strict";

    var FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,

        linearContentService = sServiceHolder.getLinearContentService(),
        NavigationManager = ax.klass.create({}, {

            // @TODO: move them to somewhere else (e.g. xdk.config/appGrid) then to be initiated on init()
            CONFIG_AUTO_NAVIGATION: false,  // Auto navigate to the first node of deeper level menu system
            CONFIG_CUSTOM_HIGHLIGHT: true,  // Use injected JSON to supply highlights contents

            MENU_UPDATE: "menuUpdate",
            MENU_RECONSTRUCT_COMPLETE: "menuReconstructComplete",
            MAIN_MENU: 1,
            SUB_MENU: 2,

            MENU_RESPOND_TIME: 200,

            _menuStack: [],
            _selectionStack: [],
            _fullSelectionStack: [],
            _breadcrumbStack: [],
            _currentMenuTitle: "",
            _currentSelectedIndex: 0,
            _disabledMenuItems: [32],

            __lastLoginStatus: false,   // to avoid circular dependency...

            _processing: 0,

            _menuUpdateCallback: undefined,
            _menuResetCallback: undefined,

            isInitiated: function() {
                return this._menuStack.length;
            },

            _resetMenu: function(loggedIn) {
                this._menuStack = [];
                this._selectionStack = [];
                this._breadcrumbStack = [];
                loggedIn = !!loggedIn; // rectify to pure boolean flag
                return this.getMainMenu(loggedIn).then(util.bind(function (mainMenu) {
                    this._menuStack[0] = mainMenu;
                    return this._menuStack[0];
                }, this));
            },

            /**
             * Get Hardcode Menu items & Refresh Level 1 Menu items from CMS
             * @param  {boolean} loggedIn
             * @return {Array}
             */
            getMainMenu: function(loggedIn) {
                this._processing++;
                loggedIn = !!loggedIn; // rectify to pure boolean flag
                return linearContentService.getNavigation().then(util.bind(function (data) {
                    var menulist = this._parseXMLtoMenulist(data),

                    //
                    // Hardcode Menu Items, appending items
                    //
                        hardcodeList = [{
                            //
                            // We could use CSS to make these upper case, but this way we keep flexibility... just in case!
                            //
                            text: sLanguageManager.getString("Settings.Settings_label_MyStuff").toUpperCase(), // Use of "Settings." is an error by Sky.
                            loginStateMustBe: true,
                            id: "mystuff",
                            _children: [
                                {
                                    text: sLanguageManager.getString("MainNavigation.MainNavigation_WatchlistSectionLabel").toUpperCase(),
                                    id: "watchlist",
                                    path: "Main/Watchlist"
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_label_RecentlyWatched").toUpperCase(), // Use of "Settings." is an error by Sky.
                                    id: "recentlyWatched",
                                    path: "Main/RecentlyWatched"
                                }
                            ]
                        },{
                            text: sLanguageManager.getString("Global.Global_Search_menu_item").toUpperCase(),
                            id: "search",
                            action: function() {
                                dialogHelper.input({
                                    dialogCss: "search-dialog",
                                    title: sLanguageManager.getString("Global.Global_SearchPopUpTitle"),
                                    message: sLanguageManager.getString("Global.Global_SearchPopUpMessage"),
                                    finishedTextInput: function(text) {
                                        //
                                        // Only proceed with the search if some search terms actually entered.
                                        //

                                        if (text) {
                                            mediator.publish("navigate", {
                                                path: "Main/SearchListing",
                                                state: {
                                                    keyword: text
                                                }
                                            });
                                        }
                                    },
                                    positiveText: sLanguageManager.getString("Suchen"),
                                    negativeText: sLanguageManager.getString("Global.Global_buttonBack_button")
                                });
                            }
                        },{
                            text: sLanguageManager.getString("MainNavigation.MainNavigation_SettingsSectionLabel").toUpperCase(),
                            id: "setting",
                            _children: [
                                {
                                    text: sLanguageManager.getString("Settings.Settings_Menu_item_Account").toUpperCase(),
                                    id: "myAccount",
                                    path: "Main/MyAccount",
                                    requireLogin: true
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelDeviceManagement").toUpperCase(),
                                    id: "deviceManagement",
                                    path: "Main/Devices",
                                    requireLogin: true
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelEULA").toUpperCase(),
                                    id: "eula",
                                    path: "Main/TextPage"
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelPrivacy_policy").toUpperCase(),
                                    id: "dataPrivacy",
                                    path: "Main/TextPage"
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelImprint").toUpperCase(),
                                    id: "imprint",
                                    path: "Main/TextPage"
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelTermsAndConditions").toUpperCase(),
                                    id: "tnc",
                                    path: "Main/TextPage"
                                }
                                /*
                                 * As per SKYSTORM-426, the FAQ and connection test items are temporarily removed.
                                 * @TODO: Reinstate FAQ and connection test in Phase 2. See SKYSTORM-184, SKYSTORM-146.
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelFAQ").toUpperCase(),
                                    id: "faq"
                                },
                                {
                                    text: sLanguageManager.getString("Settings.Settings_labelConnections_system_test").toUpperCase(),
                                    id: "connectionTest"
                                }
                                */
                            ]
                        },{
                            text: sLanguageManager.getString("Settings.Settings_labelAccount").toUpperCase(),
                            loginStateMustBe: false,
                            id: "login",
                            path: "Main/Login"
                        }],

                        _filterMenuItem = function (list) {
                            list = list.filter(function (item) {
                                if (item._children) {
                                    item._children = _filterMenuItem(item._children);
                                }
                                //
                                // For this to work, loginStateMustBe needs THREE recognised states, true, false, and don't care!
                                //
                                if (ax.util.isUndefined(item.loginStateMustBe)) {
                                    return true;
                                } else {
                                    return item.loginStateMustBe === loggedIn;
                                }
                            });
                            return list;
                        };

                    if (!menulist) {
                        console.error("Fatal error! Cannot parse XML Menu");
                        throw new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "Fatal error! Cannot parse XML Menu");
                    }
                    return menulist.concat(_filterMenuItem(hardcodeList));
                }, this)).complete(util.bind(function() {
                    this._processing--;
                }, this));
            },

            /**
             * Create a submenu based on menulist
             * the current status of menu will be stored in stacks
             * Also, automatically handle the first/preselectIndex item
             * @param  {Array} menulist         list of menu item
             * @param  {Number} preselectIndex  Item index to be handled when submenu loaded
             * @param  {Boolean} autoNavigate   Auto navigate to preselected item
             * @return {Promise.resolve}        Item that will be selected
             */
            _propagateSubmenu: function(menulist, preselectIndex, autoNavigate) {
                autoNavigate = autoNavigate || false;

                if (!menulist || !menulist.length) {
                    console.error("Cannot propagate empty submenu");
                    return promise.reject(new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "Cannot propagate empty submenu"));
                }
                if (!preselectIndex || preselectIndex >= menulist.length || preselectIndex < 0) {
                    preselectIndex = 0;
                }
                this._menuStack.push(menulist);
                this._breadcrumbStack.push(this._currentMenuTitle);
                this._selectionStack.push(this._currentSelectedIndex);
                var searchIndex,
                    deferred = promise.defer();
                for (var i=0,len=menulist.length;i<len;i++) {   // Search for selectables starting from preselectIndex
                    searchIndex = (preselectIndex + i) % len;
                    if (menulist[searchIndex].selectable !== false) {   // selectable can be undefined
                        break;
                    }
                    console.warn("Menuitem not selectable at index: " + searchIndex);
                }
                if (menulist[searchIndex].selectable === false) {   // Deadloop may happen if none of the item in menulist is selectable
                    console.error("The whole menulist is not selectable!");
                    throw new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.NOT_FOUND, "The whole menulist is not selectable!");
                }
                mediator.publish(this.MENU_UPDATE, {
                    selection: searchIndex,
                    target: this.SUB_MENU,
                    promise: deferred,
                    list: menulist,
                    obtainFocus: true
                });

                this._fullSelectionStack.splice(this._menuStack.length-1, this._fullSelectionStack.length-(this._menuStack.length-1), searchIndex);

                if (this.CONFIG_AUTO_NAVIGATION || autoNavigate) {
                    return this._handleMenu(menulist[searchIndex]);
                } else {
                    console.info("submenu propagation stopped auto navigation");
                    mediator.publish("navigate", {
                        path: "Main/Blank",
                        state: {
                            navigator: this.getParentMenuitem()
                        }
                    });
                    return deferred.promise.then(function() {
                        return menulist[searchIndex];
                    });
                }
            },

            /**
             * Insert an external submenu that is not from navigation.xml tree
             *
             * (!) Requirement for Historical Back: (!)
             * sNavigation.insertSubmenu() need to be called in or before Controller's context.setupPending's promise lifespan
             *
             * @param  {Array} menulist        Array of menu item
             * @param  {String} title          Title to be show in breadcrumb
             * @param  {Number} selectingIndex Current selecting index (or DsIndex)
             * @param  {Number} preselectIndex Item index to be handled when submenu loaded
             * @param  {Boolean} autoNavigate   Auto navigate to preselected item
             * @return {Promise}
             */
            insertSubmenu: function(menulist, title, selectingIndex, preselectIndex, autoNavigate) {
                if (!menulist || !menulist.length) {
                    console.error("Cannot propagate empty submenu");
                    return promise.reject(new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "Cannot propagate empty submenu"));
                }
                this._currentSelectedIndex = selectingIndex || this._currentSelectedIndex;
                this._currentMenuTitle = title || this._currentMenuTitle;
                autoNavigate = autoNavigate || false;
                return this._propagateSubmenu(menulist, preselectIndex, autoNavigate);
            },

            handleMenu: function(item) {
                if (this._processing) {     // Semaphore
                    console.error("sNavigationManager busy");
                    return promise.reject(new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "sNavigationManager busy"));
                }
                this._processing++;
                return this._handleMenu(item).complete(util.bind(function() {
                    this._processing--;
                }, this));
            },

            /**
             * Main Handler of menu item,
             * 1st: Execute action
             * 2nd: Navigate if path exists
             * 3rd: Resolve XML if node exists
             * 4th: Handle hardcode items
             * @param  {Object} item  menuItem to be executed, it should be one of the members of CurrentMenulist
             * @return {Promise/Promise.resolve}    Item that is handling
             */
            _handleMenu: function(item, bypassNavigate, bypassAction) {
                if (item.selectable === false) {
                    console.error("This item is not selectable");
                    return promise.reject(new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.NOT_FOUND, "This item is not selectable"));
                }
                var menulist = this._getCurrentMenulist(),
                    actionResolved;

                this._currentSelectedIndex = menulist.indexOf(item);
                this._currentMenuTitle = item.text;

                if (this._currentSelectedIndex === -1) {
                    // Fail safe: Since the menu instance may be replaced
                    for (var i=0,len=menulist.length;i<len;i++) {
                        if (item.hasOwnProperty("id") && menulist[i].hasOwnProperty("id") && item.id === menulist[i].id) {
                            this._currentSelectedIndex = i;
                            break;
                        }
                        if (item.hasOwnProperty("text") && menulist[i].hasOwnProperty("text") && item.text === menulist[i].text) {
                            console.warn("Weak identity used to recover menu index");
                            this._currentSelectedIndex = i;
                            break;
                        }
                    }
                }
                if (this._currentSelectedIndex === -1) {
                    console.warn("Cannot find item in menu system");
                    console.warn(item);
                    console.warn("Potential hazard when propagating next level menu");
                } else {
                    // The handled menu must be leaf node in fullSelectionStack
                    this._fullSelectionStack.splice(this._menuStack.length-1, this._fullSelectionStack.length-(this._menuStack.length-1), this._currentSelectedIndex);
                }

                if (!bypassAction && item.action && util.isFunction(item.action)) {
                    actionResolved = item.action();
                }

                // Path resolved, the end of propagation
                if (!bypassNavigate && item.path && item.path.length) {
                    /**
                     * Resolved menuItem:
                     * {
                     *     @param  {String} text        usually not aligned with XML label
                     *     @param  {String} path        resolution path determined by characteristics
                     *     @param  {Function} action    (Optional) action to be executed on handleMenu() at highest priority
                     *     @param  {String} url         (Optional) URL path to specific JSON in CMS
                     *     @param  {String} displayType (Optional) displayType specified in CMS
                     *     @param  {String} id          (Optional) structureType specified in CMS
                     *     @param  {Boolean} fixedMenu  (Optional) set to TRUE will stop navigate/collapse the submenu when "UP" key pressed
                     * }
                     */
                    var extendLoad = (item.path === "Main/ProgramListing") ? true : false;
                    var navigationObject = {
                        path: item.path,
                        requireLogin: item.requireLogin,
                        extendLoading: extendLoad,
                        state: {
                            navigator: item
                        }
                    };
                    console.debug("Navigate to: ",navigationObject);
                    mediator.publish("navigate", navigationObject);

                    return promise.when(actionResolved, function() {
                        return item;
                    });
                }

                // Handle XML menu
                if (item.node) {
                    return promise.when(actionResolved, util.bind(this._resolveXML, this, item.node));
                }

                // Handle hardcoded menu
                if (item._children && item._children.length) {
                    return promise.when(actionResolved, util.bind(this._propagateSubmenu, this, item._children));
                }

                console.warn("No action taken for menu item",item);

                return promise.when(actionResolved, function() {
                    return item;
                });
            },

            _isDisabledMenuItem(menuID) {
              return this._disabledMenuItems.indexOf(menuID) > -1;
            },

            /**
             * Propagate Menu if possible
             * Label the menuitem with path as soon as characteristics found
             * Execute the menuitem returned by JSON
             * @param  {XMLnode} node       XML node that appeared in navigation.xml
             * @return {Promise}
             * }
             */
            _resolveXML: function(node) {
                // attempt to decode XML menu
                var menulist = this._parseXMLtoMenulist(node);
                if (menulist) {
                    return this._propagateSubmenu(menulist);
                }
                menulist = [];
                var menuitem, label = node.getAttribute("title"),
                    promises = [],
                    _generalItemDifferentiation = function (item) {
                        var deferred = promise.defer();
                        switch (item.displayType) {
                            case "dvd_cover":
                                item.path = "Main/MoviesListing";
                                deferred.resolve(item);
                                break;
                            case "16:9":
                                item.path = "Main/TVShowsListing";
                                deferred.resolve(item);
                                break;
                            default:
                                if (item.id === "LiveplannerListing") {
                                    item.path = "Main/TVShowsListing";
                                    deferred.resolve(item);
                                    break;
                                } else if (item.id === "SportNewsListing") {
                                    item.path = "Main/TVShowsListing";
                                    deferred.resolve(item);
                                    break;
                                } else if (item.id === "EditorialSpecial") {
                                    linearContentService.cmsRequest(item.url).then(function(res) {
                                        var title = stormUtil.getSanitizedValue(res, "listing.info.title"),
                                            asset = stormUtil.getSanitizedValue(res, "listing.asset_listing.asset[0]");
                                        if (!title || !asset) {
                                            deferred.reject();
                                        } else {
                                            item.text = title.toUpperCase();
                                            item.displayType = asset.displayType;
                                            item.path = asset.displayType === "dvd_cover" ? "Main/MoviesListing" : "Main/TVShowsListing";
                                            deferred.resolve(item);
                                        }
                                    });
                                } else {
                                    console.warn("Menu item displayType not recognized: " + item.displayType + " for " + item.id);
                                    deferred.reject();
                                }
                                break;
                        }
                        return deferred.promise;
                    };

                if (label && label.length) {
                    label = label.toUpperCase();
                }

                // resolve by structureType
                switch (node.getAttribute("structureType")) {
                    case "LandingPageHighlightsSNAP":
                        if (this.CONFIG_CUSTOM_HIGHLIGHT) {
                            // Injection begins
                            return sServiceHolder.getLinearContentService().getNavigationOverrides().then(util.bind(function (injectedListing) {
                                var section = this.getSectionMenuitem(),
                                    subSection = this.getParentMenuitem();
                                if (!section || !subSection) {
                                    console.error("Unexpected error: no selectionStack history was found!");
                                    throw new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "Unexpected error: no selectionStack history was found!");
                                }

                                try {
                                    var injectedJSON = injectedListing[section.id] && injectedListing[section.id][subSection.id];
                                    //  Treats injectedJSON as LandingPageSingleListing
                                    menuitem = this._parseJSONtoMenuitem(injectedJSON);
                                    return _generalItemDifferentiation(menuitem).then(util.bind(function(menuitem) {
                                        menuitem.text = label;
                                        return this._handleMenu(menuitem);
                                    }, this));

                                } catch (error) {
                                    return promise.reject("Could not find menuitem due to: " + error);
                                }

                            }, this));
                        }

                        return linearContentService.getListingItem(node.getAttribute("path")).then(util.bind(function (itemRedirection) {
                            return linearContentService.getSnapListingItems(itemRedirection.path).then(util.bind(function (itemlist) {
                                if (!itemlist || !itemlist.length) {
                                    console.error("itemlist is empty");
                                }
                                util.each(itemlist, util.bind(function (wrappedItem) {

                                // Snap items here are an unusual shape...
                                    var firstOwnProperty;

                                    for (var propertyName in wrappedItem) {
                                        if (wrappedItem.hasOwnProperty(propertyName)) {
                                            firstOwnProperty = propertyName;
                                            break;
                                        }
                                    }

                                    var item = wrappedItem[firstOwnProperty];
                                    menuitem = this._parseSNAPJSONtoMenuitem(item, firstOwnProperty);
                                    promises.push(_generalItemDifferentiation(menuitem));
                                }, this));
                                return stormUtil.allPromises(promises, true).then(util.bind(function(menulist) {
                                    return this._propagateSubmenu(menulist);
                                }, this));
                            }, this));
                        }, this));
                        // JSHint dislikes this unreachable break, but it's useful safety against future code changes.
                        break; // jshint ignore:line

                    case "LandingPageHighlights":
                        if (this.CONFIG_CUSTOM_HIGHLIGHT) {
                            // Injection begins
                            return sServiceHolder.getLinearContentService().getNavigationOverrides().then(util.bind(function (injectedListing) {

                                var section = this.getSectionMenuitem();
                                if (!section) {
                                    console.error("Unexpected error: no selectionStack history was found!");
                                    throw new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "Unexpected error: no selectionStack history was found!");
                                }

                                try {
                                    // injectedJSON = injectedListing["blah"];
                                    var injectedJSON = injectedListing[section.id];
                                    //  Treats injectedJSON as LandingPageSingleListing
                                    menuitem = this._parseJSONtoMenuitem(injectedJSON);
                                    return _generalItemDifferentiation(menuitem).then(util.bind(function(menuitem) {
                                        menuitem.text = label;
                                        return this._handleMenu(menuitem);
                                    }, this));

                                } catch (error) {
                                    return promise.reject("Could not find menuitem due to: " + error);
                                }
                            }, this));
                        }

                        return linearContentService.getListingItem(node.getAttribute("path")).then(util.bind(function (itemlist) {
                            if (!itemlist || !itemlist.length) {
                                console.error("itemlist is empty");
                            }
                            util.each(itemlist, util.bind(function (item) {
                                menuitem = this._parseJSONtoMenuitem(item);
                                promises.push(_generalItemDifferentiation(menuitem));
                            }, this));
                            return stormUtil.allPromises(promises, true).then(util.bind(function(menulist) {
                                return this._propagateSubmenu(menulist);
                            }, this));
                        }, this));
                        // JSHint dislikes this unreachable break, but it's useful safety against future code changes.
                        break; // jshint ignore:line

                    case "LandingPageLiveplanner":
                    case "LandingPageSportNews":
                    case "LandingPageSingleListingSNAP":
                    case "LandingPageSingleListing":
                        return linearContentService.getListingItem(node.getAttribute("path")).then(util.bind(function (item) {
                            if (item.length) {
                                console.error("Singlelist should not be an array!");
                            }
                            menuitem = this._parseJSONtoMenuitem(item);
                            return _generalItemDifferentiation(menuitem).then(util.bind(function(menuitem) {
                                menuitem.text = label;  // override the text label with XML node instead of JSON item
                                return this._handleMenu(menuitem);
                            }, this));
                        }, this));
                        // JSHint dislikes this unreachable break, but it's useful safety against future code changes.
                        break; // jshint ignore:line

                    case "LandingPageOrderedListingSNAP":
                    case "LandingPageOrderedListing":
                        return linearContentService.getListingItem(node.getAttribute("path")).then(util.bind(function (orderedListings) {
                            for (var i=0,len=orderedListings.length; i<len; i++) {
                                var listing = orderedListings[i];
                                //
                                // Find the first (only) A-Z listing structure.
                                //
                                if (listing.structureType && listing.structureType.indexOf("ByLexic") !== -1) {
                                    // save cmsUrl to listing.url.
                                    listing.url = listing.path;

                                    return _generalItemDifferentiation(listing).then(util.bind(function(listing) {
                                        return linearContentService.getLetterList(listing.url).then(util.bind(function (letterList) {
                                            var rootUrl = listing.url.replace(/[^/]*$/, ""),
                                                _noDeadLoop = false;
                                            util.each(letterList, function (letterItem) {
                                                _noDeadLoop = _noDeadLoop || letterItem.linkable;   // Check for any linkable letters
                                                menulist.push({
                                                    text: letterItem.content.toString(),    // 123 will be integer
                                                    path: listing.path,
                                                    selectable: letterItem.linkable,
                                                    url: rootUrl + letterItem.content.toString() + ".json"
                                                });
                                            });

                                            // give cmsUrl back to listing.path to replace navigatePath in app for cmsRequest next time.
                                            listing.path = listing.url;

                                            if (_noDeadLoop === false) {    // If all letters are not linkable, deadloop may happen
                                                console.error("No linkable letter available (No data)");
                                                throw new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.NOT_FOUND, "No linkable letter available (No data)");
                                            }

                                            return this._propagateSubmenu(menulist);
                                        }, this));
                                    }, this));
                                }
                            }
                        }, this));
                        // JSHint dislikes this unreachable break, but it's useful safety against future code changes.
                        break; // jshint ignore:line

                    case "LandingPageDoubleListing":
                        return linearContentService.getListingItem(node.getAttribute("path")).then(util.bind(function (listings) {
                            menuitem = {
                                text: label,
                                path: "Main/MixedListing",
                                listings: listings
                            };
                            return this._handleMenu(menuitem);
                        }, this));
                        // JSHint dislikes this unreachable break, but it's useful safety against future code changes.
                        break; // jshint ignore:line
                    case "LandingPageLazyListing":
                        return linearContentService.getListingItem(node.getAttribute("path")).then(util.bind(function (orderedListings) {
                            for (var i=0,len=orderedListings.length; i<len; i++) {
                                var listing = orderedListings[i];
                                //
                                // Find the first (only) A-Z listing structure.
                                //
                                if (listing.structureType && listing.structureType.indexOf("ByLexic") !== -1) {
                                    // save cmsUrl to listing.url.
                                    listing.url = listing.path;

                                    return _generalItemDifferentiation(listing).then(util.bind(function(listing) {
                                        return linearContentService.getLetterList(listing.url).then(util.bind(function (letterList) {
                                            var rootUrl = listing.url.replace(/[^/]*$/, ""),
                                                _noDeadLoop = false;
                                            util.each(letterList, function (letterItem) {
                                                _noDeadLoop = _noDeadLoop || letterItem.linkable;   // Check for any linkable letters
                                                menulist.push({
                                                    text: letterItem.content.toString(),    // 123 will be integer
                                                    path: listing.path,
                                                    selectable: letterItem.linkable,
                                                    url: rootUrl + letterItem.content.toString() + ".json"
                                                });
                                            });

                                            // give cmsUrl back to listing.path to replace navigatePath in app for cmsRequest next time.
                                            listing.path = listing.url;

                                            if (_noDeadLoop === false) {    // If all letters are not linkable, deadloop may happen
                                                console.error("No linkable letter available (No data)");
                                                throw new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.NOT_FOUND, "No linkable letter available (No data)");
                                            }

                                            return this._propagateSubmenu(menulist);
                                        }, this));
                                    }, this));
                                }
                            }
                        }, this));
                        break; // jshint ignore:line
                }

                console.error("[sNavigationManager _resolveXML] unhandled resolution to "+node.getAttribute("structureType"));
                return promise.reject(new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "No resolution to this XML node!"));
            },

            /**
             * General parse to XML contents
             * @param  {XMLnode} node       XML node that appeared in navigation.xml
             * @return {Array/False}        Array of menulist items
             */
            _parseXMLtoMenulist: function(node) {
                if (!node || !node.childNodes || !node.childNodes.length) {
                    return false;
                }
                var label, structureType, menulist = [], id, hidden;
                for (var i=0,len=node.childNodes.length;i<len;i++) {
                    id = parseInt(node.childNodes[i].getAttribute("id"), 10);
                    label = node.childNodes[i].getAttribute("label");
                    structureType = node.childNodes[i].getAttribute("structureType");
                    hidden = node.childNodes[i].getAttribute("hide");

                    // Needs to have a label and not hidden.
                    if (label && label.length && hidden !== 'true' && !this._isDisabledMenuItem(id)) {
                        label = label.toUpperCase();
                    } else {
                        continue;      // @TODO: Waiting SKYSTORM-272
                    }
                    switch (structureType) {
                        case "LandingPageStartScreen":
                            menulist.push({
                                text: label,
                                id: "home",
                                path: "Main/Home",
                                node: node.childNodes[i]
                            });
                            break;
                        case "LandingPageEPG":
                            menulist.push({
                                text: label,
                                id: "programGuide",
                                path: "Main/ProgramListing",
                                node: node.childNodes[i]
                            });
                            break;
                        case "ClipSection":
                            // Sports clips out of scope for Phase 1, see SKYSTORM-490. @TODO: SKYSTORM-333 and others.
                            break;
                        case "ReplaysSection":
                            // Sports replays out of scope for Phase 1. @TODO: SKYSTORM-327 and others.
                            break;
                        case "LandingPageWebView":
                            // We don't want this kind of thing at all in Smart TV UI; appears under Sport, but maybe elsewhere at some point.
                            break;
                        case "LandingPageHighlightsSport":
                            menulist.push({
                                text: label,
                                id: "sport",
                                path: "Main/SportHome",
                                node: node // Sports Aktuell content is constructed from peers, not children
                            });
                            break;
                        case "SportSection":
                        case "FilmSection":
                        case "SeriesSection":
                        case "DocuSection":
                        case "KidsSection":
                        case "SnapSection":
                            menulist.push({
                                text: label,
                                id: structureType,
                                node: node.childNodes[i]
                            });
                            break;
                        // JSHint dislikes dropping through to the default case, but here it seems deliberate and acceptable.
                        default:
                            menulist.push({
                                text: label,
                                id: structureType,
                                node: node.childNodes[i]
                            });
                            break;
                    }
                }
                return menulist;
            },

            /**
             * General parser from JSON to menuitems
             * Avoid JSONObject from using item.path as it is reserved
             * @param  {Object} item  JSONObject
             * @return {Object}       menuitem
             */
            _parseJSONtoMenuitem: function(item) {
                return {
                    text: item.title && item.title.toUpperCase(),
                    url: item.path,
                    id: item.structureType,
                    displayType: item.displayType
                };
            },

            /**
             * General parser from SNAP JSON to menuitems
             * Avoid JSONObject from using item.path as it is reserved
             * @param  {Object} item  JSONObject
             * @return {Object}       menuitem
             */
            _parseSNAPJSONtoMenuitem: function(item, preKnownType) {
                return {
                    text: item.title && item.title.toUpperCase(),
                    url: item.path,
                    id: preKnownType,
                    // Linda confirms (30th Sept) that 16:9 is a preferable default; this covers us for editorial special _within Snap_.
                    displayType: item.display_type ? item.display_type : "16:9"
                };
            },

            triggerUpdateMenu: function (loggedIn, preselectedIndex) {
                var currentFocusedMenuItem = this.getSectionMenuitem(),
                    selectionIndex;

                this.__lastLoginStatus = loggedIn;

                return this.getMainMenu(this.__lastLoginStatus).then(util.bind(function (mainMenu) {
                    this._menuStack[0] = mainMenu;

                    if (!util.isUndefined(preselectedIndex)) {
                        this._selectionStack[0] = preselectedIndex;
                        this._fullSelectionStack[0] = preselectedIndex;

                    } else {

                        // Updating the menu will affect the menu position of certain items.
                        // If no specific new menu item should be focused it may be required to update
                        // the menu to focus on the currently selected item.

                        // Find index of the currently selected menu item.
                        util.each(mainMenu, util.bind(function (menuItem, index) {

                            if (currentFocusedMenuItem && (currentFocusedMenuItem.id === menuItem.id)) {
                                selectionIndex = index;
                                return util.breaker;
                            }

                        }, this));

                        // Update the menu so that currently selected menu item is still selected even if its position in the menu has changed.
                        if (util.isNumber(selectionIndex)) {
                            this._selectionStack[0] = selectionIndex;
                            this._fullSelectionStack[0] = selectionIndex;
                        }
                    }

                    if (this._menuStack.length === 1) {
                        var deferred = promise.defer();

                        mediator.publish(this.MENU_UPDATE, {
                            selection: 0,
                            list: this._menuStack && this._menuStack[0],
                            target: this.MAIN_MENU,
                            promise: deferred,
                            obtainFocus: false
                        });

                        return deferred.promise;

                    } else if (this._menuStack.length === 2) {
                        var deferred = promise.defer(),
                            lastSelection = (util.isArray(this._fullSelectionStack) && this._fullSelectionStack.length > 0) ? this._fullSelectionStack[this._fullSelectionStack.length-1] : 0;

                        mediator.publish(this.MENU_UPDATE, {
                            selection: lastSelection,
                            list: this._getCurrentMenulist(),
                            target: this.SUB_MENU,
                            promise: deferred,
                            obtainFocus: false
                        });

                        return deferred.promise;
                    }

                }, this));
            },

            triggerResetMenu: function (noFocus) {
                return this._resetMenu(this.__lastLoginStatus).then(util.bind(function () {
                    var deferred = promise.defer();
                    mediator.publish(this.MENU_UPDATE, {
                        selection: 0,
                        list: this._menuStack && this._menuStack[0],
                        target: this.MAIN_MENU,
                        promise: deferred,
                        obtainFocus: !noFocus
                    });
                    return deferred.promise;
                }, this));
            },

            /**
             * Trigger the menu to resume to previous level
             * @return {Number} current menu level
             */
            returnUpperLevelMenu: function(menuStackOnly) {
                menuStackOnly = menuStackOnly || false;

                if (this._menuStack.length <= 1) {
                    console.info("Top level menu reached");
                    return promise.resolve("Top level menu reached");
                }
                var currentMenu = this.getParentMenuitem(),
                    deferred = promise.defer();
                if (currentMenu && currentMenu.fixedMenu) {
                    console.info("This menu is not collapsible");
                    return this._menuStack.length;
                }
                this._menuStack.pop();
                this._breadcrumbStack.pop();

                if (menuStackOnly === false)
                {
                    if (this._menuStack.length > 1) {
                        mediator.publish(this.MENU_UPDATE, {
                            selection: this._popLastSelection(),
                            list: this._getCurrentMenulist(),
                            target: this.SUB_MENU,
                            promise: deferred,
                            obtainFocus: false
                        });
                    } else {
                        mediator.publish(this.MENU_UPDATE, {
                            selection: this._popLastSelection(),
                            list: this._menuStack && this._menuStack[0],
                            target: this.MAIN_MENU,
                            promise: deferred,
                            obtainFocus: true
                        });

                        this._selectionStack = [];
                        this._breadcrumbStack = [];
                    }
                }
                else
                {
                    if (this._menuStack.length <= 1) {
                        this._selectionStack = [];
                        this._breadcrumbStack = [];
                    }
                }
                return deferred.promise;
            },

            /**
             * Get Breadcrumb, with selected menu item names joined with "/"
             * is to be shown above the submenu
             * @return {String} Breadcrumb of current menu
             */
            getBreadcrumb: function() {
                return this._breadcrumbStack.join(" / ");
            },

            /**
             * Get Breadcrumb path, with selected menu item names joined with "/" but without spaces around
             * This is for tracking
             * @return {String} Breadcrumb of current menu
             */
            getPath: function() {
                return this._breadcrumbStack.join("/");
            },

            /**
             * Get the name of the root item
             * This is for tracking
             * @return {String} Name of the current root menu item
             */
            getRootSectionName: function() {
                return this._breadcrumbStack[0];
            },

            /**
             * Get Current Menu list
             * @return {Array} menulist
             */
            _getCurrentMenulist: function() {
                if (!this._menuStack.length) {
                    return [];
                }
                return this._menuStack[this._menuStack.length-1];
            },

            /**
             * Get Last Selected menu index, also popping the selectionStack
             * @return {Number} index of previous level menu
             */
            _popLastSelection: function() {
                if (!this._selectionStack.length) {
                    return 0;
                }
                return this._selectionStack.pop();
            },

            getLastSelection: function() {
                if (!this._selectionStack.length) {
                    return 0;
                }
                return this._selectionStack[this._selectionStack.length-1];
            },

            getSelectionIndex: function(menuLevelIndex) {
                if (!this._selectionStack.length || menuLevelIndex >= this._selectionStack.length || menuLevelIndex < 0) {
                    return 0;
                }
                return this._selectionStack[menuLevelIndex];
            },

            getParentMenuitem: function() {
                if (!this._menuStack.length || !this._selectionStack.length || this._menuStack.length < 2) {
                    return null;
                }
                return this._menuStack[this._menuStack.length-2][this._selectionStack[this._selectionStack.length-1]];
            },

            /**
             * It will return the mother node (section) of where you are, according to the selectionStack history
             * @return {Object} menuitem
             */
            getSectionMenuitem: function() {        // Assumption: the first level of menu must be sections...
                if (!this._selectionStack.length) {
                    return null;
                }

                var indexOfSelectedItem = this._selectionStack && util.isArray(this._selectionStack) && this._selectionStack[0];

                if (util.isNumber(indexOfSelectedItem) && this._menuStack && util.isArray(this._menuStack) && this._menuStack[0] && util.isArray(this._menuStack[0])) {
                    return this._menuStack[0][indexOfSelectedItem];

                } else {
                    return null;
                }
            },

            cloneCurrentMenuStack: function () {
                return util.clone(this._menuStack, true);   // Not primitive array
            },

            cloneCurrentTrackStack: function() {
                return this._fullSelectionStack.slice();
            },

            cloneCurrentBreadcrumb: function() {
                return this._breadcrumbStack.slice();
            },

            /**
             * Using the provided parameters to reconstruct the whole menu system
             * @param  {Array} treeNodes      The menu tree system
             * @param  {Array} treeNodeTraces Full Selection Stack
             * @param  {Array} breadcrumb     Breadcrumb stack
             * @return {Promise}
             */
            hardConstructMenu: function(treeNodes, treeNodeTraces, breadcrumb) {
                if (!treeNodes || !treeNodeTraces || !breadcrumb ||
                    !util.isArray(treeNodes) || !util.isArray(treeNodeTraces) || !util.isArray(breadcrumb) || !treeNodes.length) {
                    console.error("param mismatch!")
                    return promise.reject(new TVEError(FACILITY.NAVIGATION_MANAGER, ERROR.INTERNAL, "param mismatch!"));
                }
                if (!treeNodeTraces.length) {
                    // No trace means the menu has never been touched, implicitly means it was Home
                    // Since Home has its own menu reset function, to avoid collision, do nothing here
                    mediator.publish(this.MENU_RECONSTRUCT_COMPLETE);
                    return promise.resolve();
                }
                // Leave context clones unchange
                var resetNodes = util.clone(treeNodes, true),
                    resetTraces = treeNodeTraces.slice(),
                    resetBreadcrumb = breadcrumb.slice(),
                // Reset Promises
                    deferred = promise.defer(),
                    processPromise = deferred.promise;

                // Update main menu (the clone is not up-to-date)
                this.getMainMenu(this.__lastLoginStatus).then(util.bind(function (mainMenu) {
                    // Search clone's section (branching node) existence
                    var search = resetNodes[0][resetTraces[0]],
                        searchedIndex = -1;
                    if (!search) {
                        deferred.reject();
                        return;
                    }
                    for (var i=0,len=mainMenu.length;i<len;i++) {
                        if (mainMenu[i].id === search.id) {
                            searchedIndex = i;
                            break;
                        }
                    }
                    if (searchedIndex === -1) {
                        // New mainMenu cannot find the clone's branch
                        console.warn("menu branch node not found");
                        sHistoryManager.back();
                        deferred.resolve();
                        return;
                    }
                    // Renew branch position
                    resetNodes[0] = mainMenu;
                    resetTraces[0] = searchedIndex;
                    // Core
                    // Hard substitute all trees
                    this._menuStack = resetNodes;
                    this._selectionStack = resetTraces.slice(0, resetNodes.length-1);
                    this._fullSelectionStack = resetTraces;
                    this._breadcrumbStack = resetBreadcrumb;
                    // Re-display menus
                    if (resetNodes.length > 1) {
                        mediator.publish(this.MENU_UPDATE, {
                            selection: this._fullSelectionStack[this._fullSelectionStack.length-1],
                            list: this._getCurrentMenulist(),
                            target: this.SUB_MENU,
                            promise: deferred,
                            obtainFocus: false
                        });
                    } else {
                        mediator.publish(this.MENU_UPDATE, {

                            // Make sure to select correct main menu item, in case any main menu navigation has occurred.
                            selection: (util.isArray(this._fullSelectionStack) && this._fullSelectionStack.length > 0) ? this._fullSelectionStack[this._fullSelectionStack.length-1] : 0,
                            list: util.isArray(this._menuStack) && this._menuStack[0],
                            target: this.MAIN_MENU,
                            promise: deferred,
                            obtainFocus: false
                        });
                    }
                }, this), function () {
                    deferred.reject();
                });

                processPromise.complete(util.bind(function() {
                    mediator.publish(this.MENU_RECONSTRUCT_COMPLETE);
                }, this));
                return processPromise;
            }
        });
    return new NavigationManager();
});

/**
 * The routable controller which is extended by most controllers in TVE demo.
 * @name RoutableController
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/RoutableController
 * @extends tvedemo/ctrl/Controller
 */
define("tvedemo/ctrl/RoutableController", [
    "xdk-base/class", "xdk-ax/mvc/Controller", "xdk-ax/mediator",
    "xdk-base/util", "xdk-ax/focusManager", "xdk-base/promise",
    "tvedemo/mgr/sNavigationManager",
    "tve/sServiceHolder", "storm/OmnitureStats",
    "xdk-base/console"
], function (klass, Controller, mediator,
    util, focusMgr, promise,
    sNavigationManager,
    sServiceHolder, OmnitureStats,
    console) {

    "use strict";

    var RoutableController = klass.create(Controller, {
        /**
         * To obtain the default state of the routable controller. Developer need to overlap with this function to set the default.
         * @return {Object} the State object. Default will be {}
         * @memberof tvedemo/ctrl/RoutableController#
         * @method getDefaultState
         * @public
         */
        getDefaultState: function () {
            return {};
        }
    }, {
        /**
         * Store the stateeter for the controller
         * @name __state
         * @private
         * @memberof tvedemo/ctrl/RoutableController#
         */
        __state: {},


        //Store the focus for history back
        __historyFocus: null,

        init: function (opts) {

            // init with defaultState
            this.__state = this.constructor.getDefaultState();

            this._super(opts);
        },


        setView: function (view) {

            this._super(view);

            view.setOption("forwardFocus", true);
        },

        getContext: function () {

            var context = util.clone(this.getState());

            return context;
        },
        /**
         * Get the state of the current controller which will be extended from the default state
         * @return {Object} the stateeter set for the path.
         * @method getState
         * @memberof tvedemo/ctrl/RoutableController#
         * @public
         */
        getState: function () {
            return this.__state;
        },
        /**
         * Helper function to get the Parent Path
         * @return {tvedemo/ctrl/RoutableController}the Controller itself
         * @memberof tvedemo/ctrl/RoutableController#
         * @method getPathStates
         * @public
         */
        getPathStates: function () {
            var currentParam = this.getState(),
                targetController = this.getParentController();

            //loop the parent and extend the state from the parent
            while (targetController && targetController instanceof RoutableController) {
                currentParam = util.extend(currentParam, targetController.getState());
                targetController = targetController.getParentController();
            }

            return currentParam;
        },

        /**
         * Helper function to return extended the Parent Path state
         * @param {Object} state
         * @return {Object} extended state
         * @memberof tvedemo/ctrl/RoutableController#
         * @method extendPathStates
         * @public
         */
        extendPathStates: function (state) {
            return util.extend(state, this.getPathStates());
        },
        /**
         * Set the state, which should be set after the controller is created
         * @return {tvedemo/ctrl/RoutableController}the Controller itself
         * @memberof tvedemo/ctrl/RoutableController#
         * @method updateState
         * @public
         */
        updateState: function (state) {
            var defaultState = this.constructor.getDefaultState(),
                i;
            for (i in state) {
                if (util.isUndefined(defaultState[i])) {
                    console.error("Unmatched state. All the state should be predefined with a default State by getDefaultState function.");
                }
            }

            this.__state = util.clone(state, true);
            return this;

        },
        /**
         * For open controller, to set where to place the controller. When replace controller, it will use the original places instead of setting a new position.
         * @return {ax/af/Container} the container to be attched with the controller. Default will be the current Controller View
         * @memberof tvedemo/ctrl/RoutableController#
         * @method getSubControllerLocation
         * @public
         */
        getSubControllerLocation: function () {
            return this.getView();
        },


        _setupSubtree: function (context) {
            var i = 0,
                len = this._subControllers.length,
                subController, subCtrlrId,
                subContext,
                pendingSubcontrollers = [],
                pending;

            this.setup(context);

            // Force navigationBacktrace to be a part of setupPending
            context.setupPending = promise.when(context.setupPending, util.bind(function() {
                return this._navigationBacktrace(context);
            }, this));

            //setup sub controllers if context.subContexts[controllerId] exists
            for (; i < len; i++) {
                subController = this._subControllers[i];
                subCtrlrId = subController.getId();

                if (context && context.subContexts && context.subContexts[subCtrlrId]) {
                    subContext = context.subContexts[subCtrlrId];
                } else {
                    subContext = {};
                }

                subContext = util.extend(subContext, context);
                //wait for parent controller to finish setup
                pendingSubcontrollers.push(context.setupPending.then(function () {
                    return subController._setupSubtree(subContext);
                }));
            }

            pending = pendingSubcontrollers.length > 0 ? promise.all(pendingSubcontrollers) : context.setupPending;

            if (this.postSetup) {

                if (pending) {
                    pending.then(util.bind(function () {
                        this.postSetup(context);
                    }, this));
                }

                return promise.resolve(this.postSetup(context));
            }

            return promise.resolve(true);

        },

        /**
         * Save the current state when entered after setupPending
         * Allow history back having menu navigation system resume to the state where it was
         * @param  {Object} context Context
         * @return {promise}
         */
        _navigationBacktrace: function(context) {
            if (context.historyBack === true) {
                if (context.__menuClone) {
                    return sNavigationManager.hardConstructMenu(context.__menuClone.navigationTree, context.__menuClone.navigationTrace, context.__menuClone.breadcrumb);
                }
            } else if (sNavigationManager.isInitiated()) {
                this.saveMenuState();
            }
            return promise.resolve();
        },

        /**
         * This state is to be carried through navigation and saved in history stack
         * @return {null}
         */
        saveMenuState: function() {
            // This is to bring the menuClone revival back in History's context
            this.__state.__menuClone = {
                breadcrumb: sNavigationManager.cloneCurrentBreadcrumb(),
                navigationTree: sNavigationManager.cloneCurrentMenuStack(),
                navigationTrace: sNavigationManager.cloneCurrentTrackStack()
            };
        },
        
        /**
        * Track a level (menu) click (analytics)
         * @param  {int} level The level to track (1-2)
         * @param  {String} page The name of the page to track
         * @param  {Boolean} force Whether to force a track action
        */
        trackLevel: function(level, page, force) {
            sServiceHolder.getAnalyticsService().trackLevel(level, page, force);
        },
        /**
        * Track the view (analytics)
        * @param  {String} page The name of the page to track
        * @param  {String} channel The channel name to track
        */
        trackPage: function(page, channel) {
            sServiceHolder.getAnalyticsService().trackPage(page, channel);
        }
    });

    return RoutableController;
});
/**
 * Splash view's template
 * @name splash
 * @memberof storm/tmpl
 * @class storm/tmpl/splash
 */
define("storm/tmpl/splash", [
    "xdk-ui-basic/Layout",
    "xdk-ax/Container",
    "xdk-ui-basic/Image",
    "xdk-ui-basic/Label",
    "xdk-base/config"
], function (
    Layout,
    Container,
    Image,
    Label,
    config
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            id: "#splashView",
            width: 1,
            alignment: Layout.HORIZONTAL,
            focusable: true,
            children: [{
                klass: Image,
                css: "backdrop",
                src: "img/skystorm/splash.png"
            }, {
                klass: Label,
                css: "info",
                id: "info",
                text: "UI version: " + config.get("version")
            }, {
                klass: Image,
                css: "load",
                src: "img/loading/load.gif"
            }]
        };
    };
});
/**
 * The Id interface. Implement this interfaces to identification information of a device.
 *
 * @class xdk-base/device/interface/Id
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("xdk-base/device/interface/Id", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    var Id = Interface.create("Id", {
        /**
         * Get the device type: emulator, tv, bdp, ht (home theatre), stb.
         * @name getDeviceType
         * @function
         * @abstract
         * @deprecated replaced with getHardwareType function which standardize among the different platforms
         * @return {String} device type
         * @memberof xdk-base/device/interface/Id
         * @public
         */
        getDeviceType: [],
        /**
         * Get the hardware type: {@link xdk-base/device/interface/Id.HARDWARE_TYPE}
         * @name getHardwareType
         * @function
         * @abstract
         * @return {ax/device/interface/Id.HARDWARE_TYPE} the hardware type
         * @memberof xdk-base/device/interface/Id
         * @public
         */
        getHardwareType: [],
        /**
         * Get the MAC address.
         * @name getMac
         * @function
         * @abstract
         * @return {String} mac address. null if not available.
         * @memberof xdk-base/device/interface/Id
         * @public
         */
        getMac: [],
        /**
         * Get the system's firmware version.
         * @name getFirmware
         * @function
         * @abstract
         * @return {String} firmware version."dummyFirmware" if not available.
         * @memberof xdk-base/device/interface/Id
         * @public
         */
        getFirmware: [],
        /**
         * Get the year from the system's firmware version.
         * @name getFirmwareYear
         * @function
         * @abstract
         * @memberof xdk-base/device/interface/Id
         * @return {Number} firmware year Return 0 if not available.
         * @public
         */
        getFirmwareYear: [],
        /**
         * Get a uniqueID of the device. UUID is gernerated and stored in localStorage to pretent a
         * unique if device API is not available.
         * @name getUniqueID
         * @function
         * @abstract
         * @return {String} unique ID
         * @memberof xdk-base/device/interface/Id
         * @public
         */
        getUniqueID: [],
        /**
         * Get device's model number.
         * @name getModel
         * @function
         * @abstract
         * @return {String} "dummyModel" if not available.
         * @memberof xdk-base/device/interface/Id
         * @public
         */
        getModel: [],
        /**
         * Get device's internal IP.If there are no related api, it will return 0.0.0.0 and
         * developer may need to send ajax to public api service to get the ip.
         * @name getIP
         * @function
         * @abstract
         * @memberof xdk-base/device/interface/Id
         * @return {String} ip address."0.0.0.0" if it's not available.
         * @public
         */
        getIP: []
    });

    /**
     * Collection of the device hardware type.  
     * To provide the possible hardware type like BD, TV, MONITOR, HOME_THERTRE, EMULATOR, STB, CONSOLE, WORKSTATION, UNKNOWN etc...
     * It gives a information of the hardware information and used in device.id.getHardwareType
     * @enum {String}
     * @memberof xdk-base/device/interface/Id
     */
    Id.HARDWARE_TYPE = {
        /** Bluray player */
        BD: "Bluray",
        /**  TV */
        TV: "TV",
        /**  MONITOR */
        MONITOR: "Monitor",
        /**  HOME THEATRE */
        HOME_THEATRE: "Home Theatre",
        /**  EMULATOR */
        EMULATOR: "Emulator",
        /**  WORKSTATION */
        WORKSTATION: "Workstation",
        /**  Set Top Box */
        STB: "Set Top Box",
        /**  game console like playstation, wiiu */
        CONSOLE: "Console",
        /**  game console monitor like wiiu gamepad monitor*/
        CONSOLE_MONITOR: "Console Monitor",
        /**  mobile device like phone or tablet*/
        MOBILE: "Mobile Device",
        /**  Unknown which is unable to determine the device type among various devices*/
        UNKNOWN: "Unknown"
    };

    return Id;
});
/**
 * Mouse handler, works with {@link xdk-ax/mvc/AppRoot} internally.
 * It provide the mouse handling for the application.
 *
 * When the mouse is on (which triggers by onmouseon event or other handler), it will allow the mouse to focus item.
 * When the mouse is off (which tiggers by mouseoff or keydown event), it will turn the mouse handler off.
 * e.g when pressing a key on remote, it will off the mouse handler without any key handling (that means no directional change).
 *
 * ###Config Params
 *
 *  Attribute | Value
 * --------- | ---------
 * Key      | mouse.keep-focus
 * Type     | Boolean
 * Desc     |  Whether to keep focus when mouse on or focus on blank item.
 *             When it is false, it will blur the current focus when using mouse on the non-focusable area.
 *             When it is true, it will keep the current focus until mouse is on the another focusable item.
 * Default  |  false
 * Usage    | {@link module:xdk-base/config}
 *
 *
 * Handles:
 *
 * * mouse on/off focus changes
 * * mouse over focusable component, will focus component
 * * mouse over non-focusable component, will blur last focus
 * * mouse wheel
 *
 * @module xdk-mouse/mouseHandler
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-mouse/mouseHandler", [
    "xdk-base/core",
    "xdk-ax/focusManager",
    "xdk-base/Env",
    "xdk-base/device",
    "xdk-base/util",
    "xdk-ax/mvc/AppRoot",
    "xdk-ax/evt/type",
    "xdk-base/console",
    "xdk-base/device/interface/Id",
    "xdk-base/config"
], function (
    core,
    fm,
    Env,
    device,
    util,
    AppRoot,
    evtType,
    console,
    IId,
    config
) {
    "use strict";

    function findXDKComponent(HTMLElement) {
        if (!HTMLElement) {
            return null;
        }
        if (!HTMLElement.__comp && HTMLElement.parentNode && HTMLElement.parentNode !== document.body) {
            return findXDKComponent(HTMLElement.parentNode);
        }
        return HTMLElement.__comp || null;
    }

    var sEnv,
        sAppRoot,
        mouseOnClass = "mouse-on",
        nonFocusableClass = "mouse-focus-on-non-focusable",
        keepFocus,
        rootEle = null,
        mouseOffDelayHandle = null,
        isMouseOn = false,
        origMouseOnHandler = null,
        origMouseOffHandler = null,
        webosMouseOnOffHandler = null,
        webosBlockKey = false,
        //keycode for determining mouseon/mouseoff on webos
        WEBOS_MOUSE_ON = 1536,
        WEBOS_MOUSE_OFF = 1537,
        mouseOnCallback = null,
        mouseOffCallback = null,
        mouseOverCallback = null,
        doFocus, setMouseOnOff, mouseOnHandler, mouseOffHandler, mouseOverHandler,
        registerMouseOnOff, onCursorUpdate, mouseOffDelayFn, unregisterMouseOnOff,
        registerMouseOver, unregisterMouseOver,
        wiiCursorOnScreen = false;

    setMouseOnOff = function (newIsMouseOn) {
        var root;

        if (newIsMouseOn === isMouseOn) {
            return;
        }

        root      = getRootView();
        isMouseOn = newIsMouseOn;

        if (isMouseOn) {
            root.addClass(mouseOnClass);
            return;
        }

        root.removeClass(mouseOnClass);
        doFocus();
    };

    doFocus = function (component) {

        var focused = false;

        getRootView().removeClass(nonFocusableClass);

        //when mouse on
        if (isMouseOn) {
            //existing component
            if (component) {
                focused = fm.focus(component, {
                    skipForwardFocus: true
                });

                if (focused) {
                    return;
                }
            }

            if (!keepFocus) {
                fm.focus(null);
                return;
            }

            //when it keeps focus and mouse is on the non-focusable component/null, add a class to classify.
            getRootView().addClass(nonFocusableClass);

        }

        fm.ensureFocus();
    };

    mouseOnHandler = function () {
        var callbackResult;
        // run the callback if exist
        if (mouseOnCallback) {
            callbackResult = mouseOnCallback();
            if (callbackResult === false) {
                return true;
            }
        }

        setMouseOnOff(true);
    };

    mouseOffHandler = function (evt) {

        if (evt && evt.source !== "device") {
            //ignore the soft keyboard source or other sources which are not from the device key
            return true;
        }

        if (!isMouseOn) {
            // don"t even call callback when mouse is already off
            // so repeated key strokes will not result in repeated mouse off callback
            return true;
        }

        var callbackResult;
        // run the callback if exist
        if (mouseOffCallback) {
            callbackResult = mouseOffCallback();
            if (callbackResult === false) {
                return true;
            }
        }

        setMouseOnOff(false);
        return false;
    };

    mouseOverHandler = function (evt) {
        //IE doesn't pass in the event object
        evt = evt || window.event;
        var target = evt.target || evt.srcElement,
            component = findXDKComponent(target),
            callbackResult;

        if (getEnv().isBlockingMouse()) {
            return true;
        }

        //mouseover and no setMouseOnOff
        if (!isMouseOn) {
            mouseOnHandler();
            getRootView().addClass(mouseOnClass);
        }

        isMouseOn = true;

        // invalid event, target does not belong to a component
        if (!component) {
            doFocus(null);
            return true;
        }

        //find the right component
        while (component && !fm.isCompFocusable(component)) {
            component = component.getParent();
        }

        // run the callback if exist
        if (mouseOverCallback) {
            callbackResult = mouseOverCallback(component);
            if (callbackResult === false) {
                return true;
            }
        }

        // target is not focusable
        if (!component) {
            doFocus(null);
            return true;
        }

        doFocus(component);
        return true;
    };
    webosMouseOnOffHandler = function (keyEvent) {
        var keycode = keyEvent.keyCode,
            consumed = false;

        switch (keycode) {
            //mouse on
        case WEBOS_MOUSE_ON:
            mouseOnHandler();
            consumed = true;
            break;
            //mouse off
        case WEBOS_MOUSE_OFF:
            mouseOffHandler();
            consumed = true;
            webosBlockKey = true;
            //temporary block the keys,
            //on the TV, it will consecutive dispatch 2 events(1537 and original key event) when key down
            //try to block the second key event in order the keep focus without any direction change.
            util.defer().then(function () {
                webosBlockKey = false;
            }).done();
            break;
        }

        //stop the event to be processed in the keydown/keypress in tvkey
        if (consumed || webosBlockKey) {
            keyEvent.stopPropagation();
            keyEvent.preventDefault();
            return false;
        }

        return true;
    };
    registerMouseOnOff = function () {
        // special handling for LG mouse on/off events
        // notice, LG 2011 emulator has bug preventing window.mouseoff to work
        /**
         * @TODO use config to opt-out this logic
         */

        if (device.platform === "webos") {
            document.addEventListener("keydown", webosMouseOnOffHandler, true);
            return;
        }

        if (device.platform === "lg" && !(device.id.getFirmwareYear() <= 2011 && device.id.getHardwareType() === IId.HARDWARE_TYPE.EMULATOR)) {
            origMouseOnHandler = window.onmouseon;
            origMouseOffHandler = window.onmouseoff;
            window.onmouseon = mouseOnHandler;
            window.onmouseoff = mouseOffHandler;
            return;
        }

        //only add on tv console only
        if (device.platform === "wiiu" && nwf && window === nwf.display.DisplayManager.singleton().getTVDisplay().window) {
            // Wii controllers
            var wiiRemotes = [],
                key, remote;

            wiiRemotes[0] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_1);
            wiiRemotes[1] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_2);
            wiiRemotes[2] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_3);
            wiiRemotes[3] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_4);

            //mouseon
            for (key in wiiRemotes) {
                remote = wiiRemotes[key];
                remote.cursor.addEventListener(nwf.events.DPDControlEvent.UPDATE, onCursorUpdate);
            }

            //mouseoff
            mouseOffHandler = util.wrap(mouseOffHandler, function (orign) {
                if (wiiCursorOnScreen) {
                    //do nth when it is still on screen
                    return true;
                }
                return orign();
            });
        }
        getRootView().addEventListener(evtType.KEY, mouseOffHandler, true);
        return;
    };
    onCursorUpdate = function (e) {
        wiiCursorOnScreen = true;
        if (!isMouseOn) {
            console.info("[Wii]Mouse ON with the evt" + e);
            mouseOnHandler();
        }
        if (mouseOffDelayHandle) {
            util.clearDelay(mouseOffDelayHandle);
        }

        mouseOffDelayHandle = core.getGuid();

        util.delay(0.2, mouseOffDelayHandle).then(mouseOffDelayFn).done();
    };
    mouseOffDelayFn = function () {
        //to check if it is outside the screen. If it is outside the screen, we can do the mouse off handling
        console.info("[Wii]Mouse off outside the screen");
        wiiCursorOnScreen = false;
        mouseOffDelayHandle = null;
    };
    unregisterMouseOnOff = function () {

        if (device.platform === "webos") {
            document.removeEventListener("keydown", webosMouseOnOffHandler);
            return;
        }

        if (device.platform === "lg" && !(device.id.getFirmwareYear() <= 2011 && device.id.getHardwareType() === IId.HARDWARE_TYPE.EMULATOR)) {
            window.onmouseon = origMouseOnHandler;
            window.onmouseoff = origMouseOffHandler;
            return;
        }

        if (device.platform === "wiiu" && nwf) {
            // Wii controllers
            var wiiRemotes = [],
                key, remote;

            wiiRemotes[0] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_1);
            wiiRemotes[1] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_2);
            wiiRemotes[2] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_3);
            wiiRemotes[3] = nwf.input.WiiRemote.getController(nwf.input.WiiRemote.REMOTE_4);

            for (key in wiiRemotes) {
                remote = wiiRemotes[key];
                remote.cursor.removeEventListener(nwf.events.DPDControlEvent.UPDATE, onCursorUpdate);
            }
        }

        getRootView().removeEventListener(evtType.KEY, mouseOffHandler, true);

    };
    registerMouseOver = function () {
        rootEle.addEventListener("mouseover", mouseOverHandler);
    };
    unregisterMouseOver = function () {
        rootEle.removeEventListener("mouseover", mouseOverHandler);
    };

    var onMouseWheel = function (evt) {
        var target = evt.target || evt.srcElement;
        var eventObj = {
            deltaY: evt.wheelDelta,
            target: findXDKComponent(target)
        };
        var env = getEnv();

        env.dispatchEvent(env.EVT_ON_MOUSE_WHEEL, eventObj);
    };

    var getEnv = function () {
        sEnv = sEnv || Env.singleton();
        return sEnv;
    };

    var getRootView = function () {
        sAppRoot = sAppRoot || AppRoot.singleton();
        return sAppRoot.getView();
    };


    return {
        /**
         * Starts the mouse handlings.
         * These handlings include focus and wheel handling.
         *
         * @memberof module:xdk-mouse/mouseHandler
         * @method
         * @public
         */
        start: function () {
            rootEle = rootEle || getRootView().getRoot();

            keepFocus = config.get("mouse.keep-focus", false);

            registerMouseOnOff();
            registerMouseOver();

            if (device.platform === "lg" && window.NetCastGetMouseOnOff) {
                var newIsMouseOn = window.NetCastGetMouseOnOff().toUpperCase() === "ON";

                setMouseOnOff(newIsMouseOn);
            }

            rootEle.addEventListener("mousewheel", onMouseWheel);
        },
        /**
         * Stops the mouse handlings.
         * These handlings include focus and wheel handling.
         *
         * @memberof module:xdk-mouse/mouseHandler
         * @method
         * @public
         */
        stop: function () {
            rootEle = rootEle || getRootView().getRoot();

            unregisterMouseOnOff();
            unregisterMouseOver();

            rootEle.removeEventListener("mousewheel", onMouseWheel);

            isMouseOn = false;
        },
        /**
         * Checks whether mouse is currently on
         * @memberof module:xdk-mouse/mouseHandler
         * @method
         * @return {Boolean} whether mouse is currently on
         * @public
         */
        isMouseOn: function () {
            return isMouseOn;
        },
        /**
         * Sets a callback function to be called whenever mouse is turned on
         * @memberof module:xdk-mouse/mouseHandler
         * @param {Function} callback the callback function
         * @method
         * @public
         */
        setMouseOnCallback: function (callback) {
            mouseOnCallback = callback;
        },
        /**
         * Sets a callback function to be called whenever mouse is turned off
         * @memberof module:xdk-mouse/mouseHandler
         * @param {Function} callback the callback function
         * @method
         * @public
         */
        setMouseOffCallback: function (callback) {
            mouseOffCallback = callback;
        },
        /**
         * Sets a callback function to be called whenever mouse is moved over some component.
         * The callback will be called with parameter of the component.
         * @memberof module:xdk-mouse/mouseHandler
         * @param {Function} callback the callback function
         * @method
         * @public
         */
        setMouseOverCallback: function (callback) {
            mouseOverCallback = callback;
        }
    };

});

/**
 * PlaybackInfo stores the information of a playback.
 * The properties are accessible directly, as same as a plain JS object.
 * A public constructor can be used to initialize the values.
 * @class tve/videoPlaybackService/model/PlaybackInfo
 */
define("tve/videoPlaybackService/model/PlaybackInfo", [
        "xdk-base/class"
    ],
    function (klass) {
        return klass.create({}, {
            /**
             * @property {Number} currentTime The current playback time
             * @memberOf tve/videoPlaybackService/model/PlaybackInfo#
             */
            currentTime: 0,
            /**
             * @property {Number} duration The duration of the playback
             * @memberOf tve/videoPlaybackService/model/PlaybackInfo#
             */
            duration: 0,
            /**
             * @property {String} state The playback state
             * @memberOf tve/videoPlaybackService/model/PlaybackInfo#
             */
            state: null,

            /**
             * The constructor of this class, accessible using the `new` keyword.
             * @method
             * @param {Object} [opts] The initial values
             * @param {Number} [opts.duration=0] The duration of the playback
             * @param {Number} [opts.currentTime=0] The current playback time
             * @param {String} [opts.state=null] The playback state
             * @memberOf tve/videoPlaybackService/model/PlaybackInfo#
             * @example
             *  var playbackInfo = new PlaybackInfo({
             *      duration: 50000
             *  });
             *
             *  console.log(playbackInfo.duration); // 50000
             */
            init: function (opts) {
                opts = opts || {};

                this.duration = opts.duration || 0;
                this.currentTime = opts.currentTime || 0;
                this.state = opts.state || null;
            }
        });
    });
/**
 * Playlist stores the information of a series of playlist item {@see tve/videoPlaybackService/model/PlaylistItem} and the current state of the playback.
 * The properties are accessible directly, as same as a plain JS object.
 * A public constructor can be used to initialize the values.
 * @class tve/videoPlaybackService/model/Playlist
 */
define("tve/videoPlaybackService/model/Playlist", [
        "xdk-base/class", "tve/videoPlaybackService/model/PlaybackInfo"
    ],
    function (klass, PlaybackInfo) {
        return klass.create({}, {
            /**
             * @property {tve/videoPlaybackService/model/PlaylistItem[]} id The playlist items
             * @memberOf tve/videoPlaybackService/model/Playlist#
             */
            items: [],
            /**
             * @property {Number} currentItemIdx The index of the current playing list item
             * @memberOf tve/videoPlaybackService/model/Playlist#
             */
            currentItemIdx: 0,
            /**
             * @property {tve/videoPlaybackService/model/PlaybackInfo} currentPlaybackInfo The playback information of the current list item
             * @memberOf tve/videoPlaybackService/model/Playlist#
             */
            currentPlaybackInfo: null,
            /**
             * @property {Object} metadata The metadata of this list
             * @memberOf tve/videoPlaybackService/model/Playlist#
             */
            metadata: {},

            /**
             * The constructor of this class, accessible using the `new` keyword.
             * @method
             * @param {Object} [opts] The initial values
             * @param {PlaylistItem[]} [opts.items] The playlist items
             * @param {Number} [opts.currentItemIdx] The index of the current playing list item
             * @param {Object} [opts.metadata={}] The metadata of this list
             * @memberOf tve/videoPlaybackService/model/Playlist#
             * @example
             *  var playlist = new Playlist({
             *      items: [item0, item1, item2],
             *      currentItemIdx: 1
             *  });
             *
             *  console.log(playlist.currentItemIdx); // 1
             */
            init: function (opts) {
                opts = opts || {};

                this.items = opts.items || [];
                this.currentItemIdx = opts.currentItemIdx || 0;
                this.metadata = opts.metadata || {};

                this.currentPlaybackInfo = new PlaybackInfo();
            }

        });
    });
/**
 * PlaylistItem stores the information of a playable content, which is placed inside a playlist as an playlist item.
 * The properties are accessible directly, as same as a plain JS object.
 * A public constructor can be used to initialize the values.
 * @class tve/videoPlaybackService/model/PlaylistItem
 */
define("tve/videoPlaybackService/model/PlaylistItem", [
        "xdk-base/class"
    ],
    function (klass) {
        return klass.create({}, {
            /**
             * @property {String} id The item id
             * @memberOf tve/videoPlaybackService/model/PlaylistItem#
             */
            id: null,
            /**
             * @property {String} url The item url
             * @memberOf tve/videoPlaybackService/model/PlaylistItem#
             */
            url: null,
            /**
             * @property {Object} metadata The metadata of this item
             * @memberOf tve/videoPlaybackService/model/PlaylistItem#
             */
            metadata: {},
            /**
             * @property {Object} drmAttributes The data used to gain access to the playable content under DRM
             * @memberOf tve/videoPlaybackService/model/PlaylistItem#
             */
            drmAttributes: {},

            /**
             * The constructor of this class, accessible using the `new` keyword.
             * @method
             * @param {Object} [opts] The initial values
             * @param {String} [opts.id] The item id
             * @param {String} [opts.url] The item url
             * @param {Object} [opts.metadata={}] The metadata of this item
             * @param {Object} [opts.drmAttributes={}] The DRM attributes of this item
             * @memberOf tve/videoPlaybackService/model/PlaylistItem#
             * @example
             *  var playlistItem = new PlaylistItem({
             *      id: "id-of-the-item",
             *      url: "http://video.accedo.tv/id-of-the-item"
             *  });
             *
             *  console.log(playlistItem.url); // http://video.accedo.tv/id-of-the-item
             */
            init: function (opts) {
                opts = opts || {};

                this.id = opts.id || null;
                this.url = opts.url || null;
                this.metadata = opts.metadata || {};
                this.drmAttributes = opts.drmAttributes || null;
            }
        });
    });
/**
 * VideoPlaybackControlsEvent is an enumeration of the events used to notify the UI a particular event has happened.
 * @readonly
 * @enum {String}
 * @name VideoPlaybackControlsEvent
 */
define("tve/videoPlaybackService/evt/VideoPlaybackControlsEvent", {
    /**
     * The playback is playing
     */
    SetControlsInPlayState: "VideoPlaybackControlsEvent:SetControlsInPlayState",
    /**
     * The playback is paused
     */
    SetControlsInPauseState: "VideoPlaybackControlsEvent:SetControlsInPauseState",
    /**
     * Update the playback playhead position
     */
    UpdatePlayheadState: "VideoPlaybackControlsEvent:UpdatePlayheadState",
    /**
     * Update the volume indicator
     */
    UpdateVolumeState: "VideoPlaybackControlsEvent:UpdateVolumeState",
    /**
     * Dismiss the controls
     */
    DismissControls: "VideoPlaybackControlsEvent:DismissControls",
    /**
     * The next playlist item is played
     */
    NextPlaylistItem: "VideoPlaybackControlsEvent:NextPlaylistItem",
    /**
     * The previous playlist item is played
     */
    PreviousPlaylistItem: "VideoPlaybackControlsEvent:PreviousPlaylistItem",
    /**
     * Error occured
     */
    NotifyError: "VideoPlaybackControlsEvent:NotifyError",
    /**
     * Suspend the UI
     */
    SuspendUI: "VideoPlaybackControlsEvent:SuspendUI",
    /**
     * Update time played
     */
     TimePlayedIncreased: "VideoPlaybackControlsEvent:TimePlayedIncreased"
});
/**
 * VideoPlaybackStatusEvent is an enumeration of the events used to notify of playback events that has occured.
 * @readonly
 * @enum {String}
 * @name VideoPlaybackStatusEvent
 */
define("tve/videoPlaybackService/evt/VideoPlaybackStatusEvent", {
    /**
     * The playback is playing.
     */
    PlayState: "VideoPlaybackStatusEvent:PlayState",
    /**
     * The playback is paused.
     */
    PauseState: "VideoPlaybackStatusEvent:PauseState",
    /**
     * The playback is buffering.
     */
    BufferState: "VideoPlaybackStatusEvent:BufferState",
    /**
     * The playback is stopped.
     */
    StopState: "VideoPlaybackStatusEvent:StopState" 
});
/**
 * VideoControlsStatusEvent is an enumeration of the events associated to video controls status change.
 * @readonly
 * @enum {String}
 * @name VideoControlsStatusEvent
 */
define("tve/videoPlaybackService/evt/VideoControlsStatusEvent", {
    /**
     * Dismiss is selected
     */
    DismissSelected: "VideoControlsStatusEvent:DismissSelected",
    /**
     * Play is selected
     */
    PlaySelected: "VideoControlsStatusEvent:PlaySelected",
    /**
     * Pause is selected
     */
    PauseSelected: "VideoControlsStatusEvent:PauseSelected",
    /**
     * Volume has changed
     */
    VolumeChanged: "VideoControlsStatusEvent:VolumeChanged",
    /**
     * Playback time has changed
     */
    PlayheadMoved: "VideoControlsStatusEvent:PlayheadMoved",
    /**
     * The next playlist item is selected
     */
    NextPlaylistItemSelected: "VideoControlsStatusEvent:NextPlaylistItemSelected",
    /**
     * The previous playlist item is selected
     */
    PreviousPlaylistItemSelected: "VideoControlsStatusEvent:PreviousPlaylistItemSelected"
});
/**
 * Suspendable is an interface for {@link xdk-base/device/interface/Player} instance. Any player supporting suspension should implement this interface.<br/>
 * A suspended playback can be restored later according to the application requirement.
 *
 * @class xdk-base/device/interface/Suspendable
 * @see {@link xdk-base/device/interface/Suspendable.SuspendedPlayback}
 * @author Marco Fan <marco.fan@accedo.tv>
 */
define("xdk-base/device/interface/Suspendable", [
    "xdk-base/Interface"
], function (
    Interface
) {
    "use strict";

    var Suspendable = Interface.create("Suspendable", {
        /**
         * Suspends the current playback, returning a {@link xdk-base/device/interface/Suspendable.SuspendedPlayback} object for restoration.
         *
         * @method suspend
         * @abstract
         * @returns {ax/device/interface/Suspendable.SuspendedPlayback} The suspended playback
         * @memberof xdk-base/device/interface/Suspendable#
         */
        suspend: [],

        /**
         * Gets the number of current active suspended playbacks.
         * All suspended playback are considered as active unless they are disposed.
         *
         * @method getSuspendedCount
         * @abstract
         * @returns {Number} The number of active suspended playbacks
         * @memberof xdk-base/device/interface/Suspendable#
         */
        getSuspendedCount: []
    });

    /**
     * Media information.
     *
     * @typedef {Object} MediaMeta
     * @property {String} url The url of the media
     * @property {Object} opts The JSON object storing the other metadata such as type, drm, etc
     */

    /**
     * SuspendedPlayback is an interface for playback restoration, which will be returned by {@link xdk-base/device/interface/Suspendable#suspend}.<br/>
     * A suspended playback can be restored later according to the application requirement.<br/>
     * Suspended playback object may hold some system resources. The framework has no knowledge on when they can be release.
     * Therefore, it is the application responsibility to dispose the object after it is no longer needed, no matter it has been restored or not.
     *
     * @class xdk-base/device/interface/Suspendable.SuspendedPlayback
     * @see {@link xdk-base/device/interface/Suspendable}
     * @author Marco Fan <marco.fan@accedo.tv>
     */
    Suspendable.SuspendedPlayback = Interface.create("SuspendedPlayback", {
        /**
         * Restores the suspended playback.
         * The playback states before suspension will retain.
         *
         * @method restore
         * @abstract
         * @param {Function} cb The callback that to be called when the restoration completes
         * @memberof xdk-base/device/interface/Suspendable.SuspendedPlayback#
         */
        restore: ["cb"],

        /**
         * Disposes the suspended playback, destroying the playback states before suspension.
         * A disposed playback cannot be restored anymore.
         *
         * @method dispose
         * @abstract
         * @memberof xdk-base/device/interface/Suspendable.SuspendedPlayback#
         */
        dispose: [],

        /**
         * Returns the media information.
         *
         * @method getMediaMeta
         * @abstract
         * @returns {MediaMeta} The media metadata
         * @memberof xdk-base/device/interface/Suspendable.SuspendedPlayback#
         */
        getMediaMeta: [],

        /**
         * Returns the player instance who is responsible for restoration.
         *
         * @method getPlayer
         * @abstract
         * @returns {ax/device/interface/Player} The player instance
         * @memberof xdk-base/device/interface/Suspendable.SuspendedPlayback#
         */
        getPlayer: []
    });

    return Suspendable;
});
/**
 * Preloadable is an interface for {@link xdk-base/device/interface/Player} instance. Any player supporting preloading should implement this interface.<br/>
 * Preloading is an operation that pre-load a media while another media is being played.
 * This helps to reduce the waiting time from the user perspective, as the preloading media could be buffered in the background.
 *
 * @class xdk-base/device/interface/Preloadable
 * @see {@link xdk-base/device/interface/Preloadable.Preloaded}
 * @author Marco Fan <marco.fan@accedo.tv>
 */
define("xdk-base/device/interface/Preloadable", [
    "xdk-base/Interface",
    "xdk-base/class"
], function (
    Interface,
    klass
) {
    "use strict";

    var Preloadable = Interface.create("Preloadable", {
        /**
         * Preloads a media for playback.<br/>
         * This interface is identical to {@link xdk-base/device/interface/Player#load}, except that the media is loaded at a background player.
         *
         * @method preload
         * @abstract
         * @param {String} url The URL of the media
         * @param {Object} [opts] the options for loading the media
         * @param {String} [opts.codec] The media codec
         * @param {String} [opts.type] The media type
         * @param {String} [opts.drm] The DRM to be used
         * @returns {ax/device/interface/Preloadable.PreloadedPlayback} The metadata of the preloading
         * @memberof xdk-base/device/interface/Preloadable#
         */
        preload: ["url", "opts"],

        /**
         * Gets the number of active preloaded playback.
         * All preloaded playbacks are considered active before they got disposed.
         *
         * @method getPreloadedCount
         * @abstract
         * @returns {Number} The number of active preloaded playbacks
         * @memberof xdk-base/device/interface/Preloadable#
         */
        getPreloadedCount: []
    });

    /**
     * PreloadedPlayback is an interface for playing a preloaded playback, which will be returned by {@link xdk-base/device/interface/Preloadable#preload}.<br/>
     * A preloaded playback can be played at anytime. It should be disposed if it is no longer needed, no matter it is played or not.
     *
     * @class xdk-base/device/interface/Preloadable.PreloadedPlayback
     * @see {@link xdk-base/device/interface/Preloadable}
     * @author Marco Fan <marco.fan@accedo.tv>
     */
    Preloadable.PreloadedPlayback = Interface.create("PreloadedPlayback", {
        /**
         * Plays the preloaded playback.
         *
         * @method play
         * @abstract
         * @memberof xdk-base/device/interface/Preloadable.PreloadedPlayback#
         */
        play: ["pos"],

        /**
         * Disposes the preloaded playback, destroying the playback resources.
         * A disposed playback cannot be played anymore.
         *
         * @method dispose
         * @abstract
         * @memberof xdk-base/device/interface/Preloadable.PreloadedPlayback#
         */
        dispose: [],

        /**
         * Returns the media information.
         *
         * @method getMediaMeta
         * @abstract
         * @returns {MediaMeta} The media metadata
         * @memberof xdk-base/device/interface/Preloadable.PreloadedPlayback#
         */
        getMediaMeta: [],

        /**
         * Returns the player instance who is responsible for restoration.
         *
         * @method getPlayer
         * @abstract
         * @returns {ax/device/interface/Player} The player instance
         * @memberof xdk-base/device/interface/Preloadable.PreloadedPlayback#
         */
        getPlayer: []
    });

    return Preloadable;
});
/**
 * The abstract player provides base function of some optional features.
 * For example, speed is not supported in all the player. The abstract player will consist of those optional function.
 * @class xdk-base/device/AbstractPlayer
 * @augments ax/device/interface/Player
 */
define("xdk-base/device/AbstractPlayer", ["xdk-base/class", "xdk-base/console", "xdk-base/device/interface/Player"], function (klass, console, IPlayer) {
    "use strict";
    return klass.createAbstract([IPlayer], {
        /**
         * The playback states of the player.
         * @deprecated  
         * @enum {String}
         * @memberof xdk-base/device/AbstractPlayer
         */
        PLAYBACK_STATE: {
            /**
             * The playback is playing, this also includes skipping, speeding, bufferring.
             */
            PLAYING: "playing",
            /**
             * The playback is paused, this also includes bufferring.
             */
            PAUSED: "paused",
            /**
             * The playback is stopped, or not started yet.
             */
            STOPPED: "stopped"
        }

    }, {
        /**
         * The id of the player
         * @name __id
         * @private
         * @memberof xdk-base/device/AbstractPlayer#
         */
        __id: null,
        /**
         * Speed up/down the media playback
         * @method
         * @param {Number} speed the playback speed to set
         * @memberof xdk-base/device/AbstractPlayer#
         */
        speed: function (speed) {
            console.warn("Speeding " + speed + " is not supported in the player");
        },
        /**
         * Get the playback speed
         * @method
         * @return {Number} the playback speed
         * @memberof xdk-base/device/AbstractPlayer#
         */
        getPlaybackSpeed: function () {
            console.warn("no play back speed in the player");
            return 1;
        },
        /**
         * Get the media bitrates
         * @method
         * @return {ax/device/interface/Player~MediaBitrates} current bitrate and available bitrates
         * @memberof xdk-base/device/AbstractPlayer#
         */
        getBitrates: function () {
            console.debug("no bitrate provided");
            return null;
        },
        /**
         * Get back the path
         * @method
         * @public
         * @return {String} the path of the player
         * @memberof xdk-base/device/AbstractPlayer#
         */
        getId: function () {
            return this.__id;
        },
        /**
         * set the id of the player
         * @method
         * @public
         * @param {String} id the path of the player
         * @memberof xdk-base/device/AbstractPlayer#
         */
        setId: function (id) {
            this.__id = id;
        }
    });
});
/**
 * FallbackSuspendedPlayback is a fallback version of SuspendedPlayback used by {@link xdk-base/device/Media} for the player that has not implemented {@link xdk-base/device/interface/Suspendable.SuspendedPlayback}.
 *
 * @class xdk-base/device/FallbackSuspendedPlayback
 * @memberof xdk-base/deivce/Media
 * @author Marco Fan <marco.fan@accedo.tv>
 */
define("xdk-base/device/FallbackSuspendedPlayback", [
    "xdk-base/class",
    "xdk-base/device/interface/Suspendable",
    "xdk-base/device/AbstractPlayer",
    "xdk-base/util"
], function (
    klass,
    Suspendable,
    AbstractPlayer,
    util
) {
    "use strict";

    return klass.create([Suspendable.SuspendedPlayback], {}, {
        /**
         * Constructs a new FallbackSuspendedPlayback.
         * The Media instance is needed such that circular dependency can be avoided.
         *
         * @method
         * @param {xdk-base/device/Media} media The Media instance
         * @param {xdk-base/device/interface/Player} player The player
         * @param {Object} metadata The metadata for playback resume
         * @param {String} metadata.url The media url
         * @param {Object} [metadata.opts] The media loading options
         * @param {Number} [metadata.pos = 0] The resume position
         * @param {String} [metadata.state] The playback state
         * @memberof xdk-base/device/FallbackSuspendedPlayback#
         */
        init: function (media, player, metadata) {
            this.__media = media;
            this.__player = player;
            this.__url = metadata.url;
            this.__opts = metadata.opts || {};
            this.__pos = metadata.pos || 0;
            this.__state = metadata.state;
        },

        /**
         * Restores the suspended playback.
         * The playback states before suspension will retain.
         *
         * @method
         * @param {Function} cb The callback that to be called when the restoration completes
         * @memberof xdk-base/device/FallbackSuspendedPlayback#
         */
        restore: function (cb) {
            var sMedia = this.__media;
            var loadOpts = util.extend(util.extend({}, this.__opts, true), {
                player: this.__player
            });

            var stopped = (this.__state === AbstractPlayer.PLAYBACK_STATE.STOPPED);

            //add the state change listener for handling playing and paused
            if (!stopped) {
                // one time event listener to handle the playback state
                var onStateChange = util.bind(function (evt) {
                    switch (evt.toState) {
                    case sMedia.PLAYING:
                        if (this.__state === AbstractPlayer.PLAYBACK_STATE.PAUSED) {
                            sMedia._doPause();
                        }

                        sMedia.__stateMachine.removeEventListener(sMedia.EVT_STATE_CHANGED, onStateChange);
                        cb();
                        break;
                    }
                }, this);

                sMedia.__stateMachine.addEventListener(sMedia.EVT_STATE_CHANGED, onStateChange);
            }

            sMedia._doLoad(this.__url, loadOpts);

            //stop directly and perform callback when stopped
            if (stopped) {
                cb();
                return;
            }

            sMedia._doPlay({
                sec: this.__pos
            });
        },

        /**
         * Disposes the suspended playback, destroying he playback states before suspension.<br/>
         * A disposed playback cannot be restored anymore.
         *
         * @method
         * @memberof xdk-base/device/FallbackSuspendedPlayback#
         */
        dispose: function () {
            this.__player = null;
        },

        /**
         * Returns the media information.
         *
         * @method
         * @returns {MediaMeta} The media metadata
         * @memberof xdk-base/device/FallbackSuspendedPlayback#
         */
        getMediaMeta: function () {
            return {
                url: this.__url,
                opts: this.__opts
            };
        },

        /**
         * Returns the player instance who is responsible for restoration.
         *
         * @method
         * @returns {ax/device/interface/Player} The player instance
         * @memberof xdk-base/device/FallbackSuspendedPlayback#
         */
        getPlayer: function () {
            return this.__player;
        }
    });
});
/**
 * FallbackPreloadedPlayback is a fallback version of PreloadedPlayback used by {@link xdk-base/device/Media} for the player that has not implemented {@link xdk-base/device/interface/Preloadable.PreloadedPlayback}.
 *
 * @class xdk-base/device/FallbackPreloadedPlayback
 * @author Marco Fan <marco.fan@accedo.tv>
 */
define("xdk-base/device/FallbackPreloadedPlayback", [
    "xdk-base/class",
    "xdk-base/device/interface/Preloadable",
    "xdk-base/util",
    "xdk-base/device/playerRegistry",
    "xdk-base/core",
    "xdk-base/exception"
], function (
    klass,
    Preloadable,
    util,
    playerRegistry,
    core,
    exception
) {
    "use strict";

    return klass.create([Preloadable.PreloadedPlayback], {}, {
        /**
         * Constructs a new FallbackPreloadedPlayback.
         * The Media instance is needed such that circular dependency can be avoided.
         *
         * @method
         * @param {xdk-base/device/Media} media The Media instance
         * @param {String} url The media url
         * @param {Object} [opts] The media loading options
         * @memberof xdk-base/device/FallbackPreloadedPlayback#
         */
        init: function (media, url, opts) {
            this.__media = media;
            this.__url = url;
            this.__opts = opts || {};

            if (this.__opts.player) {
                this.__player = this.__opts.player;
            } else {
                this.__player = playerRegistry.getPlayer(this.__opts);
            }
        },

        /**
         * Plays the preloaded playback.
         *
         * @method
         * @memberof xdk-base/device/FallbackPreloadedPlayback#
         */
        play: function (pos) {
            var sMedia = this.__media;

            sMedia.load(this.__url, this.__opts);
            sMedia.play({
                sec: pos
            });
        },

        /**
         * Disposes the suspended playback, destroying he playback states before suspension.<br/>
         * A disposed playback cannot be restored anymore.
         *
         * @method
         * @memberof xdk-base/device/FallbackPreloadedPlayback#
         */
        dispose: function () {
            // do nothing as nothing has been preloaded inside the fallback implementation
        },

        /**
         * Returns the media information.
         *
         * @method
         * @returns {MediaMeta} The media metadata
         * @memberof xdk-base/device/FallbackPreloadedPlayback#
         */
        getMediaMeta: function () {
            return {
                url: this.__url,
                opts: this.__opts
            };
        },

        /**
         * Returns the player instance who is responsible for restoration.
         *
         * @method
         * @returns {ax/device/interface/Player} The player instance
         * @memberof xdk-base/device/FallbackPreloadedPlayback#
         */
        getPlayer: function () {
            return this.__player;
        }
    });
});
/**
 * The subtitle strategy interface, which will be awared by subtitle.
 *
 * @class xdk-base/device/interface/SubtitleStgy
 */
define("xdk-base/device/interface/SubtitleStgy", ["xdk-base/Interface"], function (Interface) {
    "use strict";
    var SubtitleStgy = Interface.create("SubtitleStgy", {
        /**
         * Set the player to the subtitle strategy.
         * @name setPlayer
         * @function
         * @abstract
         * @memberof xdk-base/device/interface/SubtitleStgy
         * @public
         */
        setPlayer: ["player"],
        /**
         * show the substitle.
         * @name showSubtitle
         * @function
         * @abstract
         * @param {String} id the subtitle id
         * @returns {Promise.<Boolean>} the result of showing substitle. True when successfully loaded.
         * @memberof xdk-base/device/interface/SubtitleStgy
         * @public
         */
        showSubtitle: ["id"],
        /**
         * hide the subtitle
         * @name hideSubtitle
         * @function
         * @abstract
         * @returns {Promise.<Boolean> the result of hiding subtitle. True when succesfully hided.
         * @memberof xdk-base/device/interface/SubtitleStgy
         * @public
         */
        hideSubtitle: [],
        /**
         * get the current subtitle
         * @name getCurrentSubtitle
         * @function
         * @abstract
         * @return {Promise.<ax/device/Subtitle.subsitle>} the current subtitle
         * @memberof xdk-base/device/interface/SubtitleStgy
         * @public
         */
        getCurrentSubtitle: [],
        /**
         * get all the available subtitle
         * @name getSubtitles
         * @function
         * @abstract
         * @return {Promise.<ax/device/Subtitle.subsitle[]>} the available substitle array
         * @memberof xdk-base/device/interface/SubtitleStgy
         * @public
         */
        getSubtitles: []

    });
    /**
     * The type constant for internal subtitle strategy.
     * @property {String}
     * @memberof xdk-base/device/interface/SubtitleStgy
     */
    SubtitleStgy.TYPE = "internal";

    return SubtitleStgy;
});
/**
 * The external subtitle strategy interface, which will be awared by subtitle.
 *
 * @class xdk-base/device/interface/ExtSubtitleStgy
 * @extends ax/device/interface/SubtitleStgy
 */
define("xdk-base/device/interface/ExtSubtitleStgy", [
    "xdk-base/Interface",
    "xdk-base/device/interface/SubtitleStgy"
], function (
    Interface,
    SubtitleStgy
) {
    "use strict";
    var ExtSubtitleStgy = Interface.create("ExtSubtitleStgy", [SubtitleStgy], {
        /**
         * Prepare for the subtitle, like download the external source or embedded the external subtitle into the player
         * @name prepare
         * @function
         * @abstract
         * @memberof xdk-base/device/interface/ExtSubtitleStgy
         * @public
         */
        prepare: ["subtitleOption"]
    });

    /**
     * The type constant for external subtitle strategy.
     * @property {String} 
     * @memberof xdk-base/device/interface/ExtSubtitleStgy
     */
    ExtSubtitleStgy.TYPE = "external";

    return ExtSubtitleStgy;
});
/**
 * Subtitle class which composites of external and internal subtitle strategies.
 * Each media will has its own subtitle instance which store information for the subtitles.
 *
 * @class xdk-base/device/MediaSubtitle
 */
define("xdk-base/device/MediaSubtitle", [
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/core",
    "xdk-base/exception",
    "xdk-base/util",
    "xdk-base/device/interface/SubtitleStgy",
    "xdk-base/device/interface/ExtSubtitleStgy",
    "require"
], function (
    klass,
    config,
    console,
    promise,
    core,
    exception,
    util,
    ISubtitleStgy,
    IExternalStgy,
    require
) {
    "use strict";
    /**
     * Subtitle Object which stores the information for the subtitle. It provides the langauage info and type
     * @typedef {Object} Subtitle
     * @property {String} id the id of the subtitle
     * @property {String} type The actual data entries
     * @property {String} lang the langauge code for the subtitle. It should follow the standard lang code <https://accedobroadband.jira.com/wiki/display/XDKDEV/Media+Subtitle+Strategy+support+-+2.4#MediaSubtitleStrategysupport-2.4-Standardlangcode>
     * @property {String} tag the extra information for the subtitle
     * @memberof xdk-base/device/MediaSubtitle#
     */


    /**
     * Subtitle Option for each external subtitle information provided by developer.
     * @typedef {Object} subtitleOption
     * @property {String} url the url of the subtitle
     * @property {String} type The actual data entries
     * @property {String} lang the langauge code for the subtitle. It should follow the standard lang code <https://accedobroadband.jira.com/wiki/display/XDKDEV/Media+Subtitle+Strategy+support+-+2.4#MediaSubtitleStrategysupport-2.4-Standardlangcode>
     * @property {String} tag the extra information for the subtitle
     * @memberof xdk-base/device/MediaSubtitle#
     */

    var INTERNAL_TYPE = ISubtitleStgy.TYPE,
        EXTERNAL_TYPE = IExternalStgy.TYPE;

    return klass.create({}, {
        /**
         * The player instance
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __player: null,
        /**
         * The current seletced subtitle id
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __currentId: -1,
        /**
         * The subtitle object array
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __subtitleArr: null,
        /**
         * The id mapping of the original subtitle id in strategy
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __idMapping: [],

        /**
         * The internatl strategy instance
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __internalStgy: null,

        /**
         * The external strategy instance
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __externalStgy: null,

        /**
         * The external strategy instance
         * @private
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __subtitleStgy: null,
        /**
         * init the subtitle module
         * @param {Object} subtitleStgy the object which store the information for the stgy class name.
         *  example {"internal": "InternalSubtitleStgy", "external":"ExternalSubtitleStgy"}
         * @param {xdk-base/device/interface/Player} player player instance
         * @param {xdk-base/device/interface/Preloaded.PreloadedPlayback} [preloaded] the preloadable item
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        init: function (subtitleStgy, player, preloaded) {
            this.__subtitleStgy = subtitleStgy || {};
            this.__player = player;
            this.__preloaded = preloaded;
        },
        /**
         * Prepare the subtitle
         * @param {subtitleOption[]} opts external subtitle information
         * @public
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        prepare: function (opts) {
            var internalStgyId, InternalStgy, externalStgyId, ExternalStgy;

            internalStgyId = this.__subtitleStgy.internal;
            console.info("[XDK] internal strategy is loading now");

            if (internalStgyId) {

                InternalStgy = require(internalStgyId);

                if (!klass.hasImpl(InternalStgy, ISubtitleStgy)) {
                    throw core.createException(exception.ILLEGAL_STATE, "Internal Subtitle doesn't implement subtitle strategy");
                }

                try {
                    this.__internalStgy = new InternalStgy();
                    console.info("[XDK] Success to create subtitle internal strategy " + internalStgyId);
                } catch (ex) {
                    console.warn("[XDK] Fail to create subtitle internal strategy " + internalStgyId);
                }

                this.__internalStgy.setPlayer(this.__player, this.__preloaded);
            }

            externalStgyId = this.__subtitleStgy.external;
            console.info("[XDK] external strategy is loading now");

            if (externalStgyId) {

                ExternalStgy = require(externalStgyId);

                if (!klass.hasImpl(ExternalStgy, IExternalStgy)) {
                    throw core.createException(exception.ILLEGAL_STATE, "External Subtitle doesn't implement subtitle strategy");
                }

                try {
                    this.__externalStgy = new ExternalStgy();
                    console.info("[XDK] Success to create subtitle external strategy " + externalStgyId);
                } catch (ex) {
                    console.warn("[XDK] Fail to create subtitle external strategy " + externalStgyId);
                }

                this.__externalStgy.setPlayer(this.__player, this.__preloaded);
                this.__externalStgy.prepare(opts);
            }
        },
        /**
         * Show the specific subtitle
         * @param {String} [id] the subtitle id.If it is empty, it will be the current Id.
         * @returns {Promise.<Boolean>} true when show subtitle successfully
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} no available subtitle track and fail to show
         * @public
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        showSubtitle: function (id) {
            if (util.isUndefined(id)) {

                if (this.__currentId === -1) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, " Fail to sho the subtitle when no available subtitle strategy."));
                }

                id = this.__currentId;
            }

            var targetStgy;

            try {
                targetStgy = this.__getStgyById(id);
            } catch (mException) {
                return promise.reject(mException);
            }

            if (targetStgy) {
                //get back the conversion for the id
                var originalId = this.__idMapping[id];

                this.__currentId = id;

                return targetStgy.showSubtitle(originalId);
            }

            return promise.reject(core.createException(exception.ILLEGAL_STATE, " Fail to show the subtitle when no available subtitle strategy."));

        },
        /**
         * Hide the current subtitle track
         * @returns {Promise.<Boolean>} true when hide subtitle successfully
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} no available subtitle track and fail to hide
         * @public
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        hideSubtitle: function () {
            if (this.__currentId === -1) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, " Fail hide the subtitle when no available subtitle to hide."));
            }

            var curStgy = this.__getStgyById(this.__currentId);

            if (curStgy) {
                return curStgy.hideSubtitle();
            }

            return promise.reject(core.createException(exception.ILLEGAL_STATE, " Fail hide the subtitle when no available subtitle strategy."));
        },
        /**
         * Get the strategy whether internla or external
         * @param {String} id the id of the subtitle track
         * @returns {ax/device/interface/SubtitleStgy} the subtitle strategy. Null when no available strategy
         * @private
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        __getStgyById: function (id) {
            if (!this.__subtitleArr || id > this.__subtitleStgy.length) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, " the id is not in a possible range");
            }

            var curSubtitle = this.__subtitleArr[id];

            if (curSubtitle.type === INTERNAL_TYPE && this.__internalStgy) {
                return this.__internalStgy;
            }

            if (curSubtitle.type === EXTERNAL_TYPE && this.__externalStgy) {
                return this.__externalStgy;
            }

            return null;
        },
        /**
         * Get the current subtitle information
         * @returns {Promise.<Subtitle>} the subtitle information
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} no available subtitle track
         * @memberof xdk-base/device/MediaSubtitle#
         */
        getCurrentSubtitle: function () {
            //try to get it from the internal strategy
            if (this.__currentId === -1) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, " Fail to get current substitle since it doesn't exist or set"));
            }

            return promise.resolve(this.__subtitleArr[this.__currentId]);

        },
        /**
         * Get the current subtitle information
         * @returns {Promise.<Subtitle[]>} array of the subtitle information
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        getSubtitles: function () {

            //only perform once and return the data directly
            if (this.__subtitleArr) {
                return promise.resolve(this.__subtitleArr);
            }

            var getSubtitlePromiseArr = [],
                addSubtitle = util.bind(function (item) {
                    //standardise the id to be index numbers

                    //record the original id
                    this.__idMapping.push(item.id);

                    item.id = this.__subtitleArr.length;

                    this.__subtitleArr.push(item);
                }, this);

            this.__subtitleArr = [];

            if (this.__externalStgy) {
                getSubtitlePromiseArr.push(this.__externalStgy.getSubtitles().then(util.bind(function (externalSubtitles) {
                    //push the external subtitle information into the subtitle module
                    util.each(externalSubtitles, addSubtitle);

                }, this)));
            }

            if (this.__internalStgy) {
                getSubtitlePromiseArr.push(this.__internalStgy.getSubtitles().then(util.bind(function (internalSubtitles) {
                    //push the internal subtitle information into the subtitle module
                    util.each(internalSubtitles, addSubtitle);
                }, this)));
            }

            return promise.all(getSubtitlePromiseArr).then(util.bind(function () {
                return this.__subtitleArr;
            }, this));
        },

        /**
         * deinit
         * @method
         * @memberof xdk-base/device/MediaSubtitle#
         */
        deinit: function () {
            if (this.__externalStgy && this.__externalStgy.deinit) {
                this.__externalStgy.deinit();
            }

            if (this.__internalStgy && this.__internalStgy.deinit) {
                this.__internalStgy.deinit();
            }

        }
    });

});

define('css!xdk-base/device/css/Media',[],function(){});
/**
 * Media class. Loads and plays media (by calling underlying media player).
 *
 * This class is designed as a singleton, developer should use {@link xdk-base/device/Media.singleton|singleton} to obtain the instance.
 * Creating instance using the _new_ keyword is prohibited.
 *
 * @class xdk-base/device/Media
 * @author Daniel Deng <daniel.deng@accedo.tv>
 * @author Andy Hui <andy.hui@accedo.tv>
 * @fires ax/device/Media#EVT_STATE_CHANGED
 * @fires ax/device/Media#EVT_BUFFERING_PROGRESS
 * @fires ax/device/Media#EVT_TIME_UPDATE
 * @fires ax/device/Media#EVT_FINISHED
 * @fires ax/device/Media#EVT_ERROR
 * @fires ax/device/Media#EVT_PUSHED
 * @fires ax/device/Media#EVT_POPPED
 */
define("xdk-base/device/Media", [
    "xdk-base/class",
    "xdk-base/EventDispatcher",
    "xdk-base/device/interface/Suspendable",
    "xdk-base/device/interface/Preloadable",
    "xdk-base/device/FallbackSuspendedPlayback",
    "xdk-base/device/FallbackPreloadedPlayback",
    "xdk-base/device/playerRegistry",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-base/config",
    "require",
    "xdk-base/exception",
    "xdk-base/promise",
    "xdk-base/device/AbstractPlayer",
    "xdk-base/device/interface/Player",
    "xdk-base/device/MediaSubtitle",
    "css!./css/Media"
], function (
    klass,
    EvtDisp,
    Suspendable,
    Preloadable,
    FallbackSuspendedPlayback,
    FallbackPreloadedPlayback,
    registry,
    core,
    util,
    console,
    config,
    require,
    exception,
    promise,
    AbstractPlayer,
    IPlayer,
    MediaSubtitle
) {
    "use strict";

    var Media,
        instance;

    var PLAYBACK_STATE = IPlayer.PLAYBACK_STATE;
    var PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS;

    Media = klass.create(EvtDisp, {
        /**
         * Get the singleton instance of this class.
         * @method
         * @static
         * @returns {ax/device/Media} The singleton
         * @memberof xdk-base/device/Media
         */
        singleton: function () {
            if (!instance) {
                instance = new Media();
            }

            return instance;
        }
    }, {
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        STOPPED: 0,
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        PLAYING: 1,
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        PAUSED: 2,
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        SKIPPING: 3,
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        SPEEDING: 4,
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        BUFFERING: 5,
        /**
         * PlayState of the video Object
         * @public
         * @constant
         * @memberof xdk-base/device/Media#
         */
        CONNECTING: 6,
        /**
         * Event: playState change
         *
         * @event EVT_STATE_CHANGED
         * @memberof xdk-base/device/Media#
         */
        EVT_STATE_CHANGED: "media:state-change",
        /**
         * Event: buffering progress
         *
         * @event EVT_BUFFERING_PROGRESS
         * @memberof xdk-base/device/Media#
         */
        EVT_BUFFERING_PROGRESS: "media:buffering-progress",
        /**
         * Event: time update
         *
         * @event EVT_TIME_UPDATE
         * @memberof xdk-base/device/Media#
         */
        EVT_TIME_UPDATE: "media:time-update",
        /**
         * Event: video finish
         *
         * @event EVT_FINISHED
         * @memberof xdk-base/device/Media#
         */
        EVT_FINISHED: "media:finish",
        /**
         * Event: video error
         *
         * @event EVT_ERROR
         * @memberof xdk-base/device/Media#
         */
        EVT_ERROR: "media:error",
        /**
         * Event: playback state pushed to stack
         *
         * @event EVT_PUSHED
         * @property {String} url The media url
         * @property {Object} opts The media opts
         * @property {Number} pos The suspended position
         * @property {ax/device/Media#State} state The state just before suspension
         * @property {ax/device/interface/Player} player The corresponding player
         * @memberof xdk-base/device/Media#
         */
        EVT_PUSHED: "media:pushed",
        /**
         * Event: playback state popped from stack
         *
         * @event EVT_POPPED
         * @property {String} url The media url
         * @property {Object} opts The media opts
         * @property {Number} pos The suspended position
         * @property {ax/device/Media#State} state The state just before suspension
         * @property {ax/device/interface/Player} player The corresponding player
         * @memberof xdk-base/device/Media#
         */
        EVT_POPPED: "media:popped",
        /**
         * Playback state
         * @private
         * @memberof xdk-base/device/Media#
         */
        __state: 0,
        /**
         * Previous playback state
         * @private
         * @memberof xdk-base/device/Media#
         */
        __prevState: 0,
        /**
         * last received non skip state
         * It will store the latest non skip state which will be restored to after skipping
         * @private
         * @memberof xdk-base/device/Media#
         */
        __lastReceivedNonSkipState: 0,
        /**
         * A flag to indicate whether the media is currently under an "error state".
         * This is introduced because "error state" is not one of the valid state in the lifecycle,
         * but in certain scenario we need to know whether error is appearing.
         * @private
         * @memberof xdk-base/device/Media#
         */
        __hasError: false,
        /**
         * The player implementation
         * @private
         * @memberof xdk-base/device/Media#
         */
        __player: null,
        /**
         * The media URL
         * @private
         * @memberof xdk-base/device/Media#
         */
        __url: "",
        /**
         * The media options
         * @private
         * @memberof xdk-base/device/Media#
         */
        __opts: null,
        /**
         * The media type format
         * @private
         * @memberof xdk-base/device/Media#
         */
        __type: null,
        /**
         * The DRM being used
         * @private
         * @memberof xdk-base/device/Media#
         */
        __drm: null,
        /**
         * The parent Node which store the media
         * @private
         * @memberof xdk-base/device/Media#
         */
        __parentNode: null,
        /**
         * Progressive skip delay handle
         * @private
         * @memberof xdk-base/device/Media#
         */
        __skipDelayHandle: null,
        /**
         * Progressive skip accumulated arrival time
         * @private
         * @memberof xdk-base/device/Media#
         */
        __accumulatedArrivalTime: null,
        /**
         * Progressive skip accumulated skip step
         * @private
         * @memberof xdk-base/device/Media#
         */
        __accumulatedStep: null,
        /**
         * The time returned from on time update event.
         * @private
         * @memberof xdk-base/device/Media#
         */
        __updatedTime: null,
        /**
         * The current Multi Audio Track Strategy linking to the player
         * @private
         * @memberof xdk-base/device/Media#
         */
        __multiAudioStgy: null,

        /**
         * The suspended playback stack. Works with the Suspendable interface.
         * @private
         * @memberof xdk-base/device/Media#
         */
        __playbackStack: [],

        /**
         * A flag to indicate if push() is happening
         * @private
         * @memberof xdk-base/device/Media#
         */
        __pushing: false,

        /**
         * A flag to indicate if pop() is happening
         * @private
         * @memberof xdk-base/device/Media#
         */
        __popping: false,

        /**
         * A event dispatcher used internally to notify the playback state change
         * @private
         * @memberof xdk-base/device/Media#
         */
        __stateMachine: null,

        /**
         * An object holding all un-disposed preloaded playback
         * @private
         * @memberof xdk-base/device/Media#
         */
        __preloaded: {},

        /**
         * The list of working players in the background.
         * @private
         * @memberof xdk-base/device/Media#
         */
        __backgroundPlayerList: [],

        /**
         * The subtitle module instance
         * @private
         * @memberof xdk-base/device/Media#
         */
        __subtitleModule: null,

        /**
         * The saved strategies for the preloadable
         * @private
         * @memberof xdk-base/device/Media#
         */
        __savedStrategies: {},

        /**
         * The saved strategies for the suspendable
         * @private
         * @memberof xdk-base/device/Media#
         */
        __suspendedStrategies: [],
        /**
         * Initializes this module
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        init: function () {
            this._super();
            this.__stateMachine = new EvtDisp();
        },
        /**
         * De-initializes this module
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        deinit: function () {
            if (this.__player) {
                this.__player.reset();
            }
            this.__resetStgies();
            // as url is an identifier for reload or not (see this.load), therefore reset
            this.__url = "";
            this.__opts = null;
            this._super();
        },
        /**
         * De-initializes this module
         * @method
         * @protected
         * @param {String} url the URL address of the media
         * @return {String} ext extension of the media
         * @memberof xdk-base/device/Media#
         */
        _extractMediaContainer: function (url) {
            if (/.mp4\?|\.mp4$/i.test(url)) {
                return "mp4";
            }

            if (/.wmv\?|\.wmv$|.wma\?|\.wma$|.asf\?|\.asf$/i.test(url)) {
                return "asf";
            }

            if (/.m3u8\?|\.m3u8$/i.test(url)) {
                return "hls";
            }

            if (/.mp3\?|\.mp3$/i.test(url)) {
                return "mp3";
            }

            return "*";
        },
        /**
         * Loads the specified media. The following are general options for setting the video. Some players may have special setting like bitrate.
         * Please refer to the specific player and read the properties.
         * @method
         * @param {String} url the URL address of the media
         * @param {Object} [opts] the options for loading this media
         * @param {String} [opts.type] the media type format like "mp4","hls"
         * @param {String} [opts.drm] DRM to be used e.g "playready", "wmdrm", "widevine", "verimatrix"
         * @param {Object} [opts.player] the player to play the media
         * @param {String} [opts.drmUrl] (Widevine || Playready || Verimatrix || WMDRM) Set the DRM license url
         * @param {String} [opts.serviceProvider] (Verimatrix) Set the Verimatrix DRM Service provider Name
         * @param {String} [opts.iptvServerIp] (Verimatrix) Set the Verimatrix DRM IPTV Client server IP address
         * @param {String} [opts.webServerIp] (Verimatrix) Set the Verimatrix DRM  WebClient server IP address 
         * @param {String} [opts.customData] (Playready) Set the Playready DRM Custome Data if the platform is supported
         * @param {String} [opts.portal] (Widevine) Set the portal
         * @param {String} [opts.userData] (Widevine) Set the user data
         * @param {String} [opts.deviceId] (Widevine) Set the device id
         * @param {String} [opts.deviceType] (Widevine) Set the device type
         * @param {String} [opts.authCookiesUrl] (WMDRM) Set the url to get the authentication cookies (e.g LG and Samsung)
         * @param {String} [opts.cadUrl] (WMDRM) Set the cad url to generate the xml, then player will get the authentication (e.g Philips)
         * @param {String} [opts.swfUrl] (Flash) set the flash swf url
         * @param {String} [opts.streamName] (Flash) the streamName
         * @param {Boolean} [opts.liveStreaming] (Flash) to  indicate if it is liveStreaming. If it is live streaming, no time update
         * @param {Boolean} [opts.use3d] true if to use 3D
         * @param {String} [opts.type3d] the type of 3D
         * @param {Boolean} [opts.forceReload] to forceLoad even if the url is the same
         * @param {String} [opts.startBitrate] (HLS || HAS) To set the initial bitrate e.g 2600000
         * @param {Number} [opts.bitratesFrom] (HLS || HAS) the lowest bitrate setting
         * @param {Number} [opts.bitratesTo] (HLS || HAS) the highest bitrate setting
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} The specified player cannot play the specified media
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} None of the registered player can play the specified media
         * @memberof xdk-base/device/Media#
         */
        load: function (url, opts) {
            if (this.__popping) {
                return;
            }

            this._doLoad(url, opts);
        },

        _doLoad: function (url, opts) {
            var player,
                prepareStgies = util.bind(function () {
                    this.__resetStgies();

                    //prepare again for strategies
                    this.__multiAudioStgy = this.__prepareAudioTrack(this.__player);
                    this.__subtitleModule = this.__prepareSubtitle(this.__player, opts);
                }, this);

            opts = opts || {};
            opts.type = opts.type || this._extractMediaContainer(url);
            opts.drm = opts.drm || undefined;


            // get the appropriate player based on the type & drm requirements
            try {
                player = this.__getPlayer(opts);
            } catch (ex) {
                this._onError(PLAYBACK_ERRORS.RENDER.UNSUPPORTED, "Exception caught when trying to load the media with type = " + opts.type + ", drm = " + opts.drm + ":\n" + ex.message);
                if (this.__player) {
                    // only reset the player if no background job is being done
                    if (this.__backgroundPlayerList.indexOf(this.__player) < 0) {
                        this.__player.reset();
                    }
                    this.__player = null;
                }

                throw ex;
            }

            // no need to load again if it is already loaded.
            // unless 1) the application force it, or 2) there is an error in previous trial
            if (this.__url === url && player === this.__player && !(opts.forceReload || this.__hasError)) {
                prepareStgies();
                return;
            }

            // reset the error flag for a fresh load
            this.__hasError = false;

            // set after url and player are confirmed to be different
            this.__url = url;

            // swap the player
            if (this.__player !== player) {

                // only reset the player if no background job is being done
                if (this.__player && this.__backgroundPlayerList.indexOf(this.__player) < 0) {
                    this.__player.reset();
                }

                this.__player = player;
            }

            this.__player.prepare(opts);
            prepareStgies();

            this.__type = opts.type;
            this.__drm = opts.drm;
            this.__url = url;
            this.__opts = opts;

            this.__player.load(url, opts);

        },

        /**
         * To prepare the subtitle strategy.
         * @method __prepareSubtitle
         * @param {xdk-base/device/interface/Player} player the player
         * @param {Object} opts the load options
         * @param {xdk-base/device/interface/Preloaded.PreloadedPlayback} [preloaded] item from the player, it is just for preload to get information for the current preloadable item
         * @returns {ax/device/Subtitle} the subtitle instance
         * @private
         * @memberof xdk-base/device/Media#
         */
        __prepareSubtitle: function (player, opts, preloaded) {
            var playerId, subtitleObj, subtitleList, mSubtitle;

            playerId = player.getId();

            subtitleList = config.get("device.subtitleStgy", null);

            if (!subtitleList) {
                // no subtitle list and no need to prepare the subtitle
                return null;
            }

            subtitleObj = subtitleList[playerId];

            //do nothing when no subtitle setting and subtitle object for internal or external
            if (!subtitleObj || !(subtitleObj.internal || subtitleObj.external)) {
                return null;
            }

            try {
                mSubtitle = new MediaSubtitle(subtitleObj, player, preloaded);
                mSubtitle.prepare(opts.subtitle);
                console.info("[XDK] create the subtitle");
            } catch (e) {
                console.warn("[XDK] Fail to prepare subtitle");
            }

            return mSubtitle;
        },
        /**
         * To prepare the audio track strategy.
         * @param {xdk-base/device/interface/Player} the player
         * @param {xdk-base/device/interface/Preloadable} [preloaded] item from the player, it is just for preload to get information for the current preloadable item
         * @returns {ax/device/interface/MultipleAudioTrackStgy} the multiple audio track strategy
         * @method
         * @private
         * @memberof xdk-base/device/Media#
         */
        __prepareAudioTrack: function (player, preloaded) {
            var playerId, multiAudioTrackList, multiAudioTrackId, MultiAudioTrackStgy, mMultiAudioStgy;

            //after getting player, find the relative multi audio track
            playerId = player.getId();

            multiAudioTrackList = config.get("device.multiAudioTrackStgy", null);

            if (!multiAudioTrackList) {
                // no multiple audio track
                return null;
            }
            multiAudioTrackId = multiAudioTrackList[playerId];

            //do nothing when there is no multi audio stgy for the player
            if (!multiAudioTrackList || !multiAudioTrackId) {
                return null;
            }

            console.info("[XDK] Multi Audio Track exist " + multiAudioTrackId);
            //get back the strategy
            MultiAudioTrackStgy = require(multiAudioTrackId);

            //link the multi track and pass the playerInstance to the multiAudioTrack strategy since it may need the information about the player in the strategy.
            try {
                mMultiAudioStgy = new MultiAudioTrackStgy(player);
                console.info("[XDK] Linked the player and multi audio track");
            } catch (e) {
                console.warn("[XDK] Fail to load the audio track : " + multiAudioTrackId + " : " + e.name);
            }

            return mMultiAudioStgy;
        },
        /**
         * Start the media playback. Play function will be blocked when the state is buffering, skipping or connecting.
         * @method
         * @param {Object} [opts] the options for starting playback
         * @param {Number} [opts.sec] the playback start time
         * @memberof xdk-base/device/Media#
         */
        play: function (opts) {
            if (this.__popping) {
                return;
            }

            this._doPlay(opts);
        },

        _doPlay: function (opts) {
            if (this.isState(this.SKIPPING) || this.isState(this.BUFFERING) || this.isState(this.CONNECTING)) {
                return;
            }
            if (!this.__player) {
                console.warn("Player is not ready, please call load() first to load up a player implementation.");
                return;
            }

            //if it is number then convert into the object
            if (util.isNumber(opts)) {
                opts = {
                    sec: opts
                };
            } else if (!opts) {
                opts = {};
            }

            this.__player.play(opts);
        },

        /**
         * Stop the media playback
         * @method
         * @memberof xdk-base/device/Media#
         */
        stop: function () {
            if (this.isState(this.STOPPED) || this.__popping) {
                return;
            }

            this._clearSkipDelayData();

            if (this.__player) {
                this.__player.stop();
            }
        },
        /**
         * Pause the media playback
         * @method
         * @memberof xdk-base/device/Media#
         */
        pause: function () {
            if (this.__popping) {
                return;
            }

            this._doPause();
        },

        _doPause: function () {
            if (!this.isState(this.PLAYING) && !this.isState(this.SPEEDING)) {
                return;
            }
            this.__player.pause();
        },

        /**
         * Resume the media playback
         * @method
         * @memberof xdk-base/device/Media#
         */
        resume: function () {
            if (!this.isState(this.PAUSED) || this.__popping) {
                return;
            }
            this.__player.resume();
        },
        /**
         * During media playback, seek to certain position
         * @method
         * @param {Number} sec the position to seek to in seconds
         * @memberof xdk-base/device/Media#
         */
        seek: function (sec) {
            if (this.isState(this.STOPPED) || this.__popping) {
                return;
            }
            if (this.isState(this.SKIPPING)) {
                this._clearSkipDelayData();
                this._changeState(this.__prevState);
            }
            //XDK-1475 To limit the seek time interval. Only between 0 and its duration is allowed.
            if (sec > this.getDuration()) {
                console.info("[Media] Seek time " + sec + " is larger than the duration " + this.getDuration() + ", now it will seek the duration time");
                sec = this.getDuration();
            } else if (sec < 0) {
                console.info("[Media] Seek time " + sec + " is smaller than 0 " + this.getDuration() + ", now it will seek 0s");
                sec = 0;
            }
            this.__player.seek(sec);
        },
        /**
         * Clears the progressive skip timeout and the data related to progressive skipping.
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _clearSkipDelayData: function () {
            this._clearSkipDelay();
            this.__accumulatedArrivalTime = null;
            this.__accumulatedStep = null;
        },
        /**
         * Clears the timeout of progressive skipping.
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _clearSkipDelay: function () {
            if (this.__skipDelayHandle) {
                util.clearDelay(this.__skipDelayHandle);
                this.__skipDelayHandle = null;
            }
        },
        /**
         * Skip the playback forward/backward for certain seconds.
         * There are 2 kinds of skip operation: simple and progressive.
         * For the simple skip, the operation will be carried out whenever the command is called.
         * For the progressive skip, it will be carried after a short delay. Any further progressive skips within this delay will be carried at once.
         * 
         * Please note that any simple skip comes during the progressive skip delay will be ignored.
         *
         * @method
         * @param {Object} param parameter for the skipping
         * @param {Number} param.sec number of seconds to skip (10 by default)
         * @param {Boolean} [param.progressive] whether it is progressive skipping or not
         * @param {Number} [param.multipleFactor] for progressive, multiple of increase in jump distance for each skip
         * @param {Number} [param.delaySec] for progressive, seconds of delay before the skip is fired
         * @param {Number} [param.progressiveCap] for progressive, maximum amount of second in each increase
         * @memberof xdk-base/device/Media#
         */
        skip: function (param) {
            if (this.__state === this.STOPPED || this.__popping) {
                return;
            }

            if (util.isNumber(param)) {
                param = {
                    sec: param
                };
            }
            param = param || {};
            param.sec = param.sec || 10;

            // for progressive, multiple of increase in jump distance for each detection
            var multipleFactor = param.multipleFactor || 1;
            // for progressive, seconds of delay before the skip is fired
            var delaySec = param.delaySec || 2;
            // for progressive, maximum amount of second in each increase
            var progressiveCap = param.progressiveCap || 300;
            // the target resulting time after skip
            var targetTime;
            // the actual skip action
            var __doSkip;

            if (!param.progressive || this.__player._noProgressive) {
                // issuing immediate skip during progressive will mess the state up
                if (this.__accumulatedArrivalTime) {
                    console.warn("Simple skip is forbidden during progressive skip. Abort the skip operation.");
                    return;
                }

                targetTime = this.getCurTime() + param.sec;
                if (targetTime > this.getDuration()) {
                    targetTime = this.getDuration();
                } else if (targetTime < 0) {
                    targetTime = 0;
                }
                this._clearSkipDelayData();
                this.__player.skip(targetTime - this.getCurTime());
                return;
            }

            this._onSkipping();

            if (multipleFactor < 1) {
                multipleFactor = 1; //couldn't be smaller and smaller, right?
            }

            // make sure arrival time is set
            if (!util.isNumber(this.__accumulatedArrivalTime)) {
                this.__accumulatedArrivalTime = this.getCurTime(true);
            }
            // get the skip step ready
            if (!this.__accumulatedStep || this.__accumulatedStep * param.sec < 0) {
                this.__accumulatedStep = param.sec;
            } else {
                this.__accumulatedStep = Math.round(this.__accumulatedStep * multipleFactor);
            }
            // cap the skip step
            if (this.__accumulatedStep > progressiveCap) {
                this.__accumulatedStep = progressiveCap;
            } else if (this.__accumulatedStep < -progressiveCap) {
                this.__accumulatedStep = -progressiveCap;
            }

            // if requesting a huge skip, forget about the progressive step
            if (param.sec >= progressiveCap || param.sec <= -progressiveCap) {
                this.__accumulatedArrivalTime += param.sec;
            } else { // skip a step
                this.__accumulatedArrivalTime += this.__accumulatedStep;
            }
            targetTime = this.__accumulatedArrivalTime;

            // do not go out of boundary
            if (targetTime > this.getDuration()) {
                targetTime = this.getDuration();
            } else if (targetTime < 0) {
                targetTime = 0;
            }

            __doSkip = util.bind(function () {
                this.__player.skip(targetTime - this.__player.getCurTime());
                this._clearSkipDelayData();
                this._changeState(this.__lastReceivedNonSkipState);
                console.info("[XDK] delayed skip action committed.");
            }, this);

            this._clearSkipDelay();
            this.__skipDelayHandle = core.getGuid();
            util.delay(delaySec, this.__skipDelayHandle).then(__doSkip);
            this._onTimeUpdate(targetTime, true);
        },
        /**
         * Speed up/down the media playback
         * @method
         * @param {Number} speed the playback speed to set
         * @memberof xdk-base/device/Media#
         */
        speed: function (speed) {
            if (!this.isState(this.PLAYING) && !this.isState(this.SPEEDING) && !this.isState(this.PAUSED) || this.__popping) {
                return;
            }
            this.__player.speed(speed);
        },
        /**
         * Get the media playback speed
         * @method
         * @return {Number} the playback speed
         * @memberof xdk-base/device/Media#
         */
        getPlaybackSpeed: function () {
            if (this.__state === this.STOPPED) {
                return 0;
            }
            if (this.__state === this.PLAYING) {
                return 0;
            }
            return this.__player.getPlaybackSpeed();
        },
        /**
         * Set the video window size.
         * @method
         * @param {Object} param window size parameter
         * @param {Integer} param.top window top
         * @param {Integer} param.left window left
         * @param {Integer} param.width window width
         * @param {Integer} param.height window height
         * @memberof xdk-base/device/Media#
         */
        setWindowSize: function (param) {
            if (!this.__player) {
                console.warn("Player is not ready, please call load() first to load up a player implementation.");
                return;
            }
            this.__player.setWindowSize(param);
        },
        /**
         * Set full screen
         * @method
         * @memberof xdk-base/device/Media#
         */
        setFullscreen: function () {
            if (!this.__player) {
                console.warn("Player is not ready, please call load() first to load up a player implementation.");
                return;
            }
            this.__player.setFullscreen();
        },
        /**
         * Get the media playback speed
         * @method
         * @return {ax/device/interface/Player~PlayerCapabilites} current playback bitrate
         * @memberof xdk-base/device/Media#
         */
        getBitrates: function () {
            if (this.__state === this.STOPPED) {
                return null;
            }
            return this.__player.getBitrates();
        },
        /**
         * Get the media playback state
         * @method
         * @return {Number} the current playback state
         * @memberof xdk-base/device/Media#
         */
        getState: function () {
            return this.__state;
        },
        /**
         * Check if the media playback state is the provided one
         * @method
         * @return {Boolean} true if the same
         * @memberof xdk-base/device/Media#
         */
        isState: function (state) {
            return state === this.__state;
        },
        /**
         * Get the current playback time
         * @method
         * @return {Number} the current playback time
         * @memberof xdk-base/device/Media#
         */
        getCurTime: function () {
            if (this.__state === this.STOPPED) {
                return 0;
            }
            return this.__player.getCurTime();
        },
        /**
         * Get the total playback time
         * @method
         * @return {Number} the total playback time
         * @memberof xdk-base/device/Media#
         */
        getDuration: function () {
            if (!this.__player) {
                console.warn("Player is not ready, please call load() first to load up a player implementation.");
                return 0;
            }
            return this.__player.getDuration();
        },

        /**
         * Suspends the current playback and puts the current playback states to the stack for later resumption.
         *
         * @method
         * @memberof xdk-base/device/Media#
         */
        push: function () {
            var suspendedPlayback;

            this.__pushing = true;
            this._clearSkipDelayData();

            var state = this.getState();
            var pState;

            switch (state) {
            case this.STOPPED:
                pState = PLAYBACK_STATE.STOPPED;
                break;
            case this.PAUSED:
                pState = PLAYBACK_STATE.PAUSED;
                break;
            default:
                pState = PLAYBACK_STATE.PLAYING;
                state = this.PLAYING;
                break;
            }

            var evtObject = {
                url: this.getUrl(),
                opts: this.getOpts(),
                pos: this.getCurTime(),
                state: state,
                player: this.__player
            };

            if (klass.hasImpl(this.__player.constructor, Suspendable)) {
                suspendedPlayback = this.__player.suspend();

                if (this.__backgroundPlayerList.indexOf(this.__player) === -1) {
                    this.__backgroundPlayerList.push(this.__player);
                }
            } else {
                suspendedPlayback = new FallbackSuspendedPlayback(this, this.__player, {
                    url: evtObject.url,
                    opts: evtObject.opts,
                    pos: evtObject.pos,
                    state: pState
                });

                this.__player.stop();
            }

            suspendedPlayback.__evtObject = evtObject;
            this.__playbackStack.push(suspendedPlayback);

            this.__suspendedStrategies.push({
                "audioTrack": this.__multiAudioStgy,
                "subtitleModule": this.__subtitleModule
            });

            // clear any states as if nothing happened
            this.__state = this.STOPPED;
            this.__url = undefined;
            this.__opts = undefined;
            this.__type = undefined;
            this.__drm = undefined;
            this.__player = undefined;

            this.__subtitleModule = undefined;
            this.__multiAudioStgy = undefined;

            this.__pushing = false;
            this.dispatchEvent(this.EVT_PUSHED, evtObject);
        },

        /**
         * Restores the playback to which at the peak of the suspended playback stack.
         * Will fire a {@link xdk-base/device/Media#EVT_POPPED} event upon finish.
         *
         * @method
         * @throws {exception.ILLEGAL_STATE} No previous suspended playback
         * @memberof xdk-base/device/Media#
         */
        pop: function () {
            var peak = this.__playbackStack.pop(),
                strategies = this.__suspendedStrategies.pop();

            if (!peak) {
                throw core.createException(exception.ILLEGAL_STATE, "There is no suspended playback state in the stack.");
            }

            this.__popping = true;

            if (this.__player) {
                this.__player.stop();
            }

            peak.restore(util.bind(function () {
                var media = peak.getMediaMeta();
                var evtObject = peak.__evtObject;

                this.__url = media.url;
                this.__opts = media.opts;
                this.__player = peak.getPlayer();
                this.__state = evtObject.state;

                this.__subtitleModule = strategies.subtitleModule;
                this.__multiAudioStgy = strategies.audioTrack;

                peak.dispose();

                this.__resetUnusedPlayers();

                this.__popping = false;

                this.dispatchEvent(this.EVT_POPPED, evtObject);
            }, this));
        },

        /**
         * Preload a media for lesser bufferring time.
         *
         * @method
         * @param {String} url The media url
         * @param {Object} [opts] The options for loading
         * @param {xdk-base/device/interface/Player} [opts.player] The target player to do preloading
         * @param {String} [opts.type] the media type format like "mp4","hls"
         * @param {String} [opts.drm] DRM to be used e.g "playready", "wmdrm", "widevine"
         * @param {String} [opts.drmUrl] (Widevine || Playready || Verimatrix || WMDRM) Set the DRM license url
         * @param {String} [opts.customData] (Playready) Set the Playready DRM Custome Data if the platform is supported
         * @param {String} [opts.portal] (Widevine) Set the portal
         * @param {String} [opts.userData] (Widevine) Set the user data
         * @param {String} [opts.deviceId] (Widevine) Set the device id
         * @param {String} [opts.deviceType] (Widevine) Set the device type
         * @param {String} [opts.authCookiesUrl] (WMDRM) Set the url to get the authentication cookies (e.g LG and Samsung)
         * @param {String} [opts.cadUrl] (WMDRM) Set the cad url to generate the xml, then player will get the authentication (e.g Philips)
         * @param {String} [opts.swfUrl] (Flash) set the flash swf url
         * @param {String} [opts.streamName] (Flash) the streamName
         * @param {Boolean} [opts.liveStreaming] (Flash) to indicate if it is liveStreaming. If it is live streaming, no time update
         * @param {Boolean} [opts.use3d] true if to use 3D
         * @param {String} [opts.type3d] the type of 3D
         * @returns {String} The token for identifying the preloaded playback for playing
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} The specified player cannot play the specified media
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} None of the registered player can play the specified media
         * @memberof xdk-base/device/Media#
         */
        preload: function (url, opts) {
            var preloaded;

            // clone the options
            opts = util.extend({}, opts || {}, true);
            opts.type = opts.type || this._extractMediaContainer(url);

            var player = this.__getPlayer(opts),
                token,
                strategies;

            if (klass.hasImpl(player.constructor, Preloadable)) {
                delete opts.player;

                player.prepare(opts);

                preloaded = player.preload(url, opts);

                if (this.__backgroundPlayerList.indexOf(player) === -1) {
                    this.__backgroundPlayerList.push(player);
                }
            } else {

                // player is not a Preloadable, provide fallback
                preloaded = new FallbackPreloadedPlayback(this, url, opts);

            }

            //prepare the strategies
            strategies = {
                "audioTrack": this.__prepareAudioTrack(player, preloaded),
                "subtitleModule": this.__prepareSubtitle(player, opts, preloaded)
            };

            token = this.__savePreloaded(preloaded);

            this.__savedStrategies[token] = strategies;

            return token;
        },

        /**
         * Play the preloaded media.
         *
         * @method
         * @param {String} token The token returned from {@link xdk-base/device/Media#preload}
         * @param {Number} pos The position where the playback should begin, counted in seconds
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} No associated preloaded playback
         * @memberof xdk-base/device/Media#
         */
        playPreloaded: function (token, pos) {
            this.stop();

            var preloaded = this.__getPreloadedByToken(token);

            var mediaMeta = preloaded.getMediaMeta();

            preloaded.play(pos);

            this.__url = mediaMeta.url;
            this.__opts = mediaMeta.opts;
            this.__player = preloaded.getPlayer();

            if (!this.__savedStrategies[token]) {
                this.__subtitleModule = null;
                this.__multiAudioStgy = null;
                return;
            }

            //since the subtitle and audiotrack prepare when play in the FallbackPreloaded, 
            //it will undergo another Media.load which will further call the player to prepare the object
            //it will then create another object and handle for the another subtitl creation.e
            //as a result, assign back the correct strategy for the token saved strategy from the current subtitle strategy and audio strategy

            //other case will directly use the saved strategy and mapped correctly due to no Media.load and player.prepare.
            if (preloaded instanceof FallbackPreloadedPlayback) {
                this.__savedStrategies[token].subtitleModule = this.__subtitleModule;
                this.__savedStrategies[token].audioTrack = this.__multiAudioStgy;
            } else {
                this.__subtitleModule = this.__savedStrategies[token].subtitleModule;
                this.__multiAudioStgy = this.__savedStrategies[token].audioTrack;
            }

        },
        /**
         * Dispose a preloaded object. A disposed preloaded object cannot be use any more.
         *
         * @method
         * @param {String} token The token returned from {@link xdk-base/device/Media#preload}
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} No associated preloaded playback
         * @memberof xdk-base/device/Media#
         */
        disposePreloaded: function (token) {
            var preloaded = this.__getPreloadedByToken(token);

            preloaded.dispose();

            this.__savedStrategies[token] = null;

            this.__deletePreloadedByToken(token);

            this.__resetUnusedPlayers();
        },

        /**
         * Returns the preloaded playback associated with the token.
         *
         * @method
         * @private
         * @param {String} token The token of the preloaded playback
         * @returns {ax/device/interface/Preloadable.Preloaded} The associated preloaded playback
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} No associated preloaded playback
         * @memberof xdk-base/device/Media#
         */
        __getPreloadedByToken: function (token) {
            var preloaded = this.__preloaded[token];

            if (!preloaded) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "No associated preloaded playback.");
            }

            return preloaded;
        },

        /**
         * Saves the preloaded playback, returns a token for later retrieval.
         * Developer should not save any object twice!
         *
         * @method
         * @private
         * @param {xdk-base/device/interface/Preloadable.Preloaded} preloaded The preloaded playback
         * @returns {String} The token associated to the preloaded playback
         * @memberof xdk-base/device/Media#
         */
        __savePreloaded: function (preloaded) {
            var token = core.getGuid() + "";
            this.__preloaded[token] = preloaded;

            return token;
        },

        /**
         * Deletes the preloaded playback associated with the token.
         * No exception will be thrown if no preloaded playback is associating because it should be deleted anyway.
         *
         * @method
         * @private
         * @param {String} token The token of the preloaded playback
         * @memberof xdk-base/device/Media#
         */
        __deletePreloadedByToken: function (token) {
            this.__preloaded[token] = null;
        },

        /**
         * Gets the appropricate player instance. Capabilities are ensured in this method.
         * If player is specified, the requirements are checked against the player.
         * If non is specified, the player will be retrieved from the player registry.
         * For convenience, the _opts_ argument from _load()_ could be used directly.
         *
         * @method
         * @private
         * @param {Object} opts The capabilities requirements
         * @param {String} [opts.type] The media type
         * @param {String} [opts.drm] The media drm
         * @param {xdk-base/device/interface/Player} [opts.player] The player object to check against
         * @returns {ax/device/interface/Player} The player object that fulfills all requirements
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} The player does not fulfill the requirements
         * @throws {module:xdk-base/exception.ILLEGAL_ARGUMENT} No registered player can fulfill the requirements
         * @memberof xdk-base/device/Media#
         */
        __getPlayer: function (opts) {
            var player;

            if (opts.player) {
                player = opts.player;

                if (!this.__checkCapabilities(player, opts)) {
                    throw core.createException(exception.ILLEGAL_ARGUMENT,
                        "The specified player is not capable to play the media.");
                }

                return player;
            }

            player = registry.getPlayer(opts);

            if (!player) {
                throw core.createException(exception.ILLEGAL_ARGUMENT,
                    "None of the registered player can play this type of media.");
            }

            return player;
        },

        /**
         * Checks if the player could play the specific media type and drm.
         *
         * @method
         * @private
         * @param {xdk-base/device/interface/Player} player The player to check against
         * @param {Object} opts The load options
         * @returns {Boolean} True if the player could play the media, false otherwise
         * @memberof xdk-base/device/Media#
         */
        __checkCapabilities: function (player, opts) {
            var capabilities = player.getCapabilities();

            var type = opts.type;
            var drm = opts.drm;

            var typePass = !(type && capabilities.type.indexOf(type) === -1) || type === "*";
            var drmPass = !(drm && capabilities.drms.indexOf(drm) === -1);

            return typePass && drmPass;
        },

        /**
         * Resets the unused players that are sitting in background.
         *
         * @method
         * @private
         * @memberof xdk-base/device/Media#
         */
        __resetUnusedPlayers: function () {
            for (var i = this.__backgroundPlayerList.length - 1; i >= 0; i--) {
                var player = this.__backgroundPlayerList[i];

                // if no preloaded and suspended playback associated with the player, then the player has nothing doing in background
                if ((!klass.hasImpl(player.constructor, Preloadable) || player.getPreloadedCount() === 0) &&
                    (!klass.hasImpl(player.constructor, Suspendable) || player.getSuspendedCount() === 0)) {
                    this.__backgroundPlayerList.splice(i, 1);

                    // but only reset the player if it is not in foreground
                    if (player !== this.__player) {
                        player.reset();
                    }
                }
            }
        },

        /**
         * Should be calld when player updates current time
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onTimeUpdate: function (time, isSkip) {
            if (this.isState(this.SKIPPING) && !isSkip) {
                return; // currently skipping, should not update time
            }
            this.__updatedTime = time;
            this.dispatchEvent(this.EVT_TIME_UPDATE, time);
        },
        /**
         * Should be calld when player starts connecting
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onConnecting: function () {
            this._changeState(this.CONNECTING);
        },
        /**
         * Should be calld when player starts playing
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onPlaying: function () {
            this._changeState(this.PLAYING);
        },
        /**
         * Should be calld when player paused
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onPause: function () {
            this._changeState(this.PAUSED);

        },
        /**
         * Should be calld when playback stopped
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onStopped: function () {
            this._changeState(this.STOPPED);
        },
        /**
         * Should be calld when progressive skipping has started, but skip action has not actually taken
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onSkipping: function () {
            this._changeState(this.SKIPPING);
        },
        /**
         * Should be calld when speeding has started
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onSpeeding: function () {
            this._changeState(this.SPEEDING);
        },
        /**
         * Should be calld when buffering starts
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onBufferingStart: function () {
            this._changeState(this.BUFFERING);
        },
        /**
         * Should be calld when buffering is progressing
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onBufferingProgress: function (data) {
            this.dispatchEvent(this.EVT_BUFFERING_PROGRESS, data);
        },
        /**
         * Should be calld when buffering has finished
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onBufferingFinish: function () {
            if (this.isState(this.STOPPED)) {
                return;
            }

            //when skipping, the state turned into buffering complete, the previous state should be playing.
            //so after skipping, it should back to play state instead of buffering.

            //if previous state of buffering is connecting, it will change into play instead of.
            if (this.__prevState === this.CONNECTING || this.__prevState === this.BUFFERING) {
                this._changeState(this.PLAYING);
                return;
            }

            console.debug("change back to prev state" + this.__prevState);
            this._changeState(this.__prevState);
        },
        /**
         * Should be calld when playback has finished
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onFinish: function () {
            this._changeState(this.STOPPED);
            this.dispatchEvent(this.EVT_FINISHED);
        },
        /**
         * Should be calld when playback encountered error
         * @method
         * @protected
         * @param {String} errorCode the error code
         * @param {String} errorMessage the error message
         * @memberof xdk-base/device/Media#
         */
        _onError: function (errorType, errorData, originalData) {

            this.__hasError = true;

            if (this.__popping) {
                this.__popping = false;
            }

            this._changeState(this.STOPPED);

            var code, msg, type;

            var error = {
                errorType: "",
                errorMessage: "",
                errorCode: 0,
                errorData: null
            };

            if (util.isObject(errorType)) {
                //if errorType is an object, pre process the error object properties
                code = errorType.code;
                msg = errorType.desc;
                type = errorType.evt;
                //set the internal accedo errorCode as it's available
                error.errorCode = code;
            } else {
                //if string
                type = errorType;
            }

            if (util.isObject(errorData)) {
                //override the message, by the native error message spefified.
                msg = errorData.msg || errorType.desc;
            } else if (util.isString(errorData)) {
                msg = errorData;
            }

            error.errorType = type;
            error.errorMessage = msg;

            if (originalData) {
                error.errorData = originalData;
            }

            this.dispatchEvent(this.EVT_ERROR, error);

        },
        /**
         * Internal function to change playback state
         * @protected
         * @param {String} state internal state to be changed
         * @param {*} data data to be dispatched along with the event
         * @method
         * @memberof xdk-base/device/Media#
         */
        _changeState: function (state, data) {
            if (this.__state === state) {
                console.debug("[XDK] Change State Fail as in the same state " + state);
                return;
            }

            //XDK-2039 Handling for the state change when skipping, store the last received non skip state which will be restored after skip
            if (state !== this.SKIPPING) {
                this.__lastReceivedNonSkipState = state;
            }

            //ignore any state change when performing progressive skip
            if (this.__skipDelayHandle !== null) {
                return;
            }

            this.__prevState = this.__state;
            this.__state = state;

            var evtObject = util.extend({
                fromState: this.__prevState,
                toState: this.__state
            }, data || {});

            //check the popping status before dispatching the media event.
            if (this._shouldSkipOutgoingStateChangeEvent()) {
                this.__stateMachine.dispatchEvent(this.EVT_STATE_CHANGED, evtObject);
                return;
            }

            this.dispatchEvent(this.EVT_STATE_CHANGED, evtObject);
        },

        /**
         * Returns a boolean value indicating if the state change should be ignored.
         * Ignoring the state change will also prevent the state change event from dispatch.
         *
         * @method
         * @protected
         * @returns {Boolean} True if state change should be ignored, false otherwise
         * @memberof xdk-base/device/Media#
         */
        _shouldSkipOutgoingStateChangeEvent: function () {
            return this.__pushing || this.__popping;
        },

        /**
         * To get the audio Tracks from the media
         * @method
         * @public
         * @returns {Promise.<String[]>} id The id of the track which is mainly for switching the audio track via setAudioTrack
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} unsupported feature
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} wrong formated parameter.
         * @memberof xdk-base/device/Media#
         */
        getAudioTracks: function () {
            if (!this.__multiAudioStgy) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "MultiAudioTracks strategy hasn't set yet"));
            }

            return this.__multiAudioStgy.getAudioTracks();
        },
        /**
         * To get the audio Tracks from the media
         * @method
         * @public
         * @param {String} id The id of the audio track
         * @returns {Promise.<Boolean>} Return the result after call in a promise
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} missing or invalid parameter.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} unsupported
         * @memberof xdk-base/device/Media#
         */
        setAudioTrack: function (id) {
            if (!this.__multiAudioStgy) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "MultiAudioTracks strategy hasn't set yet"));
            }

            if (!(util.isString(id))) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Argument type is not valid"));
            }

            return this.__multiAudioStgy.setAudioTrack(id);
        },
        /* Get audio track attribute
         * @method getAudioTrackAttr
         * @public
         * @param {String} id The id of the audio track
         * @param {String} attr The attribute name such as {@link xdk-base/device/interface/MultipleAudioTrackStgy#LANGCODE}
         * @param {String} defaultValue The default value of the attribute
         * @returns {Promise.<String>} return the retrieved value or default value if unable to find on the device and given that default value
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} no correct id
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof xdk-base/device/Media#
         */
        getAudioTrackAttr: function (id, attr, defaultValue) {
            if (!this.__multiAudioStgy) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "MultiAudioTracks strategy hasn't set yet"));
            }

            if (!util.isString(id) || !util.isString(attr) || !util.isString(defaultValue)) {
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Argument type is not valid or missing"));
            }

            return this.__multiAudioStgy.getAudioTrackAttr(id, attr, defaultValue);
        },
        /* Get current audio track id
         * @method getCurrentAudioTrackId
         * @public
         * @returns {Promise.<String|null>} The id of the audio track. Some audio track is unable to obtain the current track id, it will return null.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof xdk-base/device/Media#
         */
        getCurrentAudioTrackId: function () {
            if (!this.__multiAudioStgy) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "MultiAudioTracks strategy hasn't set yet"));
            }
            return this.__multiAudioStgy.getCurrentAudioTrackId();
        },
        /* Get current media url
         * @method getUrl
         * @public
         * @returns {String} the url of the current media
         * @memberof xdk-base/device/Media#
         */
        getUrl: function () {
            return this.__url;
        },
        /* Get current media options
         * @method getOpts
         * @public
         * @returns {Object} The option object set when load the url
         * @memberof xdk-base/device/Media#
         */
        getOpts: function () {
            return this.__opts;
        },
        /* Show the target subtitle
         * @method showSubtitle
         * @param {String} id the id of subtitle
         * @returns {Promise.<Boolean>} True when showing the subtitle successfully.
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} when no subtitle exist.
         * @memberof xdk-base/device/Media#
         * @public
         */
        showSubtitle: function (id) {
            if (!this.__subtitleModule) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, "No available subtitle strategy"));
            }

            return this.__subtitleModule.showSubtitle(id);
        },
        /* Hide the subtitle
         * @method hideSubtitle
         * @returns {Promise.<Boolean>} True when showing the subtitle successfully.
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} when no subtitle exist.
         * @memberof xdk-base/device/Media#
         * @public
         */
        hideSubtitle: function () {
            if (!this.__subtitleModule) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, "No available subtitle strategy"));
            }
            return this.__subtitleModule.hideSubtitle();
        },
        /* Get current subtitle
         * @method getCurrentSubtitle
         * @returns {Promise.<Object>} The current subtitle object
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} when no subtitle exist.
         * @memberof xdk-base/device/Media#
         * @public
         */
        getCurrentSubtitle: function () {
            if (!this.__subtitleModule) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, "No available subtitle strategy"));
            }
            return this.__subtitleModule.getCurrentSubtitle();
        },
        /* Get the available subtitles
         * @method getSubtitles
         * @returns {Promise.<Object[]>} The available subtitles
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} when no subtitle exist.
         * @memberof xdk-base/device/Media#
         * @public
         */
        getSubtitles: function () {
            if (!this.__subtitleModule) {
                return promise.reject(core.createException(exception.ILLEGAL_STATE, "No available subtitle strategy"));
            }
            return this.__subtitleModule.getSubtitles();
        },
        /* Reset the current linked strategies
         * @method __resetStgies
         * @memberof xdk-base/device/Media#
         * @private
         */
        __resetStgies: function () {
            if (this.__multiAudioStgy && this.__multiAudioStgy.deinit) {
                this.__multiAudioStgy.deinit();
            }

            if (this.__subtitleModule && this.__subtitleModule.deinit) {
                this.__subtitleModule.deinit();
            }

            this.__subtitleModule = null;
            this.__multiAudioStgy = null;
        }
    });

    // enforce the instance creation before returning, preventing 2 instances being created
    // (2 executions may go into the creation at the same time...)
    Media.singleton();

    return Media;
});
/**
 * VideoManager is the center and entry point of the video playback service.
 * VideoManager fires events to other components for a complete playback experience.
 *
 * @class tve/videoPlaybackService/VideoManager
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#SetControlsInPlayState
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#SetControlsInPauseState
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#UpdatePlayheadState
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#UpdateVolumeState
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#DismissControls
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#NextPlaylistItem
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#PreviousPlaylistItem
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#NotifyError
 * @fires module:tve/videoPlaybackService/evt/VideoPlaybackControlsEvent#SuspendUI
 */
define("tve/videoPlaybackService/VideoManager", [
        "xdk-base/class", "xdk-base/util", "xdk-ax/mediator", "./evt/VideoPlaybackControlsEvent",
        "./model/Playlist", "tve/TVEError", "./evt/VideoControlsStatusEvent",
        "xdk-base/console", "./model/PlaylistItem",
        "xdk-base/device/Media", "./evt/VideoPlaybackStatusEvent"
    ],
    function (klass, util, mediator, VideoPlaybackControlsEvent,
        Playlist, TVEError, VideoControlsStatusEvent,
        console, PlaylistItem,
        Media, VideoPlaybackStatusEvent) {

        var sMedia = Media.singleton();
                    /**
             * _videoLoadedCallback is called when the video position moves from starting position.
             * @type {function}
             */
        var _videoLoadedCallback = null;



        return klass.create({
            /**
             * Enumeration of status
             * @typedef {Object} STATUS
             * @property {STATUS} PLAYING playing status
             * @property {STATUS} PAUSED paused status
             * @property {STATUS} STOPPED stopped status
             * @property {STATUS} BUFFERING buffering status
             * @memberOf tve/videoPlaybackService/VideoManager
             */
            STATUS: {
                PLAYING: "PLAYING",
                PAUSED: "PAUSED",
                STOPPED: "STOPPED",
                BUFFERING: "BUFFERING"
            }
        }, {

            /**
             * The current playlist
             * @property {Playlist}
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playlist: null,

            /**
             * The current playing playlist item.
             * @property {PlaylistItem}
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _currentItem: null,

            /**
             * The current playback state
             * @property {STATUS}
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _currentPlaybackState: null,

            /**
             * The current playback time, in seconds
             * @property {Number}
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _currentPlaybackTime: 0,

            /**
             * The duration of the current playback item, in seconds
             * @property {Number}
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playbackDuration: 0,


            _currentAudioTrack: 0,
            /**
             * Constructor of the class.
             * Register to the playback events.
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            init: function () {
                this._registerPlaybackEventHandlers();
                this._registerPlaybackControlsStatusEventHandlers();
            },

            /**
             * Set the playlist for playback.
             * @method
             * @param {Playlist} playlist The playlist
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            setPlaylist: function (playlist) {
                this._playlist = playlist;
                this._playlist.currentItemIdx = -1;
            },

            /**
             * Clear the playlist.
             * @method
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            clearPlaylist: function () {
                if (!this._playlist) {
                    return;
                }

                this._playlist.items = [];
                this._playlist.currentItemIdx = -1;
            },
            /**
             * setVideoLoadedCallback
             * @param {function} func [description]
             */
            setVideoLoadedCallback: function(func){
                _videoLoadedCallback = func;
            },
            /**
             * Play the item in the playlist.
             * @method
             * @param {PlaylistItem} playlistItem The playlist item to play
             * @param {Number} [pos] The position that the playback should start, count in s
             * @throws {TVEError} if the parameter is not valid or playlist is not set
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            playPlaylistItem: function (playlistItem, pos) {
                if (!this._playlist) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is not set");
                }

                var indexInList = util.indexOf(this._playlist.items, playlistItem),
                    eventInfo = {
                        pos: 0
                    };

                if (indexInList < 0) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Item is not in playlist");
                }

                if (!util.isUndefined(pos)) {
                    pos = parseInt(pos, 10);
                    if (!util.isNumber(pos)) {
                        throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playback position is not a number");
                    }

                    eventInfo.pos = pos;
                }

                util.extend(eventInfo, this._packEventInfo(playlistItem));

                this._playlist.currentItemIdx = indexInList;

                this._play(playlistItem, pos);
                this.__dispatchEvent(VideoPlaybackControlsEvent.SetControlsInPlayState, eventInfo);
            },

            /**
             * Play the next item in the playlist.
             * @method
             * @throws {TVEError} if the playlist is not set or it is empty
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            nextItem: function () {
                var eventInfo;

                if (!this._playNextPlaylistItem()) {
                    return;
                }

                eventInfo = this._packEventInfo(this._currentItem);
                this.__dispatchEvent(VideoPlaybackControlsEvent.NextPlaylistItem, eventInfo);
            },

            /**
             * Play the previous item in the playlist.
             * @method
             * @throws {TVEError} if the playlist is not set or it is empty
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            prevItem: function () {
                var eventInfo;

                if (!this._playPrevPlaylistItem()) {
                    return;
                }

                eventInfo = this._packEventInfo(this._currentItem);
                this.__dispatchEvent(VideoPlaybackControlsEvent.PreviousPlaylistItem, eventInfo);
            },

            /**
             * Resume the previous paused playback.
             * @method
             * @throws {TVEError} if no playlist is set, playlist is empty or no playback was played
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            playResume: function () {
                if (!this._playlist) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is not set");
                }

                var lastIndex = this._playlist.items.length - 1,
                    eventInfo;

                if (lastIndex < 0) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is empty");
                }

                if (this._playlist.currentItemIdx < 0) {
                    // no playback is playing, throw exception
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "No playing item");
                } else {
                    eventInfo = this._packEventInfo(this._currentItem);

                    sMedia.resume();
                    this.__dispatchEvent(VideoPlaybackControlsEvent.SetControlsInPlayState, eventInfo);
                }
            },

            /**
             * Pause the current playback.
             * @method
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            pause: function () {
                sMedia.pause();
                this.__dispatchEvent(VideoPlaybackControlsEvent.SetControlsInPauseState, {});
            },

            /**
             * Dismiss(stop) the current playback.
             * @method
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            dismiss: function () {
                sMedia.stop();
                
                this.__dispatchEvent(VideoPlaybackControlsEvent.DismissControls, {});
            },

            /**
             * Seek to the specific position.
             * @method
             * @param {Number} pos The target position
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            seek: function (pos) {
                this._seek(pos);
                this.__dispatchEvent(VideoPlaybackControlsEvent.UpdatePlayheadState, {
                    pos: pos
                });
            },

            /**
             * Set volume to the specific level.
             * (Setting volume is not supported by XDK. This function always throw exception.)
             * @method
             * @param {Number} vol The target volume
             * @throws {TVEError} Feature not supported
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            setVolume: function (vol) {
                throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "setVolume is not supported");
            },

            /**
             * Handler for EVT_FINISHED event.
             * @method
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playbackFinished: function () {
                this.__dispatchEvent(VideoPlaybackControlsEvent.DismissControls, {});
            },

            /**
             * Handler for EVT_TIME_UPDATE event.
             * @method
             * @protected
             * @param {Object} sec The updated time
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _timeUpdated: function (sec) {
                if(_videoLoadedCallback && this._currentPlaybackTime && sec > this._currentPlaybackTime){
                    _videoLoadedCallback();
                    _videoLoadedCallback = null;
                }
                this._currentPlaybackTime = sec;
                this._playbackDuration = sMedia.getDuration();

                this.__dispatchEvent(VideoPlaybackControlsEvent.TimePlayedIncreased, {
                    pos: sec
                });

                this.__dispatchEvent(VideoPlaybackControlsEvent.UpdatePlayheadState, {
                    pos: sec,
                    duration: this._playbackDuration
                });
            },

            /**
             * Handler for EVT_ERROR event.
             * @method
             * @protected
             * @param {Object} error The error object
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playbackError: function (error) {
                this.__dispatchEvent(VideoPlaybackControlsEvent.NotifyError, {
                    error: error
                });
            },

            /**
             * Handler for EVT_STATE_CHANGED event.
             * @method
             * @protected
             * @param {Object} change The state change object
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playbackStateChanged: function (change) {
                switch (change.toState) {
                case sMedia.PLAYING:
                    if(_videoLoadedCallback){
                        _videoLoadedCallback();
                        _videoLoadedCallback = null;
                    }
                    this._currentPlaybackState = this.constructor.STATUS.PLAYING;
                    break;
                case sMedia.PAUSED:
                    this._currentPlaybackState = this.constructor.STATUS.PAUSED;
                    break;
                case sMedia.BUFFERING:
                    this._currentPlaybackState = this.constructor.STATUS.BUFFERING;
                    break;
                case sMedia.STOPPED:
                    if(_videoLoadedCallback){
                        _videoLoadedCallback();
                        _videoLoadedCallback = null;
                    }
                    this._currentPlaybackState = this.constructor.STATUS.STOPPED;
                    break;
                default:
                    return;
                }

                // Notify UI.
                this._dispatchPlaybackStatus();
            },

            /**
             * Handler for DismissSelected event.
             * @method
             * @protected
             * @param {Object} data The event information
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _dismissSelected: function (data) {
                sMedia.stop();
            },

            /**
             * Handler for PlaySelected event.
             * @method
             * @protected
             * @param {Object} data The event information
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playSelected: function (data) {
                sMedia.resume();
            },

            /**
             * Handler for PauseSelected event.
             * @method
             * @protected
             * @param {Object} data The event information
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _pauseSelected: function (data) {
                sMedia.pause();
            },

            /**
             * Handler for PlayheadMoved event.
             * @method
             * @protected
             * @param {Object} data The event information
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playheadMoved: function (data) {
                this._seek(data.pos);
            },

            /**
             * Handler for NextPlaylistItemSelected event.
             * @method
             * @protected
             * @param {Object} data The event information
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _nextPlaylistItemSelected: function (data) {
                this._playNextPlaylistItem();
            },

            /**
             * Handler for PreviousPlaylistItemSelected event.
             * @method
             * @protected
             * @param {Object} data The event information
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _previousPlaylistItemSelected: function (data) {
                this._playPrevPlaylistItem();
            },

            /**
             * Dispatch event to mediator.
             * @method
             * @private
             * @param {VideoPlaybackControlsEvent} event The event to dispatch
             * @param {Object} eventInfo The information to be dispatched along with the event
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            __dispatchEvent: function (event, eventInfo) {
                mediator.publish(event, eventInfo);
            },

            /**
             * Play an playlist item on the current video playback.
             * @method
             * @protected
             * @param {PlaylistItem} playlistItem The playlist item
             * @param {Number} pos The starting position
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _play: function (playlistItem, pos) {
                var loadData = util.extend({}, playlistItem.metadata);
                loadData = util.extend(loadData, playlistItem.drmAttributes);
                loadData.forceReload = true;

                this._currentItem = playlistItem;
                this._currentPlaybackTime = pos;
                this._playbackDuration = playlistItem.metadata.duration;

                sMedia.load(this._currentItem.url, loadData);

                // set up the player
                this._prePlaySetUp();

                // play at the specific position
                sMedia.play({sec: pos});
            },

            /**
             * Seek to target position.
             * @method
             * @protected
             * @param {Number} pos The target position
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _seek: function (pos) {
                sMedia.seek(pos);
            },

            /**
             * Play next playlist item on the current playlist.
             * @method
             * @protected
             * @returns {Boolean} true if the video can(has) been played, false otherwise
             * @throws {TVEError} No playlist/ playlist is empty
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playNextPlaylistItem: function () {
                if (!this._playlist) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is not set");
                }

                var len = this._playlist.items.length;

                if (len < 1) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is empty");
                }

                // ignore if no next item available
                if (this._playlist.currentItemIdx >= len - 1) {
                    return false;
                }

                // advance to the next item
                this._playlist.currentItemIdx++;
                this._currentItem = this._playlist.items[this._playlist.currentItemIdx];

                this._play(this._currentItem);

                return true;
            },

            /**
             * Play previous playlist item on the current playlist.
             * @method
             * @protected
             * @returns {Boolean} true if the video can(has) been played, false otherwise
             * @throws {TVEError} No playlist/ playlist is empty
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _playPrevPlaylistItem: function () {
                if (!this._playlist) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is not set");
                }

                var lastIndex = this._playlist.items.length - 1,
                    currentItem,
                    eventInfo;

                if (lastIndex < 0) {
                    throw new TVEError(TVEError.FACILITY.PLAYBACK_SERVICE, TVEError.ERROR.INVALID, "Playlist is empty");
                }

                // ignore if no previous item available
                if (this._playlist.currentItemIdx <= 0) {
                    return false;
                }

                this._playlist.currentItemIdx--;

                currentItem = this._getCurrentPlaylistItem();
                eventInfo = this._packEventInfo(currentItem);

                this._play(currentItem);

                return true;
            },

            /**
             * Create an object from a PlaylistItem for the Play event.
             * @method
             * @protected
             * @param {PlaylistItem} playlistItem The playlist item
             * @returns {Object} the event info object
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _packEventInfo: function (playlistItem) {
                var eventInfo = {
                    id: playlistItem.id,
                    url: playlistItem.url,
                    metadata: playlistItem.metadata
                };

                if (playlistItem.drmAttributes) {
                    eventInfo.drmAttributes = playlistItem.drmAttributes;
                }
                eventInfo.currentPlaybackTime = this._currentPlaybackTime;

                return eventInfo;
            },

            /**
             * Get the current playlist item.
             * @method
             * @protected
             * @returns {PlaylistItem} the current playlist item
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _getCurrentPlaylistItem: function () {
                if (!this._playlist) {
                    return null;
                }

                return this._playlist.items[this._playlist.currentItemIdx];
            },

            /**
             * Register the handlers for the playback events.
             * @method
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _registerPlaybackEventHandlers: function () {
                this.__bindedPlaybackFinished = util.bind(this._playbackFinished, this);
                sMedia.addEventListener(sMedia.EVT_FINISHED, this.__bindedPlaybackFinished);

                this.__bindedTimeUpdated = util.bind(this._timeUpdated, this);
                sMedia.addEventListener(sMedia.EVT_TIME_UPDATE, this.__bindedTimeUpdated);

                this.__bindedPlaybackError = util.bind(this._playbackError, this);
                sMedia.addEventListener(sMedia.EVT_ERROR, this.__bindedPlaybackError);

                this.__bindedPlaybackStateChanged = util.bind(this._playbackStateChanged, this);
                sMedia.addEventListener(sMedia.EVT_STATE_CHANGED, this.__bindedPlaybackStateChanged);
            },

            /**
             * Un-register the handlers for the playback events.
             * @method
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _unregisterPlaybackEventHandlers: function () {
                sMedia.removeEventListener(sMedia.EVT_FINISHED, this.__bindedPlaybackFinished);
                sMedia.removeEventListener(sMedia.EVT_TIME_UPDATE, this.__bindedTimeUpdated);
                sMedia.removeEventListener(sMedia.EVT_ERROR, this.__bindedPlaybackError);
                sMedia.removeEventListener(sMedia.EVT_STATE_CHANGED, this.__bindedPlaybackStateChanged);
            },

            /**
             * Register the handlers for the playback controls status events.
             * @method
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _registerPlaybackControlsStatusEventHandlers: function () {
                this.__bindedDismissSelected = util.bind(this._dismissSelected, this);
                mediator.subscribe(VideoControlsStatusEvent.DismissSelected, this.__bindedDismissSelected);

                this.__bindedPlaySelected = util.bind(this._playSelected, this);
                mediator.subscribe(VideoControlsStatusEvent.PlaySelected, this.__bindedPlaySelected);

                this.__bindedPauseSelected = util.bind(this._pauseSelected, this);
                mediator.subscribe(VideoControlsStatusEvent.PauseSelected, this.__bindedPauseSelected);

                this.__bindedPlayheadMoved = util.bind(this._playheadMoved, this);
                mediator.subscribe(VideoControlsStatusEvent.PlayheadMoved, this.__bindedPlayheadMoved);

                this.__bindedNextPlaylistItemSelected = util.bind(this._nextPlaylistItemSelected, this);
                mediator.subscribe(VideoControlsStatusEvent.NextPlaylistItemSelected, this.__bindedNextPlaylistItemSelected);

                this.__bindedPreviousPlaylistItemSelected = util.bind(this._previousPlaylistItemSelected, this);
                mediator.subscribe(VideoControlsStatusEvent.PreviousPlaylistItemSelected, this.__bindedPreviousPlaylistItemSelected);
            },

            /**
             * Un-register the handlers for the playback controls status events.
             * @method
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _unregisterPlaybackControlsStatusEventHandlers: function () {
                mediator.unsubscribe(VideoControlsStatusEvent.DismissSelected, this.__bindedDismissSelected);
                mediator.unsubscribe(VideoControlsStatusEvent.PlaySelected, this.__bindedPlaySelected);
                mediator.unsubscribe(VideoControlsStatusEvent.PauseSelected, this.__bindedPauseSelected);
                mediator.unsubscribe(VideoControlsStatusEvent.PlayheadMoved, this.__bindedPlayheadMoved);
                mediator.unsubscribe(VideoControlsStatusEvent.NextPlaylistItemSelected, this.__bindedNextPlaylistItemSelected);
                mediator.unsubscribe(VideoControlsStatusEvent.PreviousPlaylistItemSelected, this.__bindedPreviousPlaylistItemSelected);
            },

            /**
             * Set up the player for a playback.
             * @method
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _prePlaySetUp: function () {
                sMedia.setFullscreen();
            },

            /**
             * Dispatch playback status.
             * @return {void}
             * @protected
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            _dispatchPlaybackStatus: function () {
                var currentItem = this._getCurrentPlaylistItem(),
                    eventInfo = this._packEventInfo(currentItem);

                switch (this._currentPlaybackState) {
                    case this.constructor.STATUS.PLAYING:
                        this.__dispatchEvent(VideoPlaybackStatusEvent.PlayState, eventInfo);
                        break;
                    case this.constructor.STATUS.PAUSED:
                        this.__dispatchEvent(VideoPlaybackStatusEvent.PauseState, eventInfo);
                        break;
                    case this.constructor.STATUS.BUFFERING:
                        this.__dispatchEvent(VideoPlaybackStatusEvent.BufferState, eventInfo);
                        break;
                    case this.constructor.STATUS.STOPPED:
                        this.__dispatchEvent(VideoPlaybackStatusEvent.StopState, eventInfo);
                        break;
                }
            },

            /**
             * Get the current playlist.
             * @method
             * @returns {Playlist} the current playlist
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            getPlaylist: function () {
                return this._playlist;
            },

            /**
             * Clean up the manager.
             * @method
             * @memberOf tve/videoPlaybackService/VideoManager#
             */
            deinit: function () {
                this._unregisterPlaybackEventHandlers();
                this._unregisterPlaybackControlsStatusEventHandlers();
            }
        });
    });
/**
 * sVideoManager extends the generic VideoManager from TVE blocks, to provide specific implementation based on the use case.
 *
 * This code taken from an excerpt of ConnectVideoManager.js from TVE Demo application 1.1.1.
 *
 * @name sVideoManager
 * @class storm/mgr/sVideoManager
 */

define("storm/mgr/sVideoManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/console",
    "tve/videoPlaybackService/VideoManager",
    "xdk-base/device/Media",
    "storm/mgr/sAppConfigManager",
    "xdk-ax/mediator",
    "tve/videoPlaybackService/evt/VideoPlaybackStatusEvent",
    "xdk-base/device",
    "xdk-base/device/playerRegistry",
    "xdk-base/promise",
    "xdk-base/ajax"
], function (
    klass,
    util,
    console,
    VideoManager,
    Media,
    sAppConfigManager,
    mediator,
    VideoPlaybackStatusEvent,
    device,
    playerRegistry,
    promise,
    ajax
    ) {

    "use strict";

    var sMedia = Media.singleton();

    return klass.create(VideoManager, {}, {

        ERROR_CODES: {
            FIRMWARE_UPDATE_REQUIRED: "SEFPlayer:firmwareUpgradeRequired"
        },

        // Override functions for listeners.
        init: function () {
            this._registerPlaybackEventHandlers();
            this._registerPlaybackControlsStatusEventHandlers();

            // Listen for playback before trying to get audio languages.
            this.__audioListener        = util.bind(this.getAudioTracks,this);
            mediator.subscribe(VideoPlaybackStatusEvent.PlayState, this.__audioListener);
        },

        deinit: function () {
            this._unregisterPlaybackEventHandlers();
            this._unregisterPlaybackControlsStatusEventHandlers();
            mediator.unsubscribe(VideoPlaybackStatusEvent.PlayState, this.__audioListener);
        },

        /**
         * Skip the playback forward/backward for certain seconds.
         * @param  {Object}     param                   parameter for the skipping
         * @param  {Number}     [param.sec]             number of seconds to skip (10 by default)
         * @param  {Boolean}    [param.progressive]     whether it is progressive skipping or not
         * @param  {Number}     [param.multipleFactor]  for progressive, multiple of increase in jump distance for each skip
         * @param  {Number}     [param.delaySec]        for progressive, seconds of delay before the skip is fired
         * @param  {Number}     [param.progressiveCap]  for progressive, maximum amount of second in each increase
         * @return {void}
         * @memberOf storm/mgr/sVideoManager#
         */

        skip: function (param) {
            sMedia.skip(param);
        },

        _play: function (playlistItem, pos) {
            var loadData = util.extend({}, playlistItem.metadata);
            loadData = util.extend(loadData, playlistItem.drmAttributes);
            loadData.forceReload = true;

            this._currentItem = playlistItem;
            this._currentPlaybackTime = pos;
            this._playbackDuration = playlistItem.metadata.duration;

            // Special handling for LG since we need to parse manifest file manually to get audio languages.
            if (device.platform === "lg") {
                this.getAudioTracksFromManifest(this._currentItem.url).done(util.bind(function(audioTracks) {
                    sAppConfigManager.getDefaultAudioTrackMapping().then(util.bind(function (audioSettings) {
                        var audioLanguages,
                            audioCodecs;

                        if (!audioTracks || !audioTracks.length || !audioSettings || !audioSettings.audioLanguage || !audioSettings.audioCodec) {
                            return false;
                        }

                        audioLanguages = audioSettings.audioLanguage.split("|");
                        audioCodecs = audioSettings.audioCodec.split("|");

                        for (var codecIndex = 0; codecIndex < audioCodecs.length; codecIndex++) {
                            for (var trackIndex = 0; trackIndex < audioTracks.length; trackIndex++) {
                                // Match on codec? Try to find language match as well.
                                if (audioTracks[trackIndex].codec === audioCodecs[codecIndex]) {
                                    for (var langIndex = 0; langIndex < audioLanguages.length; langIndex++) {
                                        if (audioTracks[langIndex].LANGCODE === audioLanguages[langIndex]) {
                                            return audioTracks[langIndex].name;
                                        }
                                    }
                                }
                            }
                        }

                        // No audio language found.
                        return false;
                    }, this)).done(util.bind(function(audioLanguage) {

                        if (audioLanguage) {
                            loadData.audioLanguage = audioLanguage;
                        }

                        sMedia.load(this._currentItem.url, loadData);

                        // set up the player
                        this._prePlaySetUp();

                        // play at the specific position
                        sMedia.play(pos);    
                    }, this));
                }, this));
            } else {
                sMedia.load(this._currentItem.url, loadData);

                // set up the player
                this._prePlaySetUp();

                // play at the specific position
                sMedia.play(pos);
            }
        },

        getAudioTracksFromManifest: function (url) {
            console.log("Loading manifest file " + url);

            if (!url || url.toLowerCase().indexOf("/manifest") === -1) {
                return promise.resolve([]);
            }

            // If this is playready, we initiate a load of the manifest file manually, to read the audio tracks from
            var requestOpts = {
                method: "get"
            };
            var scope = this;
            return ajax.request(url, requestOpts).then(
                function (transport) {
                    console.log("Response:");
                    var audioTracks = [];

                    try {
                        var responseNodes = transport.responseXML.getElementsByTagName("StreamIndex");
                        var qualityLevels;

                        for (var i = 0; i < responseNodes.length; i++) {
                            if (responseNodes[i].getAttribute("Type") === "audio") {
                                qualityLevels = responseNodes[i].getElementsByTagName("QualityLevel");
                                qualityLevels = qualityLevels && qualityLevels[0];
                                var language = responseNodes[i].getAttribute("Language") || null;
                                var audioName = responseNodes[i].getAttribute("Name") || null;
                                var codec = qualityLevels && qualityLevels.getAttribute("FourCC") || null;
                                if (language && codec) {
                                    console.log("Audio track found: " + language);
                                    audioTracks.push({ id: language, LANGCODE: language, name: audioName, codec: codec });
                                }
                            }
                        }
                    }
                    catch (e) {
                        console.error("Couldn't load manifest file. " + e.message);
                    }

                    return audioTracks;
                },
                function (reason) {
                    stormUtil.traceObject(reason, "Manifest loading error", "error");

                    return [];
                });
        },

        getState: function () {
            return sMedia.getState();
        },

        getAudioTracks: function () {
            console.log("sVideoManager::getAudioTracks()");
            if (!this._audioTracks || this._audioTracks.length == 0) {
                sMedia.getAudioTracks().then(util.bind(function(tracks) {
                    // If the audiotracks could be found we stop subscribing to the stop event too
                    mediator.unsubscribe(VideoPlaybackStatusEvent.StopState, this.__stopAudioListener);

                    this._audioTracks = [];
                    this._currentAudioTrack = 0;
                    var promiseArray = [], promiseElement;
                    // Get the langcode of each stream for later use.
                    for (var i = 0; i < tracks.length; i++) {
                        promiseElement = sMedia.getAudioTrackAttr(tracks[i], "LANGCODE", "default").then(util.bind(function (id, language) {
                            this._audioTracks.push({
                                id: id,
                                lang: language
                            });
                        }, this, tracks[i]));

                        promiseArray.push(promiseElement);
                    }

                    return promise.all(promiseArray);
                }, this)).then(util.bind(function() {
                    // Once we have the audio tracks, publish this information to any listeners.
                    mediator.publish("onAudioTracks",this._audioTracks.length);
                },this));
            }
        },

        setDefaultAudioLanguage: function() {
            if (!this._audioTracks) {
                return false;
            }
            sAppConfigManager.getVideoDefaultAudioTrack().then(util.bind(function (forcedLanguage) {
                // If we don't have a language to force, stop.
                if (!forcedLanguage) {
                    return false;
                }
                forcedLanguage = forcedLanguage.split("|")[0]; // The default language to use (presumed format: "ger|audio_ger")
                for (var i = 0; i < this._audioTracks.length; i++) {
                    if (this._audioTracks[i].lang === forcedLanguage) {
                        this._currentAudioTrack = i;
                        // We've found the default language, set it and publish the update information.
                        sMedia.setAudioTrack(this._audioTracks[i].id).then(util.bind(function() {
                            mediator.publish("onAudioTrackChange", this._getCurrentAudioLanguage());
                        },this));
                    }
                }
            },this));
        },

        //@TODO Currently returns 'eng' or 'ger' -- Map this to an expanded version?
        _getCurrentAudioLanguage: function() {
            if (!this._audioTracks || util.isUndefined(this._currentAudioTrack)) {
                return false;
            }
            return this._audioTracks[this._currentAudioTrack].lang;
        },

        toggleAudio: function() {
            if (!this._audioTracks || util.isUndefined(this._currentAudioTrack)) {
                return false;
            }

            var newAudioTrack;

            // If there are still more languages, move to the next one.
            if (this._currentAudioTrack < (this._audioTracks.length-1)) {
                newAudioTrack = this._currentAudioTrack + 1;
            }
            // Otherwise, start from the beginning.
            else {
                newAudioTrack = 0;
            }

            // Set the new language and publish the new information.
            sMedia.setAudioTrack(this._audioTracks[newAudioTrack].id).then(util.bind(function() {
                this._currentAudioTrack = newAudioTrack;

                mediator.publish("onAudioTrackChange", this._getCurrentAudioLanguage());
            },this));
        }
    });
});


/**
 * Eula Model
 * @class storm/model/Eula
 */
define("storm/model/Eula", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member title - a simple textual heading for the EULA
             * @memberof storm/model/Eula#
             * @public
             * @type {String}
             */
            "title": "",

            /**
             * @member enticement - some additional small text about the EULA
             * @memberof storm/model/Eula#
             * @public
             * @type {String}
             */
            "enticement": "",

            /**
             * @member body - the EULA text itself, with markup in it
             * @memberof storm/model/Eula#
             * @public
             * @type {String}
             */
            "body": "",

            /**
             * @member timestamp - treat this as a text string (so, we only check for changes in timestamp, not ordering)
             * @memberof storm/model/Eula#
             * @public
             * @type {String}
             */
            "timestamp": ""
        }
    }, {});
});
/**
 * Eula Builder, for building the Eula model
 * @class storm/model/EulaBuilder
 */
define("storm/model/EulaBuilder", [
    "xdk-base/class",
    "storm/model/Eula"
], function (
    klass,
    Eula
    ) {

    "use strict";

    var EulaBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/EulaBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the title for building the model.
         * @param {String} title
         * @returns {storm/model/EulaBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/EulaBuilder#
         */
        setTitle: function (title) {
            this._attrs.title = title;
            return this;
        },

        /**
         * Set the enticement for building this model.
         * @param {String} enticement
         * @returns {storm/model/EulaBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/EulaBuilder#
         */
        setEnticement: function (enticement) {
            this._attrs.enticement = enticement;
            return this;
        },

        /**
         * Set the body for building this model.
         * @param {string} body
         * @returns {storm/model/EulaBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/EulaBuilder#
         */
        setBody: function (body) {
            this._attrs.body = body;
            return this;
        },

        /**
         * Set the timestamp for building this model.
         * @param {string} timestamp
         * @returns {storm/model/EulaBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/EulaBuilder#
         */
        setTimestamp: function (timestamp) {
            this._attrs.timestamp = timestamp;
            return this;
        },

        /**
         * Build the Eula model.
         * @returns {storm/model/Eula} the Eula model
         * @public
         * @method
         * @memberof storm/model/EulaBuilder#
         */
        build: function () {
            return new Eula(this._attrs);
        }
    });

    return EulaBuilder;
});
/**
 * Returns a singleton responsible to get structures describing (in human-friendly format) products like subscriptions, packages, day passes.
 * @name sEulaManager
 * @memberof storm/mgr
 * @class storm/mgr/sEulaManager
 */
define("storm/mgr/sEulaManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "tve/TVEError",
    "storm/mgr/sEditorialManager",
    "storm/mgr/sLocalStorageManager",
    "storm/model/EulaBuilder"
], function (
    klass,
    util,
    promise,
    console,
    TVEError,
    sEditorialManager,
    sLocalStorageManager,
    EulaBuilder
    ) {

    "use strict";

    var EulaManager = klass.create({
    }, {

        _createCombinedTimestamp: function(eulaModelArray) {
            var combinedTimestamp = "";

            util.each(eulaModelArray, function(eulaModel) {
                combinedTimestamp += eulaModel.get("timestamp");
            });

            return combinedTimestamp;
        },

        hasEulaBeenAgreed: function() {
            return this.getAllEulas().then(util.bind(function(eulaModelArray) {
                var combinedTimestamp = this._createCombinedTimestamp(eulaModelArray),
                    storedTimestamp = sLocalStorageManager.getStoredValue(sLocalStorageManager.KEYS.EULA_TIMESTAMP);

                console.info("EULA agreement check:");
                console.info("Stored timestamp: " + storedTimestamp);
                console.info("Combined timestamp: " + combinedTimestamp);

                return promise.resolve(combinedTimestamp === storedTimestamp);
            }, this), function(reason) {
                return promise.reject("Unable to check if EULA agreed to: "+ reason);
            });
        },

        //
        // Retrieve a combined EULA for both territories, for users to agree to
        // when the application launches. Note that we subsequently munge the
        // 'last updated' dates together, so will reshow EULA on startup if
        // EITHER of them has changed.
        //

        getAllEulas: function() {
            return promise.all([
                this.getEula("de"),
                this.getEula("at")
            ]);
        },

        //
        // Retrieve the EULA specifically for, or at least styled for, a given territory.
        //
        // If no country is specified (or if it's unrecognised) assume Germany.
        //

        getEula: function(optionalCountryCode) {
            var bAustrian = optionalCountryCode && ((optionalCountryCode + "").toUpperCase() === "AT");

            return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.EULA).then(function(response){
                var eula = response.responseJSON.eula,
                    eulaBuilder = new EulaBuilder()
                        .setTitle(bAustrian?eula.article_name_at:eula.article_name)
                        .setEnticement(bAustrian?eula.short_description_at:eula.short_description_de)
                        .setBody(bAustrian?eula.article_body_at:eula.article_body)
                        .setTimestamp(bAustrian?eula.last_update_date_at:eula.last_update_date_de);

                return eulaBuilder.build();
            });
        },

        //
        // When the user agrees to the array of EULAs we will store information about which
        // munged / combined version they've agreed to. It may be updated in future...
        // ... and they'll have to agree all over again!
        //

        agreeToEulas: function(eulaModelArray) {
            sLocalStorageManager.setStoredValue(sLocalStorageManager.KEYS.EULA_TIMESTAMP, this._createCombinedTimestamp(eulaModelArray));
        }

    });

    return new EulaManager();
});
/**
 * The loading / busy animation
 * @name Loading
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/Loading
 */
define("tvedemo/wgt/Loading", [
    "xdk-ax/Container",
    "xdk-ui-basic/Image",
    "xdk-base/class",
    "xdk-base/Env",
    "xdk-ax/mvc/AppRoot"
], function (
    Container,
    Image,
    klass,
    Env,
    AppRoot
    ) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        sEnv = Env.singleton(),

        Loading = klass.create(Container, {

        _shared: null,

        getShared: function () {

            if (!this._shared) {
                this._shared = new Loading();
            }

            return this._shared;

        },

        open: function () {
            return this.getShared().open();

        },
        close: function () {
            return this.getShared().close();
        }


    }, {

        init: function (opts) {

            opts = opts || {};

            opts.css = opts.css || "";
            opts.css += "wgt-dialog-modal wgt-loading";

            opts.parent = sAppRoot.getView();

            this._super(opts);

            this._overlay = new Container({
                parent: this,
                css: "wgt-dialog-overlay"
            });

            new Image({
                klass: Image,
                css: "load",
                src: "img/loading/load.gif",
                parent: this._overlay
            });

        },

        open: function () {
            this.show();
            sEnv.blockKeys();
        },

        close: function () {
            sEnv.unblockKeys();
            this.hide();
        }
    });

    return Loading;
});
/**
 * Returns a singleton responsible of handling deep linking data.
 * @name sAssetManager
 * @memberof tvedemo/mgr
 * @class tve/mgr/sAssetManager
 */
define("tvedemo/mgr/deepLinkingManager", 
    [
        "xdk-base/class",
        "xdk-base/device",
        "xdk-base/util",
        "xdk-ax/mediator",
        "tvedemo/wgt/Loading"
    ],
    function (
        klass,
        device,
        util,
        mediator,
        Loading
    ) {

    "use strict";

    var DeepLinking = klass.create(
        {
            CONTENT_TYPES: {
                "Film-": "FILM",
                "Episode-": "EPISODE",
                "Series-": "SERIES",
                "Season-": "SEASON",
                "Sport-:": "SPORT"
            }
        }, {

            getDeepLinkData: function() {
                var reqAppControl, data, i, payload, deepLinkData = {};

                if (device.platform === "tizen") {
                    reqAppControl = tizen.application.getCurrentApplication().getRequestedAppControl();

                    if (reqAppControl) {
                        data = reqAppControl.appControl.data;

                        for (i = 0; i < data.length; i++) {
                            console.log("[data]: " + data[i].key + " " + data[i].value[0]);
                            if (data[i].key == 'PAYLOAD') {
                                payload = data[i].value[0];
                                break;
                            }
                        }

                        try {
                            payload = JSON.parse(payload);

                            payload = JSON.parse(payload.values);
                            console.log("values");
                            console.log(payload);
                        } catch(e) {
                            console.info("Couldn't parse payload: " + e);
                            payload = null;
                        }

                        if (payload && payload.deeplink) {
                            var contentType,
                                assetId,
                                catalog = "SN";

                            payload = payload.deeplink.split('-'); // ["Film-", "1234"] // content type, assetid

                            if (!payload || payload.length < 2) {
                                // Wrong deeplinking value
                                return {};
                            }

                            deepLinkData.contentType = payload[0].toUpperCase() || "UNKNOWN";
                            deepLinkData.assetId = payload[1];
                            deepLinkData.extraId = payload[2] || null;
                        }

                    } else {
                        console.info("no req app control");
                    }
                }

                return deepLinkData;
            },

            handleDeepLinking: function() {
                var deepLinkData = this.getDeepLinkData();

                if (deepLinkData.contentType && deepLinkData.assetId) {
                    this.navigate(deepLinkData.contentType, deepLinkData.assetId);
                }
            },

            navigate: function(contentType, assetId) {
                var catalog = "sg",
                    path,
                    state,
                    message = { __forceReload: true };
                Loading.open();
                
                console.log("DEEP LINK NAVIGATION - assetId: " + assetId + ", contentType: " + contentType);

                switch(contentType) {
                    case "SERIES":
                        path = "Main/TVShow";
                        state = {
                            serieId: assetId,
                            catalog: catalog
                        };
                        
                    break;
                    case "SEASON":
                        path = "Main/TVShow";
                        state = {
                            seasonId: assetId,
                            catalog: catalog
                        };
                    break;
                    case "EPISODE":
                        path = "Main/Episode";
                        state = {
                            selectedEpisodeId: assetId,
                            catalog: catalog,
                            autoPlay: true
                        };
                    break;
                    case "FILM":
                    default:
                        path = "Main/Movie";
                        state = {
                            assetId: assetId,
                            catalog: catalog,
                            autoPlay: true
                        };
                }

                mediator.publish("navigate", {
                    path: path,
                    state: state,
                    message: message
                });
            }
        }
    );

    return new DeepLinking();

});
/**
 * The splash view's controller. Setup the splash video and image.
 * @name Splash
 * @memberof storm/ctrl
 * @class storm/ctrl/Splash
 * @extends storm/ctrl/RoutableController
 */
define("storm/ctrl/Splash", [
    "xdk-base/ax",
    "xdk-ax/mvc/AppRoot",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "storm/tmpl/splash",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-mouse/mouseHandler",
    "xdk-ax/mediator",
    "xdk-base/device/vKey",
    "storm/mgr/sAppConfigManager",
    "xdk-base/device",
    "xdk-base/promise",
    "storm/helper/util",
    "tve/videoPlaybackService/model/Playlist",
    "tve/videoPlaybackService/model/PlaylistItem",
    "tve/videoPlaybackService/evt/VideoPlaybackControlsEvent",
    "tve/videoPlaybackService/evt/VideoPlaybackStatusEvent",
    "storm/mgr/sVideoManager",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sEulaManager",
    "tvedemo/wgt/AlertDialog",
    "tvedemo/helper/dialogHelper",
    "tve/sServiceHolder",
    "tvedemo/mgr/deepLinkingManager",
    "xdk-base/console"
], function (
    ax,
    AppRoot,
    RoutableController,
    view,
    splashTmpl,
    util,
    evtType,
    focusManager,
    mouseHandler,
    mediator,
    vKey,
    sAppConfigManager,
    device,
    promise,
    stormUtil,
    Playlist,
    PlaylistItem,
    VideoPlaybackControlsEvent,
    VideoPlaybackStatusEvent,
    VideoManager,
    sLanguageManager,
    sEulaManager,
    AlertDialog,
    dialogHelper,
    sServiceHolder,
    deepLinkingManager,
    console
    ) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        LIKELY_VIDEO_DURATION = 6, // Quite long, to be absolutely sure in the EULA scenario.
        hasCheckedAppStatus = false;

    return ax.klass.create(RoutableController, {
        VIDEO_URL: "/video/splash.m4v",
        EVENT: {
            CONTROLLER_READY: 1,
            VIDEO_FINISHED: 2
        }
    }, {
        init: function () {
            
            //Start the mouse handler
            mouseHandler.start();
            
            this.setView(view.render(splashTmpl));
        },

        setup: function (context) {
            var infoText;

            this._super(context);
            this.currentView = this.getView();

            infoText = this.currentView.find("info");

            if (ax.config.get("displayVersion") === false) {
                infoText.hide();
            }

            this._handleDeepLinkingDataRef = util.bind(this.getDeepLinkData, this);

            if (device.platform === "tizen") {
                window.addEventListener("appcontrol", this._handleDeepLinkingDataRef);
            }

            this.getDeepLinkData();

            this.setupPlayback();

            sLanguageManager.setLanguage("de");
        },

        getDeepLinkData: function() {
            var deepLinkData = deepLinkingManager.getDeepLinkData();

            this._deepLinkData = deepLinkData;
        },

        checkAppStatus: function() {

            // This should only happen once.
            if (hasCheckedAppStatus === true) {
                return;
            }

            hasCheckedAppStatus = true;

            sAppConfigManager.getStatus().then(util.bind(function (transport) {

                if (transport === sAppConfigManager.constructor.STATUS.ACTIVE) {

                    return promise.all([
                        sAppConfigManager.getLatestValidVersion(), // Version retrieval must be zeroth promise, see then() below...
                        sServiceHolder.getDateTimeService().getServerDateTime(),
                        sServiceHolder.getAnalyticsService(),
                        sLanguageManager.getInitPromise(),
                        sAppConfigManager.getSamsungSpecificConfig().then(function (samsungConfig) {

                            if (samsungConfig) {

                                if (device.id && util.isFunction(device.id.setRequiredSamsung2014FirmwareIdentifiers)) {
                                    device.id.setRequiredSamsung2014FirmwareIdentifiers(samsungConfig.playback2014);
                                }
                            }

                        })
                    ]).then(util.bind(function (results) {
                        this._validVersionInfo = results[0];

                        return sEulaManager.hasEulaBeenAgreed().then(util.bind(function(outcome) {

                            if (outcome === true) {
                                this._eulaAgreed();
                            } else {
                                if (this.videoFinished) {
                                    this._showEulaPopup();
                                } else {
                                    // Wait a few seconds until the loading video has had time to proceed...
                                    util.delay(LIKELY_VIDEO_DURATION).then(ax.util.bind(function() {
                                        this._showEulaPopup();
                                    }, this));
                                }
                            }
                        }, this), function(failure) {
                            //send to failure case below
                            return promise.reject("EULA check impossible: " + failure);
                        });
                    }, this));

                } else {

                    //send to failure case below
                    return promise.reject("AppGrid says mode '" + transport + "' (not '" + sAppConfigManager.constructor.STATUS.ACTIVE + "')");

                }

            }, this)).fail(util.bind(function (msg) {
                //all get Status failure handling
                ax.console.log("Going to maintenance mode due to: " + msg);

                this.next(this.constructor.EVENT.CONTROLLER_READY, function () {
                    sAppRoot.getView().removeClass("fullscreen-video-mode");

                    mediator.publish("navigate", {
                        path: "Maintenance",
                        historySkip: true
                    });
                });

            }, this)).done();
        },

        _showEulaPopup: function() {
            sEulaManager.getAllEulas().then(util.bind(function(eulaModelArray) {
                var combinedBodyText = "";

                util.each(eulaModelArray, function(eulaModel) {
                    combinedBodyText += eulaModel.get("title") + "<br>";
                    combinedBodyText += eulaModel.get("body") + "<br>";
                });

                dialogHelper.eulaAccept({
                    title: sLanguageManager.getString("Login.Login_labelEula_confirmation_hl"),
                    hint: sLanguageManager.getString("Login.Login_labelEula_confirmation_message"),
                    body: combinedBodyText,

                    confirmButtonText: sLanguageManager.getString("Login.Login_labelEula_accept_btn"),
                    confirmAction: util.bind(function () {
                        sEulaManager.agreeToEulas(eulaModelArray);
                        this._eulaAgreed();
                    }, this),

                    cancelButtonText: sLanguageManager.getString("Global.Global_Cancel_Button"),
                    cancelAction: util.bind(function () {
                        dialogHelper.confirm({
                            title: sLanguageManager.getString("Login.Login_labelEula_is_not_accepted_hl"),
                            message: sLanguageManager.getString("Login.Login_labelEula_is_not_accepted_message"),
                            positiveText: sLanguageManager.getString("Global.Global_buttonConfirm"),
                            negativeText: sLanguageManager.getString("Global.Global_buttonClose"),
                            positiveAction: util.bind(function () {
                                this._showEulaPopup();
                            }, this),
                            negativeAction: util.bind(function () {
                                console.warn("User really does not want to accept the EULA");
                                // HARSH close.
                                device.system.exit();
                                if (navigator.userAgent.toLowerCase().indexOf("web0s") !== -1 || device.platform === 'playstation') {
                                    this._showEulaPopup();
                                }
                            }, this)
                        }, this);
                    }, this)
                });
            }, this));
        },

        _eulaAgreed: function() {
            console.log("Eula has been agreed");

            this.next(this.constructor.EVENT.CONTROLLER_READY, util.bind(function () {
                sAppRoot.getView().removeClass("fullscreen-video-mode");

                if (stormUtil.versionNotCompatible(ax.config.get("version"), this._validVersionInfo)) {
                    var dialog = new AlertDialog({
                        title: sLanguageManager.getString("Global.Global_generalAppError"), // Sky failed to supply something specific for this.
                        message: sLanguageManager.getString("Global.Global_Update_Message") + " (" + ax.config.get("version") + ")",
                        buttonText: sLanguageManager.getString("Global.Global_buttonExit")
                    });

                    focusManager.focus(dialog);

                    dialog.addEventListener(evtType.CLOSE, function() {
                        console.log("Harsh exit because app version check failed");
                        // HARSH close.
                        device.system.exit();
                    });
                } else {
                    // TODO check deeplink data and navigate appropiate.
                    // Or should we first launch main page?

                    if (device.platform === "tizen") {
                        // Remove handle for splashscreen specific handling.
                        window.removeEventListener("appcontrol", this._handleDeepLinkingDataRef);

                        // Add a handler that can redirect the application.
                        window.addEventListener("appcontrol", util.bind(deepLinkingManager.handleDeepLinking, deepLinkingManager));
                    }

                    // We only proceed to the main UI if it's likely to work!
                    mediator.publish("navigate", {
                        path: "Main",
                        historySkip: true,
                        state: {
                            deepLinkData: this._deepLinkData
                        }
                    });
                }
            }, this));
        },

        next: function (event, action) {
            if (event === this.constructor.EVENT.CONTROLLER_READY) {
                this.controllerReady = action;
            } else if (event === this.constructor.EVENT.VIDEO_FINISHED) {
                this.videoFinished = action;
            }

            if (this.controllerReady && this.videoFinished) {
                this.controllerReady();
            } else if (this.videoFinished) {
                this.videoFinished();
            }
        },

        setupPlayback: function () {

            stormUtil.getRootFolder(this.constructor.VIDEO_URL).then(util.bind(function (url) {

                var videoUrl = url;

                // Keep this if we get a new splash screen.
                this.prepareForVideoStart();

                this.__videoManager = new VideoManager();
                var items = [new PlaylistItem({
                    url: videoUrl
                })],
                    playlist = new Playlist({
                        items: items
                    });

                this.__dismissControlsRef = util.bind(this._dismissControls, this);
                mediator.subscribe(VideoPlaybackControlsEvent.DismissControls, this.__dismissControlsRef);

                this.__videoErrorRef = util.bind(this._videoError, this);
                mediator.subscribe(VideoPlaybackControlsEvent.NotifyError, this.__videoErrorRef);

                this.__playStateRef = util.bind(this._videoState, this);

                mediator.subscribe(VideoPlaybackStatusEvent.PlayState, this.__playStateRef);
                mediator.subscribe(VideoPlaybackStatusEvent.StopState, this.__playStateRef);

                this.__videoManager.setPlaylist(playlist);
                this.__videoManager.playPlaylistItem(items[0]);

            }, this));
        },

        _videoState: function() {
            this.checkAppStatus();
        },

        _dismissControls: function () {
            this.next(this.constructor.EVENT.VIDEO_FINISHED, this.dealWithVideoStop);
            this.checkAppStatus();
        },

        _videoError: function () {
            this.next(this.constructor.EVENT.VIDEO_FINISHED, this.dealWithVideoStop);
            this.checkAppStatus();
        },

        prepareForVideoStart: function () {
            this.currentView.addClass("splash-video-playing");
            sAppRoot.getView().addClass("fullscreen-video-mode");
        },

        dealWithVideoStop: function () {
            this.currentView.removeClass("splash-video-playing");
        },

        reset: function () {
            mediator.unsubscribe(VideoPlaybackControlsEvent.DismissControls, this.__dismissControlsRef);
            mediator.unsubscribe(VideoPlaybackControlsEvent.NotifyError, this.__videoErrorRef);
            mediator.unsubscribe(VideoPlaybackStatusEvent.PlayState, this.__playStateRef);
            mediator.unsubscribe(VideoPlaybackStatusEvent.StopState, this.__playStateRef);

            this.__videoManager && this.__videoManager.deinit();
        }
    });
});
/**
 * Watchlist Model
 * @class tvedemo/model/WatchList
 */
define("tvedemo/model/WatchList", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member assetId
             * @memberof tvedemo/model/WatchList#
             * @public
             * @type {String}
             */
            "assetId": null,

            /**
             * @member catalog
             * @memberof tvedemo/model/WatchList#
             * @public
             * @type {String}
             */
            "catalog": null,

            /**
             * @member insertData
             * @memberof tvedemo/model/WatchList#
             * @public
             * @type {Date}
             */
            "insertDate": null,

            /**
             * @member platform
             * @memberof tvedemo/model/WatchList#
             * @public
             * @type {string}
             */
            "platform": null,

            /**
             * @member assetType
             * @memberof tvedemo/model/WatchList#
             * @public
             * @assetType {string}
             */
            "assetType": null
        }
    }, {});
});
/**
 * WatchList Builder, for building the WatchList model
 * @class tvedemo/model/WatchList
 */
define("tvedemo/model/WatchListBuilder", ["xdk-base/class", "tvedemo/model/WatchList"], function (klass, WatchList) {

    var WatchListBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/WatchListBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the assetId for building the model.
         * @param {String} value the identifier
         * @returns {tvedemo/model/WatchList} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/WatchListBuilder#
         */
        setAssetId: function (value) {
            this._attrs.assetId = value;
            return this;
        },

        /**
         * Set the catalog for building this model.
         * @param {String} value the catalog
         * @returns {tvedemo/model/WatchList} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/WatchListBuilder#
         */
        setCatalog: function (value) {
            this._attrs.catalog = value;
            return this;
        },

        /**
         * Set the insertDate for building this model.
         * @param {Date} value the insertDate
         * @returns {tvedemo/model/WatchList} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/WatchListBuilder#
         */
        setInsertDate: function (value) {
            this._attrs.insertDate = value;
            return this;
        },

        /**
         * Set the platform for building this model.
         * @param {string} value the platform
         * @returns {tvedemo/model/WatchList} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/WatchListBuilder#
         */
        setPlatform: function (value) {
            this._attrs.platform = value;
            return this;
        },

        /**
         * Set the type for building this model.
         * @param {String} value the asset type
         * @returns {tvedemo/model/WatchList} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/WatchListBuilder#
         */
        setAssetType: function (value) {
            this._attrs.assetType = value;
            return this;
        },

        /**
         * Build the WatchList model.
         * @returns {tvedemo/model/WatchList} the Asset model
         * @public
         * @method
         * @memberof tvedemo/model/WatchListBuilder#
         */
        build: function () {
            return new WatchList(this._attrs);
        }
    });

    return WatchListBuilder;
});
/**
 * RecentlyWatched Model
 * @class tvedemo/model/RecentlyWatched
 */
define("tvedemo/model/RecentlyWatched", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member assetId
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {String}
             */
            "assetId": null,

            /**
             * @member title
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {String}
             */
            "title": null,

            /**
             * @member category
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {string}
             */
            "category": null,

            /**
             * @member color
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {string}
             */
            "color": null,

            /**
             * @member isHD
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {boolean}
             */
            "isHD": null,
            
            /**
             * @member fsk
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {int}
             */
            "fsk": null,

            /**
             * @member imageUrl
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {string}
             */
            "imageUrl": null,

            /**
             * @member time
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @type {time}
             */
            "time": null,

            /**
             * @member assetType
             * @memberof tvedemo/model/RecentlyWatched#
             * @public
             * @assetType {string}
             */
            "assetType": null
        }
    }, {});
});
/**
 * RecentlyWatched Builder, for building the RecentlyWatched model
 * @class tvedemo/model/RecentlyWatched
 */
define("tvedemo/model/RecentlyWatchedBuilder", ["xdk-base/class", "tvedemo/model/RecentlyWatched"], function (klass, RecentlyWatched) {

    var RecentlyWatchedBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the assetId for building the model.
         * @param {String} value the identifier
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setAssetId: function (value) {
            this._attrs.assetId = value;
            return this;
        },

        /**
         * Set the title for building this model.
         * @param {String} asset title
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setTitle: function (value) {
            this._attrs.title = value;
            return this;
        },

        /**
         * Set the category for building this model.
         * @param {string} value the category
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setCategory: function (value) {
            this._attrs.category = value;
            return this;
        },

        /**
         * Set the color for building this model.
         * @param {string} value the color
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setColor: function (value) {
            this._attrs.color = value;
            return this;
        },

        /**
         * Set the HD type for building this model.
         * @param {boolean} value if asset is HD or not
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setIsHD: function (value) {
            this._attrs.isHD = value;
            return this;
        },

        /**
         * Set the rating for building this model.
         * @param {String} asset rating
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setFsk: function (value) {
            this._attrs.fsk = value;
            return this;
        },

         /**
         * Set the imageUrl for building this model.
         * @param {String} value if asset is HD or not
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setImageUrl: function (value) {
            this._attrs.imageUrl = value;
            return this;
        },

         /**
         * Set the time for building this model.
         * @param {String} time when asset is seen by user
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setTime: function (value) {
            this._attrs.time = value;
            return this;
        },

         /**
         * Set the assetType this model.
         * @param {String} assettype
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        setAssetType: function (value) {
            this._attrs.assetType = value;
            return this;
        },

        /**
         * Set the endDate for building this model.
         * @param {Date} endDate
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatched#
         */
        setEndDate: function (endDate) {
            this._attrs.endDate = endDate;
            return this;
        },

        /**
         * Set the startDate for building this model.
         * @param {Date} startDate
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatched#
         */
        setStartDate: function (startDate) {
            this._attrs.startDate = startDate;
            return this;
        },

        /**
         * Set true if contentTargeting contains 'xbox' .
         * @param {Array} contentTargeting
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatched#
         */
        setContentTargeting: function (contentTargeting) {
            this._attrs.contentTargeting = (contentTargeting.indexOf("xbox") !== -1) ? true : false;
            return this;
        },

        /**
         * Set true if catalog is "sg" or "st".
         * @param {Array} contentTargeting
         * @returns {tvedemo/model/RecentlyWatched} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatched#
         */
        setCatalog: function (catalog){
            var catalogue  = ["sg", "st"]
            this._attrs.catalog = (catalogue.indexOf(catalog) !== -1) ? true : false;
            return this;
        },

        /**
        * Store the sky catalog in a usable way for the application.
        */
        setSkyCatalog: function(catalog) {
            this._attrs.skyCatalog = catalog

            return this;
        },
        /**
         * Build the RecentlyWatched model.
         * @returns {tvedemo/model/RecentlyWatched} the Asset model
         * @public
         * @method
         * @memberof tvedemo/model/RecentlyWatchedBuilder#
         */
        build: function () {
            return new RecentlyWatched(this._attrs);
        }
    });

    return RecentlyWatchedBuilder;
});
/**
 * User Model
 * @class tvedemo/model/User
 */
define("tvedemo/model/User", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member sessionId
             * @memberof tvedemo/model/User#
             * @public
             * @type {String}
             */
            "sessionId": null,

            /**
             * @member remainingAttempt - this field is visible for unsuccessful login
             * @memberof tvedemo/model/User#
             * @public
             * @type {int}
             */
            "remainingAttempt": null,

            /**
             * @member customerCode
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "customerCode": null,

            /**
             * @member customerId
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "customerId": null,

            /**
             * @member country
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "country": null,
            
            /**
             * @member email
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "email": null,

            /**
             * @member presentation
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "presentation": null,

            /**
             * @member firstName
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "firstName": null,

            /**
             * @member lastName
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "lastName": null,

            /**
             * @member privacyFlag
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "privacyFlag": null,

            /**
             * @member cardExpiry (in API mapped to ccExpire)
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "cardExpiry": null,
            
            /**
             * @member dunning - Dunning is the process of methodically communicating with customers to ensure the collection of accounts receivable.
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "dunning": null,
            
            /**
             * @member dayPassPurchaseAllowed (in API mapped to tvod)
             * @memberof tvedemo/model/User#
             * @public
             * @type {string}
             */
            "dayPassPurchaseAllowed": null,
            
            /**
             * @member isTCSigned (in API mapped to tcFlag)
             * @memberof tvedemo/model/User#
             * @public
             * @type {boolean}
             */
            "isTCSigned": null,
            
            /**
             * @member entitlements
             * @memberof tvedemo/model/User#
             * @public
             * @type {String[]}
             */
            "entitlements": [],
            
            /**
             * @member dayPasses - list of daypasses purchased by user
             * @memberof tvedemo/model/User#
             * @public
             * @type {String[]}
             */
            "dayPasses": [],
            
            /* Subscriptions/addOns has three properties (code, id, expire). In the API document, id is missed in the output parameters table.
            /**
             * @member subscriptions
             * @memberof tvedemo/model/User#
             * @public
             * @type {tve/model/AddonSubscription[]}
             */
            "subscriptions": [],
            
            /**
             * @member addOns - list of available snap services
             * @memberof tvedemo/model/User#
             * @public
             * @type {tve/model/AddonSubscription[]}
             */
            "addOns": []
                                 
        }
    }, {});
});
/**
 * User Builder, for building the User model
 * @class tvedemo/model/UserBuilder
 */
define("tvedemo/model/UserBuilder", ["xdk-base/class", "tvedemo/model/User"], function (klass, User) {

    var UserBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/UserBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the sessionId for building the model.
         * @param {String} identifier
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setSessionId: function (value) {
            this._attrs.sessionId = value;
            return this;
        },

        /**
         * Set the remainingAttempt for building this model.
         * @param {String} remainingAttempt
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setRemainingAttempt: function (value) {
            this._attrs.remainingAttempt = value;
            return this;
        },

        /**
         * Set the customerCode for building this model.
         * @param {string} customerCode
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setCustomerCode: function (value) {
            this._attrs.customerCode = value;
            return this;
        },

        /**
         * Set the customerId for building this model.
         * @param {string} customerId
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setCustomerId: function (value) {
            this._attrs.customerId = value;
            return this;
        },

        /**
         * Set country for building this model.
         * @param {String} country
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setCountry: function (value) {
            this._attrs.country = value;
            return this;
        },

        /**
         * Set the email for building this model.
         * @param {String} email
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setEmail: function (value) {
            this._attrs.email = value;
            return this;
        },

         /**
         * Set the presentation for building this model.
         * @param {String} presentation
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setPresentation: function (value) {
            this._attrs.presentation = value;
            return this;
        },

         /**
         * Set the firstName for building this model.
         * @param {String} firstName
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setFirstName: function (value) {
            this._attrs.firstName = value;
            return this;
        },

         /**
         * Set the lastName this model.
         * @param {String} lastName
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setLastName: function (value) {
            this._attrs.lastName = value;
            return this;
        },

         /**
         * Set the privacyFlag this model.
         * @param {String} privacyFlag
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setPrivacyFlag: function (value) {
            this._attrs.privacyFlag = value;
            return this;
        },  

         /**
         * Set the cardExpiry this model.
         * @param {String} cardExpiry
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setCardExpiry: function (value) {
            this._attrs.cardExpiry = value;
            return this;
        },
         /**
         * Set the dunning this model.
         * @param {String} dunning
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setDunning: function (value) {
            this._attrs.dunning = value;
            return this;
        },
         /**
         * Set the dayPassPurchaseAllowed this model.
         * @param {String} dayPassPurchaseAllowed
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setDayPassPurchaseAllowed: function (value) {
            this._attrs.dayPassPurchaseAllowed = value;
            return this;
        },
         /**
         * Set the isTCSigned this model.
         * @param {String} isTCSigned
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setIsTCSigned: function (value) {
            this._attrs.isTCSigned = value;
            return this;
        },
         /**
         * Set the isBookmarkOn this model.
         * @param {String} isBookmarkOn
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setBookmarkOn: function (value) {
            this._attrs.isBookmarkOn = value;
            return this;
        },
         /**
         * Set the entitlements this model.
         * @param {String[]} entitlements
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setEntitlement: function (value) {
            this._attrs.entitlements = value;
            return this;
        },
         /**
         * Set the dayPasses this model.
         * @param {String[]} dayPasses
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setDayPasses: function (value) {
            this._attrs.dayPasses = value;
            return this;
        },
         /**
         * Set the subscriptions this model.
         * @param {AddonSubscription[]} subscriptions
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setSubscriptions: function (value) {
            this._attrs.subscriptions = value;
            return this;
        },
         /**
         * Set the addOns this model.
         * @param {AddonSubscription[]} addOns
         * @returns {tvedemo/model/User} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        setAddOns: function (value) {
            this._attrs.addOns = value;
            return this;
        },


        /**
         * Build the User model.
         * @returns {tvedemo/model/User} the User model
         * @public
         * @method
         * @memberof tvedemo/model/UserBuilder#
         */
        build: function () {
            return new User(this._attrs);
        }
    });

    return UserBuilder;
});
//@TODO SKYSTORM-220. THIS IS NOT FOR PUBLIC USE, there will be seperate implementation for daypasses.
/**
 * AddonSubscription Model
 * @class tvedemo/model/AddonSubscription
 */
define("tvedemo/model/AddonSubscription", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member code - Entitlements generated by the subscription
             * @memberof tvedemo/model/AddonSubscription#
             * @public
             * @type {String}
             */
            "code": null,

            /**
             * @member id
             * @memberof tvedemo/model/AddonSubscription#
             * @public
             * @type {string}
             */
            "id": null,

            /**
             * @member expire - subscription expiration date
             * @memberof tvedemo/model/AddonSubscription#
             * @public
             * @type {date}
             */
            "expire": null
        }
    }, {});
});
//@TODO SKYSTORM-220. THIS IS NOT FOR PUBLIC USE, there will be seperate implementation for daypasses.

/**
 * AddonSubscription Builder, for building the User model
 * @class tvedemo/model/AddonSubscriptionBuilder
 */
define("tvedemo/model/AddonSubscriptionBuilder", ["xdk-base/class", "tvedemo/model/AddonSubscription"], function (klass, AddonSubscription) {

    var AddonSubscriptionBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/AddonSubscriptionBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the code for building the model.
         * @param {String} code
         * @returns {tvedemo/model/AddonSubscription} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AddonSubscriptionBuilder#
         */
        setCode: function (value) {
            this._attrs.code = value;
            return this;
        },

        /**
         * Set the id for building this model.
         * @param {String} id
         * @returns {tvedemo/model/AddonSubscription} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AddonSubscriptionBuilder#
         */
        setId: function (value) {
            this._attrs.id = value;
            return this;
        },

        /**
         * Set the expire for building this model.
         * @param {string} expire
         * @returns {tvedemo/model/AddonSubscription} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AddonSubscriptionBuilder#
         */
        setExpire: function (value) {
            this._attrs.expire = value;
            return this;
        },


        /**
         * Build the AddonSubscription model.
         * @returns {tvedemo/model/AddonSubscription} the AddonSubscription model
         * @public
         * @method
         * @memberof tvedemo/model/AddonSubscriptionBuilder#
         */
        build: function () {
            return new AddonSubscription(this._attrs);
        }
    });

    return AddonSubscriptionBuilder;
});
/**
 * Device Model
 * @class storm/model/Device
 */
define("storm/model/Device", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member id - the device id
             * @memberof storm/model/Device#
             * @public
             * @type {String}
             */
            "id": "",

            /**
             * @member activationDate - the device activation date
             * @memberof storm/model/Device#
             * @public
             * @type {String}
             */
            "activationDate": "",

            /**
             * @member platform - the device platform
             * @memberof storm/model/Device#
             * @public
             * @type {String}
             */
            "platform": ""
        }
    }, {});
});
/**
 * Device Builder, for building the Device model
 * @class storm/model/DeviceBuilder
 */
define("storm/model/DeviceBuilder", [
    "xdk-base/class",
    "storm/model/Device"
], function (
    klass,
    Device
    ) {

    "use strict";

    var DeviceBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/DeviceBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the id for building the model.
         * @param {String} id
         * @returns {storm/model/DeviceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceBuilder#
         */
        setId: function (id) {
            this._attrs.id = id;
            return this;
        },

        /**
         * Set the activationDate for building this model.
         * @param {String} activationDate
         * @returns {storm/model/DeviceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceBuilder#
         */
        setActivationDate: function (activationDate) {
            this._attrs.activationDate = activationDate;
            return this;
        },

        /**
         * Set the platform for building this model.
         * @param {string} platform
         * @returns {storm/model/DeviceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceBuilder#
         */
        setPlatform: function (platform) {
            this._attrs.platform = platform;
            return this;
        },

        /**
         * Build the Device model.
         * @returns {storm/model/Device} the Device model
         * @public
         * @method
         * @memberof storm/model/DeviceBuilder#
         */
        build: function () {
            return new Device(this._attrs);
        }
    });

    return DeviceBuilder;
});
/**
 * DeviceDetails Model
 * @class storm/model/DeviceDetails
 */
define("storm/model/DeviceDetails", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member resetDelay
             * @memberof storm/model/Device#
             * @public
             * @type {Number}
             */
            "resetDelay": "",

            /**
             * @member resetNextDay
             * @memberof storm/model/Device#
             * @public
             * @type {String}
             */
            "resetNextDay": "",

            /**
             * @member freeSlots
             * @memberof storm/model/Device#
             * @public
             * @type {Number}
             */
            "freeSlots": "",

            /**
             * @member deviceList - the list if activated devices
             * @memberof storm/model/Device#
             * @public
             * @type {Array}
             */
            "deviceList": ""
        }
    }, {});
});
/**
 * DeviceDetails Builder, for building the DeviceDetails model
 * @class storm/model/DeviceDetailsBuilder
 */
define("storm/model/DeviceDetailsBuilder", [
    "xdk-base/class",
    "storm/model/DeviceDetails"
], function (
    klass,
    DeviceDetails
    ) {

    "use strict";

    var DeviceDetailsBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/DeviceDetailsBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the resetDelay for building the model.
         * @param {Number} resetDelay
         * @returns {storm/model/DeviceDetailsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceDetailsBuilder#
         */
        setResetDelay: function (resetDelay) {
            this._attrs.resetDelay = resetDelay;
            return this;
        },

        /**
         * Set the resetNextDay for building this model.
         * @param {String} resetNextDay
         * @returns {storm/model/DeviceDetailsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceDetailsBuilder#
         */
        setResetNextDay: function (resetNextDay) {
            this._attrs.resetNextDay = resetNextDay;
            return this;
        },

        /**
         * Set the freeSlots for building this model.
         * @param {Number} freeSlots
         * @returns {storm/model/DeviceDetailsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceDetailsBuilder#
         */
        setFreeSlots: function (freeSlots) {
            this._attrs.freeSlots = freeSlots;
            return this;
        },

        /**
         * Set the deviceList for building this model.
         * @param {Array<Device>} deviceList
         * @returns {storm/model/DeviceDetailsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DeviceDetailsBuilder#
         */
        setDeviceList: function (deviceList) {
            this._attrs.deviceList = deviceList;
            return this;
        },

        /**
         * Build the DeviceDetails model.
         * @returns {storm/model/DeviceDetails} the DeviceDetails model
         * @public
         * @method
         * @memberof storm/model/DeviceDetailsBuilder#
         */
        build: function () {
            return new DeviceDetails(this._attrs);
        }
    });

    return DeviceDetailsBuilder;
});
/**
 * Returns a singleton responsible for end user features and UI-side state
 * @name sEndUserManager
 * @memberof tvedemo/mgr
 * @class tvedemo/mgr/sEndUserManager
 */
define("tvedemo/mgr/sEndUserManager", [
    "xdk-base/ax",
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/util",
    "xdk-base/console",
    "tve/sServiceHolder",
    "xdk-base/device",
    "xdk-base/promise",
    "tve/TVEError",
    "xdk-ax/mediator",
    "tvedemo/model/WatchListBuilder",
    "storm/mgr/sAppConfigManager",
    "tvedemo/model/RecentlyWatchedBuilder",
    "tvedemo/model/UserBuilder",
    "tvedemo/model/AddonSubscriptionBuilder",
    "storm/model/DeviceBuilder",
    "storm/model/DeviceDetailsBuilder",
    "storm/mgr/sSilkMessagesManager",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sLocalStorageManager",
    "storm/helper/silkResponseHelper",
    "tvedemo/mgr/sNavigationManager",
    "storm/event/UserEvent"
], function (
    ax,
    klass,
    config,
    util,
    console,
    sServiceHolder,
    device,
    promise,
    TVEError,
    mediator,
    WatchListBuilder,
    sAppConfigManager,
    RecentlyWatchedBuilder,
    UserBuilder,
    AddonSubscriptionBuilder,
    DeviceBuilder,
    DeviceDetailsBuilder,
    sSilkMessagesManager,
    sLanguageManager,
    sLocalStorageManager,
    silkResponseHelper,
    sNavigationManager,
    UserEvent
    ) {

    "use strict";

    var stormService = sServiceHolder.getLinearContentService(),

        loggedIn = false,

        NOT_LOGGED_IN_REASON = "Unable to perform action before login.",
        KEEP_ALIVE_DELAY_NAME = "keepAliveDelay",

        filterExpiredRecords = function (rentalRecords) {
            var filteredRecords = [],

            currentTimestamp = new Date().getTime();

            for (var i = 0; i < rentalRecords.length; i++) {
            // add to the filtered list if it has not expired yet
                if (rentalRecords[i].expirationTime > currentTimestamp) {
                    filteredRecords.push(rentalRecords[i]);
                }
            }

            return filteredRecords;
        },

        __parser = (function () {
            var parser = {};

            var parseAddonSubscriptions = function(object) {

                var addonSubscriptionBuilder = new AddonSubscriptionBuilder(),
                    addonSubscriptionModel,

                    parsedAddonSubscription = {
                        code: object.code || "",
                        id: object.id  || "",
                        expire: object.expire || ""
                    };

                addonSubscriptionModel = addonSubscriptionBuilder.setCode(parsedAddonSubscription.code)
                                        .setId(parsedAddonSubscription.id)
                                        .setExpire(parsedAddonSubscription.expire).build();

                return addonSubscriptionModel;
            };

            parser.parseAddonSubscriptions = parseAddonSubscriptions;

            var parseUser = function (userObject) {
                var userBuilder = new UserBuilder(),
                    userModel, subscriptions = [], addOns = [],

                    parsedUserObject = {
                        sessionId: userObject.skygoSessionId,
                        remainingAttempt: userObject.remainingAttempt || "",
                        customerCode: userObject.customerCode || "",
                        customerId: userObject.customerId || "",
                        country: userObject.country || "",
                        email: userObject.email || "",
                        presentation: userObject.presentation || "",
                        firstName: userObject.firstName || "",
                        lastName: userObject.lastName || "",
                        privacyFlag: userObject.privacyFlag || "",
                        cardExpiry: userObject.ccExpire || "",
                        dunning: userObject.dunning || "",
                        dayPassPurchaseAllowed: userObject.tvod || "",
                        isTCSigned: userObject.tcFlag === "Y" ? true : false,
                        isBookmarkOn: userObject.bookmarkFlag === "Y" ? true : false,
                        entitlements: userObject.entitlements || [],
                        dayPasses: userObject.dayPasses || []
                    };


                parsedUserObject.subscriptions =userObject.subscriptions;
                parsedUserObject.addOns = userObject.addOns;

                if (parsedUserObject.subscriptions && parsedUserObject.subscriptions.length > 0) {
                    subscriptions = util.map(parsedUserObject.subscriptions, function (subscription) {
                        return parseAddonSubscriptions(subscription);
                    });
                }

                //@TODO SKYSTORM-220 - DO not use addOn as of now.
                if (parsedUserObject.addOns && parsedUserObject.addOns.length > 0) {
                    addOns = util.map(parsedUserObject.addOns, function (addOn) {
                        return parseAddonSubscriptions(addOn);
                    });
                }

                userModel = userBuilder.setSessionId(parsedUserObject.sessionId)
                                       .setRemainingAttempt(parsedUserObject.url)
                                       .setCustomerCode(parsedUserObject.customerCode)
                                       .setCustomerId(parsedUserObject.customerId)
                                       .setCountry(parsedUserObject.country)
                                       .setEmail(parsedUserObject.email)
                                       .setPresentation(parsedUserObject.presentation)
                                       .setFirstName(parsedUserObject.firstName)
                                       .setLastName(parsedUserObject.lastName)
                                       .setPrivacyFlag(parsedUserObject.privacyFlag)
                                       .setCardExpiry(parsedUserObject.cardExpiry)
                                       .setDunning(parsedUserObject.dunning)
                                       .setDayPassPurchaseAllowed(parsedUserObject.dayPassPurchaseAllowed)
                                       .setIsTCSigned(parsedUserObject.isTCSigned)
                                       .setBookmarkOn(parsedUserObject.isBookmarkOn)
                                       .setEntitlement(parsedUserObject.entitlements)
                                       .setDayPasses(parsedUserObject.dayPasses)
                                       .setSubscriptions(subscriptions)
                                       //@TODO SKYSTORM-220 - DO not use addOn as of now.
                                       .setAddOns(addOns)
                                       .build();

                return userModel;
            };
            parser.parseUser = parseUser;

            parser.parseDevice = function(deviceObj) {
                var modelBuilder = new DeviceBuilder();
                modelBuilder.setId(deviceObj.deviceId).setActivationDate(deviceObj.activationDate).setPlatform(deviceObj.platform);
                return modelBuilder.build();
            };


            //
            // parseDeviceDetails treats undefined (as opposed to a proper device details object) as 'no devices (ever?) registered'.
            //

            parser.parseDeviceDetails = function(deviceDetailsObj) {
                var modelBuilder = new DeviceDetailsBuilder(),
                    devices = [];

                if (!util.isUndefined(deviceDetailsObj)) {
                    modelBuilder.setResetDelay(deviceDetailsObj.deviceResetDelay)
                        .setResetNextDay(deviceDetailsObj.deviceResetNextDay)
                        .setFreeSlots(deviceDetailsObj.freeSlots);
                    if (deviceDetailsObj.deviceList && deviceDetailsObj.deviceList.length) {
                        for (var i = 0; i < deviceDetailsObj.deviceList.length; i++) {
                            devices.push(parser.parseDevice(deviceDetailsObj.deviceList[i]));
                        }
                    }
                }

                return modelBuilder.setDeviceList(devices).build();
            };

            return parser;
        }()),

    EndUserManager = klass.create({
        }, {

            LOGOUT: {
                ON_APP_EXIT: "exit",
                RETAIN_USERNAME: "retain",
                DISCARD_USERNAME: "discard"
            },

            loggedinUser: undefined,

            init: function () {
                this.__userDataUpdatedHandler = util.bind(function () {

                    this.getUserData().then(function () {
                        mediator.publish(UserEvent.UserDataUpdated);
                    });

                }, this);

                mediator.subscribe(UserEvent.UserDataRequireUpdate, this.__userDataUpdatedHandler);
            },

            /**
             * Called just to make a round trip to the backend to validate the session id.
             * @return {Promise}
             */
            checkUserSessionIsValid: function () {
                return this.getUserData();
            },

            /**
             * Retrieve user data fo currently logged in user.
             * @return {Promise} User data.
             */
            getUserData: function () {

                return stormService.getUserData({
                    sessionId: this.getUserSessionId()
                }).then(util.bind(function (response) {

                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        var customerCode, customerId;
                        // if we already had a logged-in user with customerCode, save some info
                        if (this.loggedinUser && (customerCode = this.loggedinUser.get("customerCode"))) {
                            customerId = this.loggedinUser.get("customerId");
                        }

                        this.loggedinUser = __parser.parseUser(response);

                        // after parsing our new user infos, we check that no customerCode exists and that it's the same userId as before
                        // if so, we insert the customerCode into the model
                        if ((!this.loggedinUser.get("customerCode") || !this.loggedinUser.get("customerCode").length) && customerCode && this.loggedinUser.get("customerId") === customerId) {
                            this.loggedinUser.set("customerCode", customerCode);
                        }

                        return this.loggedinUser;
                    }, this));

                }, this));
            },

            /**
             * Accept the terms and conditions agreement.
             * @param  {boolean} acceptTermsAndConditions True if the user accepts the terms and conditions agreement, itherwise false.
             * @param  {bollean} privacy                  True if user would like privacy for his/her data, otherwise false.
             * @return {Promise}                          True if user has accepted terms and conditions otherwise false.
             */
            acceptTermsAndConditions: function (user, acceptTermsAndConditions, privacy) {
                return stormService.acceptTermsAndConditions({
                    acceptTermsAndConditions: acceptTermsAndConditions ? "Y" : "N",
                    privacyFlag: privacy ? "Y" : "N",
                    sessionId: user.get("sessionId")
                }).then(util.bind(function (response) {

                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        return this.getUserData().then(util.bind(function (result) {

                            return this.checkTermsAndConditions(result);
                        }, this));

                    }, this));

                }, this));
            },

            /**
             * Check if the user has accepted the terms and conditions.
             * @param  {tvedemo/model/User} user User to check if has accedpted the ToC
             * @return {Promise}
             */
            checkTermsAndConditions: function (user) {
                var deferred = promise.defer();

                if (!user) {
                    deferred.resolve(false);
                } else {
                    deferred.resolve(user.get("isTCSigned"));
                }

                return deferred.promise;
            },

            // this method returns a promise that resolves if user is logged in
            // otherwise, it rejects it and redirect the user to the login page;
            // after a successfull login, it will move it back to the origin ctrler that requested the loginCheck
            // the "params" object will be passed in the context (context.redirectionParams) of the ctrler after sucessfull redirection
            loginCheck: function() {
                var deferred = promise.defer();
                // if user is logged, just resolve the promise
                if (this.getUserSessionId()) {
                    deferred.resolve();
                }
                // otherwise we redirect the user to the login page and reject the promise
                else {
                    mediator.publish("navigate", {
                        path: "Main/Login",
                        message: {
                            intermediateLogin: deferred
                        }
                    });
                }
                return deferred.promise;
            },

            /**
             * Log in using the specified username and pasword.
             * This function publishes _userSession_ with the result object, if login succeeds.
             * Result object:
             *  - state: _true_ for success login
             *  - username: the username of the authenticated user
             *
             * @method login
             * @public
             * @param {String} username The username
             * @param {String} password The password
             * @return {Promise.<Object>} The promise for user login}
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            login: function (username, password, forceLogout) {
                var opts = {
                    username: username,
                    password: password
                };

                return stormService.loginUser(opts).then(util.bind(function (response) {

                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        if (response.resultMessage === "KO") {

                            if (response.resultCode === silkResponseHelper.SILK_CODE.ALREADY_LOGGED_IN && forceLogout) {
                                //The user appears to be already logged into the system reaching the number of maximum concurrent sessions. To
                                //login into the system the client has to perform a call to the Session/Kill service and then retry to login.
                                opts = {
                                    sessionId: response.skygoSessionId
                                };

                                return this.__killSession(opts, username, password);
                            }

                            return promise.reject(sSilkMessagesManager.getSilkMessageForCode(response.resultCode));
                        }

                        //
                        // Remember a username for next time, if login was successful...
                        //

                        sLocalStorageManager.setStoredValue(sLocalStorageManager.KEYS.USERNAME, username);
                        
                        // Track login
                        sServiceHolder.getAnalyticsService().login(username);

                        //@TODO - return a user object instead.
                        this._delayKeepAlive();
                        this.loggedinUser = __parser.parseUser(response);
                        loggedIn = true;
                        mediator.publish("userSession", loggedIn);

                        this.__userKickedOutHandler = util.bind(function () {
                            this._discardSession(true);
                        }, this);

                        // Subscribe to user kicked out event first after the user has logged in,
                        // since if the account is already logged in on another device is already handled.
                        mediator.subscribe(UserEvent.UserSessionKickedOut, this.__userKickedOutHandler);

                        return sNavigationManager.triggerUpdateMenu(loggedIn).then(util.bind(function() {
                            return this.loggedinUser;
                        }, this));

                    }, this), function () {

                        return promise.reject(sSilkMessagesManager.getSilkMessageForCode(response.resultCode));
                    });

                },this));
            },

            /**
             * The user appears to be already logged into the system reaching the number of maximum concurrent sessions, so kill the session.
             * @method __killSession
             * @public
             * @param {opts} sessionId
             * @param {username} username
             * @return {password} password
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            __killSession: function(opts, username, password) {
                return stormService.killSession(opts).then(util.bind(function (response) {
                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        if (response.resultMessage === "KO") {

                            switch (response.resultCode) {
                                //No active session found on TIBCO or skygoSessionid null
                                case silkResponseHelper.SILK_CODE.NO_ACTIVE_SESSION:
                                case silkResponseHelper.SILK_CODE.NULL_SESSION_ID:
                                    //@TODO - show proper error popup
                                    break;
                                default:
                                    //@Default case: we must show a error popup. Need to discuss with Jason about error handling. Sky snap errorHandlinglooks ok.
                                    break;
                            }
                        }

                        return this.login(username, password);
                    }, this));

                },this), function () {

                    //@TODO - show error message
                    console.log("Failed to kill session");

                    return promise.reject("Failed to kill session");
                });
            },


            getCustomerBookmarks: function(assetId) {
                if (!this.loggedinUser) {
                    return promise.resolve(0);
                }
                
                return stormService.getCustomerBookmarks({ assetId: assetId, sessionId: this.loggedinUser.get("sessionId") }).then(function (response) {
                    // This should return an object like 
                    // { "bookmarks":[ {
                    //             "assetId":"129938",
                    //             "duration":"5600",
                    //             "bookmark":"180",
                    //             "percentage":"3"
                    //        }
                    //    ],
                    //    "resultCode":"S_100",
                    //    "resultMessage":"OK"
                    // }
                    //
                    // or for an empty bookmark
                    // {
                    //     "resultCode" : "S_263",
                    //     "resultMessage" : "OK"
                    // }
                    
                    console.log("[sEndUserManager] getCustomerBookmarks - got callback after getting a bookmark");
                    
                    var filteredPosition = 0;
                    
                    if (response && response.hasOwnProperty("bookmarks") && Array.isArray(response.bookmarks)) {
                        for (var i=0; i< response.bookmarks.length; i++) {
                            var b = response.bookmarks[i]; 
                            if (b.hasOwnProperty("assetId") && b.assetId == assetId && b.hasOwnProperty("bookmark")) {
                                filteredPosition = b.bookmark;
                                break;
                            }
                        }
                    }
                    
                    return filteredPosition;
                }, function() {
                    console.warn("Error reading the bookmark with with assetID: " + assetId);
                    return promise.resolve(0);
                });
            },

            /**
             * The client is able to send trough SILK to Tibco the choice of the customer about the possibility to allow the Bookmark feature.
             * @method updateCustomerBookmarkFlag
             * @public
             * @param {opts} sessionId
             * @param {bookmarkFlag} bookmarkFlago
             * @return {object} resultCode,ResultMessage
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            updateCustomerBookmarkFlag: function () {
                var opts = {
                    sessionId: this.loggedinUser.get("sessionId"),
                    bookmark: this.loggedinUser.get("isBookmarkOn") === true ? "N" : "Y"
                };
                return stormService.toggleBookmarkRequest(opts);
            },
            /**
             * Log out the current user session.
             * This function publishes _userSession_ with the result object.
             * Result object:
             *  - state: _false_ for success logout
             *
             * @method logout
             * @param {String} logoutFlavour What kind of logout is this?
             * @public
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            logout: function (logoutFlavour) {
                //
                // Explicit logout action ought to make us discard any stored username.
                //

                if (logoutFlavour === this.LOGOUT.DISCARD_USERNAME) {
                    sLocalStorageManager.setStoredValue(sLocalStorageManager.KEYS.USERNAME);
                }

                if (!loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                var opts = {
                    sessionId: this.loggedinUser.get("sessionId")
                };

                return stormService.logoutUser(opts).then(util.bind(function (response) {

                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT, silkResponseHelper.MODE.BLOCK_EVENTS).then(util.bind(function () {

                        if (response.resultMessage === "KO") {

                            if (response.resultCode !== silkResponseHelper.SILK_CODE.USER_NOT_FOUND_ON_SILK_CACHE) {
                                return promise.reject(sSilkMessagesManager.getSilkMessageForCode(response.resultCode));
                            }

                        }
                        
                        // Track logout
                        sServiceHolder.getAnalyticsService().logout();

                        if (logoutFlavour === this.LOGOUT.ON_APP_EXIT) {
                            return promise.resolve("Ready to exit");

                        } else {
                            return this._discardSession();
                        }

                    }, this));

                }, this));
            },

            _discardSession: function(bAlertUser) {
                ax.util.clearDelay(KEEP_ALIVE_DELAY_NAME); // ... because if we try a keep alive with no session we might mishandle the 'no session' response!
                if (loggedIn) {
                    loggedIn = false;
                    this.loggedinUser = null;
                    mediator.publish("userSession", loggedIn);

                    // Unsubscribe to user kicked out when user has logged out.
                    mediator.unsubscribe(UserEvent.UserSessionKickedOut, this.__userKickedOutHandler);

                    return sNavigationManager.triggerUpdateMenu(false).then(function() {
                        if (bAlertUser) {
                            console.warn("Session discarded, and user has been warned!");
                            mediator.publish(UserEvent.UserHasBeenLoggedOut);
                        }
                    });
                } else {
                    return promise.resolve();
                }
            },

            /**
             * With KeepAlive operation, the client is able to refresh an existing session on SILK layer,
             * avoiding having the session expired after 20 minutes.
             * @method _keepAlive
             * @private
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            _keepAlive: function() {
                var skygoSessionId = this.getUserSessionId();

                if (!skygoSessionId) {
                    console.warn("Can't keep alive with no session id");
                    return;
                }

                stormService.keepAlive(skygoSessionId).then(util.bind(function (response) {
                    silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        if (response.resultMessage === "OK") {
                            this._delayKeepAlive();
                        } else {
                            this._discardSession(true);
                        }

                    }, this));

                },this),function (problem) {
                    console.warn("Keep alive failed due to " + problem);
                });
            },

            /**
             * wait and then refresh / sustain a SILK session
             * @method _delayKeepAlive
             * @private
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            _delayKeepAlive: function() {
                ax.util.clearDelay(KEEP_ALIVE_DELAY_NAME); // ... because _delayKeepAlive might be called not as a result of that timer.
                sAppConfigManager.getSessionKeepAlivePeriod().then(ax.util.bind(function (requiredDelay) {
                    ax.util.delay(requiredDelay / 1000, KEEP_ALIVE_DELAY_NAME).then(ax.util.bind(function() {
                        this._keepAlive();
                    }, this));
                }, this), function (problem) {
                    console.warn("Session keep alive not scheduled due to " + problem);
                });
            },

            /**
             * fetch watchList for User
             * @method getUserWatchList
             * @public
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            getUserWatchList: function() {

                if (!this.loggedinUser) {
                    // Return an empty list if the user has somehow ended up not logged in at this point.
                    return promise.resolve([]);
                }

                return stormService.getUserWatchList(this.loggedinUser.get("sessionId")).then(util.bind(function (response) {
                    // Use SILENT mode, as we'll gracefully handle errors in this area, as part of the watchlist UI...
                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(function() {
                        var watchListBuilder=null,
                            watchListModels = [], watchList=null;

                        //There can be multiple items in the watchlist.
                        if(response.watchlist) {
                            util.each(response.watchlist, function(watchListItem){
                                watchListBuilder = new WatchListBuilder();
                                watchList = watchListBuilder.setAssetId(watchListItem.assetId)
                                    .setCatalog(watchListItem.catalog)
                                    .setInsertDate(watchListItem.insertDate)
                                    .setPlatform(watchListItem.platform)
                                    .setAssetType(watchListItem.type)
                                    .build();
                                watchListModels.push(watchList);
                            });

                        }

                        return watchListModels;
                    }, util.bind(function() {
                        switch (response.resultCode) {
                            case silkResponseHelper.SILK_CODE.NO_DATA_FOUND:
                                return promise.reject(sLanguageManager.getString("Mystuff.Mystuff_labelno_watchlist_desc"));

                            default:
                                console.warn("Treating unexpected SILK response " + response.resultCode + " as no data");
                                // Also no data found, just less explicitly so!
                                return promise.reject(sLanguageManager.getString("Mystuff.Mystuff_labelno_watchlist_desc"));
                        }
                    }, this));

                }, this), function (response) {
                    console.warn("Bad failure trying to get watchlist: " + response);
                    return promise.reject(sLanguageManager.getString("Mystuff.Mystuff_labelno_watchlist_desc"));
                });
            },

            /**
             * Check if an asset is present in user's watchlist.
             * @param  {String[]} assetIds Ids of the assets to be cecked if they are present in the user's watchlist.
             * @return {Promise<boolean>}  True if assets are present in user's watchlist otherwise false.
             */
            checkIfAssetIsInUserWatchList: function (assetIds) {

                if (!this.loggedinUser) {
                    return promise.resolve(false);
                }

                return this.getUserWatchList().then(function (watchlist) {
                    var isInWatchList = false,
                        watchlistIds = [];

                    util.each(watchlist, function (watchListItem) {
                        watchlistIds.push(watchListItem.get("assetId"));
                    });

                    isInWatchList = util.every(assetIds, function (assetId) {
                        return watchlistIds.indexOf(assetId) !== -1;
                    });

                    return isInWatchList;
                }, function() {
                    return false; // We promised a boolean, not a string explaining why the watchlist couldn't be retrieved!
                });
            },

            /**
             * add asset to the userWatchList
             * @method addAssetToUserWatchList
             * @public
             * @param {opts} assetId string matching regex ^\d+(,\d+)*$
             * @return {opts} assetType
             * @memberOf tvedemo/mgr/sEndUserManager#chal
             */
            addAssetToUserWatchList: function(opts) {

                if (!this.loggedinUser) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return stormService.addAssetToUserWatchList(opts, this.loggedinUser.get("sessionId")).then(util.bind(function (response) {
                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        if (response.resultMessage === "KO") {

                            // @TODO: Error handling, UI.
                            //User is logged in but the session has been not active, call KeepAlive method to refresh the session
                            if ((response.resultCode === silkResponseHelper.SILK_CODE.USER_NOT_FOUND_ON_SILK_CACHE) || (response.resultCode === silkResponseHelper.SILK_CODE.NULL_SESSIONID)) {
                                //this.keepAlive();
                            }
                            else {
                                //@Default case: we must show a error popup. Need to discuss with Jason about error handling. Sky snap errorHandlinglooks ok.
                            }

                            return false;

                        } else {
                            return true;
                        }

                    }, this));

                },this),function (){
                    // @TODO: Error handling, UI.
                        console.error("addAssetToUserWatchList failed");
                    });
            },

            /**
             * remove asset from the userWatchList
             * @method removeAssetFromWatchList
             * @public
             * @param {opts} sessionId
             * @param {opts} assetId
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            removeAssetFromWatchList: function(opts) {

                if (!this.loggedinUser) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return stormService.removeAssetFromWatchList(opts, this.loggedinUser.get("sessionId")).then(util.bind(function (response) {

                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                        if (response.resultMessage === "KO") {

                            // @TODO: Error handling, UI.

                            //User is logged in but the session has been not active, call KeepAlive method to refresh the session
                            if ((response.resultCode === silkResponseHelper.SILK_CODE.USER_NOT_FOUND_ON_SILK_CACHE) || (response.resultCode === silkResponseHelper.SILK_CODE.NULL_SESSIONID)) {
                                //this.keepAlive();
                            }
                            else {
                                //@Default case: we must show a error popup. Need to discuss with Jason about error handling. Sky snap errorHandlinglooks ok.
                            }

                            return false;

                        } else {
                            return true;
                        }

                    }, this));

                },this),function (){

                    // @TODO: Error handling, UI.
                        console.error("removeAssetFromWatchList failed");
                    });
            },

            /**
             * fetch recently watched items by User
             * @method getRecentlyWatched
             * @public
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            getRecentlyWatched: function() {

                if (!this.loggedinUser) {
                    // Return an empty list if the user has somehow ended up not logged in at this point.
                    return promise.resolve([]);
                }

                return stormService.getRecentlyWatched(this.loggedinUser.get("sessionId")).then(function (response) {

                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(function () {

                        if (response.resultMessage === "OK") {

                            var recentlyWatchedBuilder=null,
                            recentlyWatchModels = [], recentlyWatched=null;

                            //There can be multiple items in the watchlist.
                            if(response.lastWatchedList) {
                                util.each(response.lastWatchedList, function(lastWatchedListItem){
                                    recentlyWatchedBuilder = new RecentlyWatchedBuilder();
                                    // FIX: the SILK doc says that the hd flag is called 'isHD'; overwer it seems that the actual name is 'isHd'
                                    lastWatchedListItem.isHD = util.isUndefined(lastWatchedListItem.isHD) ? lastWatchedListItem.isHd : lastWatchedListItem.isHD;
                                    recentlyWatched = recentlyWatchedBuilder.setAssetId(lastWatchedListItem.assetId).setTitle(lastWatchedListItem.title)
                                                .setCategory(lastWatchedListItem.category).setColor(lastWatchedListItem.color)
                                                .setIsHD(lastWatchedListItem.isHD).setFsk(lastWatchedListItem.fsk).setImageUrl(lastWatchedListItem.imageUrl)
                                                .setTime(lastWatchedListItem.time).setAssetType(lastWatchedListItem.type)
                                                .setStartDate(lastWatchedListItem.publishStartDate).setEndDate(lastWatchedListItem.publishEndDate)
                                                .setContentTargeting(lastWatchedListItem.contentTargeting).setCatalog(lastWatchedListItem.catalog).setSkyCatalog(lastWatchedListItem.catalog).build();
                                    recentlyWatchModels.push(recentlyWatched);
                                });

                            }

                            return recentlyWatchModels;
                        }

                        // @TODO: This needs an ELSE clause, for situations where silk returns a KO (eg, user session not found).
                    });

                },function (){
                    // @TODO: This is not effective error handling?
                        console.error("getRecentlyWatched failed");
                    });
            },

            /**
             * add asset to recently watchedList
             * @method addAssetToRecentlyWatched
             * @public
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            addAssetToRecentlyWatched: function(options) {
                options = options || {};

                ax.util.extend(options, {
                    sessionId: this.loggedinUser.get("sessionId")
                });

                return stormService.addAssetToRecentlyWatched(options).then(function (response) {
                    return silkResponseHelper.skimSilkResponse(response, silkResponseHelper.MODE.SILENT).then(function () {

                        if (response.resultMessage === "OK") {
                            return promise.resolve("Successfully added to recently watched.");

                        } else {
                            return promise.reject("Failed to add to recently watched.");
                        }

                    });

                },function (){
                    console.error("addAssetToRecentlyWatched failed");
                });
            },

            /**
             * get the device details
             * @method getDeviceDetails
             * @public
             * @return {Promise<DeviceDetails>}  model object of the device details
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            getDeviceDetails: function() {
                var deviceDetailsDeferred = promise.defer();

                stormService.getDeviceDetails({sessionId: this.getUserSessionId()}).then(function(data) {
                    silkResponseHelper.skimSilkResponse(data, silkResponseHelper.MODE.SILENT).then(function () {
                        if (data.resultMessage === "OK") {
                            deviceDetailsDeferred.resolve(__parser.parseDeviceDetails(data));
                        }

                        // Avoid displaying multiple session invalidated popups.
                        if (data.resultCode === silkResponseHelper.SILK_CODE.USER_NOT_FOUND_ON_SILK_CACHE) {
                            deviceDetailsDeferred.reject(undefined);
                        }

                        deviceDetailsDeferred.reject(sSilkMessagesManager.getSilkMessageForCode(data.resultCode));
                    }, function(e) {
                        console.warn("silkResponseHelper.skimSilkResponse rejected " + e);

                        // Magic value T_402 means 'no devices registered' (or, maybe, no devices have ever been registered).
                        if (data.resultCode === silkResponseHelper.SILK_CODE.DOMAIN_NOT_EXISTING) {
                            deviceDetailsDeferred.resolve(__parser.parseDeviceDetails(undefined));
                        } else {
                            deviceDetailsDeferred.reject(e);
                        }
                    });
                }, function(e) {
                    console.warn("stormService.getDeviceDetails response skim rejected " + e);

                    deviceDetailsDeferred.reject(e);
                });

                return deviceDetailsDeferred.promise;
            },

            /**
             * reset the device list
             * @method resetDeviceList
             * @public
             * @return {Promise<boolean>}  success/failure of the operation
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            resetDeviceList: function() {
                return stormService.resetDeviceList({sessionId: this.getUserSessionId()}).then(function(data) {

                    return silkResponseHelper.skimSilkResponse(data, silkResponseHelper.MODE.SILENT).then(function () {

                        if (data.resultMessage === "OK") {
                            return true;
                        }

                        // Avoid displaying multiple session invalidated popups.
                        if (data.resultCode === silkResponseHelper.SILK_CODE.USER_NOT_FOUND_ON_SILK_CACHE) {
                            return promise.reject(undefined);
                        }

                        return promise.reject(sSilkMessagesManager.getSilkMessageForCode(data.resultCode));
                    });
                });
            },

            /**
             * Check currently logged in users privileges to watch content.
             * @param  {tvedemo/model/Asset} asset Asset to check if user has rights to watch.
             * @return {Promise<boolean>}          True if user has rights to watch, otherwise false.
             */
            checkUserPrivileges: function (asset) {
                if (!asset) {
                    return promise.resolve(undefined); // Rejecting the promise would entail a lot of refactoring elsewhere, eg on promise.all instances.
                }

                var assetPackageCode = asset.get("packageCode"),
                    privilegeToWatch = false;
                    
                //console.log(asset.get("name") + " packageCode = " + assetPackageCode);
                //console.log("privilegeToWatch = " + privilegeToWatch);

                //console.log("Check if asset contains package code");
                if (!assetPackageCode) {
                    // If the asset does not contain any package code it is considered as being available to everyone.
                    privilegeToWatch = true;
                    //console.log("privilegeToWatch = " + privilegeToWatch);
                    return promise.resolve(privilegeToWatch);
                }
                //console.log("privilegeToWatch = " + privilegeToWatch);

                //console.log("Check if user is logged in");
                if (!loggedIn) {
                    // If user is not logged in they are not allowed to watch content that has a packageCode.
                    privilegeToWatch = false;
                    //console.log("privilegeToWatch = " + privilegeToWatch);
                    return promise.resolve(privilegeToWatch);
                }
                //console.log("privilegeToWatch = " + privilegeToWatch);

                //console.log("Check if user has access to this package");
                util.each(this.loggedinUser.get("entitlements"), function (entitlement) {
                    if (entitlement === assetPackageCode) {
                        privilegeToWatch = true;
                        //console.log("privilegeToWatch = " + privilegeToWatch);
                        return util.breaker;
                    }
                });
                //console.log("privilegeToWatch = " + privilegeToWatch);

                return promise.resolve(privilegeToWatch);
            },

            /**
             * Get the SILK / back end session id of the currently logged in user.
             * @method getUserSessionId
             * @public
             * @return {String} the skygo Session Id
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            getUserSessionId: function () {
                return this.loggedinUser && this.loggedinUser.get("sessionId");
            },

            /**
             * Get the login status
             * @method getLoginStatus
             * @public
             * @return {Bool} whether it's in a logged in status
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            getLoginStatus: function () {
                return loggedIn || false;
            },

            /**
             * Get the logged in User object
             * @method getLoggedInUser
             * @return {object | undefined}  user object
             * @memberOf tvedemo/mgr/sEndUserManager#
             */
            getLoggedInUser: function() {

                return this.getUserData().then(util.bind(function () {

                    return this.loggedinUser || undefined;
                }, this));
            },

            /**
             * Get the favorite movies of the current user.
             * @method getFavoriteMovies
             * @public
             * @returns {Promise.<Array>} a movie list
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getFavoriteMovies: function () {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }
                return this.__userSettingService.getSharedSetting("favoriteMovies");
            },

            /**
             * Add a movie to favorite list by the movie ID
             * @method addFavoriteMovieById
             * @public
             * @param {String} assetId the ID of the movie
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addFavoriteMovieById: function (assetId) {
                return this.__addFavoriteAssetHelper("favoriteMovies", assetId);
            },

            /**
             * Remove a movie from favorite list by the movie ID
             * @method removeFavoriteMovieById
             * @public
             * @param {String} assetId the ID of the movie
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            removeFavoriteMovieById: function (assetId) {
                return this.__removeFavoriteAssetHelper("favoriteMovies", assetId);
            },

            /**
             * Check if a movie is in favorite list by the movie ID
             * @method checkFavoriteForMovieById
             * @public
             * @param {String} assetId the ID of the movie
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            checkFavoriteForMovieById: function (assetId) {
                return this.__checkFavoriteAssetHelper("favoriteMovies", assetId);
            },

            /**
             * Get the favorite movies of the current user.
             * @method getFavoriteShows
             * @public
             * @returns {Promise.<Array>} a show list
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getFavoriteShows: function () {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }
                return this.__userSettingService.getSharedSetting("favoriteShows");
            },

            /**
             * Add a show to favorite list by the show ID
             * @method addFavoriteShowById
             * @public
             * @param {String} assetId the ID of the show
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addFavoriteShowById: function (assetId) {
                return this.__addFavoriteAssetHelper("favoriteShows", assetId);
            },

            /**
             * Remove a show from favorite list by the show ID
             * @method removeFavoriteShowById
             * @public
             * @param {String} assetId the ID of the show
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            removeFavoriteShowById: function (assetId) {
                return this.__removeFavoriteAssetHelper("favoriteShows", assetId);
            },

            /**
             * Check if a show is in favorite list by the show ID
             * @method checkFavoriteForShowById
             * @public
             * @param {String} assetId the ID of the show
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            checkFavoriteForShowById: function (assetId) {
                return this.__checkFavoriteAssetHelper("favoriteShows", assetId);
            },

            /**
             * Get the favorite channels of the current user.
             * @method getFavoriteChannels
             * @public
             * @returns {Promise.<Array>} a channel list
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getFavoriteChannels: function () {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("favoriteChannels");
            },

            /**
             * Add a channel to favorite list by the channel ID
             * @method addFavoriteChannelById
             * @public
             * @param {String} assetId the ID of the channel
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addFavoriteChannelById: function (assetId) {
                return this.__addFavoriteAssetHelper("favoriteChannels", assetId);
            },

            /**
             * Remove a channel from favorite list by the channel ID
             * @method removeFavoriteChannelById
             * @public
             * @param {String} assetId the ID of the channel
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            removeFavoriteChannelById: function (assetId) {
                return this.__removeFavoriteAssetHelper("favoriteChannels", assetId);
            },

            /**
             * Check if a channel is in favorite list by the chennel ID
             * @method checkFavoriteForChannelById
             * @public
             * @param {String} assetId the ID of the channel
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            checkFavoriteForChannelById: function (assetId) {
                return this.__checkFavoriteAssetHelper("favoriteChannels", assetId);
            },

            __addFavoriteAssetHelper: function (type, assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting(type).then(util.bind(function (assetArray) {
                    if (assetArray) {
                        for (var i = 0, l = assetArray.length; i < l; i++) {
                            if (assetArray[i].assetId === assetId) {
                                return null;
                            }
                        }
                        assetArray.push({
                            assetId: assetId
                        });
                        return this.__userSettingService.setSharedSetting(type, JSON.stringify(assetArray));
                    }
                    assetArray = [{
                        assetId: assetId
                    }];
                    return this.__userSettingService.setSharedSetting(type, JSON.stringify(assetArray));
                }, this));
            },

            __removeFavoriteAssetHelper: function (type, assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }
                return this.__userSettingService.getSharedSetting(type).then(util.bind(function (assetArray) {
                    if (assetArray) {
                        for (var i = 0, l = assetArray.length; i < l; i++) {
                            if (assetArray[i].assetId === assetId) {
                                assetArray.splice(i, 1);
                                return this.__userSettingService.setSharedSetting(type, JSON.stringify(assetArray));
                            }
                        }
                    }
                    return null;
                }, this));
            },

            __checkFavoriteAssetHelper: function (type, assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }
                return this.__userSettingService.getSharedSetting(type).then(function (assetArray) {
                    if (assetArray) {
                        for (var i = 0, l = assetArray.length; i < l; i++) {
                            if (assetArray[i].assetId === assetId) {
                                return true;

                            }
                        }
                    }
                    return false;
                });
            },

            /**
             * Get the expiry of the rental of a specific movie.
             * @method
             * @param {String} assetId the ID of the movie
             * @returns {Promise.<Timestamp>} the expiry in UNIX timestamp in ms
             * @throws {Promise.<tve/TVEError>} if the corresponding rental record does not exist
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getMovieRentalExpiryById: function (assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("movieRentals").then(util.bind(function (rentalRecords) {
                    if (!rentalRecords) {
                        throw new TVEError(TVEError.FACILITY.USER_SETTINGS_SERVICE, TVEError.ERROR.NOT_FOUND, "No such record");
                    }

                    // find the required movie
                    for (var i = 0, l = rentalRecords.length; i < l; i++) {
                        if (rentalRecords[i].assetId !== assetId) {
                            continue;
                        }
                        // found, return it if it has not expired yet
                        if (rentalRecords[i].expirationTime > new Date().getTime()) {
                            return rentalRecords[i].expirationTime;
                        } else {
                            throw new TVEError(TVEError.FACILITY.USER_SETTINGS_SERVICE, TVEError.ERROR.NOT_FOUND, "No valid rental in place. Maybe the rental has expired already");
                        }
                    }
                    throw new TVEError(TVEError.FACILITY.USER_SETTINGS_SERVICE, TVEError.ERROR.NOT_FOUND, "No such record");
                }, this));
            },

            /**
             * Get all rental movies
             * @method getAllMovieRentals
             * @public
             * @returns {Promise.<Object>} the rental movie list
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getAllMovieRentals: function () {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("movieRentals").then(filterExpiredRecords);
            },

            /**
             * Add a movie to the rental list
             * @method addMovieRental
             * @public
             * @param {String} assetId the ID of the movie
             * @param {String} expirationTime expiration time of the rental movie
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addMovieRental: function (assetId, expirationTime) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("movieRentals").then(util.bind(function (assetArray) {
                    if (assetArray) {
                        for (var i = 0, l = assetArray.length; i < l; i++) {
                            if (assetArray[i].assetId === assetId) {
                                assetArray[i].expirationTime = expirationTime;
                                return this.__userSettingService.setSharedSetting("movieRentals", JSON.stringify(assetArray));
                            }
                        }

                        assetArray.push({
                            assetId: assetId,
                            expirationTime: expirationTime
                        });
                        return this.__userSettingService.setSharedSetting("movieRentals", JSON.stringify(assetArray));
                    }
                    assetArray = [{
                        assetId: assetId,
                        expirationTime: expirationTime
                    }];
                    return this.__userSettingService.setSharedSetting("movieRentals", JSON.stringify(assetArray));
                }, this));
            },

            /**
             * Remove a movie from the rental list
             * @method removeMovieRentalById
             * @public
             * @param {String} assetId the ID of the movie
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            removeMovieRentalById: function (assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("movieRentals").then(util.bind(function (assetArray) {
                    if (assetArray) {
                        for (var i = 0, l = assetArray.length; i < l; i++) {
                            if (assetArray[i].assetId === assetId) {
                                assetArray.splice(i, 1);
                                return this.__userSettingService.setSharedSetting("movieRentals", JSON.stringify(assetArray));
                            }
                        }
                    }
                    return;
                }, this));
            },

            /**
             * Get last watched videos of movies and shows
             * @method getLastWatchedVideos
             * @public
             * @returns {Promise.<Object>} an object that contains a movie list and a episode list
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getLastWatchedVideos: function () {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSettings(["lastWatchedMovies", "lastWatchedEpisodes"]).then(util.bind(function (assetObj) {
                    if (assetObj && assetObj.lastWatchedMovies && assetObj.lastWatchedEpisodes) {
                        return assetObj.lastWatchedMovies.concat(assetObj.lastWatchedEpisodes);
                    }
                    return null;
                }, this));
            },

            /**
             * Add a movie to the last watched movie list
             * @method addLastWatchedMovie
             * @public
             * @param {String} assetId the ID of the movie
             * @param {String} lastPosition the latest time position of playback
             * @param {String} lastPlayedDevice the last played device's name
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addLastWatchedMovie: function (assetId, lastPosition, lastPlayedDevice) {
                return this.__addLastWatchedAsset("lastWatchedMovies", assetId, lastPosition, lastPlayedDevice);
            },

            /**
             * Get the movie from the last watched movie list by given id
             * @method getLastWatchedMovieById
             * @public
             * @param {String} assetId the ID of the movie
             * @returns {Promise.<tve/model/Asset>} the movie
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getLastWatchedMovieById: function (assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("lastWatchedMovies").then(util.bind(function (assetArray) {
                    for (var i = 0, l = assetArray.length; i < l; i++) {
                        if (assetArray[i].assetId === assetId) {
                            return assetArray[i];
                        }
                    }
                    return null;
                }, this));
            },

            /**
             * Add a episode to the last watched episode list
             * @method addLastWatchedEpisode
             * @public
             * @param {String} assetId the ID of the movie
             * @param {String} lastPosition the latest time position of playback
             * @param {String} lastPlayedDevice the last played device's name
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addLastWatchedEpisode: function (assetId, lastPosition, lastPlayedDevice) {
                return this.__addLastWatchedAsset("lastWatchedEpisodes", assetId, lastPosition, lastPlayedDevice);
            },

            /**
             * Get the episode from the last watched episode list by given id
             * @method getLastWatchedEpisodeById
             * @public
             * @param {String} assetId the ID of the episode
             * @returns {Promise.<tve/model/Asset>} the episode
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getLastWatchedEpisodeById: function (assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("lastWatchedEpisodes").then(util.bind(function (assetArray) {
                    for (var i = 0, l = assetArray.length; i < l; i++) {
                        if (assetArray[i].assetId === assetId) {
                            return assetArray[i];
                        }
                    }
                    return null;
                }, this));
            },

            __addLastWatchedAsset: function (type, assetId, lastPosition, lastPlayedDevice) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting(type).then(util.bind(function (assetArray) {
                    if (assetArray) {
                        for (var i = 0, l = assetArray.length; i < l; i++) {
                            if (assetArray[i].assetId === assetId) {
                                assetArray.splice(i, 1);
                                break;
                            }
                        }
                    } else {
                        assetArray = [];
                    }

                    assetArray.push({
                        assetId: assetId,
                        lastPosition: lastPosition,
                        lastPlayedDevice: lastPlayedDevice
                    });
                    return this.__userSettingService.setSharedSetting(type, JSON.stringify(assetArray));
                }, this));
            },

            /**
             * Get last watched channel of the current user
             * @method getLastWatchedChannel
             * @public
             * @returns {Promise.<tve/model/Channel>} the channel object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            getLastWatchedChannel: function () {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.getSharedSetting("lastWatchedChannel").then(util.bind(function (assetObj) {
                    if (assetObj) {
                        return assetObj;
                    }
                    return null;
                }, this));
            },

            /**
             * Set a channel to the last watched channel of the current user
             * @method addLastWatchedChannelById
             * @public
             * @param {Array} assetId the ID of the episode
             * @returns {Promise.<Undefined>} fulfilled with no return value
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tvedemo/mgr/sEndUserManager#
             */
            addLastWatchedChannelById: function (assetId) {
                if (!this.loggedIn) {
                    return promise.reject(NOT_LOGGED_IN_REASON);
                }

                return this.__userSettingService.setSharedSetting("lastWatchedChannel", JSON.stringify({
                    assetId: assetId
                }));
            },

            /**
             * Check if the entered pin is the correct FSK pin for the user.
             * @param  {String} fskPin     The submitted fsk pin.
             * @return {Promise<Object>}   -pinOk True if the pin was correct, otherwise false.
             *                             -remainingAttempt Number of attempts the user has left before account is blocked.
             */
            checkFskPin: function (fskPin) {

                // If no pins is entered it is impossibly the correct pin.
                // If there is no user logged in the pin is impossibly correct pin for current logged in user.
                if (!fskPin || !this.loggedinUser) {
                    return promise.resolve(false);
                }

                return stormService.checkFskPin({
                    sessionId: this.loggedinUser.get("sessionId"),
                    fskPin: fskPin
                }).then(function (result) {

                    return silkResponseHelper.skimSilkResponse(result, silkResponseHelper.MODE.SILENT).then(function () {
                        return result;
                    });
                });
            },

            deinit: function () {
                this._super();
                mediator.unsubscribe(UserEvent.UserDataRequireUpdate, this.__userDataUpdatedHandler);
            }
        });

        return new EndUserManager();
    });
/**
 * ###Introduction
 * App Router is used to navigate between the controllers
 * By setting the path, appRouter will automatically change into that page using controllerManager easily.
 *
 * ###To use the appRouter
 *
 * 1. Possible configuration in the xdk.config
 * 2. Include the AppRounter in the apps.js
 * 3. All the controllers inside the application should be extended from the {@link tvedemo/ctrl/RoutableController}
 * 4. Use mediator to publish the message in the channel "navigate" where parameter path and state in the object. "navigated event will tell you the navigation is finished."
 * E.g
 *       mediator.publish("navigate", {
 *           path: "BigController/TestDetail"
 *       });
 *
 *       mediator.subscribe("navigated",function(){
 *          //to do when finish the navigation
 *       });
 *
 * ###Flow
 * ####Assumption
 *
 * 1. Only one subcontroller inside a controller
 * 2. Path id will be based on the controllerName where"tvedemo/ctrl/Main" should be called as "Main". Possible configuration can be set the config at the beginning.
 *
 *
 * The appRouter will mainly focus on the path to navigate instead of using Controller class.
 * The path will be separate by "/". The following path is Main Controller has a Detail SubController which has a further subCOntroller called subDetail.
 * e.g Main/Detail/SubDetail
 *
 * It will find if there is subcontroller and replace the controller. If no subController, it will be opened and appended to the parent View.
 * If it is the same controller, it will also match the parameter. If the current one doesn't consist of any one of the parameter required, it will also create a new instance.
 *
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * --------- | ---------
 * Key      | approuter
 * Type     | {@link module:tvedemo/mgr/appRouter~config}
 * Desc     | The appRouter configuration
 * Default  | null
 * Usage    | {@link module:ax/config}
 *  --------------------------
 * base will be the path for controller. If base is "tvedemo/ctrl" and path you mention is "Video", it will find the amd module "tvedemo/ctrl/Video".
 *
 *e.g
 *      "approuter": {
 *          "base": "tvedemo/ctrl",
 *          "paths": {
 *              "test": "tvedemo/ctrl/Main"
 *           }
 *       }
 *
 * @module tvedemo/mgr/appRouter
 */
/*
 * @name appRouter
 * @typedef {Object} config
 * @memberof tvedemo/mgr
 * @property {String} base The base path of the path.
 * @property {Object} paths  The speific path mapping of the controller
 */
define("tvedemo/mgr/appRouter", [
    "xdk-ax/mediator",
    "xdk-ax/mvc/ControllerManager",
    "xdk-ax/mvc/AppRoot",
    "xdk-base/config",
    "xdk-base/util",
    "tvedemo/ctrl/RoutableController",
    "xdk-base/promise",
    "xdk-base/core",
    "xdk-ax/focusManager",
    "tvedemo/wgt/Loading",
    "xdk-base/console",
    "storm/helper/util",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "xdk-base/device"
], function (
    mediator,
    ControllerManager,
    AppRoot,
    config,
    util,
    RoutableController,
    promise,
    core,
    focusMgr,
    Loading,
    console,
    stormUtil,
    sEndUserManager,
    sHistoryManager,
    device
    ) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        sControllerManager = ControllerManager.singleton(),
        item,
        routerConfig = config.get("approuter", null),
        controllerList = {},
        controllerBasePath = "",
        processing = false,
        routerPaths = {
            MAIN_HOME: "Main/Home"
        };

    //update the routable controller list mapping that path id to controller module id
    if (routerConfig) {
        if (!routerConfig.base) {
            throw core.createException("appRouter", "the base is not set.");
        }

        controllerBasePath = routerConfig.base;
        //update the list path to module ID
        if (routerConfig.paths) {
            for (item in routerConfig.paths) {
                if (routerConfig.paths.hasOwnProperty(item)) {
                    controllerList[item] = routerConfig.paths[item];
                }
            }
        }
    }

    function navigateStep(param, prevStepResult) {
        var option = {},
            page = param.page,
            state = param.state,
            message = param.message,
            historySkip = param.historySkip,
            currentController,
            navigated,
            subControllers;

        //if it have prev step result
        if (prevStepResult) {
            currentController = prevStepResult.currentController;
            navigated = prevStepResult.navigated;
        } else {
            currentController = sAppRoot;
            navigated = false;
        }

        console.info("Navigate Step : " + page, state, message);

        return pageToController(page).then(function (newController) {

            // currentController might be a promise of a controller, not an actual one, so...
            var currentControllerResolved;

            if (promise.isPromise(currentController)) {
                currentControllerResolved = currentController;
            } else {
                var instantlyResolved = promise.defer();
                instantlyResolved.resolve(currentController);
                currentControllerResolved = instantlyResolved.promise;
            }

            return currentControllerResolved.then(function(resolvedCurrentController) {
                var stateSize = 0,
                    messageSize = 0,
                    targetContainer;

                subControllers = resolvedCurrentController.getSubControllers();

                if (navigated || historySkip) {
                    option = {
                        historySkip: true
                    };
                }

                //populate context with state
                if (state) {
                    option.context = util.extend(newController.getDefaultState(), state);
                } else {
                    option.context = newController.getDefaultState();
                }

                // populate context with message
                if (message && util.keys(message).length > 0) {

                    stateSize = util.keys(option.context).length;
                    messageSize = util.keys(message).length;
                    console.info("state keys: " + util.keys(option.context).join());
                    console.info("message keys: " + util.keys(message).join());
                    util.extend(option.context, message);

                    // throw exception is there's a key overlap
                    if (messageSize + stateSize !== util.keys(option.context).length) {
                        throw core.createException("appRouter", "Repeated item in state or context,");
                    }

                }

                option.historyFocus = focusMgr.getCurFocus();

                if (subControllers.length > 1) {
                    throw core.createException("appRouter", "IncorrectController, the number of subcontrollers is more than 1.");
                }

                if (!(newController.prototype instanceof RoutableController)) {
                    throw core.createException("appRouter", "the target Controller is not instance of RoutableController");
                }

                //if no subcontroller then open a new controller
                if (subControllers.length === 0) {
                    //set the state after open
                    //get the target location.Default will be the resolvedCurrentController.getView();
                    targetContainer = resolvedCurrentController.getSubControllerLocation();

                    resolvedCurrentController = sControllerManager.open(newController, targetContainer, option);

                    //wait for setup to complete
                    return promise.when(option.context.setupPending, function () {
                        option.context.setupPending = null;

                        return {
                            navigated: true,
                            currentController: resolvedCurrentController
                        };

                    });


                }

                //if it has same controller and check the state
                if (subControllers[0] instanceof newController && matchedParam(subControllers[0], state) && !option.context.__forceReload) {
                    //do nothing
                    return {
                        navigated: false,
                        currentController: subControllers[0]
                    };
                }

                //replace the current controller and set the state
                resolvedCurrentController = sControllerManager.replace(subControllers[0], newController, option);

                //wait for setup to complete
                return promise.when(option.context.setupPending, function () {
                    option.context.setupPending = null;

                    return {
                        navigated: true,
                        currentController: resolvedCurrentController
                    };

                });
            });
        });
    }


    function navigateEvtHandler(cmd) {
        var targetPath = [],
            navigated = false,
            i = 0,
            path = cmd.path || "",
            state = cmd.state || null,
            message = cmd.message || null,
            historySkip = cmd.historySkip || false,
            extendLoading = cmd.extendLoading || false,
            navigatePromise;

        if (cmd.requireLogin && !sEndUserManager.getLoginStatus()) {
            mediator.publish("navigate", {
                path: "Main/Login",
                state: {
                    redirection: {cmd: cmd}
                }
            });
            return;
        }

        //do nothing when processing back or processing navigation
        if (processing) {
            console.info("appRouter is processing. Further action is not allowed.");
            return;
        }

        processing = true;

        Loading.open();

        //interpret the targeted path
        targetPath = path.split("/");

        //handle the controller by the target Path
        for (i = 0; i < targetPath.length; i++) {
            if (!navigatePromise) {
                navigatePromise = navigateStep({
                    page: targetPath[i],
                    state: state,
                    message: message,
                    historySkip: historySkip
                });
            } else {
                navigatePromise = navigatePromise.then(util.bind(navigateStep, null, {
                    page: targetPath[i],
                    state: state,
                    message: message,
                    historySkip: historySkip
                }));
            }
        }

        navigatePromise.then(function (state) {
            navigated = state.navigated;

            console.info("finish loading");

        }).complete(function () {
            if (path === routerPaths.MAIN_HOME) {
                // NOTE: SDSLS-114: According to LG specs, we need to clear the app's internal history every time the user enters the Home.
                // We descided to do it the same way for all apps.
                sHistoryManager.clear();
            }

            //
            // @TODO: This is the point of weakness in the app at the moment, re SKYSTORM-323.
            // We close 'loading' but the new controller might have much asynchronous setup to get through!
            //
            if (!extendLoading || !navigated) {
                Loading.close();
            }
            processing = false;

            mediator.publish("navigated", cmd);
        }).done();
    }

    function matchedParam(currentController, targetParam) {
        //target then accept all cases
        if (!targetParam) {
            return true;
        }
        var item, currentParam = currentController.getState();

        //to load the current state from the parent state
        for (item in targetParam) {
            if (!util.isUndefined(currentParam[item]) && currentParam[item] !== targetParam[item]) {
                return false;
            }
        }
        return true;
    }

    //handle path
    function pageToController(path) {
        var actualPath, deferred;

        deferred = promise.defer();
        //if it can find in the predefined list
        if (controllerList[path]) {
            actualPath = controllerList[path];
        } else if (controllerBasePath) {
            actualPath = controllerBasePath + "/" + path;
            //push into the list
            controllerList[path] = actualPath;
        } else {
            throw core.createException("appRouter", "Unable to find the right controller");
        }

        //controller is not loaded
        amd.require([actualPath], function (klass) {
            deferred.resolve(klass);
        }, function () {
            deferred.reject("unable to load the module" + actualPath);
        });
        return deferred.promise;
    }


    return {
        /**
         * To active the app router
         * @method activate
         * @public
         * @memberof tvedemo/mgr/appRouter#
         */
        activate: function () {
            //listen the channel to receive the event from controllers
            mediator.subscribe("navigate", navigateEvtHandler);
        },

        /**
         * To deactivate the app router
         * @method deactivate
         * @public
         * @memberof tvedemo/mgr/appRouter#
         */
        deactivate: function () {
            mediator.unsubscribe("navigate", navigateEvtHandler);
        }
    };
});


/**
 * LifecycleEvent is an enumeration of events that take place as part of the overall application lifecycle.
 * @readonly
 * @enum {String}
 * @name LifecycleEvent
 */
define("storm/event/LifecycleEvent", {
    /**
     * Home page has been initialised for the first time.
     */
    HomePageInitialised: "LifecycleEvent:HomePageInitialised"
});
define( "storm/focusHandler", [
        "xdk-base/class",
        "xdk-ax/focusManager",
        "xdk-base/util",
        "xdk-ui-basic/Dialog",
        "tvedemo/wgt/Keyboard"
    ], function(
        klass,
        focusManager,
        util,
        Dialog,
        Keyboard
    ) {

        "use strict";

        var FocusHandler = klass.create(
            {},
            {
                init: function() {

                    // Store default focus function for future use.
                    this._defaultFocusHandler = util.bind(focusManager.focus, focusManager);

                    // Override the focushandler.
                    focusManager.focus = util.bind(function(component, options) {
                        var currentFocus = focusManager.getCurFocus(),
                            dialog = this.isComponentPartOfDialog(currentFocus);

                        // A dialog is open.
                        if (dialog) {

                            // It should be possible to navigate between components within the same dialog.
                            if (this.isPartOfSameDialog(currentFocus, component)) {
                                return this._defaultFocusHandler(component, options);

                            // Dialog is about to be closed, need to be able to continue using the app.
                            } else if (!dialog._isOpen) {
                                return this._defaultFocusHandler(component, options);

                            // In case a new dialog is about to be opened.
                            } else if (this.isComponentPartOfDialog(component)) {
                                return this._defaultFocusHandler(component, options);

                            } else if (this.isComponentPartOfKeyboard(component)) {
                                return this._defaultFocusHandler(component, options);

                            } else {

                                // Make sure correct component is focused when closing the dialog.
                                dialog._lastFocus = component;
                                return false;
                            }

                        } else {

                            // In case no dialog is open, just set focus as usual.
                            if (component && component.getRoot && component.getRoot()) {
                                return this._defaultFocusHandler(component, options);

                            } else {
                                return false;
                            }
                        }

                    }, this);
                },

                /**
                 * Check if a component is placed within a Dialog.
                 * @param  {Object}  component Component to be tested.
                 * @return {Object/Boolean}    If compoenent is placed within a dialog the dialog is returned, otherwise false.
                 */
                isComponentPartOfDialog: function(component) {
                    var comp = component;


                    // Loop through component and it's parents to see if it's part of a Dialog.
                    while (comp) {

                        if (comp instanceof Dialog) {
                            return comp;
                        }

                        comp = comp.getParent();
                    }

                    // Default return value.
                    return false;
                },

                /**
                 * Check if a component is placed within Keyboard.
                 * @param  {Object}  component Component to be tested.
                 * @return {Object/Boolean}    If compoenent is placed within keyboard the keyboard is returned, otherwise false.
                 */
                isComponentPartOfKeyboard: function(component) {
                    var comp = component;


                    // Loop through component and it's parents to see if it's part of a Dialog.
                    while (comp) {

                        if (comp instanceof Keyboard) {
                            return comp;
                        }

                        comp = comp.getParent();
                    }

                    // Default return value.
                    return false;
                },

                /**
                 * Check if two components are part of the same Dialog.
                 * @param  {Object}  firstComponent  First component to be tested.
                 * @param  {Object}  secondComponent Second component to be tested.
                 * @return {Boolean}                 True if both components are part of the same dialog, otherwise false.
                 */
                isPartOfSameDialog: function (firstComponent, secondComponent) {
                    var firstDialog = firstComponent,
                        secondDialog = secondComponent;

                    // Find dialog of first component if any exist.
                    while (firstDialog) {

                        if (firstDialog instanceof Dialog) {
                            break;
                        }

                        firstDialog = firstDialog.getParent();
                    }

                    // Find dialog of second component if any exist.
                    while (secondDialog) {

                        if (secondDialog instanceof Dialog) {
                            break;
                        }

                        secondDialog = secondDialog.getParent();
                    }

                    // Check if the components are parts of the same dialog.
                    if (firstDialog === secondDialog) {
                        return true;
                    }

                    return false;

                }
            }
        );

        return new FocusHandler({});
    }
);

/**
 * The System interface. Implement to handle the system related functionality.
 *
 * @class xdk-base/device/interface/System
 * @author Mike Leung <mike.leung@accedo.tv>
 */

define("xdk-base/device/interface/System", ["xdk-base/Interface"], function(Interface) {
    "use strict";
    var System = Interface.create("System", {
        /**
         * Setting the screen saver On/Off
         * @name setScreenSaver
         * @method
         * @abstract
         * @param {Boolean} flag True to turn on and off to turn off.
         * @return {Boolean}  Return true if success or no state change. Return false if system API not available.
         * @memberof xdk-base/device/interface/System
         */
        setScreenSaver: ["flag"],
        /**
         * Setting the system to mute/unmute.
         * @name setSystemMute
         * @method
         * @abstract
         * @param {Boolean} flag True to mute and false to unmute
         * @return {Boolean}  Return true if
         * success or no state change. Return false if system API not available.
         * @memberof xdk-base/device/interface/System
         */
        setSystemMute: ["flag"],
        /**
         * Power off the system
         * @name powerOff
         * @method
         * @abstract
         * @return {Boolean} Return false if system API not available.
         * @memberof xdk-base/device/interface/System
         */
        powerOff: [],
        /**
         * Exit the application
         * @name exit
         * @method
         * @abstract
         * @param {Object} [obj] To set the information when exit
         * @param {Boolean} [obj.toTV] True when exit back to TV source, false will go back to smartHub/App Store page.Default is true
         * @return {Boolean} Return false if system API not available.
         * @memberof xdk-base/device/interface/System
         */
        exit: [],
        /**
         * Determine whether device support mouse
         * @name hasMouse
         * @method
         * @abstract
         * @return {Boolean} Return true if the platform has pointer devices/emulation support.Return false if not available.
         * @memberof xdk-base/device/interface/System
         */
        hasMouse: [],
        /**
         * Determine whether device support hardware keyboard
         * @name hasFixedKeyboard
         * @method
         * @abstract
         * @return {Boolean} Return true if the platform has hardware keyboard support..Return false if not available.
         * @memberof xdk-base/device/interface/System
         */
        hasFixedKeyboard: [],
        /**
         * @typedef Resolution
         * @type {Object}
         * @property {Number} width in pixels
         * @property {Number} height in pixels
         * @memberof xdk-base/device/interface/System
         */
        /**
         * Get the getDisplayResolution
         * @name getDisplayResolution
         * @method
         * @abstract
         * @return {ax/device/interface/System.Resolution} Return the display resolution from of the platform.Return {width:0,height:0} if not available.
         * @memberof xdk-base/device/interface/System
         */
        getDisplayResolution: [],
        /**
         * Whether SSL is supported in the device
         * @name suportSSL
         * @method
         * @abstract
         * @return {Boolean} Return true if the platform support SSL certificate verification.
         * @memberof xdk-base/device/interface/System
         */
        supportSSL: [],
        /**
         * Get the current network status
         * @name getNetworkStatus
         * @method
         * @abstract
         * @return {Promise.<Boolean>}  Return true if the network is connected.
         * @memberof xdk-base/device/interface/System
         */
        getNetworkStatus: [],
        /**
         * Since some devices may be unable to detect the update of the dom, it may only repaint without reflow. It may cause issues on the display.
         * It provides a way to update the elements after the update and force it to redraw the element.
         * @name redraw
         * @method
         * @param {HTMLElement} [element=document.body] the target element. Default will be document.body
         * @memberof xdk-base/device/interface/System
         */
        redraw:["element"]

    });

    /**
     * The event when changes in network connection. True if network is connected
     * @event EVT_NETWORK_STATUS_CHANGED
     * @type {Boolean} 
     * @memberof xdk-base/device/interface/System
     * @example
     * //add the event listener to the system, where the event type is from the interface ax/device/interface/System.EVT_NETWORK_STATUS_CHANGED
     * Device.system.addEventListener(ISystem.EVT_NETWORK_STATUS_CHANGED, function(newStatus){
     *      //when there is status change, it will receive the new status and developers can perform action   
     *      console.log("the status changed into"+ newStatus);
     * });
     *
     */
    System.EVT_NETWORK_STATUS_CHANGED = "device:system:network-status-changed";

    /**
     * The event when changes in env size. 
     * @event EVT_RESIZE
     * @type {ax/device/interface/System.Resolution} 
     * @memberof xdk-base/device/interface/System
     * @example
     * //add the event listener to the system, where the event type is from the interface ax/device/interface/System.EVT_RESIZE
     * Device.system.addEventListener(ISystem.EVT_RESIZE, function(newResolution){
     *      //when there is resolution change
     *      console.log("the width changed into "+ newResolution.width);
     * });
     *
     */
    System.EVT_RESIZE = "device:system:resize";

    return System;
});
/**
 * To load the XDK core, TVE Blocks, and required files for starting TVE Demo.
 */
require([
    "xdk-base/Env",
    "xdk-ax/mvc/AppRoot",
    "storm/ctrl/Splash",
    "xdk-base/console",
    "xdk-base/promise",
    "tve/sAppGridServiceHolder",
    "tvedemo/mgr/appRouter",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/mgr/sEndUserManager",
    "storm/mgr/sAppConfigManager",
    "storm/mgr/sLanguageManager",
    "storm/event/LifecycleEvent",
    "xdk-base/config",
    "xdk-base/device",
    "xdk-ax/evt/type",
    "tvedemo/wgt/ConfirmDialog",
    "xdk-base/util",
    "tvedemo/wgt/Loading",
    "xdk-ax/mediator",
    "xdk-mouse/mouseHandler",
    "storm/focusHandler",
    "tvedemo/helper/dialogHelper",
    "xdk-base/device/interface/System"
], function (
    Env,
    AppRoot,
    SplashCtrl,
    console,
    promise,
    sAppGridServiceHolder,
    appRouter,
    sHistoryMgr,
    sEndUserManager,
    sAppConfigManager,
    sLanguageManager,
    LifecycleEvent,
    config,
    device,
    evtType,
    ConfirmDialog,
    util,
    sLoading,
    mediator,
    mouseHandler,
    // Just to make sure our app specific focus handler is loaded as early as possible.
    focusHandler,
    dialogHelper,
    ISystem
    ) {

    "use strict";

    var sEnv = Env.singleton(),
        sAppRoot = AppRoot.singleton(),
        flagExitPopup = false,
        DESTINATION = {
            TV: "tv",
            HUB: "smarthub"
        },

        exit = function (destination) {
            console.warn("Exiting, to destination " + destination);

            var deferUntilLoggedOut = promise.defer();

            // Show the busy animation while we exit...
            // but only on Samsung, because on LG the app only minimizes. It never really exits.
            if (device.platform === "samsung" || device.platform === "tizen") {
                sLoading.open();

                sEndUserManager.logout(sEndUserManager.LOGOUT.ON_APP_EXIT).then(function(outcome) {
                    deferUntilLoggedOut.resolve("Success: " + outcome);
                }, function(reason) {
                    if (promise.isPromise(reason)) {

                        reason.then(function (reasonMessage) {
                            var message = reasonMessage && reasonMessage.get("description");

                            deferUntilLoggedOut.resolve("Failure: " + message);
                        });

                    } else {
                        deferUntilLoggedOut.resolve("Failure: " + reason);
                    }
                });
            }
            else
            {
                sEndUserManager.logout(sEndUserManager.LOGOUT.RETAIN_USERNAME).then(function(outcome) {
                        deferUntilLoggedOut.resolve("Success!");
                }, function(reason) {

                    if (promise.isPromise(reason)) {

                        reason.then(function (reasonMessage) {
                            var message = reasonMessage && reasonMessage.get("description");

                            deferUntilLoggedOut.resolve("Failure: " + message);
                        });

                    } else {
                        deferUntilLoggedOut.resolve("Failure: " + reason);
                    }
                });
            }

            deferUntilLoggedOut.promise.then(function(forDebugPurposes) {
                console.log("Final logout: " + forDebugPurposes);
                sLoading.close();
                if (console.__sendLog) console.__sendLog();
                device.system.exit({
                    toTV: (destination === DESTINATION.TV)
                });
            });
        },

        exitKeyHandler = function (evt) {
            if (device.platform === "playstation") {
                return;
            }

            var bExitExits = (evt.id === device.vKey.EXIT.id),
                bBackExits = (evt.id === device.vKey.BACK.id && sHistoryMgr.getHistoryStack().length === 0);

            // EXIT popup
            if (bExitExits || bBackExits) {
                // Do not reshow exit confirm dialog if it is already showing...
                if (flagExitPopup || dialogHelper.isAnyDialogOpen()) {
                    return true; // allow other components to handle the event
                }

                // show confirm dialog instead of exiting directly
                var exitPopup = new ConfirmDialog({
                    css: "exit",
                    title: sLanguageManager.getString("ui.exit.title"),
                    message: sLanguageManager.getString("ui.exit.body"),
                    positiveText: sLanguageManager.getString("ui.exit.exitYesButton"),
                    negativeText: sLanguageManager.getString("ui.exit.exitNoButton"),
                    positiveAction: function () {
                        if (device.platform === "samsung" || device.platform === "tizen") {
                            exit(bExitExits?DESTINATION.TV:DESTINATION.HUB);
                        } else {
                            // If it's something other than Samsung,
                            // always exit to Launcher
                            exit(DESTINATION.HUB);
                        }
                    },
                    parent: sAppRoot.getView()
                });

                mediator.publish("exitPopup", true); // This is subscribed to by OnNow controller. Elsewhere?

                // reset to no popup
                exitPopup.addEventListener(evtType.CLOSE, function () {
                    flagExitPopup = false;
                    mediator.publish("exitPopup", false);
                });

                flagExitPopup = true;
                return false;
            }
        },

        networkFailureDialog = null,
        networkStatusChangeHandler = function (status) {
            if (status === false) {
                var replace = {
                    "device": device.platform === "playstation" ? "Playstation" : "Smart TV"
                };

                networkFailureDialog = dialogHelper.error({
                    title: sLanguageManager.getString("ui.networkFail.title"),
                    reason: sLanguageManager.getString("ui.networkFail.body", replace),
                    buttonText: sLanguageManager.getString("ui.global.retry"),
                    closeAction: function() {
                        device.system.getNetworkStatus().then(function (status) {
                            if (status) {
                                networkStatusChangeHandler(status);
                            } else {
                                exit(DESTINATION.HUB);
                            }
                        });
                    }
                });
            } else if (networkFailureDialog) {
                try {
                    networkFailureDialog.close();
                } catch (e) {
                    console.warn("Trouble closing network status popup due to " + e);
                }
                networkFailureDialog = null;
                if (!__isAppLaunched) {
                    console.warn("Invoking window.location.reload()...");
                    window.location.reload(true);
                }
            }
        },

        __isAppLaunched = false,

        __homeInitialisedObserver = function () {
            __isAppLaunched = true;
            mediator.unsubscribe(LifecycleEvent.HomePageInitialised, __homeInitialisedObserver);
        };

    sEnv.addEventListener(sEnv.EVT_ONLOAD, function () {
        sAppRoot.getView().addClass(device.id.getModel());

        mouseHandler.setMouseOnCallback(function() {
            mediator.publish("mouseOn");
        });

        mouseHandler.setMouseOffCallback(function() {
            mediator.publish("mouseOff");
        });

        mediator.subscribe(LifecycleEvent.HomePageInitialised, __homeInitialisedObserver);

        //
        // Early on we set up handling of the smart-hub key for graceful termination...
        //
        sEnv.addEventListener(sEnv.EVT_ONKEY, function (evt) {
            if (device.tvkey.constructor.SMART_HUB && evt.id === device.tvkey.constructor.SMART_HUB.id) {
                console.warn("Smart-hub key is pressed, trying to exit to HUB");
                exit(DESTINATION.HUB);
                // Why are these here? Do we need to handle CH_UP down on some platforms?
                // Does not look like it's allowed on tizen.
            } else if (device.platform !== "tizen" && device.tvkey.constructor.CH_UP && evt.id === device.tvkey.constructor.CH_UP.id) {
                console.warn("CH_UP key is pressed, trying to exit to TV");
                exit(DESTINATION.TV);
            } else if (device.platform !== "tizen" && device.tvkey.constructor.CH_DOWN && evt.id === device.tvkey.constructor.CH_DOWN.id) {
                console.warn("CH_DOWN key is pressed, trying to exit to TV");
                exit(DESTINATION.TV);
            }
        });

        appRouter.activate();

        sHistoryMgr.activate();

        sAppGridServiceHolder.getAppGridService().applicationStart().fail(function () {
            console.warn("Cannot send applicationStart to the AppGrid service");
        });

        sAppRoot.setMainController(SplashCtrl);

        sAppRoot.getView().addEventListener(evtType.KEY, exitKeyHandler, true);

        //
        // Just listening for changes doesn't seem reliable on some devices, if state has already transitioned to false.
        // Therefore perform an explicit check during startup...
        //

        device.system.getNetworkStatus().then(function(firstObservedStatus) {
            networkStatusChangeHandler(firstObservedStatus);
            device.system.addEventListener(ISystem.EVT_NETWORK_STATUS_CHANGED, networkStatusChangeHandler);
        });

    });

//
// Final tidying...
//

    sEnv.addEventListener(sEnv.EVT_ONUNLOAD, function () {
        sAppGridServiceHolder.getAppGridService().applicationStop().done();
    });

});
define("app", ["xdk-base/amd","xdk-base/domReady","../dep/dep.config.js","../dep/img.map.js","amd.config.js"], function(){});

/**
 * HTML5 media player.
 *
 * @class xdk-base/device/shared/Html5Player
 * @augments ax/device/interface/Player
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-base/device/shared/Html5Player", [
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/device/AbstractPlayer",
    "xdk-base/device/interface/Player",
    "xdk-base/device/Media",
    "xdk-base/util",
    "xdk-base/console",
    "require"
], function (
    core,
    klass,
    AbstractPlayer,
    IPlayer,
    Media,
    util,
    console,
    require) {
    "use strict";
    var sMedia = Media.singleton(),
        resolution = null,
        getResolution = function () {
            if (resolution) {
                return resolution;
            }
            resolution = require("xdk-base/device")
                .system.getDisplayResolution();
            return resolution;
        };

    var PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS;

    return klass.create(AbstractPlayer, {}, {
        /**
         * to see the html 5 player is onLoaded or not. If it is onloaded, user can seek time
         * @protected
         * @constant
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _onLoaded: false,
        /**
         * container name of the player
         * @protected
         * @constant
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _CONTAINER_NAME: "Html5PlayerContainer",
        /**
         * parent node of the player object
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _parentNode: null,
        /**
         * the player object
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _playerObject: null,
        /**
         * the init status of the player, if it isn't true, the event Listener or player may not been attached to DOM
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _prepared: false,
        /**
         * total time of the video
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _duration: 0,
        /**
         * connection time out (in sec) when the video is fail to play
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _connectionTimeLimit: 90,
        // in sec
        /**
         * store the timeout of the connection time out
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _connectionTimeOut: null,
        /**
         * to check if it is connected
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _connected: false,
        /**
         * to check if it is paused
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _pausedVideo: false,
        /**
         * if the video format HLS is supported
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _supportHLS: false,
        /**
         * if the video format DASH is supported
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _supportDASH: false,
        /**
         * to check if the video format is supported
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _support: true,
        /**
         * to check if it needs to seek before play
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _seek: false,
        /**
         * to store the time which needed to be seek
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _seekTime: 0,
        /**
         * to store the last loaded media URL
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _url: null,

        /**
         * Sets to true once the media is finished.
         * @private
         * @type {Boolean}
         * @memberof xdk-base/device/shared/Html5Player#
         */
        __hasFinished: true,

        /**
         * Sets to true after the error is reported, and further error shouldn't be reported until the next load.
         * @private
         * @type {Boolean}
         * @memberof xdk-base/device/shared/Html5Player#
         */
        __errorReported: false,

        init: function () {
            this.__bindedOnLoad = util.bind(this._onLoad, this);
            this.__bindedOnTimeUpdate = util.bind(this._onTimeUpdate, this);
            this.__bindedOnWaiting = util.bind(this._onWaiting, this);
            this.__bindedOnPlaying = util.bind(this._onPlaying, this);
            this.__bindedOnError = util.bind(this._onError, this);
            this.__bindedOnFinished = util.bind(this._onFinished, this);
            this.__bindedOnCanPlay = util.bind(this._onCanPlay, this);
            this.__bindedOnDurationChange = util.bind(this._onDurationChange, this);
            this.__bindedOnRateChange = util.bind(this._onRateChange, this);
        },

        /**
         * Prepare the player
         * @name prepare
         * @method
         * @param {object} opts The opts parameter passed from {@link xdk-base/device/Media#load|device.media.load}
         * @param {HTMLElement} [opts.parentNode] parentNode to be append the player object.
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        prepare: function (opts) {
            console.info("html5 player prepare" + opts);
            //check if prepared and check parentNode
            if (this._prepared) {
                return;
            }

            //default position to place the video object
            this._parentNode = document.getElementsByTagName("body")[0];

            //add a container to handle the object
            this._playerContainer = document.createElement("div");
            this._playerContainer.id = this._CONTAINER_NAME;
            this._playerContainer.className = "playerContainer";

            //create the player object
            this._playerObject = document.createElement("video");
            this._playerObject.id = "Html5Player";
            this._playerObject.className = "playerObject";

            this._playerContainer.appendChild(this._playerObject);
            this._parentNode.appendChild(this._playerContainer);

            this._addVideoEventListeners(this._playerObject);

            this.hide();
            this._prepared = true;
        },

        /**
         * resets the video player, to non-playing mode
         * @method
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        reset: function () {
            if (!this._prepared) {
                return;
            }
            this.hide();
            this._stopPlayback();
            this._removeVideoEventListeners(this._playerObject);
            this.deinit();
        },
        /**
         * deinit the video player and remove the eventListener
         * @method
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        deinit: function () {
            if (!this._prepared) {
                return;
            }
            this._prepared = false;
            this._stopPlayback();

            if (this._playerContainer) {
                this._playerContainer.removeChild(this._playerObject);
                this._parentNode.removeChild(this._playerContainer);
                this._playerContainer = null;
            } else {
                this._parentNode.removeChild(this._playerObject);
            }
            console.info("HTML5 video player deinit successfull.");
            return;
        },
        /**
         * play the video item
         * @method
         * @param {Object} opts object containing the required options
         * @param {Number} opts.sec Play the video at the specified second
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        play: function (opts) {
            if (this.__errorReported) {
                console.warn("[Html5Player] Play after error. A load() operation is expected to reset the state.");
                return;
            }

            console.info("[XKD HTML5] Play requested.");
            if (!this._support) {
                this._stopPlayback();
                sMedia._onError(PLAYBACK_ERRORS.RENDER.UNSUPPORTED, "unsupport format in the html5 video player");
                return;
            }

            //if stop the video and press play, it will play the previous video
            if (this.url && (!this._playerObject.getAttribute("src") || this._playerObject.getAttribute("src") !==
                    this.url)) {
                this._playerObject.setAttribute("src", this.url);
                this._playerObject.load();
            }

            this.show();

            if (!this._connected) {
                this._connected = true;
                sMedia._onConnecting();
                this._playerObject.play();
                this._removeConnectionTimeOut();
                this._connectionTimeOut = core.getGuid();
                util.delay(this._connectionTimeLimit, this._connectionTimeOut)
                    .then(util.bind(this._onConnectionTimeout, this), function () {
                        // ignore clear delay
                        return;
                    })
                    .done();

            }

            this.__hasFinished = false;
            this._pausedVideo = false;
            this._seek = false;

            //allow to set sec:0
            if (opts && !util.isUndefined(opts.sec)) {
                this._seek = true;
                this._seekTime = opts.sec;
            }

            //make sure the speed is 1.
            if (this.getPlaybackSpeed() !== 1) {
                this._playerObject.playbackRate = 1;
            }

            if (this._onLoaded) {
                //remove time out when it is onloaded
                this._removeConnectionTimeOut();
                if (this._seek && this._seekTime > 0) {
                    // create a seeked event listener that works only once
                    var play = util.bind(function () {
                        this._playerObject.removeEventListener("seeked", play);
                        //don't play the video if it is paused when seeking
                        if (this._pausedVideo) {
                            return;
                        }
                        this._playerObject.play();
                    }, this);

                    this._playerObject.addEventListener("seeked", play);
                    this.__setCurrentTime(this._seekTime);
                    this._seek = false;

                    return;
                }
            }


            this._playerObject.play();
        },
        /**
         * pause the video item
         * @method
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        pause: function () {
            console.info("[XDK HTML5] Pausing video.");
            this._pausedVideo = true;
            this._playerObject.pause();
            sMedia._onPause();
        },
        /**
         * stop the video playback
         * @method
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        stop: function () {
            console.info("[XDK HTML5] Stopping video");

            this._stopPlayback();

            sMedia._onStopped();
        },
        /**
         * stop the video playback for real
         * @method
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _stopPlayback: function () {
            this._playerObject.pause();

            this.hide();
            this._removeConnectionTimeOut();
            this._connected = false;

            //XDK-2053 Fail to set current time if the video is not loaded
            if (this._onLoaded && !this.__hasFinished) {
                this.__setCurrentTime(0);
            }
        },
        /**
         * resume playing the video
         * @method
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        resume: function () {
            console.info("[XDK HTML5] Resuming...");
            this._playerObject.play();
            this._pausedVideo = false;

            //make sure the speed is 1.
            if (this.getPlaybackSpeed() !== 1) {
                this._playerObject.playbackRate = 1;
            }
        },
        /**
         * Skip the playback forward/backward for certain seconds
         * @method
         * @param {Number} sec number of seconds to skip (10 by default)
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        skip: function (sec) {
            this.__setCurrentTime(this.getCurTime()+sec);
        },
        /**
         * Seek to specifiy position of the video
         * @method
         * @param {Number} sec the position to seek to in seconds
         * @memberof xdk-base/device/shared/Html5Player#
         */
        seek: function (sec) {
            //since it is so strange when seek the duration and no response, try to seek a sec before the end.
            if (sec === this._duration) {
                sec = Math.floor(this.getDuration() - 1);
            }
            this.__setCurrentTime(sec);
        },
        /**
         * returns playback speed
         * @method
         * @return {Number} playback speed
         * @memberof xdk-base/device/shared/Html5Player#
         * @public
         */
        getPlaybackSpeed: function () {
            return this._playerObject.playbackRate;
        },
        /**
         * Get the current playback time
         * @method
         * @return {Number} the current playback time
         * @memberof xdk-base/device/shared/Html5Player#
         * @public
         */
        getCurTime: function () {
            return this._playerObject.currentTime;
        },
        /**
         * to set the total time of the player
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @proteced
         */
        _setDuration: function () {
            this._duration = this._playerObject.duration;
        },
        /**
         * to get the total time of the video
         * @method
         * @return {number} the total time of the video
         * @memberof xdk-base/device/shared/Html5Player#
         * @public
         */
        getDuration: function () {
            return this._duration;
        },
        /**
         * Show the player
         * @method
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        show: function () {
            if (this._playerObject) {
                this._playerObject.style.visibility = "visible";
            }
        },
        /**
         * Hide the player
         * @method
         * @public
         * @memberof xdk-base/device/shared/Html5Player#
         */
        hide: function () {
            if (this._playerObject) {
                this._playerObject.style.visibility = "hidden";
            }
        },
        /**
         * Gets the player's capabilities
         * @method
         * @return {ax/device/interface/Player~PlayerCapabilites}
         * @memberof xdk-base/device/shared/Html5Player#
         */
        getCapabilities: function () {
            var cap = {
                type: ["mp4", "mp3"]
            };
            if (this._supportHLS) {
                cap.type.push("hls");
            }
            if (this._supportDASH) {
                cap.type.push("dash");
            }
            return cap;
        },
        /**
         * Loads the specified media
         * @method
         * @param {String} url the URL address of the media
         * @param {Object} [opts] the options for loading this media
         * @param {module:xdk-base/device/playerRegistry.DRM} [opts.drm] DRM to be used
         * @memberof xdk-base/device/shared/Html5Player#
         */
        load: function (mediaUrl, opts) {
            this.url = mediaUrl;
            if (!this._prepared) {
                return false;
            }

            opts = opts || {};

            // prepare the player object then do the loading
            // if the player object cannot be prepared, then skip loading
            // todo: throw exception?
            if (this._preparePlayerObject(opts)) {
                this._doLoad(mediaUrl, opts);
            }

            return mediaUrl;
        },

        /**
         * Return the readiness of the video metadata.
         * @method
         * @returns {Boolean} True if the metadata has been loaded, false otherwise.
         * @memberof xdk-base/device/shared/Html5Player#
         */
        isMetadataLoaded: function () {
            return this._onLoaded;
        },

        /**
         * Sets video window size
         * @method
         * @param {Object} param window size parameter
         * @param {Boolean} param.relativeToParent True if relative to the parent position and then use the css position:relative. \
         *                   Default will be false and use position:fixed
         * @param {Integer} param.top window top
         * @param {Integer} param.left window left
         * @param {Integer} param.width window width
         * @param {Integer} param.height window height
         * @memberof xdk-base/device/shared/Html5Player#
         */
        setWindowSize: function (obj) {
            if (!this._playerObject) {
                console.warn("[Html5Player] Fail to set the size due to no playerObject");
                return;
            }

            var objClassName = "playerObject",
                deviceResolution = getResolution();

            //determine whether it is relative to parent which add a relative class with "position:relative"
            if (obj.relativeToParent) {
                objClassName += " relative";
            }

            //determine whether it is fullscreen and add a fullscreen selector
            if (obj.width === deviceResolution.width && obj.height === deviceResolution.height) {
                objClassName += " fullscreen";
            }

            this._playerObject.className = objClassName;
            this._playerObject.style.width = obj.width + "px";
            this._playerObject.style.height = obj.height + "px";
            this._playerObject.style.left = obj.left + "px";
            this._playerObject.style.top = obj.top + "px";

            this._currentWindowSize = obj;

            return;
        },
        /**
         * Sets video window size
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         */
        setFullscreen: function () {
            var deviceResolution = getResolution();
            this.setWindowSize({
                top: 0,
                left: 0,
                height: deviceResolution.height,
                width: deviceResolution.width
            });
        },

        /**
         * Prepares the player object for the later playback.
         *
         * @method
         * @protected
         * @param {Object} opts The loading options
         * @returns {Boolean} Return true if the preparation success, false otherwise
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _preparePlayerObject: function (opts) {
            if (!this._playerObject) {
                return false;
            }

            if (opts.parentNode) {
                //move to the correct place
                if (this._playerContainer) {
                    this._parentNode.removeChild(this._playerContainer);
                    this._playerContainer = null;
                }
                this._parentNode = opts.parentNode;
                this._parentNode.appendChild(this._playerObject);
            }

            return true;
        },

        /**
         * Do the actual job to load a new media.
         *
         * @method
         * @protected
         * @param {String} mediaUrl The media url
         * @param {Object} opts The loading options
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _doLoad: function (mediaUrl, opts) {
            this.__hasFinished = false;
            this.__errorReported = false;
            this._onLoaded = false;
            this._connected = false;
            this._pausedVideo = true;
            this._playerObject.setAttribute("src", mediaUrl);
            this._playerObject.load();
            this.hide();

            if (opts.type === "mp3") {
                this.setWindowSize({
                    "width": 0,
                    "height": 0,
                    "top": 0,
                    "left": 0
                });
            }

            this._support = this._canPlayMedia(opts);
        },

        /**
         * Checks if the player could play the specific media type and drm.
         *
         * @method
         * @protected
         * @param {Object} opts The load options
         * @returns {Boolean} True if the player could play the media, false otherwise
         * @memberof xdk-base/device/shared/MultiObjectHtml5Player#
         */
        _canPlayMedia: function (opts) {
            var capabilities = this.getCapabilities();

            var type = opts.type;
            var drm = opts.drm;

            var typePass = !(type && capabilities.type.indexOf(type) === -1) || type === "*";
            var drmPass = !(drm && capabilities.drms.indexOf(drm) === -1);

            return typePass && drmPass;
        },

        /**
         * event handler for HTML5 canplay event
         * @method
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _onCanPlay: function () {
            //since it isn't onConnected, so it can't play
            if (this._pausedVideo || !this._connected) {
                return;
            }
            this._playerObject.play();
        },
        /**
         * Timeout to throw error if it is still in connecting with the connectionTimeLimit
         * @method
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _onConnectionTimeout: function () {
            this._stopPlayback();
            sMedia._onError(PLAYBACK_ERRORS.NETWORK.FAILED);
        },

        /**
         * Callback for durationchange event.
         *
         * @method
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _onDurationChange: function () {
            this._onLoaded = true;
            this._setDuration();
            this._performInitialSeek();
        },

        /**
         * Onload of the video to load the duration of the video
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _onLoad: function () {
            this._removeConnectionTimeOut();
            this._onDurationChange();

            //ignore the state change when speeding
            if (!this._connected || this.getPlaybackSpeed() !== 1) {
                return;
            }

            console.info("[XDK HTML5] onload event");
            sMedia._onBufferingStart();
            sMedia._onBufferingProgress();
        },

        /**
         * Performs the seek operation for the initial play(sec) command.
         * This should be done after the duration is ready, otherwise it won't work.
         *
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _performInitialSeek: function () {
            if (!this._seek || this._seekTime < 0) {
                return;
            }

            this.__setCurrentTime(this._seekTime);
            this._seek = false;
        },

        /**
         * Adds the event listeners to the video object.
         *
         * @method
         * @protected
         * @param {Video} video The HTML5 video object
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _addVideoEventListeners: function (video) {
            video.addEventListener("loadedmetadata", this.__bindedOnLoad);
            video.addEventListener("waiting", this.__bindedOnWaiting);
            video.addEventListener("timeupdate", this.__bindedOnTimeUpdate);
            video.addEventListener("seeking", this.__bindedOnWaiting);
            video.addEventListener("seeked", this.__bindedOnPlaying);
            video.addEventListener("playing", this.__bindedOnPlaying);
            video.addEventListener("error", this.__bindedOnError);
            video.addEventListener("ended", this.__bindedOnFinished);
            video.addEventListener("canplay", this.__bindedOnCanPlay);
            video.addEventListener("durationchange", this.__bindedOnDurationChange);
            video.addEventListener("ratechange", this.__bindedOnRateChange);
        },

        /**
         * Removes the event listeners from the video object.
         *
         * @method
         * @protected
         * @param {Video} video The HTML5 video object
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _removeVideoEventListeners: function (video) {
            video.removeEventListener("loadedmetadata", this.__bindedOnLoad);
            video.removeEventListener("waiting", this.__bindedOnWaiting);
            video.removeEventListener("timeupdate", this.__bindedOnTimeUpdate);
            video.removeEventListener("seeking", this.__bindedOnWaiting);
            video.removeEventListener("seeked", this.__bindedOnPlaying);
            video.removeEventListener("playing", this.__bindedOnPlaying);
            video.removeEventListener("error", this.__bindedOnError);
            video.removeEventListener("ended", this.__bindedOnFinished);
            video.removeEventListener("canplay", this.__bindedOnCanPlay);
            video.removeEventListener("durationchange", this.__bindedOnDurationChange);
            video.removeEventListener("ratechange", this.__bindedOnRateChange);
        },

        /**
         * To remove the connection time out set when set Media url and play
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _removeConnectionTimeOut: function () {
            if (this._connectionTimeOut !== null) {
                util.clearDelay(this._connectionTimeOut);
                this._connectionTimeOut = null;
            }
        },
        /**
         * to invoke the waiting msg
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _onWaiting: function () {
            if (sMedia.isState(sMedia.CONNECTING) || this.__needBlockStateChange()) {
                return;
            }
            console.info("[xdk html5] waiting");
            sMedia._onBufferingStart();
            sMedia._onBufferingProgress();
        },
        /**
         * __needBlockStateChange, when it is not connected or speeding, try to block the state change and maintain the state.
         * @method
         * @returns {Boolean} True if the need to block the state change
         * @memberof xdk-base/device/shared/Html5Player#
         * @private
         */
        __needBlockStateChange: function () {
            return !this._connected || (this.getPlaybackSpeed() !== 1);
        },
        /**
         * _onPlaying to be invoked when the player play
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _onPlaying: function () {
            //ignore the state change when speeding
            if (this.__needBlockStateChange()) {
                return;
            }
            console.info("[xdk html5] onplaying event");
            this._removeConnectionTimeOut();
            if (!this._pausedVideo) {
                sMedia._onPlaying();
            } else {
                sMedia._onPause();
            }
            if (sMedia.isState(sMedia.BUFFERING)) {
                sMedia._onBufferingFinish();
            }
        },
        /**
         * to update the time when the video is playing
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _onTimeUpdate: function () {
            var curTime;

            if (!this._connected) {
                return;
            }

            curTime = this.getCurTime();

            if (curTime < 0) {
                curTime = 0;
            }

            sMedia._onTimeUpdate(curTime);
        },
        /**
         * when the video finish playing the video
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _onFinished: function () {
            console.info("[XDK HTML5] finished event");
            this.__hasFinished = true;
            this._stopPlayback();
            sMedia._onFinish();
        },
        /**
         * when the video has error
         * @method
         * @memberof xdk-base/device/shared/Html5Player#
         * @protected
         */
        _onError: function (e) {
            // to avoid throw second error when it is alreay in error state or it is already finished
            if (this.__hasFinished || this.__errorReported) {
                return;
            }

            var msg = "",
                error;

            if (this._playerObject.networkState === this._playerObject.NETWORK_NO_SOURCE) {
                // media not found
                error = PLAYBACK_ERRORS.NETWORK.FILE;

                this._removeConnectionTimeOut();
                this.hide();
                this._connected = false;
                this._onLoaded = false;

            } else {
                switch (e.target.error.code) {
                case e.target.error.MEDIA_ERR_ABORTED:
                    error = PLAYBACK_ERRORS.RENDER.ABORTED;
                    break;
                case e.target.error.MEDIA_ERR_NETWORK:
                    error = PLAYBACK_ERRORS.NETWORK.FAILED;
                    break;
                case e.target.error.MEDIA_ERR_DECODE:
                    error = PLAYBACK_ERRORS.RENDER.DECODE;
                    break;
                case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    error = PLAYBACK_ERRORS.RENDER.UNSUPPORTED;
                    break;
                default:
                    error = PLAYBACK_ERRORS.RENDER.FAILED;
                    break;
                }
                this._stopPlayback();
            }


            this.__errorReported = true;

            console.error("[XDK HTML5] onRenderError : " + msg);

            sMedia._onError(error);
        },

        /**
         * handle the player event when playback rate change
         * @protected
         * @memberof xdk-base/device/shared/Html5Player#
         */
        _onRateChange: function() {
            var rate = this._playerObject.playbackRate;

            //check from the rate change event to determine whether it is speeding or not.
            if (rate !== 1) {
                sMedia._onSpeeding();
                return;
            }

            sMedia._onPlaying();
        },
        /**
         * get the playobject
         * @protected
         * @returns {HTML5Element} the html5 video object
         * @memberof xdk-base/device/shared/Html5Player#
         */
        getPlayerObject: function () {
            return this._playerObject;
        },
        /**
         * Speed up/down the media playback
         * @method speed
         * @param {Number} speed The speed for the video. It now only accepts number larger than 0, where 1 is the normal speed. 
         * @memberof xdk-base/device/shared/Html5Player#
         * @public
         */
        speed: function (speed) {

            if (!util.isNumber(speed)) {
                console.warn("Speed value must be a number");
                return;
            }

            if (speed <= 0) {
                console.warn("Negative playbackRate is not supported");
                return;
            }

            if (sMedia.isState(sMedia.PAUSED)) {
                this._playerObject.play();
            }

            this._playerObject.playbackRate = speed;
            this._pausedVideo = false;
        },
        /**
         * set the player object current time
         * @method __setCurrentTime
         * @param {Number} sec the target second 
         * @memberof xdk-base/device/shared/Html5Player#
         * @private
         */
        __setCurrentTime: function (sec) {
            this._playerObject.currentTime = sec;
        }
    });
});
/**
 * To provide the polling for the connection checking like the Lan status or internet status
 *
 * ###Configuration Parameters
 *
 * Attribute | Value
 * --------- | ---------
 * Key       | device.connection-poller.consec-failure-threshold
 * Type      | Number
 * Desc      | How many polling failures to consider the internet is disconnected.  ConnectionPoller parameter will be applied before this configuration and then default value when setting the consecutive failure threshold.
 * Default   | 3
 * Usage     | {@link module:xdk-base/config}
 * --------------------------
 * Attribute | Value
 * --------- | ---------
 * Key       | device.connection-poller.interval
 * Type      | Number
 * Desc      | Polling interval in second. ConnectionPoller parameter will be applied before this configuration and then default value when setting the polling interval.
 * Default   | 15
 * Usage     | {@link module:xdk-base/config}
 *
 * @name ConnectionPoller
 * @class xdk-base/device/shared/ConnectionPoller
 * @fires ax/device/shared/ConnectionPoller.EVT_STATUS_CHANGED
 * @param {CheckNetworkStatus} checkStatus The function to check the status about the connection
 * @param {OnNetworkStatusChange} onStatusChange The callback function to call when the network status has changed
 * @param {Object} [opts] optional parameter
 * @param {Boolean} [opts.networkStatus=true] False if it is original disconnected from network. So it will dispatch the status change when there is difference from the initial or previous status.
 * @param {Number} [opts.consecFailureThreshold=3] Number of trials before changing the network status to be failure. Parameter will be applied before the configuration of "device.connection-poller.consec-failure-threshold" and then default value 
 * @param {Number} [opts.interval=15] Number of seconds between the next polling.  Parameter will be applied before the configuration of "device.connection-poller.interval" and then default value 
 * @augments EventDispatcher
 * @example
 * new ConnectionPoller(function(checkStatusCB){
 *     checkStatusCB(deviceAPI.isConnected);  //where deviceAPI.isConnected (Boolean) may be the device api to get the current network information.
 * }, function(newStatus){
 *    //onStatusChange receive the event of new Status then system will dispatch the event.
 *    system.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, newStatus);
 * }, {
 *     consecFailureThreshold: 3,
 *     pollingInterval:  15
 * });
 */
/**
 * A function to check the network status.
 * This function accepts a callback and will execute it with the latest network status once the check is complete.
 *
 * @callback CheckNetworkStatus
 * @param {OnNetworkCheckDone} onStatusChange The status check completion callback
 */
/**
 * A callback that passed into {@link CheckNetworkStatus}.
 * This will be called with the latest network status once the check is complete.
 *
 * @callback OnNetworkCheckDone
 * @param {Boolean} status The network status. True means connected, false means disconnected.
 */
/**
 * A callback that being called when the network status has changed.
 *
 * @callback OnNetworkStatusChange
 * @param {Boolean} status The new network status. True means connected, false means disconnected.
 */
define("xdk-base/device/shared/ConnectionPoller", [
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-base/config",
    "xdk-base/exception"
], function (
    core,
    klass,
    util,
    console,
    config,
    exception
) {
    "use strict";

    var ConnectionPoller = klass.create({}, {
        /**
         * The timer to save the interval
         * @private
         * @name __timer
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        __timer: null,
        /**
         * The interval to pull the data
         * @private
         * @name __pollingInterval
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        __pollingInterval: 15,
        /**
         * Storing the current connection status. Assumed true at the beginning by default
         * @private
         * @name __currentStatus
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        __currentStatus: true,
        /**
         * Consecutive polling failures
         * @private
         * @name __consecFailure
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        __consecFailure: 0,
        /**
         * Number of consecutive polling failures required to consider the connection is disconnected
         * @protected
         * @member
         * @name __consecFailureThreshold
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        __consecFailureThreshold: 3,
        /**
         * The check status function when checking the current network status
         * @protected
         * @method
         * @name _checkStatus
         * @param {Function} checkStatusCB the callback function when check status change. Run checkStatusCHangeCB(true) if changed into network connected.
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        _checkStatus: null,
        init: function (checkStatus, onStatusChange, opts) {
            if (!util.isFunction(checkStatus) || !util.isFunction(onStatusChange)) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "Check Status or onStatusChange function is not defined properly.");
            }

            this._checkStatus = checkStatus;
            this._onStatusChange = onStatusChange;
            opts = opts || {};

            // assume network status at the beginning is true for default
            this.__currentStatus = util.isBoolean(opts.networkStatus) ? opts.networkStatus : true;

            this.__consecFailureThreshold = util.isNumber(opts.consecFailureThreshold) ? opts.consecFailureThreshold : config.get("device.connection-poller.consec-failure-threshold", this.__consecFailureThreshold);
            this.__pollingInterval = util.isNumber(opts.pollingInterval) ? opts.pollingInterval : config.get("device.connection-poller.interval", this.__pollingInterval);
        },
        /**
         * Get the lastest connection status from polling
         * @method isConnected
         * @public
         * @return {Boolean} internet connection status
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        isConnected: function () {
            return this.__currentStatus;
        },
        /**
         * Start the internet polling
         * @method startPolling
         * @public
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        startPolling: function () {
            // start polling
            this.__timer = core.getGuid() + "-ConnectionPoller-polling";
            util.delay(this.__pollingInterval, this.__timer).then(util.bind(this.__poll, this), function () {}).done();
        },
        /**
         * get the current status of the connection poller whether it is pooling
         * @method isPolling
         * @public
         * @memberof module:xdk-base/device/shared/InternetPoller#
         */
        isPolling: function () {
            return this.__timer !== null;
        },
        /**
         * Handle the polling cycle
         * @method __poll
         * @private
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        __poll: function () {
            var __checkStatusDoneCb = util.bind(function (__currentStatus, newStatus) {
                console.info("[ConnectionPoller] Checking the connection status:" + __currentStatus);
                // no status change, poll again later
                if (__currentStatus === newStatus) {
                    this.startPolling();
                    return;
                }

                // success or fail count >= limit, confirm the status change
                if (newStatus || (!newStatus && this.__consecFailure >= this.__consecFailureThreshold - 1)) {
                    this.__currentStatus = newStatus;
                    this._onStatusChange(this.__currentStatus);
                    this.__consecFailure = 0;

                    this.startPolling();
                    return;
                }

                // failed, check again immediately
                this.__consecFailure++;
                this._checkStatus(__checkStatusDoneCb);
            }, this, this.__currentStatus);

            this._checkStatus(__checkStatusDoneCb);
        },
        /**
         * To stop the polling
         * @method stopPolling
         * @public
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        stopPolling: function () {
            util.clearDelay(this.__timer);
            this.__timer = null;
            this.__consecFailure = 0;
        },
        /**
         * Set the polling interval, default value is 20 if not set
         * @method setPollingInterval
         * @public
         * @param {Number} interval polling interval in seconds
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        setPollingInterval: function (interval) {
            this.__pollingInterval = interval;
        },
        /**
         * Get the polling interval
         * @method getPollingInterval
         * @public
         * @return {Number} polling interval in seconds
         * @memberof xdk-base/device/shared/ConnectionPoller#
         */
        getPollingInterval: function () {
            return this.__pollingInterval;
        }
    });

    return ConnectionPoller;
});
/**
 * The Storage interface. Implement this interfaces to indicate the method to store the data e.g.like cookies, localStorage.
 *
 * @class xdk-base/device/interface/Storage
 * @author Mike Leung <mike.leung@accedo.tv>
 */

define("xdk-base/device/interface/Storage", ["xdk-base/Interface"], function(Interface) {
    "use strict";
    return Interface.create("Storage", {
        /**
         * Sets a value into the storage for the specified key.
         * @name set
         * @function
         * @abstract
         * @param {String} key the key to store the value to
         * @param {mixed} value the value to store
         * @memberof xdk-base/device/interface/Storage
         */
        set: [],
        /**
         * Gets a value from the storage for the specified key.
         * @name get
         * @function
         * @abstract
         * @param {String} key the key to store the value to
         * @returns {mixed} the retrieved value.Return false if key doesn't exist in storage.
         * @memberof xdk-base/device/interface/Storage
         */
        get: ["key"],
        /**
         * Clears a entry from the storage for the specified key.
         * @name unset
         * @function
         * @abstract
         * @param {String} key the key to store the value to
         * @memberof xdk-base/device/interface/Storage
         */
        unset: [],
        /**
         * Clears all entries from the storage.
         * @name clear
         * @function
         * @abstract
         * @memberof xdk-base/device/interface/Storage
         */
        clear: []
    });
});
/**
 * Storage class to indicate the method to store the data e.g.like cookies, localStorage
 *
 * ###Config Params
 *
 * Attribute | Value
 * --------- | ---------
 * Key      | device:storage:prefix
 * Type     | String
 * Desc     | Unique prefix string for the underlying storage to uniquely map entries to the current App like cookies
 * Default  | "AccedoXDK"
 * Usage    | {@link module:xdk-base/config}
 *
 * @class xdk-base/device/AbstractStorage
 * @augments ax/device/interface/Storage
 */
define("xdk-base/device/AbstractStorage", ["xdk-base/class", "xdk-base/config", "xdk-base/device/interface/Storage", "require"], function (
    klass, config,
    IStorage, require) {
    "use strict";
    return klass.createAbstract([IStorage], {}, {
        /**
         * Unique prefix string for the underlying storage to uniquely map entries to the current App like cookies
         * @name _uniquePrefix
         * @memberof xdk-base/device/AbstractStorage#
         * @protected
         */
        _uniquePrefix: config.get("device.storage.prefix", "AccedoXDK"),
        /**
         * Gets a value from the storage for the specified key.
         * @name get
         * @function
         * @param {String} key the key to store the value to
         * @returns {mixed} the retrieved value.Return false if key doesn't exist in storage.
         * @memberof xdk-base/device/AbstractStorage#
         */
        /*jshint unused:false */
        get: function (key) {
            return false;
        },
        /*jshint unused:true */
        /**
         * Clears all entries from the storage.
         * @name clear
         * @function
         * @memberof xdk-base/device/AbstractStorage#
         */
        clear: function () {

            var device = require("xdk-base/device"),
                uuid, UUID_KEY = device.id.__UUID_KEY;

            uuid = this.get(UUID_KEY);

            this._doClear();

            this.set(UUID_KEY, uuid);
        }
    });
});
/**
 * To provide storage interface using Cookies
 * @class xdk-base/device/shared/CookiesStorage
 * @augments ax/device/AbstractStorage
 */
define("xdk-base/device/shared/CookiesStorage", ["xdk-base/class", "xdk-base/device/AbstractStorage", "xdk-base/util", "xdk-base/console"], function (klass, AbstractStorage, util, console) {
    "use strict"; 
    var CookiesStorage = klass.create(AbstractStorage, {}, {
        /**
         * To temporary store the cookies instead of getting and setting each tiem
         * @private
         * @name __tempCookies
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        __tempCookies: null,
        /**
         * to set the variable
         * @function
         * @param {String} k the key to store the value to
         * @param {mixed} v the value to store
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        set: function (k, v) {
            console.log("using cookies storage");
            //to load the cookies when the cookies is not loaded yet
            if (!this.__tempCookies) {
                this.__getCookies();
            }

            this.__tempCookies[k] = v;
            this.__setCookies();
        },
        /**
         * to get the variable
         * @function
         * @param {String} k the key to store the value to
         * @returns {mixed} v the retrieved value.Return false if key doesn't exist in storage.
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        get: function (k) {
            //to load the cookies when the cookies is not loaded yet
            if (!this.__tempCookies) {
                this.__getCookies();
            }

            var value;

            if (this.__tempCookies && this.__tempCookies[k]) {
                value = this.__tempCookies[k];

                if (!util.isUndefined(value)) {
                    return value;
                }
            }

            return null;
        },
        /**
         * to unset the variable
         * @function
         * @param {String} k the key to store the value to
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        unset: function (k) {
            //to load the cookies when the cookies is not loaded yet
            if (!this.__tempCookies) {
                this.__getCookies();
            }

            if (this.__tempCookies && !util.isUndefined(this.__tempCookies[k])) {
                this.__tempCookies[k] = null;
                delete this.__tempCookies[k];
                this.__setCookies();
            }
        },
        /**
         * To clear the local storage
         * @protected
         * @method
         * @name _doClear
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        _doClear: function () {
            this.__tempCookies = {};
            this.__setCookies();
        },
        /**
         * to get the cookies from the device (which should be get at the first time), other cases will get from the __tempCookies
         * @private
         * @name clear
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        __getCookies: function () {
            var cookies, cookieString, i, l;
            if (!util.isString(document.cookie)) {
                console.warn("document.cookie doesn't exist and unable to get the cookies");
                return;
            }

            if (!document.cookie) {
                //empty cookies
                this.__tempCookies = {};
                return;
            }

            cookies = document.cookie.split(";");
            for (i = 0, l = cookies.length; i < l; i++) {
                cookieString = util.strip(cookies[i]);
                if (util.startsWith(cookieString, this._uniquePrefix + "=")) {
                    cookieString = cookieString.substring((this._uniquePrefix + "=").length);
                    if (cookieString) {
                        try {
                            this.__tempCookies = util.parse(decodeURIComponent(cookieString));
                            return;
                        } catch (e) {
                            console.warn("unable to load the cookies");
                        }
                    }

                }
            }
            this.__tempCookies = {};
        },
        /**
         * to set the cookies
         * @private
         * @name __setCookies
         * @memberof xdk-base/device/shared/CookiesStorage#
         */
        __setCookies: function () {
            if (!this.__tempCookies) {
                console.warn("cookie Object is undefined and unable to set into the cookies");
                return false;
            }

            var days = 365,
                date, expires, cookieString;
            if (!util.isEmpty(this.__tempCookies)) {
                date = (new Date());
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toGMTString();
            } else {
                expires = "; expires= -1";
            }

            cookieString = this._uniquePrefix + "=" + encodeURIComponent(util.stringify(this.__tempCookies)) + expires + "; domain=" + location.hostname + "; path=/";
            document.cookie = cookieString;
        }
    });
    return CookiesStorage;
});
/**
 * Flash media player. Able to play RTMP streams.
 * @augments ax/device/interface/Player
 * @class xdk-base/device/shared/FlashPlayer
 */
define("xdk-base/device/shared/FlashPlayer", ["xdk-base/core", "xdk-base/class", "xdk-base/device/AbstractPlayer", "xdk-base/device/interface/Player", "xdk-base/device/Media",
    "xdk-base/util", "xdk-base/console", "require"
], function (core, klass, AbstractPlayer, IPlayer, Media, util, console, require) {
    "use strict";
    var sMedia = Media.singleton(),
        resolution = null,
        getResolution = function () {
            if (resolution) {
                return resolution;
            }
            resolution = require("xdk-base/device")
                .system.getDisplayResolution();
            return resolution;
        };

    var PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS;

    return klass.create(AbstractPlayer, {}, {
        _curTime: 0,
        /**
         * to see the html 5 player is onLoaded or not. If it is onloaded, user can seek time
         * @protected
         * @constant
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _onLoaded: false,
        /**
         * container name of the player
         * @protected
         * @constant
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _CONTAINER_NAME: "FlashPlayerContainer",
        /**
         * parent node of the player object
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _parentNode: null,
        /**
         * the player object
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _playerObject: null,
        /**
         * the init status of the player, if it isn't true, the event Listener or player may not been attached to DOM
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _prepared: false,
        /**
         * total time of the video
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _duration: 0,
        /**
         * connection time out (in sec) when the video is fail to play
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _connectionTimeLimit: 90,
        // in sec
        /**
         * store the timeout of the connection time out
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _connectionTimeOut: null,
        /**
         * to check if it is connected
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _connected: false,
        /**
         * to check if it is paused
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _pausedVideo: false,
        /**
         * if the video format HLS is supported
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _supportHLS: false,
        /**
         * to check if the video format is supported
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _support: true,
        /**
         * to check if it needs to seek before play
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _seek: false,
        /**
         * to store the time which needed to be seek
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _seekTime: 0,
        /**
         * to store the last loaded media URL
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _url: null,
        init: function (devicePackage) {
            //Flash player doesn't support in 2011 samsung(limitation:like unable to change the screen size and unable to dynamic create the object) & 2010
            if (devicePackage.getId() === "samsung" && devicePackage.getInterface(devicePackage.constructor.ID)
                .getFirmwareYear() < 2012) {
                throw core.createException("FlashPlayerNotSupported",
                    "Flash Player is not supported when less than 2012.");
            }
        },
        /**
         * Prepare the player, should be called before using
         * @name prepare
         * @method
         * @param {object} opts The opts parameter passed from {@link xdk-base/device/Media#load|device.media.load}
         * @param {HTMLElement} [opts.parentNode] parentNode to be append the player object.
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        prepare: function (opts) {

            if (!opts.swfUrl) {
                console.warn("Unable to find the url of the flash");
                return false;
            }

            //check if prepared and check parentNode
            if (this._prepared) {
                return;
            }

            //default parent node should be the body
            this._parentNode = window.document.getElementsByTagName("body")[0];

            //create div container tag
            this._playerContainer = document.createElement("div");
            this._playerContainer.id = this._CONTAINER_NAME;
            this._playerContainer.className = "playerContainer";

            //create the player object
            try {
                var paramUrl, paramQuality, paramwmode, paramBgColor;
                this._playerObject = document.createElement("object");
                this._playerObject.setAttribute("id", "FlashPlayer");
                this._playerObject.className = "playerObject";
                this._playerObject.setAttribute("type", "application/x-shockwave-flash");

                paramUrl = document.createElement("param");
                paramUrl.name = "movie";
                paramUrl.value = opts.swfUrl;
                this._playerObject.appendChild(paramUrl);

                paramQuality = document.createElement("param");
                paramQuality.name = "quality";
                paramQuality.value = "high";
                this._playerObject.appendChild(paramQuality);

                paramwmode = document.createElement("param");
                paramwmode.name = "wmode";
                paramwmode.value = "transparent";
                this._playerObject.appendChild(paramwmode);

                paramBgColor = document.createElement("param");
                paramBgColor.name = "bgcolor";
                paramBgColor.value = "000000";
                this._playerObject.appendChild(paramBgColor);

                this._playerContainer.appendChild(this._playerObject);

                this._parentNode.appendChild(this._playerContainer);
                window.__flashCallback = util.bind(this.callback, this);

                this._inited = true;

            } catch (e) {
                console.error("VideoPlayer error: while creating the player object: " + e);
                return false;
            }
            this._prepared = true;

        },
        /**
         * resets the video player, to non-playing mode
         * @method
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        reset: function () {
            if (!this._prepared) {
                return;
            }
            this.hide();
            this._stopPlayback();
            this.deinit();
        },
        /**
         * deinit the video player and remove the eventListener
         * @method
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        deinit: function () {
            if (!this._prepared) {
                return;
            }
            this._prepared = false;

            if (this._playerContainer) {
                this._playerContainer.removeChild(this._playerObject);
                this._parentNode.removeChild(this._playerContainer);
                this._playerContainer = null;
            } else {
                this._parentNode.removeChild(this._playerObject);
            }

            delete window.__flashCallback;
            console.info("Flash video player deinit successfull.");
            return;
        },
        /**
         * play the video item
         * @method
         * @param {Object} opts object containing the required options
         * @param {Number} opts.sec Play the video at the specified second
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        play: function (opts) {
            console.info("[XKD flash] Play requested.");

            if (!this._support) {
                this._stopPlayback();
                sMedia._onError(PLAYBACK_ERRORS.RENDER.UNSUPPORTED, "unsupport format in the flash video player");
                return;
            }

            //if stop the video and press play, it will play the previous video
            if (sMedia.isState(sMedia.STOPPED) && this._url && this._playerObject.loadUrl) {
                if (this._urlOpts.type === "rtmp") {
                    //to filter the useless attribute when passing into flash
                    var flashOpt = {};
                    if (this._urlOpts.streamName) {
                        flashOpt.streamName = this._urlOpts.streamName;
                    }
                    if (this._urlOpts.liveStreaming) {
                        flashOpt.liveStreaming = this._urlOpts.liveStreaming;
                        this._noProgressive = true;
                    } else {
                        this._noProgressive = false;
                    }
                    this._playerObject.loadUrl(this._url, flashOpt);
                } else if (this._urlOpts.type === "mp4") {
                    this._playerObject.loadUrl(null, {
                        streamName: this._url
                    });
                }

            }

            this.show();

            if (!this._connected) {
                this._connected = true;
                sMedia._onConnecting();
                try {
                    this._playerObject.play();
                } catch (ex) {
                    console.warn(
                        "unable to play the video.Flash hasn't been initialized correctly. Please check the url"
                    );
                }
                this._removeConnectionTimeOut();
                this._connectionTimeOut = core.getGuid();
                util.delay(this._connectionTimeLimit, this._connectionTimeOut)
                    .then(util.bind(this._onConnectionTimeout, this))
                    .done();
            }

            this._pausedVideo = false;
            this._seek = false;

            if (opts && opts.sec) {
                this._seek = true;
                this._seekTime = opts.sec;
            }

            if (sMedia.isState(sMedia.PAUSED)) {
                if (this.__withholdSeek) {
                    this.__withholdSeek = false;
                    this.seek(this.__withholdSeekTime);
                }
                this._playerObject.play();
                sMedia._onPlaying();
            }
        },
        /**
         * pause the video item
         * @method
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        pause: function () {
            console.info("[XDK flash] Pausing video.");
            this._pausedVideo = true;
            this._playerObject.pause();
            sMedia._onPause();
        },
        /**
         * stop the video playback
         * @method
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        stop: function () {
            console.info("[XDK flash] Stopping video");

            this._stopPlayback();

            sMedia._onStopped();
        },
        /**
         * stop the video playback for real
         * @method
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _stopPlayback: function () {
            this.__withholdSeek = false;
            this.__withholdSeekTime = 0;
            if (this._playerObject && this._playerObject.pause) {
                this._playerObject.pause();
            }
            this.hide();
            this._removeConnectionTimeOut();
            this._connected = false;
            this._onLoaded = false;
        },
        /**
         * resume playing the video
         * @method
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        resume: function () {
            console.info("[XDK flash] Resuming...");

            //perform the seek when resume from pause
            if (sMedia.isState(sMedia.PAUSED) && this.__withholdSeek) {
                this.__withholdSeek = false;
                this.seek(this.__withholdSeekTime);
            }

            this._playerObject.play();
            this._pausedVideo = false;
            sMedia._onPlaying();
        },
        /**
         * Skip the playback forward/backward for certain seconds
         * @method
         * @param {Number} sec number of seconds to skip (10 by default)
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        skip: function (sec) {
            //if it is paused and then press skip, it will save and do it after resume.
            if (sMedia.isState(sMedia.PAUSED) || sMedia._prevState === sMedia.PAUSED) {
                this.__withholdSeek = true;
                if (this.getCurTime() + sec > this.getDuration() && this.getCurTime() + sec >= 0) {
                    this.__withholdSeekTime = this.getDuration();
                    //update the player time
                }
                this.__withholdSeekTime = this.getCurTime() + sec;
                this._onTimeUpdate(this.__withholdSeekTime);
                return;
            }
            this._playerObject.seek(this.getCurTime() + sec);
        },
        /**
         * Seek to specifiy position of the video
         * @method
         * @param {Number} sec the position to seek to in seconds
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        seek: function (sec) {
            if (sec < 0) {
                return false;
            }

            if (this._inited && this._url && sec >= 0) {
                //since it is invalid time in some video to set the duration and then make it to be duration -1.
                if (sec === this._duration) {
                    sec = Math.floor(this.getDuration() - 1);
                }
                this._playerObject.seek(sec);
                sMedia._onTimeUpdate(sec);
                return true;
            }
        },
        /**
         * Get the current playback time
         * @method
         * @return {Number} the current playback time
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @public
         */
        getCurTime: function () {
            return this._curTime;
        },
        /**
         * to set the total time of the player
         * @method
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @proteced
         */
        _setDuration: function (time) {
            this._duration = time;
        },
        /**
         * to get the total time of the video
         * @method
         * @return {number} the total time of the video
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @public
         */
        getDuration: function () {
            return this._duration;
        },
        /**
         * Show the player
         * @method
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        show: function () {
            if (this._playerObject) {
                this._playerObject.style.visibility = "visible";
            }
        },
        /**
         * Hide the player
         * @method
         * @public
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        hide: function () {
            if (this._playerObject) {
                this._playerObject.style.visibility = "hidden";
            }
        },
        /**
         * Gets the player's capabilities
         * Removed MP4 supported from flash player
         * @method
         * @return {ax/device/interface/Player~PlayerCapabilites}
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        getCapabilities: function () {
            var cap = {
                type: ["rtmp"]
            };
            return cap;
        },
        /**
         * Loads the specified media
         * @method
         * @param {String} mediaUrl the URL address of the media
         * @param {Object} [opts] the options for loading this media
         * @param {String} [opts.swfUrl] (Flash) set the flash swf url
         * @param {String} [opts.streamName] (Flash) the streamName
         * @param {Boolean} [opts.liveStreaming] (Flash) to  indicate if it is liveStreaming. If it is live streaming, no time update
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        load: function (mediaUrl, opts) {
            this._playerOpts = opts;
            if (!this._prepared) {
                return false;
            }

            if (this._playerObject) {
                //move to the correct place
                if (opts.parentNode) {
                    if (this._playerContainer) {
                        this._parentNode.removeChild(this._playerContainer);
                        this._playerContainer = null;
                    }
                    this._parentNode = opts.parentNode;
                    this._parentNode.appendChild(this._playerObject);
                }
                this._url = mediaUrl;
                this._urlOpts = opts;
            }
            return mediaUrl;
        },
        /**
         * Sets video window size
         * @method
         * @param {Object} obj window size parameter
         * @param {Boolean} param.relativeToParent True if relative to the parent position and then use the css position:relative. \
         *   Default will be false and use position:fixed
         * @param {Number} obj.top window top
         * @param {Number} obj.left window left
         * @param {Number} obj.width window width
         * @param {Number} obj.height window height
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        setWindowSize: function (obj) {
            if (obj.relativeToParent) {
                this._playerObject.style.position = "relative";
            } else {
                this._playerObject.style.position = "fixed";
            }

            if (this._playerObject) {
                this._playerObject.style.width = obj.width + "px";
                this._playerObject.style.height = obj.height + "px";
                this._playerObject.style.left = obj.left + "px";
                this._playerObject.style.top = obj.top + "px";
                if (this._playerObject.setWindowSize) {
                    this._playerObject.setWindowSize(obj.width, obj.height);
                }
            }

            this._currentWindowSize = obj;
            return;
        },
        /**
         * Sets video window size
         * @method
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        setFullscreen: function () {
            this.setWindowSize({
                top: 0,
                left: 0,
                height: getResolution()
                    .height,
                width: getResolution()
                    .width
            });
            this._playerObject.style.position = "fixed";
        },
        /**
         * Timeout to throw error if it is still in connecting with the connectionTimeLimit
         * @method
         * @protected
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        _onConnectionTimeout: function () {
            this._stopPlayback();
            sMedia._onError(PLAYBACK_ERRORS.NETWORK.DISCONNECTED);
            console.info("[xdk flash] Connection error");
        },
        /**
         * Onload of the video to load the duration of the video
         * @method
         * @param {object} data send from the flash player, like the duration
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @protected
         */
        _onLoad: function (data) {
            this._onLoaded = true;
            this._removeConnectionTimeOut();
            this._setDuration(data.duration);
            //seek time should be after setting the total time, otherwise there are conflict and condition checking error
            if (this._seek && this._seekTime > 0) {
                this._playerObject.seek(this._seekTime);
                this._seek = false;
            }

            if (!this._connected) {
                return;
            }

            console.info("[XDK flash] onload event");
            sMedia._onBufferingStart();
            sMedia._onBufferingProgress();
        },
        /**
         * To remove the connection time out set when set Media url and play
         * @method
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @protected
         */
        _removeConnectionTimeOut: function () {
            if (this._connectionTimeOut !== null) {
                util.clearDelay(this._connectionTimeOut);
                this._connectionTimeOut = null;
            }
        },
        /**
         * _onPlaying to be invoked when the player play
         * @method
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @protected
         */
        _onPlaying: function () {
            if (!this._connected) {
                return;
            }
            console.info("[xdk flash] onplaying event");
            this._removeConnectionTimeOut();
            if (!this._pausedVideo) {
                sMedia._onPlaying();
            } else {
                sMedia._onPause();
            }
            if (sMedia.isState(sMedia.BUFFERING)) {
                sMedia._onBufferingFinish();
            }
        },
        /**
         * to update the time when the video is playing
         * @method
         * @param {Number} time
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @protected
         */
        _onTimeUpdate: function (time) {
            if (!this._connected) {
                return;
            }
            this._curTime = time;
            sMedia._onTimeUpdate(time);
        },
        /**
         * when the video finish playing the video
         * @method
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @protected
         */
        _onFinished: function () {
            console.info("[XDK flash] finished event");
            this._stopPlayback();
            sMedia._onFinish();
        },
        /**
         * when the video has some error
         * @method _onError
         * @param {String} errorMsg from the player
         * @memberof xdk-base/device/shared/FlashPlayer#
         * @protected
         */
        _onError: function (errorMsg) {
            // to avoid throw second error when it is alreay in error state or it is already finished
            if (sMedia.isState(sMedia.STOPPED)) {
                return;
            }
            this._stopPlayback();
            sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, {
                code: null,
                msg: errorMsg
            }, errorMsg);
            console.error("[xdk flash] onRenderError : " + errorMsg);
        },
        /**
         * the callback from the flash player
         * @method callback
         * @param {String} evt the callback name
         * @param {Object} data the related data of the event
         * @memberof xdk-base/device/shared/FlashPlayer#
         */
        callback: function (evt, data) {
            data = util.parse(data);
            console.debug("[xdk flash] callback" + evt + "data" + data.code);
            switch (evt) {
            case "timeUpdate":
                this._onTimeUpdate(data.time);
                break;
            case "loadedmetadata":
                console.debug("load meta data");
                this._onLoad(data);
                break;
            case "statuschange":
                switch (data.code) {
                case "NetStream.Finish":
                    this._onFinished();
                    break;
                case "NetStream.Buffer.Full":
                case "NetStream.Seek.Complete":
                    this._onPlaying();
                    break;
                case "NetStream.Play.Start":
                case "NetStream.Buffer.Empty":
                case "NetStream.Seek.Notify":
                    if (sMedia.isState(sMedia.PAUSED) || sMedia.isState(sMedia.SKIPPING)) {
                        return;
                    }
                    if (!sMedia.isState(sMedia.BUFFERING)) {
                        sMedia._onBufferingStart();
                    } else {
                        sMedia._onBufferingProgress();
                    }
                    break;
                case "NetStream.Play.Stop":
                    break;
                case "NetStream.Play.StreamNotFound":
                    sMedia._onError(PLAYBACK_ERRORS.NETWORK.FILE, null, data);
                    break;
                case "NetStream.Play.FileStructureInvalid":
                    sMedia._onError(PLAYBACK_ERRORS.RENDER.UNSUPPORTED, null, data);
                    break;
                }
                break;
            }
        }
    });
});
/**
 * To provide the html5 localstorage as storage.
 * @class xdk-base/device/shared/LocalStorage
 * @augments ax/device/AbstractStorage
 *
 */
define("xdk-base/device/shared/LocalStorage", ["xdk-base/class", "xdk-base/device/AbstractStorage", "xdk-base/console"], function (klass, AbstractStorage, console) {
    "use strict"; 
    return klass.create(AbstractStorage, {}, {
        /**
         * to set the variable
         * @public
         * @method
         * @name set
         * @param {String} k keys
         * @param {String} v values
         * @memberof xdk-base/device/shared/LocalStorage#
         */
        set: function (k, v) {
            console.log("using Localstorage");
            localStorage.setItem(k, v);
        },
        /**
         * to get the variable
         * @public
         * @method
         * @name get
         * @param {String} k keys
         * @return {String} v values
         * @memberof xdk-base/device/shared/LocalStorage#
         */
        get: function (k) {
            return localStorage.getItem(k);
        },
        /**
         * to unset the variable
         * @public
         * @method
         * @name unset
         * @param {String} k keys
         * @memberof xdk-base/device/shared/LocalStorage#
         */
        unset: function (k) {
            localStorage.removeItem(k);
        },
        /**
         * To do clear the local storage
         * @protected
         * @method
         * @name _doClear
         * @memberof xdk-base/device/shared/LocalStorage#
         */
        _doClear: function () {
            localStorage.clear();
        }
    });
});
/**
 * OPIF DRM Agent is a DRM agent that follows the OPIF's Open IPTV specification.
 * @see {@link http://www.oipf.tv/docs/Release1/OIPF-T1-R1-Specification-Volume-5-Declarative-Application-Environment-V1_0-2009-01-06.pdf}
 * @class xdk-base/device/shared/opif/DrmAgent
 */
define("xdk-base/device/shared/opif/DrmAgent", [
    "xdk-base/class",
    "xdk-base/promise",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-base/core",
    "xdk-base/exception"
], function (
    klass,
    promise,
    util,
    console,
    core,
    exception
) {
    "use strict";

    var MSG_TYPE = "application/vnd.ms-playready.initiator+xml",
        SYSTEM = {
            UNKNOWN: "Unknown",
            PLAY_READY: "PlayReady",
            MARLIN: "Marlin"
        };

    return klass.create({}, {
        /**
         * The DRM Agent object
         * @protected
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _drmAgent: undefined,
        /**
         * The DRM systen id
         * @protected
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _systemId: undefined,
        /**
         * Counter for the DRM request
         * @protected
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _requestCounter: 0,
        /**
         * The license acquisition defer object
         * @private
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        __laDeferred: undefined,
        /**
         * The last license acquisition promise object in the queue
         * @private
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        __queuedPromise: undefined,
        /**
         * Flag to indicate if an acquisition is processing
         * @private
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        __acquiuringLicense: false,
        /**
         * Process queue
         * @private
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        __queue: [],
        /**
         * Flag to indicate if the queue is being processed
         * @private
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        __processingQueue: false,

        /**
         * Initialize the DrmAgent.
         * @method
         * @param {Object} drmAgent The platform dependent drmAgent
         * @param {String} systemId The system id used to identify the device
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        init: function (drmAgent, systemId) {
            if (!drmAgent) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "No valid native drm agent available");
            }
            if (!systemId) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "systemId is mandatory");
            }

            this._drmAgent = drmAgent;
            this._systemId = systemId;

            drmAgent.onDRMMessageResult = util.bind(this._onDRMMessageResult, this);
            drmAgent.onDRMRightsError = util.bind(this._onDRMRightsError, this);
        },

        deinit: function () {
            var drmAgent = this._drmAgent;

            this._drmAgent = null;
            this._systemId = null;

            drmAgent.onDRMMessageResult = null;
            drmAgent.onDRMRightsError   = null;
        },

        /**
         * Send the license request to the native drm agent.
         * @method
         * @param {String} laUrl The url of the license acquisition server
         * @param {String} [customData] The custom data
         * @returns {Promise.<Boolean>} Return true when the license acqiusition success
         * @throws {Promise.<ax/Exception>} Reject if any error occurs
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        sendLicenseRequest: function (laUrl, customData) {
            var deferred = promise.defer(),
                process = util.bind(function (_defer) {
                    var _promise;
                    // reset counter for each process
                    this._requestCounter = 0;

                    this.__laDeferred = _defer;

                    // promise = _promise, but get from _defer to avoid closure issue
                    _promise = _defer.promise;

                    this._sendDRMMessages(laUrl, customData);

                    // the license acquisition resolved, resolve the individual promise
                    return _promise.then(function (msg) {
                        _defer.resolve(msg);
                    }).fail(function (reason) {
                        _defer.reject(reason);
                    });
                }, this, deferred);

            // only process the request if none is working AND the queue is not empty
            // otherwise push to the queue
            if (!this.__acquiuringLicense && this.__queue.length === 0) {
                this.__acquiuringLicense = true;
                process(deferred);
            } else {
                this.__queue.push(process);
            }

            return deferred.promise;
        },

        /**
         * Process the request queue.
         * @protected
         * @method
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _processQueue: function () {
            if (this.__processingQueue) {
                return;
            }

            this.__processingQueue = true;
            var fn = this.__queue.shift();
            if (fn) {
                fn().then(util.bind(function () {
                    this.__processingQueue = false;
                    this._processQueue();
                }, this));
            } else {
                this.__processingQueue = false;
            }
        },

        /**
         * The actual function to send DRM messages.
         * @protected
         * @method
         * @param {String} laUrl The url of the license acquisition server
         * @param {String} [customData] The custom data
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _sendDRMMessages: function (laUrl, customData) {
            var xmlLicenseAcquisition;

            try {
                // license URL
                if (util.isString(laUrl)) {
                    this._requestCounter++;

                    xmlLicenseAcquisition = "<?xml version='1.0' encoding='utf-8'?>" +
                            "<PlayReadyInitiator xmlns='http://schemas.microsoft.com/DRM/2007/03/protocols/'>" +
                                "<LicenseServerUriOverride>" +
                                    "<LA_URL>" + laUrl + "</LA_URL>" +
                                "</LicenseServerUriOverride>" +
                            "</PlayReadyInitiator>";
                    this._drmAgent.sendDRMMessage(MSG_TYPE, xmlLicenseAcquisition, this._systemId);
                    console.info("sendDRMMessage (License Acquisition URL): " + laUrl);
                }

                // custom Data
                if (util.isString(customData)) {
                    this._requestCounter++;

                    xmlLicenseAcquisition = "<?xml version='1.0' encoding='utf-8'?>" +
                            "<PlayReadyInitiator xmlns='http://schemas.microsoft.com/DRM/2007/03/protocols/'>" +
                                "<SetCustomData>" +
                                    "<CustomData>" + customData + "</CustomData>" +
                                "</SetCustomData>" +
                            "</PlayReadyInitiator>";
                    this._drmAgent.sendDRMMessage(MSG_TYPE, xmlLicenseAcquisition, this._systemId);
                    console.info("sendDRMMessage (CustomData): " + customData);
                }
            } catch (e) {
                console.warn("[DrmAgent] ERROR: sendDRMMessage (" + e + ")");
                this._requestCounter = 0; // fail, reset counter
                this.__acquiuringLicense = false;
                this.__laDeferred.reject(core.createException(exception.INTERNAL, "sendDRMMessage failed: " + e));
            }
        },

        /**
         * Callback to be called by the native drm agent when sendDRMMessage() is finished.
         * @protected
         * @method
         * @param {String} msgId Identifies the original message which has lead to this resulting message
         * @param {String} resultMsg DRM system specific result message
         * @param {Number} resultCode Integer result code
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _onDRMMessageResult: function (msgId, resultMsg, resultCode) {
            var description;

            this._requestCounter--;

            switch (resultCode) {
                case 0:
                    description = "Successful";
                    if (this._requestCounter > 0) {
                        description += ", but not yet ready (request counter > 0)";
                    }
                    break;
                case 1:
                    if (resultMsg === "0x8004C600") {
                        description = "Server could not deliver a license (server internal error)";
                    } else if (resultMsg === "0x8004C580") {
                        description = "Acquired license successfully but domain certificate missing on device";
                    }
                    break;
                case 2:
                    description = "Cannot process request";
                    break;
                case 3:
                    description = "Unknown MIME type";
                    break;
                case 4:
                    description = "User consent needed";
                    break;
            }
            console.info("[DrmAgent] onDRMMessageResult: resultCode:" + resultCode + " - " + description);
            console.debug("[DrmAgent] counter down to " + this._requestCounter);

            if (this._requestCounter === 0) {
                this._onLicenseAcquired();
            }
        },

        /**
         * Callback to be called when the license acquisition is done.
         * This function will resolve the license acquisition defer.
         * @protected
         * @method
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _onLicenseAcquired: function () {
            console.info("[DrmAgent] license acquired");
            this.__laDeferred.resolve(true);
            this.__acquiuringLicense = false;
            this._processQueue();
        },

        /**
         * Callback to be called by the native drm agent when license acquisition fails.
         * This function will reject the license acquisition defer.
         * @protected
         * @method
         * @param {Number} errorState Error state code
         * @param {String} contentId
         * @param {String} drmSystemId The identifier of the drm system
         * @param {String} rightsIssuerUrl The url of the rights issuer
         * @memberof xdk-base/device/shared/opif/DrmAgent#
         */
        _onDRMRightsError: function (errorState, contentId, drmSystemId, rightsIssuerUrl) {
            var systemName = SYSTEM.UNKNOWN,
                description;

            switch(errorState) {
                case 0:
                    description = "No license (0), consumption of the content is blocked";
                    break;
                case 1:
                    description = "Invalid License (1), consumption of the content is blocked";
                    break;
                case 2:
                    description = "Valid License (2), consumption of the content is unblocked";
                    break;
                default:
                    description = "Unknown (" + errorState + ")";
                    break;
            }

            if (drmSystemId) {
                if (drmSystemId.indexOf("19188") !== -1) {
                    systemName = SYSTEM.MARLIN;
                } else if (drmSystemId.indexOf("19219") !== -1) {
                    systemName = SYSTEM.PLAY_READY;
                } else {
                    systemName = drmSystemId;
                }
            }

            console.warn("[DrmAgent] onDRMRightsError (from " + systemName + "): " + description + "; contentId:" + contentId + "; rightsIssuerUrl: " + rightsIssuerUrl);
            this.__laDeferred.reject(core.createException(exception.UNAUTHORIZED, description));
            this.__acquiuringLicense = false;
            this._processQueue();
        }
    });
});

/**
 * Extended class from abstract tv key to handle the regular tv key code via the document onkeydown and onkeypress. It provides the basic feature on the browser platform to start with
 * @class xdk-base/device/shared/browser/TvKey
 */
define("xdk-base/device/shared/browser/TvKey", ["xdk-base/class", "xdk-base/console", "xdk-base/util", "xdk-base/device/shared/browser/keyMap"], function (klass, console, util, keyMap) {
    "use strict";
    return klass.create({}, {
        __keys: null,
        __chars: null,
        init: function () {
            this.initKeyMapping(keyMap.REMOTE);
        },
        /**
         * To init the KeyMapping via the map object which can use the {@link module:xdk-base/device/shared/browser/keyMap.REMOTE} or {@link module:xdk-base/device/shared/browser/keyMap.KEYBOARD}.
         * @param {Object} keyMap the keyCode object mapping e.g { 38: keyboardVKey.UP }. Each keyCode object should be keycode to keyboardVKey or VKey reference
         * @param {Obejct} [charMap] the charCode object mapping. Each charCode object should be keycode to keyboardVKey or VKey reference
         * @public
         * @method initKeyMapping
         * @memberof xdk-base/device/shared/browser/TvKey#
         * @example
         * keyMap.REMOTE = {
         *   keyCode: {
         *     38: keyboardVKey.UP,
         *     40: keyboardVKey.DOWN,
         *     37: keyboardVKey.LEFT,
         *     39: keyboardVKey.RIGHT,
         *     13: keyboardVKey.OK
         *    }
         *    }
         *    this.initKeyMapping(keyMap.REMOTE);
         */
        initKeyMapping: function (keyMap, charMap) {
            if (keyMap) {
                if (!this.__keys) {
                    this.__keys = {};
                }
                util.each(keyMap.VKey, util.bind(function (item) {
                    this.__keys[item.key] = item.value;
                }, this));
            }

            if (charMap && charMap.VKey) {
                if (!this.__chars) {
                    this.__chars = {};
                }
                util.each(charMap.VKey, util.bind(function (item) {
                    this.__chars[item.key] = item.value;
                }, this));
            }
        },
        /**
         * initializes the key handling logic for the device, after DOM ready. SInce it is for browser based. It will add keydown and keypress event
         * @method initKeyHandling
         * @function
         * @memberof xdk-base/device/shared/browser/TvKey#
         * @public
         */
        initKeyHandling: function () {
            document.onkeypress = util.bind(this.keyHandler, this);
            document.onkeydown = util.bind(this.keyHandler, this);
        },
        /**
         * To handle the key when receive key event
         * @method keyHandler
         * @function
         * @param {Object} evt the event from the browser key event
         * @param {Function} dispatchKey the callback function when dispatch the key
         * @memberof xdk-base/device/shared/browser/TvKey#
         * @public
         */
        keyHandler: function (evt) {
            var virtualKey, tvKey, deviceHandler;

            deviceHandler = require("xdk-base/device").getDeviceHandler();

            //convert the event to our key standard with code and isChar attribute
            virtualKey = this.getVirtualKey(evt);
            tvKey = this.getMappedKey(virtualKey);
            if (tvKey) {
                deviceHandler.onDeviceKey(tvKey);
                evt.preventDefault();
                return false;
            }
            return true;
        },
        /* To check if it should handle in the char code instead of the keycode. 
         * @private
         * @method __isCharTyped
         * @returns {Boolean}
         * @memberof xdk-base/device/shared/browser/TvKey#
         */
        __isCharTyped: function (keyCode) {
            if ((keyCode >= 65 && keyCode <= 90) || // a-z
                (keyCode >= 48 && keyCode <= 57) || // 0-9
                (keyCode >= 96 && keyCode <= 111) || // numpad
                keyCode === 32 // space and symbols
            ) {
                return true;
            }
            return false;
        },
        /* To get the mapped key from the virtual key
         * @public
         * @methold getMappedKey
         * @param {Object} evt the event from the browser key event
         * @returns {Object} return the object from {@link module:xdk-base/device/shared/keyboardVKey} or {@link module:xdk-base/device/VKey}
         * @memberof xdk-base/device/shared/browser/TvKey#
         */
        getMappedKey: function (virtualKey) {
            var keyCode = virtualKey.code,
                isChar = virtualKey.isChar;
            console.info("Received key, code :" + keyCode + " isChar : " + isChar);
            if (!isChar) {
                if (this.__chars && this.__isCharTyped(keyCode)) {
                    return false;
                }
                if (this.__keys[keyCode]) {
                    return this.__keys[keyCode];
                }
            } else { // key press event
                if (this.__chars && this.__chars[keyCode]) {
                    return this.__chars[keyCode];
                }
                // unknown key, let key down handler handle it
            }
            return false;
        },
        /* To standardize the key object from the key event
         * @public
         * @methold getVirtualKey
         * @param {Obejct} virtualKey the virtual key format in keyCode and isChar
         * @returns {Object} return standard format of key event
         * @memberof xdk-base/device/shared/browser/TvKey#
         */
        getVirtualKey: function (evt) {
            if (evt.type.toLowerCase() === "keypress") {
                return {
                    code: evt.charCode,
                    isChar: true
                };
            }
            return {
                code: evt.keyCode,
                isChar: false
            };
        },
        /* To get all the key mapping of charCode/ keyCode to keyboardVKey obejct from the browser TvKey
         * @public
         * @methold getKeyMapping
         * @returns {Object} return object of keyCode and charCode Object
         * @memberof xdk-base/device/shared/browser/TvKey#
         */
        getKeyMapping: function () {
            var map = {
                keyCode: this.__keys
            };
            if (this.__chars) {
                map.charCode = this.__chars;
            }
            return map;
        }
    });
});
/**
 * The STA keyMAP which uses the window.VK_DOWN to get the keyCode to map the keys
 * @module xdk-base/device/shared/browser/keyMap
 **/
define("xdk-base/device/shared/sta/keyMap", ["xdk-base/util", "xdk-base/device/vKey"], function (util, VKey) {
    "use strict";
    var keys = {
        VKey: {},
        keyCode: {}
    },
        VKKey = ["DOWN", "UP", "LEFT", "RIGHT", "ENTER", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "RED", "BLUE", "GREEN", "YELLOW", "PLAY", "PAUSE", "STOP", "FAST_FWD", "REWIND", "BACK"];
    util.each(VKKey, function (item) {
        var code = window["VK_" + item];
        if (!code) {
            return;
        }

        if (item.length !== 1) {
            if (item === "ENTER") {
                item = "OK";
            }
            if (item === "FAST_FWD") {
                item = "FF";
            }
            if (item === "REWIND") {
                item = "RW";
            }
            keys.VKey[code] = VKey[item];
            keys.keyCode[item] = code;
        } else {
            //number set
            keys.VKey[code] = VKey["KEY_" + item];
            keys.keyCode["KEY_" + item] = code;
        }
    });
    return {
        /*
         *The key mapping of sta. It will map the following keys "DOWN", "UP", "LEFT", "RIGHT", "ENTER", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "RED", "BLUE", "GREEN", "YELLOW", "PLAY", "PAUSE", "STOP", "FAST_FWD", "REWIND", "BACK"
         * @name STA
         * @constant
         * @memberof module:xdk-base/device/shared/sta/keyMap
         * @public
         */
        STA: keys
    };
});
/**
 * Class extend from the brwoser tvkey which uses the sta tvkey
 * @class xdk-base/device/shared/sta/TvKey
 * @extends ax/device/shared/browser/TvKey
 */
define("xdk-base/device/shared/sta/TvKey", ["xdk-base/class", "xdk-base/device/shared/browser/TvKey", "xdk-base/device/shared/sta/keyMap"], function (klass, browserTvKey, staKeyMap) {
    "use strict";   
    return klass.create(browserTvKey, {}, {
        init: function () {
            this.initKeyMapping(staKeyMap.STA);
            this.initKeyHandling();
        }
    });
});
/**
 * OPIF DRM Agent is a DRM agent that follows the OPIF's Open IPTV specification.
 * @see {@link http://www.oipf.tv/docs/Release1/OIPF-T1-R1-Specification-Volume-5-Declarative-Application-Environment-V1_0-2009-01-06.pdf}  
 * @class tvedemo/ext/device/shared/opif/DrmAgent
 */
define("tvedemo/ext/device/shared/opif/DrmAgent", ["xdk-base/class", "xdk-base/promise", "xdk-base/util", "xdk-base/console", "xdk-base/core", "xdk-base/exception", "storm/helper/util"], function (klass, promise, util, console, core, exception, stormUtil) {
    "use strict";
    var MSG_TYPE = "application/vnd.ms-playready.initiator+xml",
        SYSTEM = {
            UNKNOWN: "Unknown",
            PLAY_READY: "PlayReady",
            MARLIN: "Marlin"
        };

    return klass.create({}, {
        /**
         * The DRM Agent object
         * @protected
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _drmAgent: undefined,
        /**
         * The DRM systen id
         * @protected
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _systemId: undefined,
        /**
         * Counter for the DRM request
         * @protected
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _requestCounter: 0,
        /**
         * The license acquisition defer object
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __laDeferred: undefined,
        /**
         * The join domain defer object
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __jdDeferred: undefined,
        /**
         * Flag to indicate if an joinDomain is processing
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __joiningDomain: false,
        /**
         * The last license acquisition promise object in the queue
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __queuedPromise: undefined,
        /**
         * Flag to indicate if an acquisition is processing
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __acquiuringLicense: false,
        /**
         * Process queue
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __queue: [],
        /**
         * Flag to indicate if the queue is being processed
         * @private
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        __processingQueue: false,

        /**
         * Initialize the DrmAgent.
         * @method
         * @param {Object} drmAgent The platform dependent drmAgent
         * @param {String} systemId The system id used to identify the device
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        init: function (drmAgent, systemId) {
            if (!drmAgent) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "No valid native drm agent available");
            }
            if (!systemId) {
                throw core.createException(exception.ILLEGAL_ARGUMENT, "systemId is mandatory");
            }

            this._drmAgent = drmAgent;
            this._systemId = systemId;

            drmAgent.onDRMMessageResult = util.bind(this._onDRMMessageResult, this);
            drmAgent.onDRMRightsError = util.bind(this._onDRMRightsError, this);
        },

        /**
         * Send the license request to the native drm agent.
         * @method
         * @param {String} laUrl The url of the license acquisition server
         * @param {String} [customData] The custom data
         * @returns {Promise.<Boolean>} Return true when the license acqiusition success
         * @throws {Promise.<ax/Exception>} Reject if any error occurs
         * @memberof tvedemo/ext/device/shared/opif/DrmAgent#
         */
        sendLicenseRequest: function (laUrl, customData) {
            var deferred = promise.defer(),
                process = util.bind(function (_defer) {
                    
                    console.log("Processing request");
                    var _promise;
                    // reset counter for each process
                    //this._requestCounter = 0;

                    this.__laDeferred = _defer;

                    // promise = _promise, but get from _defer to avoid closure issue
                    _promise = _defer.promise;

                    this._sendDRMMessages(laUrl, customData);

                    // the license acquisition resolved, resolve the individual promise
                    return _promise.then(function (msg) {
                        _defer.resolve(msg);
                    }).fail(function (reason) {
                        _defer.reject(reason);
                    });
                }, this, deferred);

            // only process the request if none is working AND the queue is not empty
            // otherwise push to the queue
            if (!this.__acquiuringLicense && this.__queue.length === 0) {
                this.__acquiuringLicense = true;
                process(deferred);
            } else {
                this.__queue.push(process);
            }

            return deferred.promise;
        },

        /**
         * Counter to make sure that join domain request loops does not occur.
         * @type {Number}
         * @memberOf tvedemo/ext/device/shared/opif/DrmAgent#
         */
        joinDomainAttempts: 0,

        /**
         * Playready only function, join domain. Defaults to current data set.
         * @function joinDomain
         * @param domainController {String} The URL to the domainController
         * @param dsId             {String} The id for the service
         * @param accountId        {String}
         * @param customData       {String} customdata to send in GET format (eg. assetID=123&license=false)
         * @param dsIdFormat       {String} The format of the dsId parameter
         * @return                 {void}
         */
        joinDomain: function(domainController, dsId, accountId, customData, dsIdFormat) {
            
            
            if (this.joinDomainAttempts >= 1) {
                return;
            }
            this.joinDomainAttempts++;

            accountId = accountId || null;
            
            var deferred = promise.defer(),
                process = util.bind(function (_defer) {
                    
                    console.log("Processing joinDomain request");
                    var _promise;
                    this._requestCounter++;

                    this.__jdDeferred = _defer;

                    // promise = _promise, but get from _defer to avoid closure issue
                    _promise = _defer.promise;

                    var xmlInitiator = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                                        "<PlayReadyInitiator xmlns=\"http://schemas.microsoft.com/DRM/2007/03/protocols/\">" +
                                             "<JoinDomain>" +
                                                "<DomainController>" + domainController + "</DomainController>" +
                                                "<DS_ID>" + dsId + "</DS_ID>" +
                                                (accountId ? "<AccountID>" + accountId + "</AccountID>" : "") +
                                             "<CustomData>" + customData + "</CustomData>" +
                                             "</JoinDomain>" +
                                        "</PlayReadyInitiator>";
                    //console.log("DRM message contents:");
                    //console.log(xmlInitiator);
                    
                    try {
                        this._drmAgent.sendDRMMessage(MSG_TYPE, xmlInitiator, this._systemId);
                    }
                    catch(e)
                    {
                        console.error(e.message);
                        _defer.reject(e.message);
                    }

                    // the license acquisition resolved, resolve the individual promise
                    return _promise.then(function (msg) {
                        _defer.resolve(msg);
                    }).fail(function (reason) {
                        _defer.reject(reason);
                    });
                }, this, deferred);

            // only process the request if none is working AND the queue is not empty
            // otherwise push to the queue
            if (!this.__joiningDomain && this.__queue.length === 0) {
                this.__joiningDomain = true;
                process(deferred);
            } else {
                this.__queue.push(process);
            }

            return deferred.promise;
        },

        /**
         * Process the request queue.
         * @protected
         * @method
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _processQueue: function () {
            if (this.__processingQueue) {
                return;
            }

            this.__processingQueue = true;
            var fn = this.__queue.shift();
            if (fn) {
                fn().then(util.bind(function () {
                    this.__processingQueue = false;
                    this._processQueue();
                }, this));
            } else {
                this.__processingQueue = false;
            }
        },

        /**
         * The actual function to send DRM messages.
         * @protected
         * @method
         * @param {String} laUrl The url of the license acquisition server
         * @param {String} [customData] The custom data
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _sendDRMMessages: function (laUrl, customData) {
            var xmlLicenseAcquisition;

            try {
                // license URL
                if (util.isString(laUrl)) {
                    this._requestCounter++;

                    xmlLicenseAcquisition = "<?xml version='1.0' encoding='utf-8'?>" +
                            "<PlayReadyInitiator xmlns='http://schemas.microsoft.com/DRM/2007/03/protocols/'>" +
                                "<LicenseServerUriOverride>" +
                                    "<LA_URL>" + laUrl + "</LA_URL>" +
                                "</LicenseServerUriOverride>" +
                            "</PlayReadyInitiator>";
                    this._drmAgent.sendDRMMessage(MSG_TYPE, xmlLicenseAcquisition, this._systemId);
                    console.log("sendDRMMessage (License Acquisition URL): " + laUrl);
                    //console.log("DRM message contents:");
                    //console.log(xmlLicenseAcquisition);
                }

                // custom Data
                if (util.isString(customData)) {
                    this._requestCounter++;

                    xmlLicenseAcquisition = "<?xml version='1.0' encoding='utf-8'?>" +
                            "<PlayReadyInitiator xmlns='http://schemas.microsoft.com/DRM/2007/03/protocols/'>" +
                                "<SetCustomData>" +
                                    "<CustomData>" + customData + "</CustomData>" +
                                "</SetCustomData>" +
                            "</PlayReadyInitiator>";
                    this._drmAgent.sendDRMMessage(MSG_TYPE, xmlLicenseAcquisition, this._systemId);
                    console.log("sendDRMMessage (CustomData): " + customData);
                    //console.log("DRM message contents:");
                    //console.log(xmlLicenseAcquisition);
                }
            } catch (e) {
                console.warn("[DrmAgent] ERROR: sendDRMMessage (" + e + ")");
                this._requestCounter = 0; // fail, reset counter
                this.__acquiuringLicense = false;
                this.__laDeferred.reject(core.createException(exception.INTERNAL, "sendDRMMessage failed: " + e));
            }
        },

        /**
         * Callback to be called by the native drm agent when sendDRMMessage() is finished.
         * @protected
         * @method
         * @param {String} msgId Identifies the original message which has lead to this resulting message
         * @param {String} resultMsg DRM system specific result message
         * @param {Number} resultCode Integer result code
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _onDRMMessageResult: function (msgId, resultMsg, resultCode) {
            var description;

            this._requestCounter--;

            switch (resultCode) {
                case 0:
                    description = "Successful";
                    if (this._requestCounter > 0) {
                        description += ", but not yet ready (request counter > 0)";
                    }
                    break;
                case 1:
                    if (resultMsg === "0x8004C600") {
                        description = "Server could not deliver a license (server internal error)";
                    } else if (resultMsg === "0x8004C580") {
                        description = "Acquired license successfully but domain certificate missing on device";
                    }
                    break;
                case 2:
                    description = "Cannot process request";
                    break;
                case 3:
                    description = "Unknown MIME type";
                    break;
                case 4:
                    description = "User consent needed";
                    break;
            }
            console.log("[DrmAgent] onDRMMessageResult: msgId: "+msgId+" resultMsg: "+resultMsg+" resultCode: " + resultCode + " - " + description);
            console.log("[DrmAgent] counter down to " + this._requestCounter);
            
            // Packing arguments into object and send with resolve
            var result = {
                msgId: msgId,
                resultMsg: resultMsg,
                resultCode: resultCode,
                description: description
            };
        
            if (this.__joiningDomain)
            {
                this._onDomainJoinded(result);
            }
            else if (this._requestCounter === 0) 
            {
                this._onLicenseAcquired(result);
            }
        },

        /**
         * Callback to be called when the join domain is done.
         * This function will resolve the join domain defer.
         * @protected
         * @method
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _onDomainJoinded: function (result) {
            console.log("[DrmAgent] domain joined");
            this.__jdDeferred.resolve(result);
            this.__joiningDomain = false;
            this.joinDomainAttempts = 0;
            //this._processQueue();
        },

        /**
         * Callback to be called when the license acquisition is done.
         * This function will resolve the license acquisition defer.
         * @protected
         * @method
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _onLicenseAcquired: function (result) {
            console.log("[DrmAgent] license acquired (or not)");
            stormUtil.traceObject(result, "Result", "log");
            this.__laDeferred.resolve(result);
            this.__acquiuringLicense = false;
            this._processQueue();
        },

        /**
         * Callback to be called by the native drm agent when license acquisition fails.
         * This function will reject the license acquisition defer.
         * @protected
         * @method
         * @param {Number} errorState Error state code
         * @param {String} contentId 
         * @param {String} drmSystemId The identifier of the drm system
         * @param {String} rightsIssuerUrl The url of the rights issuer
         * @memberof ax/device/shared/opif/DrmAgent#
         */
        _onDRMRightsError: function (errorState, contentId, drmSystemId, rightsIssuerUrl) {
            var systemName = SYSTEM.UNKNOWN,
                description;

            switch(errorState) {
                case 0:
                    description = "No license (0), consumption of the content is blocked";
                    break;
                case 1:
                    description = "Invalid License (1), consumption of the content is blocked";
                    break;
                case 2:
                    description = "Valid License (2), consumption of the content is unblocked";
                    break;
                default:
                    description = "Unknown (" + errorState + ")";
                    break;
            }

            if (drmSystemId) {
                if (drmSystemId.indexOf("19188") !== -1) {
                    systemName = SYSTEM.MARLIN;
                } else if (drmSystemId.indexOf("19219") !== -1) {
                    systemName = SYSTEM.PLAY_READY;
                } else {
                    systemName = drmSystemId;
                }
            }

            console.warn("[DrmAgent] onDRMRightsError (from " + systemName + "): " + description + "; contentId:" + contentId + "; rightsIssuerUrl: " + rightsIssuerUrl);
            if (this.__acquiuringLicense)
            {
                this.__laDeferred.reject(core.createException(exception.UNAUTHORIZED, description));
                this.__acquiuringLicense = false;
            }
            if (this.__joiningDomain)
            {
                this.__jdDeferred.reject(core.createException(exception.UNAUTHORIZED, description));
                this.__joiningDomain = false;
            }
            this._processQueue();
        }
    });
});

/**
 * Devices view's template
 * @name text
 * @memberof tvedemo/tmpl
 * @class tvedemo/tmpl/devices
 */
define("tvedemo/tmpl/devices", [
    "xdk-ui-basic/Layout", 
    "xdk-ui-basic/Label", 
    "xdk-ax/Container",
    "xdk-ui-basic/Button", 
    "storm/mgr/sLanguageManager",
    "storm/helper/util"
], function (
    Layout,
    Label, 
    Container,
    Button,
    sLanguageManager,
    stormUtil
    ) {

    "use strict";

    return function (opts) {
        return {
            klass: Layout,
            id: "#deviceView",
            css: "subcontrollerPage",
            width: 1,
            alignment: Layout.VERTICAL,
            children: [{
                klass: Container,
                children: [{
                    klass: Label,
                    css: "storm-page-title",
                    text: sLanguageManager.getString("Settings.Settings_Devices_Headline")
                },{
                    klass: Container,
                    id: "deviceContainer",
                    children: [{
                        klass: Label,
                        css: "storm-label",
                        text: sLanguageManager.getString("Settings.Settings_devices_maxnumber")
                    },{
                        klass: Layout,
                        alignment: Layout.HORIZONTAL,
                        children: [{
                            klass: Label,
                            css: "storm-label",
                            text: sLanguageManager.getString("Settings.Settings_devices_freeslots")
                        },{
                            klass: Label,
                            css: "storm-label devices-left",
                            id: "freeDevicesLeft"
                        }]
                    },{
                        klass: Label,
                        css: "storm-label",
                        id: "deviceStatus"
                    },{
                        klass: Container,
                        id: "devicesList",
                        css: "device-list",
                        children: stormUtil.repeater(function() {
                            return {
                                klass: Layout,
                                width: 2,
                                alignment: Layout.HORIZONTAL,
                                children: [{
                                    klass: Label,
                                    css: "storm-label device-item"
                                },{
                                    klass: Label,
                                    css: "storm-label"
                                }]
                            };
                        }, opts.rows)
                    },{
                        klass: Button,
                        id: "resetDeviceList",
                        css: "storm-button disabled",
                        text: sLanguageManager.getString("Settings.Settings_devicesResetButton")       
                    },{
                        klass: Label,
                        css: "storm-label small",
                        text: sLanguageManager.getString("Settings.Settings_devicesResetMessage")
                    },{
                        klass: Label,
                        css: "storm-label small",
                        id: "nextResetDate"
                    }]
                }]
            }]
        };
    };
});
/**
 * The Devices Page view's controller.
 * @name Devices
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Devices
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Devices", [
    "xdk-base/ax",
    "xdk-base/device",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/devices",
    "tvedemo/mgr/sEndUserManager",
    "tve/sServiceHolder",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "storm/mgr/sLanguageManager",
    "storm/helper/silkResponseHelper",
    "storm/helper/util",
    "tvedemo/helper/dialogHelper",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/sMoment"
], function (
    ax,
    device,
    RoutableController,
    view,
    devicesTmpl,
    sEndUserManager,
    sServiceHolder,
    util,
    evtType,
    focusManager,
    sLanguageManager,
    silkResponseHelper,
    stormUtil,
    dialogHelper,
    sHistoryManager,
    moment
    ) {

    return ax.klass.create(RoutableController, {
        getDefaultState: function() {
            return {
                __forceReload: true
            };
        }
    }, {

        MAX_DEVICES: 4,
        DATE_FORMAT_SRC: sLanguageManager.getString("ui.parsing.deviceDate"),
        DATE_FORMAT_DST: sLanguageManager.getString("ui.format.deviceDate"),

        _formatDate: function(dateString) {
            return stormUtil.transcodeDateString(dateString, this.DATE_FORMAT_SRC, this.DATE_FORMAT_DST);
        },

        init: function () {
            this.setView(view.render(devicesTmpl, {rows: this.MAX_DEVICES}));
        },

        setup: function (context) {
            var view = this.getView();

            if (context.historyBack === true) {
                if (!sEndUserManager.getLoginStatus()) {
                    sHistoryManager.back();
                    return;
                }
            }

            this._freeDevicesLeft = view.find("freeDevicesLeft");
            this._deviceStatus = view.find("deviceStatus");
            this._deviceList = view.find("devicesList");
            this._nextResetDate = view.find("nextResetDate");
            this._resetListBtn = view.find("resetDeviceList");

            // disable reset button and attach click listener
            this._resetListBtn.disable();
            this._resetClickHandlerRef = util.bind(this._resetClickHandler, this);
            this._resetListBtn.addEventListener(evtType.CLICK, this._resetClickHandlerRef);

            // @TODO: we have to be logged-in
            context.setupPending = this._getDeviceDetailsPromise().then(util.bind(function() {
                view.setOption("focusable", this._resetListBtn.isDisabled());
                focusManager.focus(view);
            }, this));
        },

        _getDeviceDetailsPromise: function() {
            return sEndUserManager.getDeviceDetails().then(util.bind(function(details) {
                this._freeDevicesLeft.setText(details.get("freeSlots"));
                this._nextResetDate.setText(sLanguageManager.getString("Settings.Settings_devicesNextDate") + ": " + this._formatDate(details.get("resetNextDay")));

                // Populate devices list.
                var devices = details.get("deviceList") || [],
                    deviceRows = this._deviceList.getChildren(),
                    curDeviceId = device.id.getUniqueID(),
                    isCurDeviceRegistered;

                for (var i = 0, rowChildren; i < deviceRows.length; i++) {
                    rowChildren = deviceRows[i].getChildren();

                    if (i < devices.length) {
                        rowChildren[0].addClass("highlighted");
                        rowChildren[0].setText(devices[i].get("platform"));
                        rowChildren[1].setText(this._formatDate(devices[i].get("activationDate")));

                        // Check if current device is one of the ones listed.
                        isCurDeviceRegistered = isCurDeviceRegistered || devices[i].get("id") === curDeviceId;

                    } else {
                        rowChildren[0].removeClass("highlighted");
                        rowChildren[0].setText(sLanguageManager.getString("Settings.Settings_labelDeviceManagement_Missing_device" + (i+1)));
                        rowChildren[1].setText("-");
                    }
                }

                // Now we know if our device is register.
                this._deviceStatus.setText(isCurDeviceRegistered ? sLanguageManager.getString("Settings.Settings_devicesThisDeviceIsRegistered")
                                                                 : sLanguageManager.getString("Settings.Settings_devicesThisDeviceIsNotRegistered"));

                // Check if we can reset the list.
                return sServiceHolder.getDateTimeService().getServerDateTime().then(util.bind(function(time) {
                    if (moment(time).diff(moment(details.get("resetNextDay"), this.DATE_FORMAT_SRC), "hours") >= 0 && devices.length) {
                        this._resetListBtn.enable();
                    } else {
                        this._resetListBtn.disable();
                    }
                }, this));

            }, this), dialogHelper.fromSilkMessagePromise);
        },

        _resetClickHandler: function() {
            sEndUserManager.resetDeviceList().then(util.bind(function() {
                this._getDeviceDetailsPromise();
            }, this), dialogHelper.fromSilkMessagePromise);
        },

        reset: function() {
            if (this._resetListBtn) {
                this._resetListBtn.removeEventListener(evtType.CLICK, this._resetClickHandlerRef);
            }
        }
    });
});
define("xdk-ui-grid/gridStgy", ["xdk-base/console", "xdk-ax/Component", "xdk-ax/Container", "xdk-base/device/vKey", "xdk-base/util", "xdk-base/promise"], function (console, Component, Container, vKey, util, promise) {
    "use strict";
    var mod = function (number, divisor) { // modulo operation
            //in wiiU 1%0 is 0, so we try to standardize the %0 which should be NaN in all the platform
            if (divisor === 0) {
                return NaN;
            }
            return ((number % divisor) + divisor) % divisor;
        },
        strategies = {};



    // ======== pre-ready strategies ========
    strategies.BASIC_PREREADY_STGY = function (state) {
        state.selectedDsIndex = 0;
        state.selectedGridRow = 0;
    };


    // ======== check scrollable strategies ========
    strategies.BASIC_CHECK_SCROLLABLE_STGY = function (curState, toState) {
        var dsCount = curState.ds.getTotalCount();
        if (toState.firstSlotDsIndex < -curState.cols || toState.firstSlotDsIndex >= dsCount + curState.cols) {
            // going out of bound, not selectable
            return false;
        }

        if (toState.selectedDsIndex >= dsCount) {
            toState.selectedDsIndex = dsCount - 1;
            toState.selectedGridCol = (dsCount - 1) % curState.cols;
        }
        return true;
    };


    // ======== check selectable strategies ========
    strategies.BASIC_CHECK_SELECTABLE_STGY = function (curState, toState) {
        var toDsIndex = toState.selectedDsIndex,
            dataCount = curState.ds.getTotalCount(),
            toDsRow, lastDsRow;

        if (toDsIndex < 0) {
            return false;
        }

        // Unknown datasource
        if (dataCount === -2) {
            return true;
        }

        if (toDsIndex < dataCount) { // witnin range
            return true;
        }

        toDsRow = Math.floor(toDsIndex / curState.cols);
        lastDsRow = Math.floor((dataCount - 1) / curState.cols);

        if (toDsRow <= lastDsRow) { // we can still go to that row
            toState.selectedDsIndex = dataCount - 1;
            toState.selectedGridCol = mod(dataCount - 1, this._cols);
            return true;
        }

        return false;
    };

    // ======== data mapping strategies ========
    strategies.BASIC_DATA_MAPPING_STGY = function (curState, dataArr, gridRow, gridCol, dsIndex) {
        if (dsIndex < 0 || dsIndex >= curState.ds.getTotalCount()) {
            return null;
        }
        return dataArr[gridRow * curState.cols + gridCol];
    };


    // ======== scroll entrance strategies ========
    // first param determines the item alignments
    // first param should be pre-detemined using util.bind()
    strategies.BASIC_SCROLL_ENTRANCE_STGY = function (verticalAlign, container, scrollStep, curState, toState) {
        var newRowsComponents = toState.gridComponents.slice(toState.newRowsStart, toState.newRowsStart + toState.newRowsCount),
            newRowsCount = toState.newRowsCount,
            i, j, rowComponent, rowChildren, placement, marker,

            // REMOVE    
            children = container.getChildren(),
            len;
        //only deinit when there are children
        if (children.length > 0) {
            //throw all the child when the step is larger than the size
            if (scrollStep > children.length || -scrollStep > children.length) {
                for (i = 0; i < children.length && children[i]; i++) {
                    children[i].deinit();
                }
            } else if (scrollStep > 0) {
                // scrolling downwards, top rows need to be removed
                for (i = 0; i < scrollStep && children[i]; i++) {
                    // throw away child
                    children[i].deinit();
                }
            } else {
                // scrolling upwards, bottoom rows need to be removed
                len = children.length;
                for (i = len + scrollStep; i < len && children[i]; i++) {
                    // throw away child
                    children[i].deinit();
                }
            }
        }

        children = container.getChildren();

        // ADD
        for (i = 0; i < newRowsCount; i++) {
            rowChildren = [];
            for (j = 0; j < curState.cols; j++) {
                if (!newRowsComponents[i] || !newRowsComponents[i][j] || !newRowsComponents[i][j].getRoot()) {
                    break;
                }
                rowChildren.push(newRowsComponents[i][j]);
            }
            rowComponent = new Container({
                css: verticalAlign ? "wgt-grid-row-v" : "wgt-grid-row-h",
                children: rowChildren
            });

            if (children.length > 0 && scrollStep < 0 && curState.gridComponents && curState.gridComponents[0]) {
                placement = Component.PLACE_BEFORE;
                marker = curState.gridComponents[0][0].getParent();
            } else {
                placement = Component.PLACE_APPEND;
                marker = null;
            }

            container.attach(rowComponent, placement, marker);
        }

    };


    // ======== scroll shift strategies ========
    strategies.BASIC_SCROLL_SHIFT_STGY = function (container, scrollStep, curState, toState) {
        var message = "grid shifting...... do nothing for basic grid.";
        console.info(message);
        return promise.resolve(message);
    };


    // ======== scroll exit strategies ========
    strategies.BASIC_SCROLL_EXIT_STGY = function (container, scrollStep, curState, toState) {
        var message = "grid exiting shift, remove items is already done in entrance function...... do nothing for basic grid.";
        console.info(message);
        return promise.resolve(message);
    };


    // ======== key navigation strategies ========
    strategies.BASIC_HORIZONTAL_KEY_NAVIGATION_STGY = function (key, curState) {
        switch (key) {

        case vKey.UP.id:
            return {
                rowChange: -1
            };
        case vKey.DOWN.id:
            return {
                rowChange: 1
            };
        case vKey.LEFT.id:
            return {
                colChange: -1
            };
        case vKey.RIGHT.id:
            return {
                colChange: 1
            };
        default:
            return;
        }
    };
    strategies.BASIC_VERTICAL_KEY_NAVIGATION_STGY = function (key, curState) {
        switch (key) {

        case vKey.UP.id:
            return {
                colChange: -1
            };
        case vKey.DOWN.id:
            return {
                colChange: 1
            };
        case vKey.LEFT.id:
            return {
                rowChange: -1
            };
        case vKey.RIGHT.id:
            return {
                rowChange: 1
            };
        default:
            return;

        }
    };

    // ======== onUpdate strategies ========
    strategies.BASIC_ONUPDATE_STGY = function (evt, state, ds) {
        if (evt.action === "reset") {
            //no need to change state and redraw directly.
            return true;
        }

        var dataCount = ds.getTotalCount(),
            updatedFrom = evt.index,
            updatedTo = updatedFrom + evt.length,
            firstSlotDsIndex = state.firstSlotDsIndex,
            lastSlotDsIndex = state.firstSlotDsIndex + state.rows * state.cols - 1,
            maxRow, currentRow;

        if (lastSlotDsIndex < 0 && firstSlotDsIndex >= -dataCount && // within first negative page
            mod(firstSlotDsIndex, dataCount) >= updatedTo) { // no overlap with update
            return false;
        }
        if (firstSlotDsIndex > 0 && lastSlotDsIndex < dataCount && // within first positive page
            lastSlotDsIndex < updatedFrom) { // no overlap with update
            return false;
        }

        if (evt.action === "fetch" &&
            (updatedTo < firstSlotDsIndex || //since the changed item is not in the page (assume fetch just update the data)
                updatedFrom > lastSlotDsIndex) //the changed item is not in the page
        ) {
            return false;
        }

        //update selectedDsIndex on datasource change
        while (dataCount <= state.selectedDsIndex) {
            state.selectedDsIndex--;
        }


        maxRow = Math.floor((dataCount - 1) / state.cols);
        currentRow = Math.floor(dataCount - firstSlotDsIndex) / state.cols;

        //update the selectedDsIndex when it focus on the last page and remove action, it will move the focus to the previous row in some cases.
        if (evt.action === "remove" && maxRow >= state.rows - 1 && state.selectedGridRow < state.rows - 1 && currentRow <= state.rows - 1) {
            state.selectedDsIndex = state.selectedDsIndex - state.cols;
        }

        if (state.selectedGridRow > maxRow && maxRow < state.rows) {
            state.selectedGridRow = maxRow;
        }

        return true;
    };

    // ======== ds range calculation strategies ========
    strategies.BASIC_DS_RANGE_CALCULATION_STGY = function (dsIndex, targetRow, curState) {
        var result = {},
            targetGridCol = mod(dsIndex, curState.cols),
            dataTotalCount = curState.ds.getTotalCount();

        result.from = dsIndex - (targetRow * curState.cols) - targetGridCol;
        result.to = result.from + curState.rows * curState.cols;

        //since the total count is -1 (which is not ready, the actualFrom and actualTo should be the same as from/to.)
        if (dataTotalCount === -1) {
            result.actualFrom = result.from;
            result.actualTo = result.to;
            return result;
        }

        result.actualFrom = mod(result.from, dataTotalCount);
        result.actualTo = mod(result.actualFrom + curState.rows * curState.cols, dataTotalCount);

        return result;
    };

    return strategies;
});
define("xdk-ui-grid/Grid", [
    "xdk-base/class",
    "xdk-ax/Container",
    "xdk-ui-basic/AbstractScrollable",
    "xdk-base/console",
    "xdk-ax/data/Datasource",
    "xdk-ax/evt/type",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-base/core",
    "xdk-ax/focusManager",
    "xdk-base/promise",
    "xdk-ui-grid/gridStgy"
], function (
    klass,
    Container,
    Scrollable,
    console,
    Ds,
    evtType,
    vKey,
    util,
    core,
    focusMgr,
    promise,
    gridStgy
) {

    "use strict";
    var mod = function (number, divisor) { // modulo operation
            //in wiiU 1%0 is 0, so we try to standardize the %0 which should be NaN in all the platform
            if (divisor === 0) {
                return NaN;
            }
            return ((number % divisor) + divisor) % divisor;
        },
        stgyNotReadyErrFn = function () {
            throw core.createException("IncorrectState", "This Grid\"s strategy has not been specified yet!");
        },
        rejectionHandler = function (error) {
            console.info(error);
        },
        rejectionLogger = function (error) {
            console.info(error);
            throw error;
        },
        getPromiseWithMessage = function (message) {
            console.info(message);
            return promise.resolve(message);
        },
        getRejectedPromiseWithMessage = function (message) {
            console.info(message);
            return promise.reject(message);
        };


    return klass.create(Scrollable, {
                VERTICAL: 1,
                HORIZONTAL: 2,
                SCROLL_BASE_ON_ITEM: 1,
                SCROLL_BASE_ON_ROW: 2,
                SCROLL_BASE_ON_PAGE: 3
    }, {
                _ready: false,
                _cols: 5,
                _rows: 5,
                _scrollbarBehavior: 3,
        // ==== grid fillings information ====
                _selectedDsIndex: 0,
                _selectedGridRow: 0,
                _selectedGridCol: 0,
                _firstSlotDsIndex: 0,
                _lastSlotDsIndex: 0,
                _data: null,
        // ==== ds ====
                _ds: null,
        // ==== dom stuff ====
                _gridComponents: null,
                _container: null,
        // ==== strategies ====
                _prereadyStgy: stgyNotReadyErrFn,
                _checkScrollableStgy: stgyNotReadyErrFn,
                _checkSelectableStgy: stgyNotReadyErrFn,
                _dataMappingStgy: stgyNotReadyErrFn,
                _displayStgy: stgyNotReadyErrFn,
                _scrollEntranceStgy: stgyNotReadyErrFn,
                _scrollShiftStgy: stgyNotReadyErrFn,
                _scrollExitStgy: stgyNotReadyErrFn,
                _keyNavigationStgy: stgyNotReadyErrFn,
                _onUpdateStgy: stgyNotReadyErrFn,
                _dsRangeCalculationStgy: stgyNotReadyErrFn,
                setPrereadyStgy: function (stgy) {
            this._prereadyStgy = stgy;
        },
                setCheckScrollableStgy: function (stgy) {
            this._checkScrollableStgy = stgy;
        },
                setCheckSelectableStgy: function (stgy) {
            this._checkSelectableStgy = stgy;
        },
                setDataMappingStgy: function (stgy) {
            this._dataMappingStgy = stgy;
        },
                setDisplayStgy: function (stgy) {
            this._displayStgy = stgy;
        },
                setScrollEntranceStgy: function (stgy) {
            this._scrollEntranceStgy = stgy;
        },
                setScrollShiftStgy: function (stgy) {
            this._scrollShiftStgy = stgy;
        },
                setScrollExitStgy: function (stgy) {
            this._scrollExitStgy = stgy;
        },
                setKeyNavigationStgy: function (stgy) {
            this._keyNavigationStgy = stgy;
        },
                setOnUpdateStgy: function (stgy) {
            this._onUpdateStgy = stgy;
        },
                setDsRangeCalculationStgy: function (stgy) {
            this._dsRangeCalculationStgy = stgy;
        },
                init: function (opts) {
            opts = opts || {};

            if (opts.rows) {
                this._rows = opts.rows;
            }
            if (opts.cols) {
                this._cols = opts.cols;
            }
            if (opts.scrollbarBehavior) {
                this._scrollbarBehavior = opts.scrollbarBehavior;
            }

            this._super(opts);

            this._root.addClass("wgt-grid");

            //to create a container which can be scrolled later and for the animation. width:200% is for horizontal grid
            //as it will go to below of the grid when adding a new row and affect the animation
            this._container = new Container({
                css: "wgt-grid-scroll",
                parent: this
            });

            this.addEventListener(evtType.KEY, this._keyHandler);
            this.addEventListener(evtType.FOCUS, util.bind(this._onFocusHandler, this));

            //Set default ds calculation stgy for backward compatibility
            this.setDsRangeCalculationStgy(gridStgy.BASIC_DS_RANGE_CALCULATION_STGY);
        },
                setDatasource: function (ds) {

            if (!(ds instanceof Ds)) {
                return getRejectedPromiseWithMessage("Cannot set an invalid datasource");
            }

            //If the given datasource is already registered for this grid, do nothing
            if (this._ds === ds) {
                return getRejectedPromiseWithMessage("Unable to set set the same datasource");
            }

            //Remove the previous datasource, if any
            if (this._ds && this.__datasourceListener) {
                this._ds.removeEventListener(Ds.EVT_UPDATED, this.__datasourceListener);
            }

            //Remove all the current children
            this.reset();

            this._ready = false;
            //Register the new datasource
            this._ds = ds;


            var range, state;

            // see if need to change anything
            state = {
                selectedDsIndex: this._selectedDsIndex,
                selectedGridRow: this._selectedGridRow,
                cols: this._cols,
                rows: this._rows,
                ds: ds
            };
            this._prereadyStgy(state);
            this._selectedDsIndex = state.selectedDsIndex;
            this._selectedGridRow = state.selectedGridRow;

            range = this._dsRangeCalculationStgy(this._selectedDsIndex, this._selectedGridRow, state);

            // updated the grid state in case strategy have updated it
            this._selectedGridCol = mod(this._selectedDsIndex, this._cols);
            this._firstSlotDsIndex = range.from;


            //private listner ref for removal
            if (!this.__datasourceListener) {
                this.__datasourceListener = util.bind(this._onDatasourceUpdated, this);
            }

            //listen for more the data source if there is any update
            this._ds.addEventListener(Ds.EVT_UPDATED, this.__datasourceListener);

            return this.__validateDs(range.actualFrom, range.actualTo).then(util.bind(this.select, this, this._selectedDsIndex, this._selectedGridRow));
        },
                getDatasource: function () {
            return this._ds;
        },
                getDatasouce: function () {
            return this.getDatasource();
        },
                scroll: function (step, opts) {
            if (!this._ready) {
                return getRejectedPromiseWithMessage("Grid is not ready yet");
            }

            var dsStep = step * this._cols,
                selectedGridRow = this._selectedGridRow - step,
                selectedDsIndex = this._selectedDsIndex,
                firstSlotDsIndex = this._firstSlotDsIndex + dsStep,
                lastSlotDsIndex = firstSlotDsIndex + this._rows * this._cols - 1,
                curState, toState;

            // limit selected grid row to within view
            if (selectedGridRow < 0) {
                selectedGridRow = 0;
            } else if (selectedGridRow >= this._rows) {
                selectedGridRow = this._rows - 1;
            }

            // limit selected datasource index to within view
            if (selectedDsIndex < firstSlotDsIndex) {
                do {
                    selectedDsIndex += this._cols;
                } while (selectedDsIndex < firstSlotDsIndex);
            } else if (selectedDsIndex > lastSlotDsIndex) {
                do {
                    selectedDsIndex -= this._cols;
                } while (selectedDsIndex > lastSlotDsIndex);
            }

            // calculate target state
            toState = {
                selectedDsIndex: selectedDsIndex,
                selectedGridRow: selectedGridRow,
                selectedGridCol: this._selectedGridCol,
                firstSlotDsIndex: firstSlotDsIndex,
                lastSlotDsIndex: lastSlotDsIndex
            };

            curState = {
                selectedDsIndex: this._selectedDsIndex,
                selectedGridRow: this._selectedGridRow,
                selectedGridCol: this._selectedGridCol,
                firstSlotDsIndex: this._firstSlotDsIndex,
                lastSlotDsIndex: this._firstSlotDsIndex + this._rows * this._cols - 1,
                rows: this._rows,
                cols: this._cols,
                ds: this._ds
            };

            if (!this._checkScrollableStgy(curState, toState)) {
                return getRejectedPromiseWithMessage("Check scrollable strategy indicates scrolling bound has reached.");
            }

            return this.select(toState.selectedDsIndex, toState.selectedGridRow, opts).fail(rejectionLogger);
        },
                select: function (dsIndex, targetRow, opts) {

            this._ready = false;

            opts = opts || {};

            var curState = {
                    selectedDsIndex: this._selectedDsIndex,
                    selectedGridRow: this._selectedGridRow,
                    selectedGridCol: this._selectedGridCol,
                    firstSlotDsIndex: this._firstSlotDsIndex,
                    lastSlotDsIndex: this._firstSlotDsIndex + this._rows * this._cols - 1,
                    data: this._data,
                    gridComponents: this._gridComponents,
                    ds: this._ds,
                    rows: this._rows,
                    cols: this._cols
                },
                curRange = this._dsRangeCalculationStgy(this._selectedDsIndex, this._selectedGridRow, curState),
                toState = {
                    selectedDsIndex: dsIndex,
                    selectedGridRow: targetRow,
                    selectedGridCol: mod(dsIndex, this._cols),
                    firstSlotDsIndex: -1,
                    // not calculated yet
                    lastSlotDsIndex: -1,
                    // not calculated yet
                    data: null,
                    // not calculated yet
                    gridComponents: null // not calculated yet
                },
                self = this,
                selectable, scrollStep, toRange, actualDsFrom, actualDsTo, updateSelectionFn, scrollFn, dataArr = [],
                dataTotalCount = this._ds.getTotalCount(),
                fail;

            // automatically guess target row
            if (!util.isNumber(targetRow)) {
                if (dsIndex >= curRange.from && dsIndex < curRange.to) {
                    targetRow = this._selectedGridRow;
                } else if (dsIndex < curRange.from) {
                    targetRow = 0;
                } else {
                    targetRow = this._rows - 1;
                }

                toState.selectedGridRow = targetRow;
            }

            // calculate some of the new state information
            toRange = this._dsRangeCalculationStgy(dsIndex, targetRow, curState);
            toState.firstSlotDsIndex = toRange.from;
            toState.lastSlotDsIndex = toRange.to - 1;
            // check selectable strategy
            selectable = this._checkSelectableStgy(curState, toState);

            if (opts.forceRender && !selectable) { // disregard selectable boolean
                console.info("Grid: forced render.");
            } else if (!selectable) {
                this._ready = true;
                return getRejectedPromiseWithMessage("Putting item at datasource index " + dsIndex + ", to row " + targetRow + ", is not posible.");
            }


            // calculate scroll steps
            scrollStep = (toState.firstSlotDsIndex - curState.firstSlotDsIndex) / this._cols;


            updateSelectionFn = function () {
                console.info("Grid: updating selection...");

                var compGrid = toState.gridComponents,
                    selectedGridRow = toState.selectedGridRow,
                    selectedGridCol = toState.selectedGridCol;

                try {
                    curState.gridComponents[curState.selectedGridRow][curState.selectedGridCol].removeClass("wgt-grid-selected");
                } catch (ex) {
                    // most likely the component has been deinited
                }
                compGrid[selectedGridRow][selectedGridCol].addClass("wgt-grid-selected");

                self._ready = true;

                if (focusMgr.isCompChildFocused(self)) {
                    focusMgr.focus(compGrid[selectedGridRow][selectedGridCol]);
                }

                if (selectable) {
                    self.setOption("forwardFocus", compGrid[selectedGridRow][selectedGridCol]);
                } else {
                    self.setOption("forwardFocus", undefined);
                }

                self.dispatchEvent(evtType.SELECTION_CHANGED, toState);
            };

            actualDsFrom = toRange.actualFrom;
            actualDsTo = toRange.actualTo;

            fail = util.wrap(getRejectedPromiseWithMessage, function (orign, msg) {
                self._ready = true;
                console.info("fail to selection changed");
                self.dispatchEvent(evtType.SELECTION_CHANGED, toState);
                return orign(msg);
            });

            scrollFn = function (fetchedDataArr) {
                dataArr = dataArr.concat(fetchedDataArr);
                toState.data = dataArr;

                return self._scroll(dataArr, scrollStep, curState, toState, opts);
            };

            if (actualDsFrom >= actualDsTo || this._rows * this._cols > dataTotalCount) { // seems like need looping
                return this._ds.getRange(actualDsFrom, dataTotalCount).then(function (data) {

                    if (actualDsFrom === 0) { // no need to fetch the other half
                        return data;
                    }

                    if (curState.rows * curState.cols > dataTotalCount) { // fetch all remaining
                        actualDsTo = actualDsFrom;
                    } else if (actualDsTo === 0) { // the other half has nothing
                        return data;
                    }

                    dataArr = dataArr.concat(data);
                    return self._ds.getRange(0, actualDsTo); // fetch the other half
                }).then(scrollFn).then(updateSelectionFn).fail(fail);
            }

            return this._ds.getRange(actualDsFrom, actualDsTo).then(scrollFn).then(updateSelectionFn).fail(fail);

        },
                _scroll: function (dataArr, scrollStep, curState, toState, opts) {
            var newRowsCount = Math.min(Math.abs(scrollStep), this._rows),
                newRowsStart = scrollStep > 0 ? this._rows - newRowsCount : 0,
                dataCount = this._ds.getTotalCount(),
                i, j, childComp, curData, isInit = !curState.gridComponents,
                newRowsComponents = [],
                gridComponents = curState.gridComponents,
                self = this,
                updateGridStateFn, actualSelectedDsIdx = mod(toState.selectedDsIndex, dataCount);

            updateGridStateFn = function () {
                // update grid state
                self._selectedDsIndex = toState.selectedDsIndex;
                self._selectedGridRow = toState.selectedGridRow;
                self._selectedGridCol = toState.selectedGridCol;
                self._firstSlotDsIndex = toState.firstSlotDsIndex;
                self._lastSlotDsIndex = toState.lastSlotDsIndex;
                self._data = toState.data;
                // ==== dom stuff ====
                self._gridComponents = toState.gridComponents;
            };

            if (isInit) { // we are initializing the grid!
                newRowsCount = this._rows;
                newRowsStart = 0;
                gridComponents = [];
            }

            // prepare the new rows' components
            for (i = newRowsStart; i < newRowsStart + newRowsCount; i++) {
                for (j = 0; j < this._cols; j++) {

                    curData = this._dataMappingStgy(curState, dataArr, i, j, toState.firstSlotDsIndex + i * this._cols + j);

                    if (!curData) {
                        continue;
                    }

                    childComp = this._displayStgy(curData);
                    childComp.getRoot().addClass("wgt-grid-item");

                    // make sure it is an array
                    newRowsComponents[i - newRowsStart] = newRowsComponents[i - newRowsStart] || [];
                    // put into new row
                    newRowsComponents[i - newRowsStart].push(childComp);
                }
            }

            // calculate the updated grid components
            if (newRowsStart === 0) {
                gridComponents = newRowsComponents.concat(gridComponents).slice(0, this._rows);
            } else {
                gridComponents = gridComponents.concat(newRowsComponents).slice(newRowsCount, this._rows + newRowsCount);
            }

            // information on the newly added rows
            toState.newRowsStart = newRowsStart;
            toState.newRowsCount = newRowsCount;
            toState.gridComponents = gridComponents;

            // dispatch scroll event
            switch (this._scrollbarBehavior) {
            case this.constructor.SCROLL_BASE_ON_ITEM:
                this.dispatchScrolledInfo(actualSelectedDsIdx, 1, dataCount);
                break;
            case this.constructor.SCROLL_BASE_ON_ROW:
                this.dispatchScrolledInfo(actualSelectedDsIdx - mod(actualSelectedDsIdx, this._cols), this._cols, dataCount);
                break;
            case this.constructor.SCROLL_BASE_ON_PAGE:
                this.dispatchScrolledInfo(mod(toState.firstSlotDsIndex, dataCount), this._cols * this._rows, dataCount);
                break;
            }

            // no need to scroll, just return
            if (!isInit && scrollStep === 0) {
                updateGridStateFn();
                return getPromiseWithMessage("No scroll needed.");
            }


            return promise.when(this._scrollEntranceStgy(this._container, scrollStep, curState, toState), function () {

                // initialization, only create elements
                if (isInit) {
                    updateGridStateFn();
                    return getPromiseWithMessage("Currently initializing grid, no shift animation will be performed.");
                }


                // no animation
                if (opts.noAnimation === true) {

                    return promise.when(self._scrollExitStgy(self._container, scrollStep, curState, toState), function () {
                        updateGridStateFn();
                        return getPromiseWithMessage("Animation is turned off, no shift animation will be performed.");
                    });
                }

                // do everything
                return self._scrollShiftStgy(self._container, scrollStep, curState, toState).then(function () {
                    self._scrollExitStgy(self._container, scrollStep, curState, toState);

                    updateGridStateFn();

                    return true;
                });

            });

        },
                reset: function () {
            // ==== dom stuff ====
            this._gridComponents = null;

            util.each(this._container.getChildren(), function (child) {
                child.detach();
            });

            this.setOption("forwardFocus", undefined);

            this._selectedDsIndex = 0;
            this._selectedGridRow = 0;
            this._selectedGridCol = 0;
            this._firstSlotDsIndex = 0;
            this._lastSlotDsIndex = 0;
            this._data = null;

        },
                isReady: function () {
            return this._ready;
        },
                _keyHandler: function (evt) {
            if (!this._ready) {
                return false; // comsume the key
            }

            var focusRet, evtKey = evt.id,
                curFocus, parent, child, toGridCol, toGridRow, toDsIndex, scrollStep, navi, curState, selectResult, maxRow, maxCol;

            switch (evtKey) {
            case vKey.UP.id:
            case vKey.DOWN.id:
            case vKey.LEFT.id:
            case vKey.RIGHT.id:
                focusRet = focusMgr.directionalFocusChangeByKey(evt, this);
                break;
            default:
                return true;
            }

            if (focusRet) {
                return false;
            }

            curFocus = focusMgr.getCurFocus();
            child = curFocus;
            parent = child.getParent();
            while (parent && parent !== this && !child.getRoot().hasClass("wgt-grid-item")) {
                child = parent;
                parent = child.getParent();
            }

            if (!parent || parent === this) { // parent should be container
                return true;
            }

            curState = {
                selectedDsIndex: this._selectedDsIndex,
                selectedGridRow: this._selectedGridRow,
                selectedGridCol: this._selectedGridCol,
                firstSlotDsIndex: this._firstSlotDsIndex,
                lastSlotDsIndex: this._firstSlotDsIndex + this._rows * this._cols - 1,
                data: this._data,
                gridComponents: this._gridComponents,
                ds: this._ds,
                rows: this._rows,
                cols: this._cols
            };

            navi = this._keyNavigationStgy(evt.id, curState);
            navi = util.extend({
                rowChange: 0,
                colChange: 0,
                scroll: 0,
                forceRender: false
            }, navi);

            toGridRow = this._selectedGridRow + navi.rowChange;
            toGridCol = this._selectedGridCol + navi.colChange;
            scrollStep = navi.scroll;

            maxRow = this._rows;

            if (scrollStep < 0) {
                //scrolling backward
                maxCol = this._cols;
            } else {
                maxCol = this._gridComponents[this._selectedGridRow].length < this._cols ? this._gridComponents[this._selectedGridRow].length : this._cols;
            }


            // translate exessive row change into scrolling
            if (toGridRow < 0) {
                toGridRow = 0;
                scrollStep += toGridRow;
            } else if (toGridRow >= maxRow) {
                scrollStep += toGridRow - (maxRow - 1);
                toGridRow = maxRow - 1;
            }

            if (toGridCol < 0) {
                toGridCol = 0;
            } else if (toGridCol >= maxCol) {
                toGridCol = maxCol - 1;
            }

            toDsIndex = this._selectedDsIndex + navi.rowChange * this._cols + navi.scroll * this._cols + (toGridCol - this._selectedGridCol);

            if (this._selectedDsIndex === toDsIndex && this._selectedGridRow === toGridRow && this._selectedGridCol === toGridCol) {
                // no change at all
                return true;
            }

            selectResult = this.select(toDsIndex, toGridRow, {
                forceRender: navi.forceRender
            });

            selectResult.fail(rejectionHandler).done();

            return promise.isRejected(selectResult);
        },
                _onFocusHandler: function (evt) {
            if (!this._ready) {
                return;
            }

            var i = 0,
                j = 0,
                len, rowLen, rowComponents, comp, selectedDsIndex;

            // just focus child if grid gets focused
            if (evt.target === this) {
                focusMgr.focus(this._gridComponents[this._selectedGridRow][this._selectedGridCol]);
                return;
            }

            len = this._gridComponents.length;
            for (i = 0; i < len && this._gridComponents[i]; i++) {
                rowComponents = this._gridComponents[i];
                rowLen = rowComponents.length;
                for (j = 0; j < rowLen && rowComponents[j]; j++) {
                    comp = this._gridComponents[i][j];

                    if (focusMgr.isCompFocused(comp) || focusMgr.isCompChildFocused(comp)) { // found

                        // updated selection
                        this._gridComponents[this._selectedGridRow][this._selectedGridCol].removeClass("wgt-grid-selected");
                        comp.addClass("wgt-grid-selected");

                        selectedDsIndex = this._firstSlotDsIndex + i * this._cols + j;

                        //early return if it is the original selected item
                        if (i === this._selectedGridRow && j === this._selectedGridCol && this._selectedDsIndex === selectedDsIndex) {
                            return;
                        }

                        this._selectedGridRow = i;
                        this._selectedGridCol = j;
                        this._selectedDsIndex = selectedDsIndex;

                        //to set back the forwardfocus to the new component
                        this.setOption("forwardFocus", comp);
                        
                        //dispatch the event about the selection changed
                        this.dispatchEvent(evtType.SELECTION_CHANGED, {
                            selectedDsIndex: this._selectedDsIndex,
                            selectedGridRow: this._selectedGridRow,
                            selectedGridCol: this._selectedGridCol,
                            firstSlotDsIndex: this._firstSlotDsIndex,
                            lastSlotDsIndex: this._lastSlotDsIndex,
                            data: this._data,
                            gridComponents: this._gridComponents
                        });

                        return;
                    }
                }
            }
        },

                _onDatasourceUpdated: function (evt) {
            console.info("Grid: datasource updated!");

            if (!this._ready) {
                console.info("Grid: not yet ready to react to datasource update!");
                return;
            }

            var state, ret, selectedDsIndex, selectedGridRow, range, selectForceRender = true;

            // see if need to change anything after the data updated
            state = {
                selectedDsIndex: this._selectedDsIndex,
                selectedGridRow: this._selectedGridRow,
                selectedGridCol: this._selectedGridCol,
                firstSlotDsIndex: this._firstSlotDsIndex,
                cols: this._cols,
                rows: this._rows,
                ds: this._ds
            };

            ret = this._onUpdateStgy(evt, state, this._ds);

            if (!ret) {
                return;
            }

            selectedDsIndex = state.selectedDsIndex;
            selectedGridRow = state.selectedGridRow;

            range = this._dsRangeCalculationStgy(selectedDsIndex, selectedGridRow, state);

            this.reset();

            //forceRender is used to update the grid even no change in selectdDsIndex. But it is not needed when reset.
            if (evt.action === "reset") {
                selectForceRender = false;
            }

            this.__validateDs(range.actualFrom, range.actualTo).then(util.bind(this.select, this, selectedDsIndex, selectedGridRow, {
                forceRender: selectForceRender
            })).fail(function () {
                console.info("fail to update grid");
            }).done();
        },
                __validateDs: function (from, to) {
            //ds not ready
            if (this._ds.getTotalCount() === -1) {
                return this._ds.getRange(from, to).then(util.bind(function () {

                    if (this._ds.getTotalCount() === -1) {
                        return getRejectedPromiseWithMessage("Unable to initialize the datasource, totalCount still equals -1");
                    }

                }, this));
            }

            //reject with exception if trying to set an empty datasource;
            if (this._ds.getTotalCount() === 0) {
                console.warn("tried to set an datasource 0 total count, grid can will only be updated if it's notified by EVT_UPDATED from datasource with new total count");
            }

            return promise.resolve();
        },
                getSelectedDsIndex: function () {
            var totalCount;
            if (this._ds) {
                totalCount = this._ds.getTotalCount();
                if (totalCount > 0) {
                    return mod(this._selectedDsIndex, totalCount);
                }
            }
            return -1;
        },
                getSelectedComp: function () {
            return this._gridComponents[this._selectedGridRow][this._selectedGridCol];
        },
                getSelectedData: function () {
            var ds = this.getDatasource(),
                dsIndex = this.getSelectedDsIndex();

            if (ds && ds.getFetchedData && dsIndex > -1) {
                return ds.getFetchedData(dsIndex);
            }

            return null;
        },
                getSelectedPosition: function () {
            return {
                row: this._selectedGridRow,
                col: this._selectedGridCol
            };
        },
                getCompByCoor: function (row, col) {
            if (row < 0 || col < 0 || row >= this._gridComponents.length || col >= this._gridComponents[row].length) {
                return undefined;
            }

            return this._gridComponents[row][col];
        }
    });
});
define("xdk-ui-grid/boundedGridStgy", [
    "xdk-base/device/vKey",
    "xdk-ui-grid/gridStgy"
], function (
    vKey,
    gridStgy
) {
    "use strict";
    var mod = function (number, divisor) { // modulo operation
            return ((number % divisor) + divisor) % divisor;
        },
        strategies = {};

    // ======== check selectable strategies ========
    strategies.SCROLL_BOUNDARY_CHECK_SELECTABLE_STGY = function (frontBoundary, endBoundary, curState, toState) {
        var toDsIndex = toState.selectedDsIndex,
            toGridRow = toState.selectedGridRow,
            dataCount = curState.ds.getTotalCount(),
            toDsRow, lastDsRow;

        if (toDsIndex < 0) {
            return false;
        }

        toDsRow = Math.floor(toDsIndex / curState.cols);
        lastDsRow = Math.floor((dataCount - 1) / curState.cols);

        // inside the forbidden boundary
        if (toGridRow < frontBoundary || toGridRow >= curState.rows - endBoundary) {
            // need to be reaching ends to allow selection
            if (toDsRow > frontBoundary && toDsRow < lastDsRow - endBoundary) {
                // not allowed
                return false;
            }
        }

        if (toDsIndex < dataCount) { // witnin range
            return true;
        }

        if (toDsRow <= lastDsRow) { // we can still go to that row
            toState.selectedDsIndex = dataCount - 1;
            toState.selectedGridCol = mod(dataCount - 1, this._cols);
            return true;
        }

        return false;
    };

    // ======== key navigation strategies ========
    strategies.SCROLL_BOUNDARY_KEY_NAVIGATION_STGY = function (isVertical, frontBoundary, endBoundary, key, state) {
        var rowStep, curDsIndex = state.selectedDsIndex,
            dataCount = state.ds.getTotalCount(),
            curGridRow = state.selectedGridRow,
            toGridRow, lastDsRow, toDsRow;

        if (isVertical) {
            switch (key) {
            case vKey.UP.id:
                return {
                    colChange: -1
                };
            case vKey.DOWN.id:
                return {
                    colChange: 1
                };
            case vKey.LEFT.id:
                rowStep = -1;
                break;
            case vKey.RIGHT.id:
                rowStep = 1;
                break;
            default:
                break;
            }
        } else {
            switch (key) {
            case vKey.UP.id:
                rowStep = -1;
                break;
            case vKey.DOWN.id:
                rowStep = 1;
                break;
            case vKey.LEFT.id:
                return {
                    colChange: -1
                };
            case vKey.RIGHT.id:
                return {
                    colChange: 1
                };
            default:
                break;
            }
        }


        if (frontBoundary <= 0 && endBoundary <= 0) { // no boundary actually
            return {
                rowChange: rowStep
            };
        }

        toGridRow = curGridRow + rowStep;
        toDsRow = Math.floor(curDsIndex / state.cols) + rowStep;
        lastDsRow = Math.floor((dataCount - 1) / state.cols);

        // inside the forbidden boundary
        if (toGridRow < frontBoundary || toGridRow >= state.rows - endBoundary) {
            // need to be reaching ends to allow selection
            if (toDsRow < frontBoundary || toDsRow > lastDsRow - endBoundary) {
                // allowed
                return {
                    rowChange: rowStep
                };
            }
            return {
                scroll: rowStep
            };
        }

        return {
            rowChange: rowStep
        };
    };

        // ======== onUpdate strategies ========
    strategies.ONUPDATE_STGY = function (frontBoundary, endBoundary, evt, state, ds) {

        var ret = gridStgy.BASIC_ONUPDATE_STGY(evt, state, ds);

        var dataCount = ds.getTotalCount(),
            firstSlotDsIndex = state.firstSlotDsIndex,
            lastSlotDsIndex = state.firstSlotDsIndex + state.rows * state.cols - 1;
        //checking the dsIndex whether lie on the boundary cases

        //bottom boundary
        if (lastSlotDsIndex < dataCount - 1) {

            //check whether the new focus is in the bottom boundary

            var endDiff = state.selectedGridRow - (state.rows - 1 - endBoundary);

            if (endDiff >= 0) {
                //update the new dsIndex and row so that fulfill the end boundary
                state.selectedDsIndex = state.selectedDsIndex - endDiff * state.cols;
                state.selectedGridRow -= endDiff;
                return true;
            }
        }

        //front boundary
        if (firstSlotDsIndex !== 0) {
            //check whether the new focus is in the front boundary
            var frontDiff = frontBoundary - state.selectedGridRow;

            if (frontDiff >= 0) {
                //update the new dsIndex and row so that fulfill the front boundary
                state.selectedDsIndex = state.selectedDsIndex + frontDiff * state.cols;
                state.selectedGridRow += frontDiff;
                return true;
            }
        }

        return ret;
    };

    return strategies;
});

define('css!xdk-ui-grid/css/Grid',[],function(){});
define("xdk-ui-grid/BoundedGrid", ["xdk-base/class","xdk-ui-grid/Grid","xdk-ui-grid/gridStgy","xdk-ui-grid/boundedGridStgy","xdk-base/util","css!./css/Grid"], function (klass, Grid, gridStgy, boundedGridStgy, util) {
    "use strict";
    return klass.create(Grid, {}, {
                init: function (opts) {
            this._super(opts);

            var isVerticalAlign = opts.alignment === Grid.VERTICAL,
                frontBoundary = opts.scrollFrontBoundary || 0,
                endBoundary = opts.scrollEndBoundary || 0;

            this.setPrereadyStgy(gridStgy.BASIC_PREREADY_STGY);
            this.setCheckScrollableStgy(gridStgy.BASIC_CHECK_SCROLLABLE_STGY);
            this.setCheckSelectableStgy(util.bind(boundedGridStgy.SCROLL_BOUNDARY_CHECK_SELECTABLE_STGY, this, frontBoundary, endBoundary));
            this.setDataMappingStgy(gridStgy.BASIC_DATA_MAPPING_STGY);

            this.setScrollEntranceStgy(util.bind(gridStgy.BASIC_SCROLL_ENTRANCE_STGY, this, isVerticalAlign));

            this.setScrollShiftStgy(gridStgy.BASIC_SCROLL_SHIFT_STGY);
            this.setScrollExitStgy(gridStgy.BASIC_SCROLL_EXIT_STGY);

            this.setOnUpdateStgy(util.bind(boundedGridStgy.ONUPDATE_STGY, this, frontBoundary, endBoundary));

            this.setKeyNavigationStgy(
                util.bind(boundedGridStgy.SCROLL_BOUNDARY_KEY_NAVIGATION_STGY, this, isVerticalAlign, frontBoundary, endBoundary));

            this.setDsRangeCalculationStgy(gridStgy.BASIC_DS_RANGE_CALCULATION_STGY);
        }
    });
});

define('css!tvedemo/wgt/css/BasicGrid',[],function(){});
/**
 * BasicGrid is an abstract grid widget that handles the arrows display according to the number of items and the position of the focus.
 *
 * @name BasicGrid
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/BasicGrid
 * @extends ax/ext/ui/BoundedGrid
 */
define("tvedemo/wgt/BasicGrid", [
    "xdk-base/class",
    "xdk-ui-grid/BoundedGrid",
    "xdk-ax/Container",
    "xdk-ax/evt/type",
    "xdk-ui-basic/Button",
    "xdk-base/util",
    "xdk-ax/Component",
    "xdk-base/device/vKey",
    "css!./css/BasicGrid"
], function (
    klass,
    BoundedGrid,
    Container,
    evtType,
    Button,
    util,
    Component,
    vKey
    ) {

    "use strict";

    var DEFAULT_ROWS = 2,
        DEFAULT_COLS = 7,
        TOP = 0,
        RIGHT = 1,
        BOTTOM = 2,
        LEFT = 3;

    return klass.create(BoundedGrid, {}, {

        //The image widgets to indicate the scrolling state.
        _arrows: [],

        //The alignment of the grid.
        _alignment: 0,

        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} [opts] Options
         * @param {Number} [opts.alignment=Grid.VERTICAL] The grid alignment.
         * @param {Boolean} [opts.isPaginated=false] Whether it is paginated (Only support horizontal paginated grid)
         * @param {Number} [opts.rows=2] The number of rows appears in the grid
         * @param {Number} [opts.cols=7] The number of cols appears in the grid
         * @param {Object} [opts.buttonOpts] The option for the asset button created inside the grid. {@link  tvedemo/wgt/AssetButton}
         * @memberof tvedemo/wgt/BasicGrid#
         */
        init: function (opts) {
            opts = opts || {};

            var alignment = opts.alignment || BoundedGrid.VERTICAL,
                rows = opts.rows,
                cols = opts.cols,
                isVertical;

            //@todo only support horizontal grid temporary for paginated..and arrow is horizontal scroll direction
            opts.isPaginated = opts.isPaginated || false;

            if (opts.isPaginated) {
                this._alignment = BoundedGrid.HORIZONTAL;
            } else {
                this._alignment = opts.alignment = alignment;
            }

            isVertical = this._alignment === BoundedGrid.VERTICAL;

            opts.rows = (isVertical ? (cols || DEFAULT_COLS) : (rows || DEFAULT_ROWS));
            opts.cols = (isVertical ? (rows || DEFAULT_ROWS) : (cols || DEFAULT_COLS));
            opts.forwardFocus = true;

            this._super(opts);

            // paginated grid stgy
            if (opts.isPaginated) {
                this.setScrollEntranceStgy(util.bind(this.__scroll_entrance_stgy, this, isVertical));
                this.setKeyNavigationStgy(util.bind(this.__vertical_key_navigation_stgy, this, isVertical));
            }

            this.addClass("wgt-basicgrid");

            this._initArrows();
        },

        /**
         * Override the function to update the arrows button after the original setDatasource() functions finished.
         * @method
         * @Override
         * @param {ax/af/data/Datasource} ds datasource to set
         * @public
         * @memberof tvedemo/wgt/BasicGrid#
         */
        setDatasource: function (ds) {
            return this._super(ds).then(util.bind(this._updateArrows, this));
        },

        /**
         * Get the selection state of the grid.
         * State information including the selection position interms of rows and cols, slection index.
         * @method
         * @public
         * @memberof tvedemo/wgt/BasicGrid#
         */
        getSelectionStates: function () {
            if (!this.getDatasource() || !this.getDatasource().getTotalCount()) {
                return;
            }
            var rows = Math.ceil(this.getDatasource().getTotalCount() / this._cols),
                cols = this._cols,
                currentRow = Math.floor(this._selectedDsIndex / cols),
                currentCol = this._selectedGridCol,
                total = this.getDatasource().getTotalCount(),
                pageSize = this._rows * this._cols,
                pageNumber = Math.floor(this._selectedDsIndex / pageSize) + 1, // use floor() because we want index 0 counted in page 1
                maxPage = Math.ceil(total / pageSize), // use ceil() because 0 entry should result in 0 page
                canScrollForward = total - this._firstSlotDsIndex > pageSize,
                canScrollBackward = this._firstSlotDsIndex !== 0;

            // swap the rows and cols if alignment is vertical
            if (this._alignment === BoundedGrid.VERTICAL) {
                var temp;

                temp = rows;
                rows = cols;
                cols = temp;

                temp = currentRow;
                currentRow = currentCol;
                currentCol = temp;
            }

            // a more-than-enough information, should serve most of the requirements
            return {
                selectedDsIndex: this._selectedDsIndex,
                isFirstRow: currentRow === 0,
                isLastRow: currentRow === (rows - 1),
                isFirstCol: currentCol === 0,
                isLastCol: currentCol === (cols - 1),
                row: currentRow,
                col: currentCol,
                pageSize: pageSize,
                pageNumber: pageNumber,
                maxPage: maxPage,
                canScrollForward: canScrollForward,
                canScrollBackward: canScrollBackward
            };
        },

        /**
         * Attach the arrows to the grid structure, and add the event listener for the visibility control.
         * @method
         * @protected
         * @memberof tvedemo/wgt/BasicGrid#
         */
        _initArrows: function () {
            //only create the arrow when in the speicifc alignment
            if (this._alignment === BoundedGrid.VERTICAL || this.getOption("isPaginated")) {
                this._arrows[LEFT] = new Button({
                    css: "wgt-grid-arrow"
                }).addClass("left");
                this._arrows[RIGHT] = new Button({
                    css: "wgt-grid-arrow"
                }).addClass("right");

                this.attach(this._arrows[LEFT], Container.PLACE_BEFORE, this._container);
                this.attach(this._arrows[RIGHT], Container.PLACE_APPEND);

                // hide the arrows before the data is ready
                this._arrows[LEFT].hide();
                this._arrows[RIGHT].hide();
            } else {
                this._arrows[TOP] = new Button({
                    css: "wgt-grid-arrow"
                }).addClass("top");
                this._arrows[BOTTOM] = new Button({
                    css: "wgt-grid-arrow"
                }).addClass("bottom");

                this.attach(this._arrows[TOP], Container.PLACE_BEFORE, this._container);
                this.attach(this._arrows[BOTTOM], Container.PLACE_APPEND);

                // hide the arrows before the data is ready
                this._arrows[TOP].hide();
                this._arrows[BOTTOM].hide();
            }

            this.addEventListener(evtType.FOCUS, this._updateArrows);
        },

        /**
         * Show/hide the arrows based on the selection states.
         * @method
         * @protected
         * @memberof tvedemo/wgt/BasicGrid#
         */
        _updateArrows: function () {
            var states = this.getSelectionStates();

            if (this._alignment === BoundedGrid.VERTICAL || this.getOption("isPaginated")) {
                if (states && states.canScrollBackward) {
                    this._arrows[LEFT].show();
                } else {
                    this._arrows[LEFT].hide();
                }

                if (states && states.canScrollForward) {
                    this._arrows[RIGHT].show();
                } else {
                    this._arrows[RIGHT].hide();
                }
            } else {
                if (states && states.canScrollBackward) {
                    this._arrows[TOP].show();
                } else {
                    this._arrows[TOP].hide();
                }

                if (states && states.canScrollForward) {
                    this._arrows[BOTTOM].show();
                } else {
                    this._arrows[BOTTOM].hide();
                }
            }
        },
        //now only support horizontal aligment and handle the paginated
        __vertical_key_navigation_stgy: function (isVertical, key, state) {
            var curDsIndex = state.selectedDsIndex,
                dataCount = state.ds.getTotalCount(),
                curGridRow = state.selectedGridRow,
                curGridCol = state.selectedGridCol,
                lastDsRow, curDsRow;
            curDsRow = Math.floor(curDsIndex / state.cols);
            lastDsRow = Math.floor((dataCount - 1) / state.cols);

            if (isVertical) {
                //@todo vertical alignment
                switch (key) {
                case vKey.UP.id:
                    return {
                        colChange: -1
                    };
                case vKey.DOWN.id:
                    return {
                        colChange: 1
                    };
                case vKey.LEFT.id:
                    return {
                        rowChange: -1
                    };
                case vKey.RIGHT.id:
                    return {
                        rowChange: 1
                    };
                default:
                    break;
                }
            } else {
                switch (key) {
                case vKey.UP.id:
                    if (curGridRow > 0) {
                        return {
                            rowChange: -1
                        };
                    }
                    break;
                case vKey.DOWN.id:
                    if (curGridRow < state.rows - 1) {
                        return {
                            rowChange: 1
                        };
                    }
                    break;
                case vKey.LEFT.id:
                    if (curGridCol > 0) {
                        return {
                            colChange: -1
                        };
                    } else {
                        if (curDsRow - state.rows >= 0) {
                            return {
                                scroll: -state.rows,
                                colChange: state.cols - 1 - curGridCol
                            };
                        } else if (curDsRow - (state.rows - curGridRow) > 0) {
                            return {
                                scroll: state.rows - curGridRow,
                                colChange: state.cols - 1 - curGridCol
                            };
                        }
                    }
                    break;
                case vKey.RIGHT.id:
                    //normal
                    if (curGridCol < state.cols - 1) {
                        return {
                            colChange: 1
                        };
                    } else {
                        if (curDsRow + state.rows <= lastDsRow) {
                            return {
                                scroll: state.rows,
                                colChange: 0 - curGridCol
                            };
                        } else if (curDsRow + (state.rows - curGridRow) <= lastDsRow) {
                            return {
                                scroll: state.rows,
                                rowChange: 0 - curGridRow,
                                colChange: 0 - curGridCol
                            };
                        }
                    }
                    break;
                default:
                    break;
                }
            }
        },
        __scroll_entrance_stgy: function (verticalAlign, container, scrollStep, curState, toState) {
            var newRowsComponents = toState.gridComponents.slice(toState.newRowsStart, toState.newRowsStart + toState.newRowsCount),
                newRowsCount = toState.newRowsCount,
                i, j, rowComponent, rowChildren, placement, marker,

                // REMOVE   
                children = container.getChildren(),
                len;
            //only deinit when there are children
            if (children.length > 0) {
                // scrolling downwards, top rows need to be removed
                if (scrollStep > 0) {
                    for (i = 0; i < scrollStep && children[i]; i++) {
                        // throw away child
                        children[i].deinit();
                    }
                } else {
                    // scrolling upwards, bottoom rows need to be removed
                    len = children.length;
                    for (i = len + scrollStep; i < len && children[i]; i++) {
                        // throw away child
                        children[i].deinit();
                    }
                }
            }

            children = container.getChildren();

            // ADD
            for (i = 0; i < newRowsCount; i++) {
                rowChildren = [];
                for (j = 0; j < curState.cols; j++) {
                    //also check if the new Components has no root 
                    if (!newRowsComponents[i] || !newRowsComponents[i][j] || !newRowsComponents[i][j].getRoot()) {
                        break;
                    }
                    rowChildren.push(newRowsComponents[i][j]);
                }
                rowComponent = new Container({
                    css: verticalAlign ? "wgt-grid-row-v" : "wgt-grid-row-h",
                    children: rowChildren
                });

                if (children.length > 0 && scrollStep < 0 && curState.gridComponents && curState.gridComponents[0]) {
                    placement = Component.PLACE_BEFORE;
                    marker = curState.gridComponents[0][0].getParent();
                } else {
                    placement = Component.PLACE_APPEND;
                    marker = null;
                }

                container.attach(rowComponent, placement, marker);
            }
        }
    });
});

/**
 * Resource Model
 * @class tve/model/Resource
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/Resource", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member id
             * @memberof tve/model/Resource#
             * @public
             * @type {String}
             */
            "id": null,

            /**
             * @member url
             * @memberof tve/model/Resource#
             * @public
             * @type {String}
             */
            "url": null,

            /**
             * @member mimeType
             * @memberof tve/model/Resource#
             * @public
             * @type {String}
             */
            "mimeType": null,

            /**
             * @member metadata
             * @memberOf tve/model/Resource#
             * @public
             * @type {Object}
             */
            "metadata": {},

            /**
             * @member duration
             * @memberof tve/model/Resource#
             * @public
             * @type {Number}
             */
            "duration": null,

            /**
             * @member geoLock
             * @memberof tve/model/Resource#
             * @public
             * @type {Boolean}
             */
            "geoLock": null,

            /**
             * @member width
             * @memberof tve/model/Resource#
             * @public
             * @type {Number}
             */
            "width": null,

            /**
             * @member height
             * @memberof tve/model/Resource#
             * @public
             * @type {Number}
             */
            "height": null,

            /**
             * @member parentalRating
             * @memberof tve/model/Resource#
             * @public
             * @type {Number}
             */
            "parentalRating": null
        }
    }, {});
});
/**
 * A channel logo widget with a default placeholder.
 * @name ChannelLogo
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/ChannelLogo
 * @param {String|ax/af/mvc/ModelRef} opts.src The image src
 * @param {String|ax/af/mvc/ModelRef} opts.errorImg The error image
 * @param {String|ax/af/mvc/ModelRef} opts.alt The alt of image
 */

define("tvedemo/wgt/ChannelLogo", [
    "xdk-base/class",
    "xdk-ui-basic/Image",
    "xdk-base/util"
], function (
    klass,
    Image,
    util
    ) {

    "use strict";

    var PLACEHOLDER = "img/placeholders/channel_placeholder.png";

    return klass.create(Image, {}, {

        /**
         * override parent's init() method
         * @method
         * @memberof  tvedemo/wgt/ChannelLogo#
         * @protected
         */
        init: function (opts) {
            opts.src = opts.src || PLACEHOLDER;

            this._super(opts);

            this.setErrorCallback(util.bind(function () {
                this.setSrc(PLACEHOLDER);
            }, this));
        }
    });
});
/**
 * Episode Model
 * @class tve/model/Episode
 * @augments tve/model/Asset
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/Episode", ["xdk-base/class", "tve/model/Asset", "xdk-base/util"], function (klass, Asset, util) {
    return klass.create(Asset, {

        defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member tvSeasonId
             * @memberof tve/model/Episode#
             * @public
             * @type {String}
             */
            "tvSeasonId": null,

            /**
             * @member tvShowId
             * @memberof tve/model/Episode#
             * @public
             * @type {String}
             */
            "tvShowId": null,

            /**
             * @member episodeNumber
             * @memberof tve/model/Episode#
             * @public
             * @type {Number}
             */
            "episodeNumber": null
        }, true)
    }, {});
});
/**
 * TVChannel Model
 * @class tve/model/TVChannel
 * @augments tve/model/Asset
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/TVChannel", ["xdk-base/class", "tve/model/Asset", "xdk-base/util"], function (klass, Asset, util) {
    return klass.create(Asset, {

        defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member channelNumber
             * @memberof tve/model/TVChannel#
             * @public
             * @type {String}
             */
            "channelNumber": null,
            "mobilepc": null,
            "packageCode": null
        }, true)
    }, {});
});
/**
 * Asset Builder, for building the Asset model
 * @class tve/model/AssetBuilder
 */
define("tve/model/AssetBuilder", ["xdk-base/class", "tve/model/Asset"], function (klass, Asset) {

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tve/model/AssetBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the identifier for building this model.
         * @param {String} value the identifier
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setId: function (value) {
            this._attrs.id = value;
            return this;
        },

        /**
         * Set the title for building this model.
         * @param {String} value the title
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setTitle: function (value) {
            this._attrs.title = value;
            return this;
        },

        /**
         * Set the description for building this model.
         * @param {String} value the description
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setDescription: function (value) {
            this._attrs.description = value;
            return this;
        },

        /**
         * Set the geo lock for building this model.
         * @param {Boolean} value the geo lock
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setGeoLock: function (value) {
            this._attrs.geoLock = value;
            return this;
        },

        /**
         * Set the published date for building this model.
         * @param {Date} value the published date
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setPublishedDate: function (value) {
            this._attrs.publishedDate = value;
            return this;
        },

        /**
         * Set the available date for building this model.
         * @param {Date} value the available date
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setAvailableDate: function (value) {
            this._attrs.availableDate = value;
            return this;
        },

        /**
         * Set the metadata for building this model.
         * @param {Object} value the metadata
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setMetadata: function (value) {
            this._attrs.metadata = value;
            return this;
        },

        /**
         * Set the credits for building this model.
         * @param {Object} value the credits
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setCredits: function (value) {
            this._attrs.credits = value;
            return this;
        },

        /**
         * Set the categories for building this model.
         * @param {tve/model/MediaCategory[]} value the categories
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setCategories: function (value) {
            this._attrs.categories = value;
            return this;
        },

        /**
         * Set the parental ratings for building this model.
         * @param {String[]} value the parental ratings
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setParentalRatings: function (value) {
            this._attrs.parentalRatings = value;
            return this;
        },

        /**
         * Set the images for building this model.
         * @param {tve/model/Resource[]} value the images
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setImages: function (value) {
            this._attrs.images = value;
            return this;
        },

        /**
         * Set the videos for building this model.
         * @param {tve/model/Resource[]} value the videos
         * @returns {tve/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        setVideos: function (value) {
            this._attrs.videos = value;
            return this;
        },

        /**
         * Build the Asset model.
         * @returns {tve/model/Asset} the Asset model
         * @public
         * @method
         * @memberof tve/model/AssetBuilder#
         */
        build: function () {
            return new Asset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Episode Builder, for building the Episode model
 * @class tve/model/EpisodeBuilder
 */
define("tve/model/EpisodeBuilder", [
    "xdk-base/class", "tve/model/AssetBuilder", "tve/model/Episode"
], function (klass, AssetBuilder, Episode) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the TV season id for building this model.
         * @param {String} value the TV season id
         * @returns {tve/model/EpisodeBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/EpisodeBuilder#
         */
        setTVSeasonId: function (value) {
            this._attrs.tvSeasonId = value;
            return this;
        },

        /**
         * Set the TV show id for building this model.
         * @param {String} value the TV show id
         * @returns {tve/model/EpisodeBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/EpisodeBuilder#
         */
        setTVShowId: function (value) {
            this._attrs.tvShowId = value;
            return this;
        },

        /**
         * Set the episode number for building this model.
         * @param {Number} value the episode number
         * @returns {tve/model/EpisodeBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/EpisodeBuilder#
         */
        setEpisodeNumber: function (value) {
            this._attrs.episodeNumber = value;
            return this;
        },

        /**
         * Build the Episode model.
         * @returns {tve/model/Episode} the Episode model
         * @public
         * @method
         * @memberof tve/model/EpisodeBuilder#
         */
        build: function () {
            return new Episode(this._attrs);
        }
    });

    return Builder;
});
/**
 * MediaCategory Model
 * @class tve/model/MediaCategory
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/MediaCategory", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member id
             * @memberof tve/model/MediaCategory#
             * @public
             * @type {String}
             */
            "id": null,

            /**
             * @member title
             * @memberof tve/model/MediaCategory#
             * @public
             * @type {String}
             */
            "title": null,

            /**
             * @member description
             * @memberof tve/model/MediaCategory#
             * @public
             * @type {String}
             */
            "description": null,

            /**
             * @member categories
             * @memberof tve/model/MediaCategory#
             * @public
             * @type {tve/model/MediaCategory[]}
             */
            "categories": []
        }
    }, {});
});
/**
 * Media Category Builder, for building the MediaCategory model
 * @class tve/model/MediaCategoryBuilder
 */
define("tve/model/MediaCategoryBuilder", ["xdk-base/class", "tve/model/MediaCategory"], function (klass, MediaCategory) {

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tve/model/MediaCategoryBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the identifier for building this model.
         * @param {String} value the identifier
         * @returns {tve/model/MediaCategoryBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/MediaCategoryBuilder#
         */
        setId: function (value) {
            this._attrs.id = value;
            return this;
        },

        /**
         * Set the title for building this model.
         * @param {String} value the title
         * @return {tve/model/MediaCategoryBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/MediaCategoryBuilder#
         */
        setTitle: function (value) {
            this._attrs.title = value;
            return this;
        },

        /**
         * Set the description for building this model.
         * @param {String} value the description
         * @return {tve/model/MediaCategoryBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/MediaCategoryBuilder#
         */
        setDescription: function (value) {
            this._attrs.description = value;
            return this;
        },

        /**
         * Set the categories for building this model.
         * @param {tve/model/MediaCategory[]} value the categories
         * @return {tve/model/MediaCategoryBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/MediaCategoryBuilder#
         */
        setCategories: function (value) {
            this._attrs.categories = value;
            return this;
        },

        /**
         * Build the MediaCategory model.
         * @return {tve/model/MediaCategory} the MediaCategory model
         * @public
         * @method
         * @memberof tve/model/MediaCategoryBuilder#
         */
        build: function () {
            return new MediaCategory(this._attrs);
        }
    });

    return Builder;
});
/**
 * Resource Builder, for building the Resource model
 * @class tve/model/ResourceBuilder
 */
define("tve/model/ResourceBuilder", ["xdk-base/class", "tve/model/Resource"], function (klass, Resource) {

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tve/model/ResourceBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the identifier for building this model.
         * @param {String} value the identifier
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setId: function (value) {
            this._attrs.id = value;
            return this;
        },

        /**
         * Set the url for building this model.
         * @param {String} value the url
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setUrl: function (value) {
            this._attrs.url = value;
            return this;
        },

        /**
         * Set the mime type for building this model.
         * @param {String} value the mime type
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setMimeType: function (value) {
            this._attrs.mimeType = value;
            return this;
        },

        /**
         * Set the metadata for building this model.
         * @param {Object} value the metadata
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setMetadata: function (value) {
            this._attrs.metadata = value;
            return this;
        },

        /**
         * Set the duration for building this model.
         * @param {Number} value the duration
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setDuration: function (value) {
            this._attrs.duration = value;
            return this;
        },

        /**
         * Set the geo lock for building this model.
         * @param {Boolean} value the geo lock
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setGeoLock: function (value) {
            this._attrs.geoLock = value;
            return this;
        },

        /**
         * Set the width for building this model.
         * @param {Number} value the width
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setWidth: function (value) {
            this._attrs.width = value;
            return this;
        },

        /**
         * Set the height for building this model.
         * @param {Number} value the height
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setHeight: function (value) {
            this._attrs.height = value;
            return this;
        },

        /**
         * Set the parental rating for building this model.
         * @param {Number} value the parental rating
         * @returns {tve/model/ResourceBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        setParentalRating: function (value) {
            this._attrs.parentalRating = value;
            return this;
        },

        /**
         * Build the Resource model.
         * @returns {tve/model/Resource} the Resource model
         * @public
         * @method
         * @memberof tve/model/ResourceBuilder#
         */
        build: function () {
            return new Resource(this._attrs);
        }
    });

    return Builder;
});
/**
 * TVSeason Model
 * @class tve/model/TVSeason
 * @augments tve/model/Asset
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/TVSeason", ["xdk-base/class", "tve/model/Asset", "xdk-base/util"], function (klass, Asset, util) {
    return klass.create(Asset, {

        defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member seasonNumber
             * @memberof tve/model/TVSeason#
             * @public
             * @type {Number}
             */
            "seasonNumber": null,

            /**
             * @member tvShowId
             * @memberof tve/model/TVSeason#
             * @public
             * @type {String}
             */
            "tvShowId": null,

            /**
             * @member startYear
             * @memberof tve/model/TVSeason#
             * @public
             * @type {Number}
             */
            "startYear": null,

            /**
             * @member endYear
             * @memberof tve/model/TVSeason#
             * @public
             * @type {Number}
             */
            "endYear": null,

            /**
             * @member episodeIds
             * @memberof tve/model/TVSeason#
             * @public
             * @type {String[]}
             */
            "episodeIds": []
        }, true)
    }, {});
});
/**
 * TVSeason Builder, for building the TVSeason model
 * @class tve/model/AssetBuilder
 */
define("tve/model/TVSeasonBuilder", [
    "xdk-base/class", "tve/model/AssetBuilder", "tve/model/TVSeason"
], function (klass, AssetBuilder, TVSeason) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the season number for building this model.
         * @param {Number} value the season number
         * @returns {tve/model/TVSeasonBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVSeasonBuilder#
         */
        setSeasonNumber: function (value) {
            this._attrs.seasonNumber = value;
            return this;
        },

        /**
         * Set the show id for building this model.
         * @param {String} value the show id
         * @returns {tve/model/TVSeasonBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVSeasonBuilder#
         */
        setTVShowId: function (value) {
            this._attrs.tvShowId = value;
            return this;
        },

        /**
         * Set the start year for building this model.
         * @param {Number} value the start year
         * @returns {tve/model/TVSeasonBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVSeasonBuilder#
         */
        setStartYear: function (value) {
            this._attrs.startYear = value;
            return this;
        },

        /**
         * Set the end year for building this model.
         * @param {Number} value the end year
         * @returns {tve/model/TVSeasonBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVSeasonBuilder#
         */
        setEndYear: function (value) {
            this._attrs.endYear = value;
            return this;
        },

        /**
         * Set the episode ids for building this model.
         * @param {String[]} value the episode ids
         * @returns {tve/model/TVShowBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVSeasonBuilder#
         */
        setEpisodeIds: function (value) {
            this._attrs.episodeIds = value;
            return this;
        },

        /**
         * Build the TVSeason model.
         * @returns {tve/model/TVSeason} the TVSeason model
         * @public
         * @method
         * @memberof tve/model/TVSeasonBuilder#
         */
        build: function () {
            return new TVSeason(this._attrs);
        }
    });

    return Builder;
});
/**
 * TVShow Builder, for building the TVShow model
 * @class tve/model/TVShowBuilder
 */
define("tve/model/TVShowBuilder", [
    "xdk-base/class", "tve/model/AssetBuilder", "tve/model/TVShow"
], function (klass, AssetBuilder, TVShow) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the season ids for building this model.
         * @param {String[]} value season ids
         * @returns {tve/model/TVShowBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVShowBuilder#
         */
        setSeasonIds: function (value) {
            this._attrs.seasonIds = value;
            return this;
        },

        /**
         * Set the episode ids for building this model.
         * @param {String[]} value the episode ids
         * @returns {tve/model/TVShowBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVShowBuilder#
         */
        setEpisodeIds: function (value) {
            this._attrs.episodeIds = value;
            return this;
        },

        /**
         * Build the TVShow model.
         * @returns {tve/model/TVShow} the TVShow model
         * @public
         * @method
         * @memberof tve/model/TVShowBuilder#
         */
        build: function () {
            return new TVShow(this._attrs);
        }
    });

    return Builder;
});
/**
 * Returns a singleton responsible to convert metadata as well as assets retrevied from VOD service to desired format (list, ds, etc)
 * @name sVODManager
 * @memberof tve/mgr
 * @class tve/mgr/sVODManager
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/mgr/sVODManager", [
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/util",
    "tve/sServiceHolder",
    "xdk-ax/data/LocalDatasource",
    "xdk-base/core",
    "xdk-base/promise",
    "tve/util/CacheHelper",
    "lib/base64",
    "tve/TVEError",
    "tve/model/AssetBuilder",
    "tve/model/EpisodeBuilder",
    "tve/model/MediaCategoryBuilder",
    "tve/model/ResourceBuilder",
    "tve/model/TVSeasonBuilder",
    "tve/model/TVShowBuilder"
], function (
    klass,
    config,
    util,
    serviceHolder,
    LocalDatasource,
    core,
    promise,
    Cache,
    base64,
    TVEError,
    AssetBuilder,
    EpisodeBuilder,
    MediaCategoryBuilder,
    ResourceBuilder,
    TVSeasonBuilder,
    TVShowBuilder) {

    "use strict";

    var CACHE_KEY_PREFIX = {
        TV_SHOWS: "tvshows",
        MOVIES: "movies",
        EPISODES: "episodes",
        TV_SEASONS: "tvseasons",
        ALL_TV_SHOWS: "all_tvshows",
        ALL_TV_SEASONS: "all_tvseasons",
        ALL_MOVIES: "all_movies",
        ALL_EPISODES: "all_episodes",
        ALL_CATEGORIES: "all_categories",
        ALL_TV_SHOWS_DS: "all_tvshows_ds",
        ALL_TV_SEASONS_DS: "all_tvseasons_ds",
        ALL_MOVIES_DS: "all_movies_ds",
        ALL_EPISODES_DS: "all_episodes_ds",

        MOVIE_COVER: "movie_cover",
        MOVIE_THUMBNAIL: "movie_thumbnail",
        MOVIE_TRAILER: "movie_trailer",
        MOVIE_CONTENT: "movie_content",

        TV_SHOW_THUMBNAIL: "tvshow_thumbnail",
        TV_SHOW_CONTENT: "tvshow_content",

        TV_SEASON_THUMBNAIL: "tvseason_thumbnail",
        TV_SEASON_CONTENT: "tvseason_content",

        EPISODE_THUMBNAIL: "episode_thumbnail",
        EPISODE_CONTENT: "episode_content"
    },

        CACHE_SIZE = 1000,
        RESOURCE_CACHE_SIZE = 4000,

        FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,

        TTL = 30 * 60 * 1000, // 30 minutes

        PAGE_SIZE = 30, //define how many data to load every time call the server

        //constants below are added only for TVE Demo
        MOVIE_CAT_FID = "c_1000",
        TVSHOW_CAT_FID = "c_2000",

        vodContentService = serviceHolder.getVODContentService(),

        __parser = (function () {
            var parser = {},

                __IMAGES = {
                    COVER: "cover",
                    THUMBNAIL: "thumbnail"
                },

                __arrayToMapHelper = function (subObj, parseMap) {
                    var ret = {},
                        NAME = parseMap[0],
                        VALUE = parseMap[1],
                        subObjName, subObjValue, subLen, i;

                    subLen = subObj.length;

                    for (i = 0; i < subLen; i++) {
                        subObjName = subObj[i][NAME];
                        subObjValue = subObj[i][VALUE];
                        if (!subObjName || !subObjValue) {
                            continue;
                        }
                        ret[subObjName] = subObjValue;
                    }

                    return ret;
                },

                __parseAssetObj = function (obj) {
                    if (!obj.id || !obj.title) {
                        throw new TVEError(FACILITY.VOD_MANAGER, ERROR.INVALID, "Cannot parse asset: no id/title");
                    }

                    var assetObj = {
                        id: obj.id,
                        title: obj.title,
                        description: obj.description || "",
                        publishedDate: obj.publishedDate ? new Date(obj.publishedDate) : null,
                        availableDate: obj.publishedDate ? new Date(obj.availableDate) : null,
                        metadata: {},
                        credits: obj.credits ? __arrayToMapHelper(obj.credits, ["role", "name"]) : [],
                        categories: [],
                        parentalRatings: obj.parentalRatings || [],
                        images: []
                    },
                        flagThumb = false,
                        flagCover = false,
                        videoContent;

                    if (obj.categories) {
                        util.each(obj.categories, function (category) {
                            assetObj.categories.push(parseMediaCategory(category));
                        });
                    }

                    if (obj.images) {
                        util.each(obj.images, function (image) {
                            if (flagThumb && flagCover) {
                                return util.breaker;
                            }

                            if (!flagThumb && util.indexOf(image.type, __IMAGES.THUMBNAIL) > -1) {
                                assetObj.images.push(parseResource(image));
                                assetObj.metadata.thumbnail$resId = image.id;
                                flagThumb = true;
                                return;
                            }

                            if (!flagCover && util.indexOf(image.type, __IMAGES.COVER) > -1) {
                                assetObj.images.push(parseResource(image));
                                assetObj.metadata.cover$resId = image.id;
                                flagCover = true;
                                return;
                            }
                        });
                    }

                    if (obj.videos) {
                        assetObj.videos = [];

                        util.each(obj.videos, function (video) {
                            if (!videoContent) {
                                videoContent = video;
                                return;
                            }
                            if (videoContent && video.width > videoContent.width) {
                                videoContent = video;
                            }
                        });

                        if (videoContent) {
                            assetObj.videos.push(parseResource(videoContent));
                            assetObj.metadata.trailer$resId = videoContent.id;
                            assetObj.metadata.content$resId = videoContent.id;
                        }
                    }

                    return assetObj;
                };

            /**
             * Inject the banner into parsedAssetObj.
             * This function will find the banner in the assetObj's images array, and inject it into that of parsedAssetObj.
             * __parsedAssetObj__ will be modified.
             * @private
             * @method
             * @param {Object} parsedAssetObj The target object to be injected
             * @param {Object} assetObj The original object that contains the banner image
             * @memberOf tve/mgr/sVODManager#
             */
            var injectBanner = function (parsedAssetObj, assetObj) {
                var assetImages = parsedAssetObj.images || [];

                if (util.isArray(assetObj.images)) {
                    util.each(assetObj.images, function (imageObj) {
                        if (util.indexOf(imageObj.type, "banner") > -1) {
                            assetImages.push(parseResource(imageObj));
                        }
                    });
                }
            };

            var parseAsset = function (obj) {
                var builder = new AssetBuilder(),
                    model,
                    parsedObj = __parseAssetObj(obj);

                // inject the banner into parsedObj
                injectBanner(parsedObj, obj);

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description)
                    .setPublishedDate(parsedObj.publishedDate).setAvailableDate(parsedObj.AvailableDate)
                    .setMetadata(parsedObj.metadata).setCredits(parsedObj.credits).setCategories(parsedObj.categories)
                    .setParentalRatings(parsedObj.parentalRatings).setImages(parsedObj.images).setVideos(parsedObj.videos)
                    .build();

                return model;
            };
            parser.parseAsset = parseAsset;

            var parseTVShow = function (obj) {
                var builder = new TVShowBuilder(),
                    model,
                    parsedObj = __parseAssetObj(obj);

                // inject the banner into parsedObj
                injectBanner(parsedObj, obj);

                parsedObj.seasonIds = [];
                if (obj.tvSeasons) {
                    util.each(obj.tvSeasons, function (tvSeason) {
                        parsedObj.seasonIds.push(tvSeason.id);
                    });
                }

                parsedObj.episodeIds = [];
                if (obj.episodes) {
                    util.each(obj.episodes, function (episode) {
                        parsedObj.episodeIds.push(episode.id);
                    });
                }

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description)
                    .setPublishedDate(parsedObj.publishedDate).setAvailableDate(parsedObj.AvailableDate)
                    .setMetadata(parsedObj.metadata).setCredits(parsedObj.credits).setCategories(parsedObj.categories)
                    .setParentalRatings(parsedObj.parentalRatings).setImages(parsedObj.images).setVideos(parsedObj.videos)
                    .setSeasonIds(parsedObj.seasonIds).setEpisodeIds(parsedObj.episodeIds).build();

                return model;
            };
            parser.parseTVShow = parseTVShow;

            var parseTVSeason = function (obj) {
                var builder = new TVSeasonBuilder(),
                    model,
                    parsedObj = __parseAssetObj(obj);

                parsedObj.tvShowId = obj.tvShowId;
                parsedObj.seasonNumber = obj.tvSeasonNumber;
                parsedObj.startYear = obj.startYear;
                parsedObj.endYear = obj.endYear;

                parsedObj.episodeIds = [];
                if (obj.episodes) {
                    util.each(obj.episodes, function (episode) {
                        parsedObj.episodeIds.push(episode.id);
                    });
                }

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description)
                    .setPublishedDate(parsedObj.publishedDate).setAvailableDate(parsedObj.AvailableDate)
                    .setMetadata(parsedObj.metadata).setCredits(parsedObj.credits).setCategories(parsedObj.categories)
                    .setParentalRatings(parsedObj.parentalRatings).setImages(parsedObj.images).setTVShowId(parsedObj.tvShowId)
                    .setSeasonNumber(parsedObj.seasonNumber).setStartYear(parsedObj.startYear).setEndYear(parsedObj.endYear)
                    .setEpisodeIds(parsedObj.episodeIds).setVideos(parsedObj.videos).build();

                return model;
            };
            parser.parseTVSeason = parseTVSeason;

            var parseEpisode = function (obj) {
                var builder = new EpisodeBuilder(),
                    model,
                    parsedObj = __parseAssetObj(obj);

                parsedObj.tvSeasonId = obj.tvSeasonId;
                parsedObj.tvShowId = obj.tvShowId;
                parsedObj.episodeNumber = obj.episodeNumber;

                if (!parsedObj.episodeNumber) {
                    util.each(obj.metadata, function (metadata) {
                        if (metadata.name === "VOD$episodeNumber") {
                            parsedObj.episodeNumber = metadata.value;
                            return util.breaker;
                        }
                    });
                }

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description)
                    .setPublishedDate(parsedObj.publishedDate).setAvailableDate(parsedObj.AvailableDate)
                    .setMetadata(parsedObj.metadata).setCredits(parsedObj.credits).setCategories(parsedObj.categories)
                    .setParentalRatings(parsedObj.parentalRatings).setImages(parsedObj.images).setTVShowId(parsedObj.tvShowId)
                    .setEpisodeNumber(parsedObj.episodeNumber).setVideos(parsedObj.videos).build();

                return model;
            };
            parser.parseEpisode = parseEpisode;

            var parseMediaCategory = function (obj) {
                var builder = new MediaCategoryBuilder(),
                    model,
                    parsedObj = {
                        id: obj.id,
                        title: obj.title,
                        description: obj.description || "",
                        categories: []
                    };

                if (obj.categories) {
                    util.each(obj.categories, function (category) {
                        parsedObj.categories.push(parseMediaCategory(category));
                    });
                }

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description).build();

                return model;
            };
            parser.parseMediaCategory = parseMediaCategory;

            var parseResource = function (obj) {
                var builder = new ResourceBuilder(),
                    model,
                    parsedObj = {
                        id: obj.id,
                        url: obj.url || "",
                        mimeType: obj.format || "",
                        metadata: {},
                        language: obj.language || "",
                        duration: obj.duration || 0,
                        geoLock: obj.geoLock || false,
                        width: obj.width || 0,
                        height: obj.height || 0
                    };


                if (obj.type) {
                    parsedObj.metadata.type = obj.type;
                }

                model = builder.setId(parsedObj.id).setUrl(parsedObj.url).setMimeType(parsedObj.mimeType)
                    .setMetadata(parsedObj.metadata).setDuration(parsedObj.duration).setGeoLock(parsedObj.geoLock)
                    .setWidth(parsedObj.width).setHeight(parsedObj.height).build();

                return model;
            };
            parser.parseResource = parseResource;

            return parser;
        }()),

        VODManager = klass.create({
            /**
             * Available SORY_BY enum for sorting
             * (This was modified in product demo.)
             * @name SORT_BY
             * @typedef {Object} SORT_BY
             * @property {String} DEFAULT - default, i.e. no sorting
             * @property {String} TITLE - sort by title
             * @property {String} LATEST - sort by latest
             * @public
             * @memberof tve/mgr/sVODManager
             * @static
             */
            SORT_BY: {
                DEFAULT: "",
                TITLE: "title|asc",
                LATEST: "publishedDate|desc"
            },
            /**
             * Human readable of SORY_BY enum text
             * (This was added in product demo.)
             * @name SORT_BY_TXT
             * @typedef {Object} SORT_BY_TXT
             * @property {String} DEFAULT - default, i.e. no sorting
             * @property {String} TITLE - sort by title
             * @property {String} LATEST - sort by latest
             * @public
             * @memberof tve/mgr/sVODManager
             * @static
             */
            SORT_BY_TXT: {
                DEFAULT: "Default",
                TITLE: "Title",
                LATEST: "Latest"
            }
        }, {

            _cache: new Cache({
                ttl: TTL,
                size: CACHE_SIZE
            }),

            _resourceCache: new Cache({
                ttl: TTL,
                size: RESOURCE_CACHE_SIZE
            }),

            /**
             * Get TVshows in an array format
             * @method getTVShows
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {Number} [opts.startIndex] the start index of return array
             * @param {Number} [opts.count] the number of return array
             * @param {Array}  [opts.ids] the tvshow IDs
             * @public
             * @returns {Promise.<tve/model/TVShow[]>} An array of TVShow models
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVShows: function (opts) {

                opts = opts || {};

                if (!util.isObject(opts)) {
                    return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "Incorrect parameter type"));
                }

                var __opts = {},
                    startIndex = opts.startIndex,
                    count = opts.count,
                    ids = opts.ids,
                    cacheKey,
                    ret,
                    entriesHandler,

                    // sortBy
                    sortOptions,

                    // local page filter is used for getXsByIds, which does not have server side pagination
                    flagPageFilter = false;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                if (ids) {
                    __opts.ids = ids;

                    if (util.isNumber(startIndex) && count) {
                        flagPageFilter = true;
                    }
                }

                cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_TV_SHOWS, __opts);
                ret = this._cache.getCache(cacheKey);

                // handle cache
                if (ret) {
                    if (flagPageFilter) {
                        ret = ret.slice(startIndex, startIndex + count);
                    }
                    return promise.resolve(ret);
                }

                // handle return
                entriesHandler = util.bind(function (tvShows) {
                    ret = util.reduce(tvShows.entries, function (prev, curr) {
                        prev.push(__parser.parseTVShow(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.TV_SHOWS);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    // cache the whole list, but return only the page needed
                    if (flagPageFilter) {
                        return ret.slice(startIndex, startIndex + count);
                    }
                    return ret;
                }, this);

                if (ids) {
                    return vodContentService.getTVShowsByIds(ids, __opts).then(entriesHandler)
                        .then(util.bind(this.__prefetchTVSeasonsForTVShows, this));
                }

                return vodContentService.getAllTVShows(__opts).then(entriesHandler)
                    .then(util.bind(this.__prefetchTVSeasonsForTVShows, this));
            },

            /**
             * Get TVShows in a datasource format. Note: if both ids and categoryId are set, ids would be chosen as parameter to return result
             * @method getTVShowsDs
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {String}  [opts.categoryId] the category ID
             * @param {Array} [opts.ids] the tvshow IDs
             * @public
             * @returns {LocalDatasource.<tve/model/TVShow>} a DS of TVShow data
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowsDs: function (opts) {

                opts = opts || {};

                var __opts = {},
                    cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_TV_SHOWS_DS, opts),
                    cache = this._cache.getCache(cacheKey),
                    ids, categoryId = opts.categoryId,
                    serviceFn, ds,
                    // sortBy
                    sortOptions,
                    fetchFn;

                if (cache) {
                    return cache;
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                // type checking
                ids = opts.ids && opts.ids.join ? opts.ids : null;

                if (ids) {
                    serviceFn = util.bind(vodContentService.getTVShowsByIds, vodContentService, ids);

                } else if (categoryId) {
                    serviceFn = util.bind(vodContentService.getTVShowsByCategoryId, vodContentService, categoryId);

                } else {
                    // if no ids are provided, fetch all
                    serviceFn = util.bind(vodContentService.getAllTVShows, vodContentService);
                }

                // prefetch the TV seasons
                fetchFn = util.bind(function (__opts) {
                    return serviceFn(__opts).then(util.bind(this.__prefetchTVSeasonsForTVShows, this));
                }, this);

                ds = this.__dataListToDsHelper(fetchFn, __parser.parseTVShow, __opts);
                // function cache
                this._cache.setObject(cacheKey, ds);
                return ds;
            },

            /**
             * Get TVshow by given TVShow Id
             * @method getTVShowById
             * @param {String} id the ID of the tvshow
             * @public
             * @returns {Promise.<tve/model/TVShow>} TVShow model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowById: function (id) {

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SHOWS, {
                    id: id
                }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return vodContentService.getTVShowById(id).then(util.bind(function (tvshow) {

                    tvshow = __parser.parseTVShow(tvshow);

                    this._cache.setObject(cacheKey, tvshow);

                    return tvshow;

                }, this));
            },

            /**
             * Get TVshows by given Category Id
             * @method getTVShowsByCategoryId
             * @param {String} categoryId the ID of the category
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @public
             * @returns {Promise.<tve/model/TVShow[]>} An array of TVShow models
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowsByCategoryId: function (categoryId, opts) {

                opts = opts || {};

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SHOWS, util.extend({
                    categoryId: categoryId
                }, opts)),
                    ret = this._cache.getCache(cacheKey),
                    __opts = {},
                    // sortBy
                    sortOptions;

                if (ret) {
                    return promise.resolve(ret);
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.getTVShowsByCategoryId(categoryId, __opts).then(util.bind(function (tvShows) {
                    ret = util.reduce(tvShows.entries, function (prev, curr) {
                        prev.push(__parser.parseTVShow(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.TV_SHOWS);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    return ret;

                }, this));
            },

            /**
             * Search TV shows by the specific keyword.
             * @method
             * @param {String} key The search key
             * @param {Object} [opts] The options of the request
             * @returns {tve/model/TVShow[]} The TV shows that matched the keyword
             * @memberOf tve/mgr/sVODManager#
             */
            searchTVShows: function (key, opts) {
                opts = opts || {};

                var tvShows,
                    __opts = {},
                    sortOptions;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.searchTVShows(key, __opts).then(util.bind(function (responseObj) {
                    tvShows = util.reduce(responseObj.entries, function (prev, curr) {
                        prev.push(__parser.parseTVShow(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(tvShows, CACHE_KEY_PREFIX.TV_SHOWS);

                    return tvShows;
                }, this));
            },

            /**
             * Get TV show thumbnail by given TVShow model.
             * Return the defaultResource when none is found if provided.
             * @method getTVShowThumbnail
             * @param {tve/model/TVShow} tvShow the TVShow model
             * @param {tve/model/Resource} [defaultResource] The resource to return if not found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for thumbnail
             * @throws {Promise.<tve/TVEError>} if the associated resource could not be found
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowThumbnail: function (tvShow, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SHOW_THUMBNAIL + tvShow.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(tvShow, "thumbnail", cacheKey, defaultResource);
            },

            /**
             * Get TV show content by given TVShow model
             * @method getTVShowContent
             * @param {tve/model/Asset} tvShow the TVShow model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for content
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowContent: function (tvShow) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SHOW_CONTENT + tvShow.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                //Accedo OVP service only provides one video in the content.
                ret = tvShow.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no content found"));
            },

            /**
             * Get all Movies in an array format
             * @method getMovies
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {Number} [opts.startIndex] the start index of return array
             * @param {Number} [opts.count] the number of return array
             * @param {Array}  [opts.ids] the movie IDs
             * @public
             * @returns {Promise.<tve/model/Asset[]>} An array of Asset (type Movie) models
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMovies: function (opts) {

                opts = opts || {};

                if (!util.isObject(opts)) {
                    return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "Incorrect parameter type"));
                }

                var __opts = {},
                    startIndex = opts.startIndex,
                    count = opts.count,
                    ids = opts.ids,
                    cacheKey,
                    ret,
                    entriesHandler,

                    // sortBy
                    sortOptions,

                    // local page filter is used for getXsByIds, which does not have server side pagination
                    flagPageFilter = false;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                if (ids) {
                    __opts.ids = ids;

                    if (util.isNumber(startIndex) && count) {
                        flagPageFilter = true;
                    }
                }

                cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_MOVIES, __opts);
                ret = this._cache.getCache(cacheKey);

                // handle cache
                if (ret) {
                    if (flagPageFilter) {
                        ret = ret.slice(startIndex, startIndex + count);
                    }
                    return promise.resolve(ret);
                }

                // handle return
                entriesHandler = util.bind(function (movies) {
                    ret = util.reduce(movies.entries, function (prev, curr) {
                        prev.push(__parser.parseAsset(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.MOVIES);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    // cache the whole list, but return only the page needed
                    if (flagPageFilter) {
                        return ret.slice(startIndex, startIndex + count);
                    }
                    return ret;
                }, this);


                if (ids) {
                    return vodContentService.getMoviesByIds(ids, __opts).then(entriesHandler);
                }

                return vodContentService.getAllMovies(__opts).then(entriesHandler);

            },

            /**
             * Get Movies in a datasource format. Note: if both ids and categoryId are set, ids would be chosen as parameter to return result
             * @method getChannelsDs
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {String}  [opts.categoryId] the category ID
             * @param {Array}  [opts.ids] the movie IDs
             * @public
             * @returns {LocalDatasource.<tve/model/Asset>} a DS of Asset (type Movie) data
             * @memberof tve/mgr/sLinearManager#
             */
            getMoviesDs: function (opts) {

                opts = opts || {};

                var __opts = {},
                    cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_MOVIES_DS, opts),
                    cache = this._cache.getCache(cacheKey),
                    ids, categoryId = opts.categoryId,
                    serviceFn, ds,
                    // sortBy
                    sortOptions;

                if (cache) {
                    return cache;
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                // type checking
                ids = opts.ids && opts.ids.join ? opts.ids : null;

                if (ids) {
                    serviceFn = util.bind(vodContentService.getMoviesByIds, vodContentService, ids);

                } else if (categoryId) {
                    serviceFn = util.bind(vodContentService.getMoviesByCategoryId, vodContentService, categoryId);

                } else {
                    // if no ids are provided, fetch all
                    serviceFn = util.bind(vodContentService.getAllMovies, vodContentService);
                }

                ds = this.__dataListToDsHelper(serviceFn, __parser.parseAsset, __opts);
                // function cache
                this._cache.setObject(cacheKey, ds);
                return ds;
            },

            /**
             * Get Movie by given Movie Id
             * @method getMovieById
             * @param {String} id the ID of the movie
             * @public
             * @returns {Promise.<tve/model/Asset>} Asset (type Movie) model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMovieById: function (id) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.MOVIES, {
                    id: id
                }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return vodContentService.getMovieById(id).then(util.bind(function (movie) {

                    movie = __parser.parseAsset(movie);

                    this._cache.setObject(cacheKey, movie);

                    return movie;

                }, this));
            },

            /**
             * Get Movies by given Category Id
             * @method getMoviesByCategoryId
             * @param {String} categoryId the ID of the category
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @public
             * @returns {Promise.<tve/model/Asset[]>} An array of Asset (type Movie) models
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMoviesByCategoryId: function (categoryId, opts) {

                opts = opts || {};

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.MOVIES, util.extend({
                    categoryId: categoryId
                }, opts)),
                    ret = this._cache.getCache(cacheKey),
                    __opts = {},
                    // sortBy
                    sortOptions;

                if (ret) {
                    return promise.resolve(ret);
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.getMoviesByCategoryId(categoryId, __opts).then(util.bind(function (movies) {
                    ret = util.reduce(movies.entries, function (prev, curr) {
                        prev.push(__parser.parseAsset(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.MOVIES);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    return ret;

                }, this));
            },

            /**
             * Search movies by the specific keyword.
             * @method
             * @param {String} key The search key
             * @param {Object} [opts] The options of the request
             * @returns {tve/model/Asset[]} The movies that matched the keyword
             * @memberOf tve/mgr/sVODManager#
             */
            searchMovies: function (key, opts) {
                opts = opts || {};

                var movies,
                    __opts = {},
                    sortOptions;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.searchMovies(key, __opts).then(util.bind(function (responseObj) {
                    movies = util.reduce(responseObj.entries, function (prev, curr) {
                        prev.push(__parser.parseAsset(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(movies, CACHE_KEY_PREFIX.MOVIES);

                    return movies;
                }, this));
            },

            /**
             * Get movie cover by given Asset model.
             * Return the default cover when not found if given.
             * @method getMovieCover
             * @param {tve/model/Asset} movie the Asset model
             * @param {tve/model/Resource} [defaultResource] The resource to return when not found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for cover
             * @throws {Promise.<tve/TVEError>} if the associated resource could not be found
             * @memberof tve/mgr/sVODManager#
             */
            getMovieCover: function (movie, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.MOVIE_COVER + movie.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(movie, "cover", cacheKey, defaultResource);
            },

            /**
             * Get movie thumbnail by given Asset model.
             * Return the default thumbnail when not found if given.
             * @method getMovieThumbnail
             * @param {tve/model/Asset} movie the Asset model
             * @param {tve/model/Resource} [defaultResource] The resource to return when not found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for thumbnail
             * @throws {Promise.<tve/TVEError>} if the associated resource could not be found
             * @memberof tve/mgr/sVODManager#
             */
            getMovieThumbnail: function (movie, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.MOVIE_THUMBNAIL + movie.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(movie, "thumbnail", cacheKey, defaultResource);
            },

            /**
             * Get movie trailer by given Asset model
             * @method getMovieTrailer
             * @param {tve/model/Asset} movie the Asset model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for trailer
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMovieTrailer: function (movie) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.MOVIE_TRAILER + movie.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                //Accedo OVP service only provides one video in the content.
                ret = movie.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no trailer found"));
            },

            /**
             * Get movie content by given Asset model
             * @method getMovieContent
             * @param {tve/model/Asset} movie the Asset model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for content
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMovieContent: function (movie) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.MOVIE_CONTENT + movie.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                //Accedo OVP service only provides one video in the content.
                ret = movie.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no content found"));
            },

            /**
             * Get all Episodes in an array format
             * @method getEpisodes
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @public
             * @returns {Promise.<tve/model/Asset[]>} An array of Asset (type Episode) models
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodes: function (opts) {

                opts = opts || {};

                if (!util.isObject(opts)) {
                    return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "Incorrect parameter type"));
                }

                var __opts = {},
                    cacheKey,
                    ret,
                    // sortBy
                    sortOptions;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_EPISODES, __opts);
                ret = this._cache.getCache(cacheKey);

                // handle cache
                if (ret) {
                    return promise.resolve(ret);
                }

                return vodContentService.getAllEpisodes(__opts).then(util.bind(function (episodes) {
                    ret = util.reduce(episodes.entries, function (prev, curr) {
                        prev.push(__parser.parseEpisode(curr));
                        return prev;
                    }, []);
                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.EPISODES);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    return ret;
                }, this));
            },

            /**
             * Get Episodes in a datasource format
             * @method getEpisodesDs
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {String}  [opts.showId] the show ID
             * @param {String}  [opts.seasonId] the season ID
             * @public
             * @returns {LocalDatasource.<tve/model/Episode>} a DS of Episode
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodesDs: function (opts) {

                opts = opts || {};

                var __opts = {},
                    cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_EPISODES_DS, opts),
                    cache = this._cache.getCache(cacheKey),
                    ids,
                    showId = opts.showId,
                    seasonId = opts.seasonId,
                    serviceFn, ds,
                    // sortBy
                    sortOptions;

                if (cache) {
                    return cache;
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                // type checking
                ids = opts.ids && opts.ids.join ? opts.ids : null;

                if (showId) {
                    serviceFn = util.bind(vodContentService.getEpisodesByTVShowId, vodContentService, showId);
                } else if (seasonId) {
                    serviceFn = util.bind(vodContentService.getEpisodesByTVSeasonId, vodContentService, seasonId);
                } else {
                    // if no ids are provided, fetch all
                    serviceFn = util.bind(vodContentService.getAllEpisodes, vodContentService);
                }

                ds = this.__dataListToDsHelper(serviceFn, __parser.parseEpisode, __opts);
                // function cache
                this._cache.setObject(cacheKey, ds);
                return ds;
            },

            /**
             * Get Episode by given episode Id
             * @method getEpisodeById
             * @param {String} id the ID of the episode
             * @public
             * @returns {Promise.<tve/model/Asset>} Asset (type Episode) model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodeById: function (id) {

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.EPISODES, {
                    id: id
                }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return vodContentService.getEpisodeById(id).then(util.bind(function (episode) {
                    episode = __parser.parseEpisode(episode);

                    this._cache.setObject(cacheKey, episode);

                    return episode;

                }, this));
            },

            /**
             * Get Episodes by given TVshow Id
             * @method getEpisodesByTVShowId
             * @param {String} showId the ID of the tv show
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @public
             * @returns {Promise.<tve/model/Asset[]>} An array of Asset (type Episode) models
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodesByTVShowId: function (showId, opts) {

                opts = opts || {};

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.EPISODES, util.extend({
                    showId: showId
                }, opts)),
                    ret = this._cache.getCache(cacheKey),
                    __opts = {},
                    // sortBy
                    sortOptions;

                if (ret) {
                    return promise.resolve(ret);
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.getEpisodesByTVShowId(showId, __opts).then(util.bind(function (episodes) {
                    ret = util.reduce(episodes.entries, function (prev, curr) {
                        prev.push(__parser.parseEpisode(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.EPISODES);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    return ret;

                }, this));
            },

            /**
             * Search episodes by the specific keyword.
             * @method
             * @param {String} key The search key
             * @param {Object} [opts] The options of the request
             * @returns {tve/model/Episode[]} The episodes that matched the keyword
             * @memberOf tve/mgr/sVODManager#
             */
            searchEpisodes: function (key, opts) {
                opts = opts || {};

                var episodes,
                    __opts = {},
                    sortOptions;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.searchEpisodes(key, __opts).then(util.bind(function (responseObj) {
                    episodes = util.reduce(responseObj.entries, function (prev, curr) {
                        prev.push(__parser.parseEpisode(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(episodes, CACHE_KEY_PREFIX.EPISODES);

                    return episodes;
                }, this));
            },

            /**
             * Get episode thumbnail by given Episode model.
             * Return `defaultResource` when none is found if provided.
             * @method getEpisodeThumbnail
             * @param {tve/model/Episode} episode the Episode model
             * @param {tve/model/Resource} [defaultResource] The resource to return if not found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for thumbnail
             * @throws {Promise.<tve/TVEError>} if the associated resource could not be found
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodeThumbnail: function (episode, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.EPISODE_THUMBNAIL + episode.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(episode, "thumbnail", cacheKey, defaultResource);
            },

            /**
             * Get episode content by given Episode model
             * @method getEpisodeContent
             * @param {tve/model/Episode} episode the Episode model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for content
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodeContent: function (episode) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.EPISODE_CONTENT + episode.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                //Accedo OVP service only provides one video in the content.
                ret = episode.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no content found"));
            },

            /**
             * Get TV Season by given season Id
             * @method getTVSeasonById
             * @param {String} id the ID of the tv season
             * @public
             * @returns {Promise.<tve/model/TVSeason>} TVSeason model
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVSeasonById: function (id) {

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SEASONS, {
                    id: id
                }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return vodContentService.getTVSeasonById(id).then(util.bind(function (tvSeason) {
                    tvSeason = __parser.parseTVSeason(tvSeason);

                    this._cache.setObject(cacheKey, tvSeason);

                    return tvSeason;
                }, this));
            },

            /**
             * Search TV seasons by the specific keyword.
             * @method
             * @param {String} key The search key
             * @param {Object} [opts] The options of the request
             * @returns {tve/model/TVSeason[]} The TV seasons that matched the keyword
             * @memberOf tve/mgr/sVODManager#
             */
            searchTVSeasons: function (key, opts) {
                opts = opts || {};

                var tvSeasons,
                    __opts = {},
                    sortOptions;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                return vodContentService.searchTVSeasons(key, __opts).then(util.bind(function (responseObj) {
                    tvSeasons = util.reduce(responseObj.entries, function (prev, curr) {
                        prev.push(__parser.parseTVSeason(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(tvSeasons, CACHE_KEY_PREFIX.TV_SEASONS);

                    return tvSeasons;
                }, this));
            },

            /**
             * Get TV season thumbnail by given TVSeason model.
             * Return `defaultResource` when none is found if provided.
             * @method getTVSeasonThumbnail
             * @param {tve/model/TVSeason} tvSeason the TVSeason model
             * @param {tve/model/Resource} [defaultResource] The resource to return if not found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for thumbnail
             * @throws {Promise.<tve/TVEError>} if the associated resource could not be found
             * @memberof tve/mgr/sVODManager#
             */
            getTVSeasonThumbnail: function (tvSeason, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SEASON_THUMBNAIL + tvSeason.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(tvSeason, "thumbnail", cacheKey, defaultResource);
            },

            /**
             * Get TV season content by given TVSeason model
             * @method getTVSeasonContent
             * @param {tve/model/TVSeason} tvSeason the TVSeason model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for content
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVSeasonContent: function (tvSeason) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_SEASON_CONTENT + tvSeason.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                //Accedo OVP service only provides one video in the content.
                ret = tvSeason.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no content found"));
            },

            // 2nd level model cache
            __modelCacheHandler: function (arr, keyPrefix) {
                var modelCacheKey,
                    i, l;
                for (i = 0, l = arr.length; i < l; i++) {
                    modelCacheKey = this.__generateCacheKey(keyPrefix, {
                        id: arr[i].get("id")
                    });
                    this._cache.setObject(modelCacheKey, arr[i]);
                }
            },

            __dataListToDsHelper: function (serviceFn, parser, opts) {

                opts = opts || {};

                var ds = new LocalDatasource(),
                    dataArray = [],
                    dataLoader = util.bind(function (from, size) {
                        var __opts = util.extend({
                            pageSize: PAGE_SIZE,
                            pageNumber: 1 + Math.ceil(from / PAGE_SIZE)
                        }, opts);

                        return serviceFn(__opts).then(util.bind(function (data) {
                            dataArray = dataArray.concat(util.reduce(data.entries, function (prev, curr) {
                                prev.push(parser(curr));
                                return prev;
                            }, []));

                            return {
                                data: dataArray.slice(from, from + size),
                                total: data.totalCount
                            };
                        }, this));
                    }, this);

                ds.setDataLoader(dataLoader);
                return ds;
            },

            /**
             * Generate a cache key based on request information
             * @method __generateCacheKey
             * @param {String} the prefix string of the cache key
             * @param {Object} parameters Request parameters, object containing key-value pairs that are convertible into key1=value1&key2=value2 format with e.g toQueryString() method
             * @return {String} the string for the cache key
             * @memberof tve/mgr/sVODManager#
             * @private
             */
            __generateCacheKey: function (prefix, parameters) {
                var queryString = parameters ? util.toQueryString(parameters) : "",
                    str = prefix + "?" + queryString;

                if (window.btoa) {
                    return window.btoa(str);
                } else {
                    return base64.encode(str);
                }
            },

            __getImageForResourceArrayByType: function (arr, type) {
                for (var i = 0, l = arr.length; i < l; i++) {
                    if (arr[i].get("metadata").type === type) {
                        return arr[i];
                    }
                }
                return null;
            },

            //=========================================================
            //====== functions below are added only for TVE Demo ======
            //=========================================================

            /**
             * Get a data source that loads the tv shows under a specific category.
             * (This is a method added in product demo.)
             * @method
             * @param {String} id The id of the category
             * @param {Object} [opts] The request options
             * @returns {ax/af/data/Datasource} the data source
             * @memberOf tve/mgr/sVODManager#
             */
            getTVShowsDsByCategoryId: function (id, opts) {
                return this.getTVShowsDs(util.extend({
                    categoryId: id
                }, opts));
            },

            /**
             * Get a list of TV shows with the specific IDs.
             * (This is a method added in product demo.)
             * @method
             * @param {String[]} ids The IDs of the tv shows
             * @param {Object} [opts] The request options
             * @returns {Promise.<tve/model/TVShow[]>} the tv shows
             * @memberOf tve/mgr/sVODManager#
             */
            getTVShowsByIds: function (ids, opts) {
                return this.getTVShows(util.extend({
                    ids: ids
                }, opts));
            },

            /**
             * Get a data source that loads the movies under a specific category.
             * (This is a method added in product demo.)
             * @method
             * @param {String} id The id of the category
             * @param {Object} [opts] The request options
             * @returns {ax/af/data/Datasource} the data source
             * @memberOf tve/mgr/sVODManager#
             */
            getMoviesDsByCategoryId: function (id, opts) {
                return this.getMoviesDs(util.extend({
                    categoryId: id
                }, opts));
            },

            /**
             * Get a list of movies with the specific IDs.
             * (This is a method added in product demo.)
             * @method
             * @param {String[]} ids The IDs of the movies
             * @param {Object} [opts] The request options
             * @returns {Promise.<tve/model/Asset[]>} the movies
             * @memberOf tve/mgr/sVODManager#
             */
            getMoviesByIds: function (ids, opts) {
                return this.getMovies(util.extend({
                    ids: ids
                }, opts));
            },

            /**
             * Get a data source that loads the episodes under a specific TV show.
             * (This is a method added in product demo.)
             * @method
             * @param {String} id The id of the tv show
             * @param {Object} [opts] The request options
             * @returns {ax/af/data/Datasource} the data source
             * @memberOf tve/mgr/sVODManager#
             */
            getEpisodesDsByTVShowId: function (id, opts) {
                return this.getEpisodesDs(util.extend({
                    showId: id,
                    sortBy: this.constructor.SORT_BY.LATEST
                }, opts));
            },

            /**
             * Get a data source that loads the related movies of a movie.
             * (This is a method added in product demo.)
             * @method
             * @param {String} id The id of the movie
             * @param {Object} [opts] The request options
             * @returns {Promise.<ax/af/data/Datasource>} the data source of the related movies
             * @memberOf tve/mgr/sVODManager#
             */
            getRelatedMoviesDs: function (id, opts) {
                var serviceFn = function (opts) {

                    return this.getMovieById(id).then(util.bind(function (movie) {
                        var movieCatId = movie.get("categories")[0] ? movie.get("categories")[0].get("id") : null,
                            promiseFn = movieCatId ? vodContentService.getMoviesByCategoryId(movieCatId) : vodContentService.getAllMovies();

                        return promiseFn.then(util.bind(function (resultArray) {
                            util.each(resultArray.entries, function (movieObj, index) {
                                if (movieObj.id === id) {
                                    resultArray.entries.splice(index, 1);
                                    resultArray.totalCount--;
                                    return util.breaker;
                                }
                            });

                            return resultArray;
                        }));

                    }, this));
                };
                return this.__dataListToDsHelper(util.bind(serviceFn, this), __parser.parseAsset, opts);
            },

            /**
             * Get a data source that loads the movie search result.
             * (This is a method added in product demo.)
             * @method
             * @param {String} keyword The search key
             * @param {Object} [opts] The request options
             * @returns {Promise.<ax/af/data/Datasource>} the data source of the matched movies
             * @memberOf tve/mgr/sVODManager#
             */
            getMovieSearchResultDs: function (keyword, opts) {
                var serviceFn = function (opts) {
                    return vodContentService.searchMovies(keyword);
                };
                return this.__dataListToDsHelper(util.bind(serviceFn, this), __parser.parseAsset, opts);
            },

            /**
             * Get a data source that loads the tv show search result.
             * (This is a method added in product demo.)
             * @method
             * @param {String} keyword The search key
             * @param {Object} [opts] The request options
             * @returns {Promise.<ax/af/data/Datasource>} the data source of the matched tv shows
             * @memberOf tve/mgr/sVODManager#
             */
            getTVShowSearchResultDs: function (keyword, opts) {
                var serviceFn = function (opts) {
                    return vodContentService.searchTVShows(keyword);
                };
                return this.__dataListToDsHelper(util.bind(serviceFn, this), __parser.parseTVShow, opts);
            },

            /**
             * Get movie banner by given Asset model
             * (This is a method added in product demo.)
             * @method
             * @param {tve/model/Asset} movie the Asset model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for banner
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMovieBanner: function (movie) {
                var cacheKey = this.__generateCacheKey("movie_banner" + movie.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                ret = this.__getImageForResourceArrayByType(movie.get("images"), "banner");

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }

                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no banner found"));
            },

            /**
             * Get TV Show banner by given Asset model
             * (This is a method added in product demo.)
             * @method
             * @param {tve/model/Asset} show the Asset model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for banner
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowBanner: function (show) {
                var cacheKey = this.__generateCacheKey("tvshow_banner" + show.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                ret = this.__getImageForResourceArrayByType(show.get("images"), "banner");

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }

                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "no banner found"));
            },

            /**
             * Get the TV Show associated to a specific Episode.
             * (This is a method added in product demo.)
             * @method
             * @param {tve/model/Episode} episode the Episode model
             * @public
             * @returns {Promise.<tve/model/TVShow>} The associated TV Show
             * @throws {Promise.<tve/TVEError>} if the episode has no associated TV show
             * @memberof tve/mgr/sVODManager#
             */
            getTVShowByEpisode: function (episode) {
                var metadata = episode.get("metadata"),
                    tvShowId = metadata.VOD$tvShowId;

                if (!tvShowId) {
                    return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "No associated TV Show"));
                }

                return this.getTVShowById(tvShowId);
            },

            /**
             * Get the rental information of the movie.
             * (This is a method added in product demo.)
             * @method
             * @param {tve/model/Asset} movie the Asset model
             * @public
             * @returns {Promise.<Object>} The object consists of the number of days that the movie can be rented (days) and the price (price)
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sVODManager#
             */
            getMovieRentalInfo: function (movie) {
                var metadata = movie.get("metadata"),
                    days = metadata.rental$period || 7,
                    price = metadata.rental$price || 2.99;

                return promise.resolve({
                    days: days,
                    price: price
                });
            },

            /**
             * Get TV Seasons
             * @method
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {Number} [opts.startIndex] the start index of the result
             * @param {Number} [opts.count] the number of items needed in the returned array
             * @param {String[]}  [opts.ids] the season IDs
             * @public
             * @returns {Promise.<tve/model/TVSeason[]>} the matched TV seasons
             * @memberof tve/mgr/sVODManager#
             */
            getTVSeasons: function (opts) {
                opts = opts || {};

                if (!util.isObject(opts)) {
                    return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, "Incorrect parameter type"));
                }

                var __opts = {},
                    startIndex = opts.startIndex,
                    count = opts.count,
                    ids = opts.ids,
                    cacheKey,
                    ret,
                    entriesHandler,

                    // sortBy
                    sortOptions,

                    // local page filter is used for getXsByIds, which does not have server side pagination
                    flagPageFilter = false;

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                if (ids) {
                    __opts.ids = ids;

                    if (util.isNumber(startIndex) && count) {
                        flagPageFilter = true;
                    }
                }

                cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_TV_SHOWS, __opts);
                ret = this._cache.getCache(cacheKey);

                // handle cache
                if (ret) {
                    if (flagPageFilter) {
                        ret = ret.slice(startIndex, startIndex + count);
                    }
                    return promise.resolve(ret);
                }

                // handle return
                entriesHandler = util.bind(function (seasons) {
                    ret = util.reduce(seasons.entries, function (prev, curr) {
                        prev.push(__parser.parseTVSeason(curr));
                        return prev;
                    }, []);

                    // 2nd level model cache
                    this.__modelCacheHandler(ret, CACHE_KEY_PREFIX.TV_SEASONS);

                    // function cache
                    this._cache.setObject(cacheKey, ret);

                    // cache the whole list, but return only the page needed
                    if (flagPageFilter) {
                        return ret.slice(startIndex, startIndex + count);
                    }
                    return ret;
                }, this);

                if (ids) {
                    return vodContentService.getTVSeasonsByIds(ids, __opts).then(entriesHandler);
                }

                return vodContentService.getAllTVSeasons(__opts).then(entriesHandler);
            },

            /**
             * Get TV seasons in a datasource format. Note: if both ids and categoryId are set, ids would be chosen as parameter to return result
             * @method
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {String}  [opts.categoryId] the category ID
             * @param {String[]} [opts.ids] the tv season IDs
             * @public
             * @returns {Datasource.<tve/model/TVSeason>} a DS of TVSeason
             * @memberof tve/mgr/sLinearManager#
             */
            getTVSeasonsDs: function (opts) {
                opts = opts || {};

                var __opts = {},
                    cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_TV_SEASONS_DS, opts),
                    cache = this._cache.getCache(cacheKey),
                    ids,
                    serviceFn, ds,
                    // sortBy
                    sortOptions;

                if (cache) {
                    return cache;
                }

                if (opts.sortBy) {
                    sortOptions = opts.sortBy.split("|");
                    __opts.sortingKey = sortOptions[0];
                    __opts.sortingOrder = sortOptions[1];
                }

                // type checking
                ids = opts.ids && opts.ids.join ? opts.ids : null;

                if (ids) {
                    serviceFn = util.bind(vodContentService.getTVSeasonsByIds, vodContentService, ids);
                } else {
                    // if no ids are provided, fetch all
                    serviceFn = util.bind(vodContentService.getAllTVSeasons, vodContentService);
                }

                ds = this.__dataListToDsHelper(serviceFn, __parser.parseTVSeason, __opts);
                // function cache
                this._cache.setObject(cacheKey, ds);
                return ds;
            },

            /**
             * Get a list of TV seasons with the specific IDs.
             * (This is a method added in product demo.)
             * @method
             * @param {String[]} ids The IDs of the tv seasons
             * @param {Object} [opts] The request options
             * @returns {Promise.<tve/model/TVSeasons[]>} the tv seasons
             * @memberOf tve/mgr/sVODManager#
             */
            getTVSeasonsByIds: function (ids, opts) {
                return this.getTVSeasons(util.extend({
                    ids: ids
                }, opts));
            },

            /**
             * Get a list of TV seasons with the specific IDs.
             * (This is a method added in product demo.)
             * @method
             * @param {String[]} ids The IDs of the tv seasons
             * @param {Object} [opts] The request options
             * @returns {Datasource.<tve/model/TVSeasons[]>} the tv seasons Ds
             * @memberOf tve/mgr/sVODManager#
             */
            getTVSeasonsDsByIds: function (ids, opts) {
                return this.getTVSeasonsDs(util.extend({
                    ids: ids
                }, opts));
            },

            /**
             * Get a list of TV seasons by under the specific TV show.
             * (This is a method added in product demo.)
             * @method
             * @param {String} id The ID of the tv show
             * @param {Object} [opts] The request options
             * @returns {Promise.<tve/model/TVSeasons[]>} the tv seasons
             * @memberOf tve/mgr/sVODManager#
             */
            getTVSeasonsByTVShowId: function (id, opts) {
                return this.getTVShowById(id).then(util.bind(function (show) {
                    var seasonIds = show.get("seasonIds");

                    if (seasonIds.length > 0) {
                        return this.getTVSeasonsByIds(seasonIds);
                    } else {
                        return [];
                    }
                }, this)).fail(function (reason) {
                    throw new TVEError(FACILITY.VOD_MANAGER, ERROR.NOT_FOUND, "Cannot get the required TV show.");
                });
            },

            /**
             * Get Episodes by given TV season Id.
             * (This is a method added in product demo.)
             * @method
             * @param {String} seasonId the ID of the tv season
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sVODManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @public
             * @returns {Datasource.<tve/model/Episode[]>} the episodes under the TV season
             * @memberof tve/mgr/sVODManager#
             */
            getEpisodesDsByTVSeasonId: function (seasonId, opts) {
                return this.getEpisodesDs(util.extend({
                    seasonId: seasonId,
                    sortBy: this.constructor.SORT_BY.LATEST
                }, opts));
            },

            __prefetchTVSeasonsForTVShows: function (shows) {
                var len = shows.length,
                    seasonIds = [],
                    i;

                for (i = 0; i < len; i++) {
                    seasonIds = seasonIds.concat(shows[i].get("seasonIds"));
                }

                if (seasonIds.length === 0) {
                    return shows;
                }

                // prefetch
                return this.getTVSeasonsByIds(seasonIds).then(function (seasons) {
                    // prefetch purpose only, return the original result
                    return shows;
                });
            },

            /**
             * Get a particular image of an asset by type and then cache it in the resource cache.
             * A fallback could be set as the default if no resource matches the criteria.
             * @method
             * @private
             * @param {tve/model/Asset} asset The asset to search
             * @param {String} type The image type, such as "thumbnail", "cover", etc.
             * @param {String} cacheKey The key used to cache the resource
             * @param {tve/model/Resource} [fallback] The fallback resource object to return as a fallback, in case the target is not found
             * @returns {Promise.<tve/model/Resource>} the matched image
             * @throws {Promise.<tve/TVEError>} the resource is not found, and no fallback is available
             * @memberOf tve/mgr/sVODManager#
             */
            __getImageAndCacheWithFallback: function (asset, type, cacheKey, fallback) {
                var resource = this.__getImageForResourceArrayByType(asset.get("images"), type);

                if (resource) {
                    this._resourceCache.setObject(cacheKey, resource);
                    return promise.resolve(resource);
                }

                if (fallback) {
                    return promise.resolve(fallback);
                }

                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, type + " not found"));
            }

        });

    return new VODManager();

});
/**
 * Asset Model
 * @class tvedemo/model/Asset
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/Asset", ["xdk-base/class", "tve/model/ImmutableModel"], function(klass, ImmutableModel) {
    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {
            /**
             * @member id
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {Number}
             */
            "id": null,
            /**
             * @member licensing
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "licensing": null,
            /**
             * @member apixId
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {Number}
             */
            "apixId": null,
            /**
             * @member eventId
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {Number}
             */
            "eventId": null,
            /**
             * @member type
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "type": null,
            /**
             * @member title
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "title": null,
            /**
             * @member synopsis
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "synopsis": null,
            /**
             * @member cast
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String[]}
             */
            "cast": null,
            /**
             * @member country
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {Number}
             */
            "country": null,
            /**
             * @member year
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "year": null,
            /**
             * @member parentalRating
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {Object}
             */
            "parentalRating": null,
            /**
             * @member packageCode
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "packageCode": null,
            /**
             * @member packageColourCode
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "packageColourCode": null,
            /**
             * @member genreList
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String[]}
             */
            "genreList": null,
            /**
             * @member logoUrl
             * @memberOf tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "logoUrl": null,
            /**
             * @member images
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {Object}
             */
            "images": null,
            /**
             * @member dvdCover
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {Object}
             */
            "dvdCover": null,
            /**
             * @member blackedOut
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {boolean}
             */
            "blackedOut": null,
            /**
             * @member catalog
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {String}
             */
            "catalog": null,
            /**
             * @member isHD
             * @memberof tvedemo/model/Asset#
             * @public
             * @type {boolean}
             */
            "isHD": null
        }
    }, {});
});
/**
 * Asset Builder, for building the Asset model
 * @class tvedemo/model/AssetBuilder
 */
define("tvedemo/model/AssetBuilder", ["xdk-base/class", "tvedemo/model/Asset"], function (klass, Asset) {

    "use strict";

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/AssetBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the identifier for building this model.
         * @param {String} value the identifier
         * @return {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setId: function (value) {
            this._attrs.id = value;
            return this;
        },

        /**
         * Set the licensing value for building this model (either 'old' or 'new' style).
         * @param {String} value the licensing
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setLicensing: function (value) {
            this._attrs.licensing = value;
            return this;
        },

        /**
         * Set the title for building this model.
         * @param {String} value the title
         * @return {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setTitle: function (value) {
            this._attrs.title = value;
            return this;
        },

        /**
         * Set the description for building this model.
         * @param {String} value the description
         * @return {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setSynopsis: function (value) {
            this._attrs.synopsis = value;
            return this;
        },

        /**
         * Set the parental rating for building this model.
         * @param {Object} value the parental rating
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setParentalRating: function (value) {
            this._attrs.parentalRating = value;
            return this;
        },

        /**
         * Set the apix id for building this model.
         * @param {Number} value apix id
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setApixId: function (value) {
            this._attrs.apixId = value;
            return this;
        },

        /**
         * Set the event id for building this model.
         * @param {Number} value the event id
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setEventId: function (value) {
            this._attrs.eventId = value;
            return this;
        },

        /**
         * Set the type for building this model.
         * @param {String} value the asset type
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setType: function (value) {
            this._attrs.type = value;
            return this;
        },

        /**
         * Set the cast for building this model.
         * @param {String[]} value the cast
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setCast: function (value) {
            this._attrs.cast = value;
            return this;
        },

        /**
         * Set the genre list for building this model.
         * @param {String[]} value the genre list
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setGenreList: function (value) {
            this._attrs.genreList = value;
            return this;
        },

        /**
         * Set the country for building this model.
         * @param {String} value the country
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setCountry: function (value) {
            this._attrs.country = value;
            return this;
        },

        /**
         * Set the year for building this model.
         * @param {String} value the year
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setYear: function (value) {
            this._attrs.year = value;
            return this;
        },

        /**
         * Set the package code for building this model.
         * @param {String} value the package code
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setPackageCode: function (value) {
            this._attrs.packageCode = value;
            return this;
        },

        /**
         * Set the package colour code for building this model.
         * @param {String} value the package colour code
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setPackageColourCode: function (value) {
            this._attrs.packageColourCode = value;
            return this;
        },

        /**
         * Set the logo url for building this model.
         * @param {String} value the logo url
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setLogoUrl: function (value) {
            this._attrs.logoUrl = value;
            return this;
        },

        /**
         * Set the images for building this model.
         * @param {Object} value the images
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setImages: function (value) {
            this._attrs.images = value;
            return this;
        },

        /**
         * Set the dvd cover for building this model.
         * @param {Object} value the dvd cover
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setDvdCover: function (value) {
            this._attrs.dvdCover = value;
            return this;
        },

        /**
         * Set the blacked out for building this model.
         * @param {Object} value the blacked out
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setBlackedOut: function (value) {
            this._attrs.blackedOut = value;
            return this;
        },

        /**
         * Set the catalog for building this model.
         * @param {Object} value the catalog
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setCatalog: function (value) {
            this._attrs.catalog = value;
            return this;
        },

        /**
         * Set the HD type for building this model.
         * @param {boolean} value if asset is HD or not
         * @returns {tvedemo/model/AssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        setIsHD: function (value) {
            this._attrs.isHD = value;
            return this;
        },

        /**
         * Build the Asset model.
         * @return {tvedemo/model/Asset} the Asset model
         * @public
         * @method
         * @memberof tvedemo/model/AssetBuilder#
         */
        build: function () {
            return new Asset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Film Asset Model, inherits from Asset Model
 * @class tvedemo/model/FilmAsset
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/FilmAsset", ["xdk-base/class", "xdk-base/util", "tvedemo/model/Asset"], function(klass, util, Asset) {
    "use strict";

    return klass.create(Asset, {

      defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member live
             * @memberOf tvedemo/model/FilmAsset#
             * @public
             * @type {Boolean}
             */
            "live": null,
            /**
             * @member videoQuality
             * @memberOf tvedemo/model/FilmAsset#
             * @public
             * @type {String}
             */
            "videoQuality": null,
            /**
             * @member video
             * @memberOf tvedemo/model/FilmAsset#
             * @public
             * @type {tve/model/Resource}
             */
            "video": null,
            /**
             * @member trailer
             * @memberOf tvedemo/model/FilmAsset#
             * @public
             * @type {tve/model/Resource}
             */
            "trailer": null,
            /**
             * @ememeber length
             * @memberOf tvedemo/model/FilmAsset#
             * @public
             * @type {String}
             */
            "length": null,
            /**
             * @ememeber date
             * @memberOf tvedemo/model/FilmAsset#
             * @public
             * @type {Date}
             */
            "date": null
        }, true)

    }, {});
});
/**
 * Film Asset Builder, for building the Film Asset model
 * @class tvedemo/model/FilmAssetBuilder
 */
define("tvedemo/model/FilmAssetBuilder", ["xdk-base/class", "tvedemo/model/FilmAsset", "tvedemo/model/AssetBuilder"], function (klass, FilmAsset, AssetBuilder) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the video quality for building this model.
         * @param {String} value the video quality
         * @returns {tvedemo/model/FilmAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/FilmAssetBuilder#
         */
        setVideoQuality: function (value) {
            this._attrs.videoQuality = value;
            return this;
        },

        /**
         * Set the video for building this model.
         * @param {tve/model/Resource} value the video
         * @returns {tvedemo/model/FilmAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/FilmAssetBuilder#
         */
        setVideo: function (value) {
            this._attrs.video = value;
            return this;
        },

        /**
         * Set the trailer for building this model.
         * @param {tve/model/Resource} value the trailer
         * @returns {tvedemo/model/FilmAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/FilmAssetBuilder#
         */
        setTrailer: function (value) {
            this._attrs.trailer = value;
            return this;
        },

        /**
         * Set the live for building this model.
         * @param {Boolean} value the live
         * @returns {tvedemo/model/FilmAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/FilmAssetBuilder#
         */
        setLive: function (value) {
            this._attrs.live = value;
            return this;
        },

        /**
         * Set the length for building this model.
         * @param {Object} value the length
         * @returns {tvedemo/model/FilmAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/FilmAssetBuilder#
         */
        setLength: function (value) {
            this._attrs.length = value;
            return this;
        },

        /**
         * Set the date for building this model.
         * @param {Date} value the date
         * @returns {tvedemo/model/FilmAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/FilmAssetBuilder#
         */
        setDate: function (value) {
            this._attrs.date = value;
            return this;
        },

        /**
         * Build the Asset model.
         * @return {tvedemo/model/Asset} the Asset model
         * @public
         * @method
         * @memberof tve/model/FilmAssetBuilder#
         */
        build: function () {
            return new FilmAsset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Serie Asset Model, inherits from Asset Model
 * @class tvedemo/model/SerieAsset
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/SerieAsset", ["xdk-base/class", "xdk-base/util", "tvedemo/model/Asset"], function(klass, util, Asset) {
    "use strict";

    return klass.create(Asset, {

      defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member seasons
             * @memberof tvedemo/model/SerieAsset#
             * @public
             * @type {tvedemo/model/Season[]}
             */
            "seasons": null,
            /**
             * @member numberOfSeasons
             * @memberof tvedemo/model/SerieAsset#
             * @public
             * @type {Number}
             */
            "numberOfSeasons": null
        }, true)

    }, {});
});
/**
 * Serie Asset Builder, for building the Serie Asset model
 * @class tvedemo/model/SerieAssetBuilder
 */
define("tvedemo/model/SerieAssetBuilder", [
    "xdk-base/class",
    "tvedemo/model/SerieAsset",
    "tvedemo/model/AssetBuilder"
], function (
    klass,
    SerieAsset,
    AssetBuilder
    ) {

    "use strict";

    var Builder = klass.create(AssetBuilder, {}, {

        /** 
         * Set the seasons for building this model.
         * @param {tvedemo/model/SerieAsset[]} value the seasons
         * @return {tvedemo/model/SerieAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SerieAssetBuilder#
         */
        setSeasons: function (value) {
            this._attrs.seasons = value;
            return this;
        },

        /** 
         * Set the number of seasons for building this model.
         * @param {Number} value the number of seasons
         * @return {tvedemo/model/SerieAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SerieAssetBuilder#
         */
        setNumberOfSeasons: function (value) {
            this._attrs.numberOfSeasons = value;
            return this;
        },

        /**
         * Build the SeriesAsset model.
         * @return {tvedemo/model/SeriesAsset} the Asset model
         * @public
         * @method
         * @memberof tvedemo/model/SerieAssetBuilder#
         */
        build: function () {
            return new SerieAsset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Season Asset Model, inherits from Asset Model
 * @class tvedemo/model/SeasonAsset
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/SeasonAsset", ["xdk-base/class", "xdk-base/util", "tvedemo/model/Asset"], function(klass, util, Asset) {
    "use strict";

    return klass.create(Asset, {

      defaults: util.extend(util.clone(Asset.defaults), {

          /**
           * @member seasonNumber. The number of THIS season, not the total number of seasons.
           * @memberof tvedemo/model/SeasonAsset#
           * @public
           * @type {Number}
           */
          "seasonNumber": null,

          /**
           * @member episodes
           * @memberof tvedemo/model/SeasonAsset#
           * @public
           * @type {tvedemo/model/Episode[]}
           */
          "episodes": null,

            /**
             * @member numberOfEpisodes
             * @memberof tvedemo/model/SeasonAsset#
             * @public
             * @type {Number}
             */
            "numberOfEpisodes": null,

            /**
             * @member serieId - The season's serie id
             * @memberof tvedemo/model/SeasonAsset#
             * @public
             * @type {Number}
             */
            "serieId": null

        }, true)

    }, {});
});
/**
 * Season Asset Builder, for building the Season Asset model
 * @class tvedemo/model/SeasonAssetBuilder
 */
define("tvedemo/model/SeasonAssetBuilder",
    [
        "xdk-base/class",
        "tvedemo/model/SeasonAsset",
        "tvedemo/model/AssetBuilder"
    ], function (
        klass,
        SeasonAsset,
        AssetBuilder
        ) {

    "use strict";

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the seasonNumber for building this model.
         * @param {Number} value the episodes
         * @return {tvedemo/model/SeasonAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SeasonAssetBuilder#
         */
        setSeasonNumber: function (value) {
            this._attrs.seasonNumber = value;
            return this;
        },

        /**
         * Set the episodes for building this model.
         * @param {tvedemo/model/EpisodeAsset[]} value the episodes
         * @return {tvedemo/model/SeasonAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SeasonAssetBuilder#
         */
        setEpisodes: function (value) {
            this._attrs.episodes = value;
            return this;
        },

        /**
         * Set the number of episodes for building this model.
         * @param {Number} value the number of episodes
         * @return {tvedemo/model/SeasonAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SeasonAssetBuilder#
         */
        setNumberOfEpisodes: function (value) {
            this._attrs.numberOfEpisodes = value;
            return this;
        },

        /**
         * Set the season's serie Id for building this model.
         * @param {Number} value the season's serie Id
         * @return {tvedemo/model/SeasonAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SeasonAssetBuilder#
         */
        setSerieId: function (value) {
            this._attrs.serieId = value;
            return this;
        },

        /**
         * Build the Season Asset model.
         * @return {tvedemo/model/SeasonAsset} the Season Asset model
         * @public
         * @method
         * @memberof tve/model/SeasonAssetBuilder#
         */
        build: function () {
            return new SeasonAsset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Episode Asset Model, inherits from Asset Model
 * @class tvedemo/model/EpisodeAsset
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/EpisodeAsset", ["xdk-base/class", "xdk-base/util", "tvedemo/model/Asset"], function(klass, util, Asset) {
    "use strict";

    return klass.create(Asset, {

        defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member episodeNumber
             * @memberOf tvedemo/model/EpisodeAsset#
             * @public
             * @type {Number}
             */
            "episodeNumber": null,

            /**
             * @member video
             * @memberOf tvedemo/model/EpisodeAsset#
             * @public
             * @type {String}
             */
            "video": null,

            /**
             * @member seasonNumber
             * @memberOf tvedemo/model/EpisodeAsset#
             * @public
             * @type {Number}
             */
            "seasonNumber": null,

            /**
             * @member serieTitle
             * @memberOf tvedemo/model/EpisodeAsset#
             * @public
             * @type {String}
             */
            "serieTitle": null,

            /**
             * @member serieId
             * @memberOf tvedemo/model/EpisodeAsset#
             * @public
             * @type {Number}
             */
            "serieId": null,

            /**
             * @member seasonId
             * @memberOf tvedemo/model/EpisodeAsset#
             * @public
             * @type {Number}
             */
            "seasonId": null

        }, true)

    }, {});
});
/**
 * Episode Asset Builder, for building the Episode Asset model
 * @class tvedemo/model/EpisodeAssetBuilder
 */
define("tvedemo/model/EpisodeAssetBuilder", ["xdk-base/class", "tvedemo/model/EpisodeAsset", "tvedemo/model/AssetBuilder"], function (klass, EpisodeAsset, AssetBuilder) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the episode number for building this model.
         * @param {String} value the episode number
         * @returns {tvedemo/model/EpisodeAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/EpisodeAssetBuilder#
         */
        setEpisodeNumber: function (value) {
            this._attrs.episodeNumber = value;
            return this;
        },

        /**
         * Set the video for building this model.
         * @param {tve/model/Resource} value the video
         * @returns {tvedemo/model/EpisodeAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/EpisodeAssetBuilder#
         */
        setVideo: function (value) {
            this._attrs.video = value;
            return this;
        },

        /**
         * Set the seasons number for building this model.
         * @param {String} value the seasons number
         * @returns {tvedemo/model/EpisodeAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/EpisodeAssetBuilder#
         */
        setSeasonNumber: function (value) {
            this._attrs.seasonNumber = value;
            return this;
        },

        /**
         * Set the serie title for building this model.
         * @param {String} value the serie title
         * @returns {tvedemo/model/EpisodeAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/EpisodeAssetBuilder#
         */
        setSerieTitle: function (value) {
            this._attrs.serieTitle = value;
            return this;
        },

        /** 
         * Set the season id for building this model.
         * @param {Number} value the season id
         * @return {tvedemo/model/EpisodeAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/EpisodeAssetBuilder#
         */
        setSeasonId: function (value) {
            this._attrs.seasonId = value;
            return this;
        },

        /** 
         * Set the serie id for building this model.
         * @param {Number} value the serie id
         * @return {tvedemo/model/EpisodeAssetBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/EpisodeAssetBuilder#
         */
        setSerieId: function (value) {
            this._attrs.serieId = value;
            return this;
        },

        /**
         * Build the Episode Asset model.
         * @return {tvedemo/model/EpisodeAsset} the Episode Asset model
         * @public
         * @method
         * @memberof tve/model/EpisodeAssetBuilder#
         */
        build: function () {
            return new EpisodeAsset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Sport Asset Model, inherits from Asset Model
 * @class tvedemo/model/SportAsset
 */
define("tvedemo/model/SportAsset", ["xdk-base/class", "xdk-base/util", "tvedemo/model/Asset"], function(klass, util, Asset) {
    "use strict";

    return klass.create(Asset, {

      defaults: util.extend(util.clone(Asset.defaults), {
            "subtitle": null,
            "channelCode": null,
            "channelName": null,
            "currentType": null,
            "licensing": null,
            "live": null,
            "simulCast": null,
            "length": null,
            "license": null,
            "video": null,
            "mediaUrl": null,
            "mediaUrlHls": null,
            "onAir": null,
            "startTime": null,
            "endTime": null,
            "date": null,
            "previewPath": null,
            "webvodCanonicalUrl": null
        }, true)

    }, {});
});
/**
 * Sport Asset Builder, for building the Sport Asset model
 * @class tvedemo/model/SerieAssetBuilder
 */
define("tvedemo/model/SportAssetBuilder", [
    "xdk-base/class",
    "tvedemo/model/SportAsset",
    "tvedemo/model/AssetBuilder"
], function (
    klass,
    SportAsset,
    AssetBuilder
    ) {

    "use strict";

    var Builder = klass.create(AssetBuilder, {}, {
        setSubtitle: function (value) {
            this._attrs.subtitle = value;
            return this;
        },
        setChannelCode: function (value) {
            this._attrs.channelCode = value;
            return this;
        },
        setChannelName: function (value) {
            this._attrs.channelName = value;
            return this;
        },
        setCurrentType: function (value) {
            this._attrs.currentType = value;
            return this;
        },
        setLicensing: function (value) {
            this._attrs.licensing = value;
            return this;
        },
        setLive: function (value) {
            this._attrs.live = value;
            return this;
        },
        setSimulCast: function (value) {
            this._attrs.simulCast = value;
            return this;
        },
        setLength: function (value) {
            this._attrs.length = value;
            return this;
        },
        setLicense: function (value) {
            this._attrs.license = value;
            return this;
        },
        setVideo: function (value) {
            this._attrs.video = value;
            return this;
        },        
        setMediaUrl: function (value) {
            this._attrs.mediaUrl = value;
            return this;
        },
        setMediaUrlHls: function (value) {
            this._attrs.mediaUrlHls = value;
            return this;
        },
        setOnAir: function (value) {
            this._attrs.onAir = value;
            return this;
        },
        setStartTime: function (value) {
            this._attrs.startTime = value;
            return this;
        },
        setEndTime: function (value) {
            this._attrs.endTime = value;
            return this;
        },
        setDate: function (value) {
            this._attrs.date = value;
            return this;
        },
        setPreviewPath: function (value) {
            this._attrs.previewPath = value;
            return this;
        },
        setWebvodCanonicalUrl: function (value) {
            this._attrs.webvodCanonicalUrl = value;
            return this;
        },
        build: function () {
            return new SportAsset(this._attrs);
        }
    });

    return Builder;
});
/**
 * Returns a singleton responsible to convert assets retrieved from asset service to desired format.
 * @name sAssetManager
 * @memberof tvedemo/mgr
 * @class tve/mgr/sAssetManager
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/mgr/sAssetManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/core",
    "xdk-base/promise",
    "tve/util/CacheHelper",
    "lib/base64",
    "tve/TVEError",
    "tve/sServiceHolder",
    "tve/model/ResourceBuilder",
    "tvedemo/model/AssetBuilder",
    "tvedemo/model/FilmAssetBuilder",
    "tvedemo/model/SerieAssetBuilder",
    "tvedemo/model/SeasonAssetBuilder",
    "tvedemo/model/EpisodeAssetBuilder",
    "tvedemo/model/SportAssetBuilder",
    "storm/mgr/sAppConfigManager",
    "storm/helper/util",
    "xdk-base/console"
], function (
    klass,
    util,
    core,
    promise,
    Cache,
    base64,
    TVEError,
    serviceHolder,
    ResourceBuilder,
    AssetBuilder,
    FilmAssetBuilder,
    SerieAssetBuilder,
    SeasonAssetBuilder,
    EpisodeAssetBuilder,
    SportAssetBuilder,
    sAppConfigManager,
    stormUtil,
    console
    ) {

    "use strict";

    var CACHE_KEY_PREFIX = {
            ASSET: "asset",
            FILMS: "films",
            SERIE: "serie",
            SEASON: "season",
            EPISODE: "episode",
            EPISODES: "episodes",
            SPORT: "sport"
        },

        CACHE_SIZE = 1000,

        // 30 minutes.
        TTL = 30 * 60 * 1000,

        SECONDS = 60,

        MILLISECONDS = 1000,

        stormService = serviceHolder.getStormAssetService(),

        __parser = (function () {
            var parser = {};

            var parseResource = function (obj) {
                var builder = new ResourceBuilder(),
                    model,
                    parsedObj = {
                        id: obj.id,
                        url: obj.url || "",
                        mimeType: obj.format || "",
                        metadata: {},
                        language: obj.language || "",
                        duration: obj.duration || 0,
                        geoLock: obj.geoLock || false,
                        width: obj.width || 0,
                        height: obj.height || 0,
                        parentalRating: obj.parentalRating
                    };


                if (obj.type) {
                    parsedObj.metadata.type = obj.type;
                }

                model = builder.setId(parsedObj.id)
                        .setUrl(parsedObj.url)
                        .setMimeType(parsedObj.mimeType)
                        .setMetadata(parsedObj.metadata)
                        .setDuration(parsedObj.duration)
                        .setGeoLock(parsedObj.geoLock)
                        .setWidth(parsedObj.width)
                        .setHeight(parsedObj.height)
                        .setParentalRating({

                            // Movie trailers only contain a number as parental rating, not an object.
                            value: parsedObj.parentalRating ? (parsedObj.parentalRating.value || parsedObj.parentalRating) : null,
                            display: parsedObj.parentalRating ? (parsedObj.parentalRating.value || parsedObj.parentalRating) : null
                        })
                        .build();

                return model;
            };
            parser.parseResource = parseResource;

            var __parseStormAssetObject = function (object) {
                var assetObject = {
                    id: object.id,
                    apixId: object.apix_id,
                    eventId: object.event_id,
                    type: object.asset_type,
                    title: object.title,
                    synopsis: object.synopsis || "",
                    cast: object.cast_list && object.cast_list.cast,
                    genreList: object.genre,
                    country: object.country && object.country.iso_code,
                    year: object.year_of_production,
                    parentalRating: object.parental_rating,
                    packageColourCode: object.package_color_code,
                    packageCode: object.package_code,
                    logoUrl: object.logo,
                    images: object.main_picture && object.main_picture.picture,
                    dvdCover: object.dvd_cover,
                    blackedOut: object.epgBlackout || false,
                    catalog: object.catalog,
                    isHD: object.hd && object.hd === "yes"
                };

                return assetObject;
            };

            var __parseStormFilmAsset = function (object) {
                var filmAssetObject = __parseStormAssetObject(object),
                    video = object.ms_media_url ? parseResource({url: object.ms_media_url}) : null,
                    trailer = (object.main_trailer && object.main_trailer.trailer) ? parseResource(object.main_trailer.trailer) : null;

                filmAssetObject.video = video;
                filmAssetObject.trailer = trailer;
                filmAssetObject.live = object.flag_live === "yes" ? true : false;
                filmAssetObject.videoQuality = object.quality;
                filmAssetObject.date = object.on_air && object.on_air.start_date ? new Date(object.on_air.start_date) : null;

                // Video length comes in minutes, need to convert into milliseconds.
                filmAssetObject.length = object.lenght ? object.lenght * SECONDS * MILLISECONDS : null;

                filmAssetObject.licensing = object.extended_license;

                return filmAssetObject;
            };

            var __parseStormSerieAsset = function (object) {
                var serieAssetObject = __parseStormAssetObject(object),
                    genreList = [],
                    i,
                    len;

                serieAssetObject.year = object.year_of_production_start;
                serieAssetObject.seasons = object.seasons && object.seasons.season;
                serieAssetObject.numberOfSeasons = object.seasons && object.seasons.count;

                genreList.push(object.category.main);

                len = (object.category.other ? object.category.other.length : 0);

                for (i = 0; i < len; i++) {
                    genreList.push(object.category.other[i]);
                }

                serieAssetObject.genreList = genreList;

                return serieAssetObject;
            };

            var __parseStormSeasonAsset = function (object) {
                var seasonAssetObject = __parseStormAssetObject(object);

                seasonAssetObject.serieId = object.serie_id;
                seasonAssetObject.seasonNumber = object.nr || object.season_nr;
                seasonAssetObject.episodes = object.episodes && object.episodes.episode;
                seasonAssetObject.numberOfEpisodes = object.episodes && object.episodes.count;

                return seasonAssetObject;
            };

            var __parseStormEpisodeAsset = function (object) {
                var episodeAssetObject = __parseStormAssetObject(object),
                    video = object.ms_media_url ? parseResource({url: object.ms_media_url}) : null;

                episodeAssetObject.video = video;
                episodeAssetObject.episodeNumber = object.episode_nr;
                episodeAssetObject.seasonNumber = object.season_nr;
                episodeAssetObject.serieTitle = object.serie_title;
                episodeAssetObject.serieId = object.serie_id;
                episodeAssetObject.seasonId = object.season_id;

                return episodeAssetObject;
            };

            var __parseStormSportAsset = function (object) {
                var sportAssetObject = __parseStormAssetObject(object),
                    video = object.media_url ? parseResource({url: object.media_url}) : null;

                sportAssetObject.video = video;
                sportAssetObject.subtitle = object.subtitle;
                sportAssetObject.channelCode = object.channel_code;
                sportAssetObject.channelName = object.channel_name;
                sportAssetObject.currentType = object.current_type;
                sportAssetObject.licensing = object.extended_license;
                sportAssetObject.live = object.flag_live === "yes" ? true : false;
                sportAssetObject.simulCast = object.flag_simulcast === "yes" ? true : false;
                sportAssetObject.length = object.lenght ? object.lenght * SECONDS * MILLISECONDS : null;
                sportAssetObject.license = object.license;
                sportAssetObject.mediaUrl = object.media_url;
                sportAssetObject.mediaUrlHls = object.media_url_hls;
                sportAssetObject.onAir = object.on_air;
                if (object.on_air) {
                    var onAir = object.on_air;
                    sportAssetObject.startTime = onAir.start_date && onAir.start_time && stormUtil.parseSkyDateTimeToDate(onAir.start_date, onAir.start_time).getTime();
                    sportAssetObject.endTime = onAir.end_date && onAir.end_time && stormUtil.parseSkyDateTimeToDate(onAir.end_date, onAir.end_time).getTime();
                    sportAssetObject.date = onAir.start_date ? new Date(onAir.start_date) : null;
                }
                sportAssetObject.previewPath = object.preview_path;
                sportAssetObject.webvodCanonicalUrl = object.webvod_canonical_url;

                return sportAssetObject;
            };

            var __buildStormAsset = function (builder, parsedObject) {
                builder.setId(parsedObject.id)
                    .setTitle(parsedObject.title)
                    .setSynopsis(parsedObject.synopsis)
                    .setParentalRating(parsedObject.parentalRating)
                    .setApixId(parsedObject.apixId)
                    .setEventId(parsedObject.eventId)
                    .setType(parsedObject.type)
                    .setCast(parsedObject.cast)
                    .setGenreList(parsedObject.genreList)
                    .setCountry(parsedObject.country)
                    .setYear(parsedObject.year)
                    .setPackageCode(parsedObject.packageCode)
                    .setPackageColourCode(parsedObject.packageColourCode)
                    .setLogoUrl(parsedObject.logoUrl)
                    .setImages(parsedObject.images)
                    .setDvdCover(parsedObject.dvdCover)
                    .setBlackedOut(parsedObject.blackedOut)
                    .setCatalog(parsedObject.catalog)
                    .setLicensing(parsedObject.licensing)
                    .setIsHD(parsedObject.isHD);

            };

            var parseStormFilmAsset = function (object) {
                var builder = new FilmAssetBuilder(),
                    model,
                    parsedObject = __parseStormFilmAsset(object);

                __buildStormAsset(builder, parsedObject);

                model = builder.setVideoQuality(parsedObject.videoQuality)
                    .setVideo(parsedObject.video)
                    .setTrailer(parsedObject.trailer)
                    .setLive(parsedObject.live)
                    .setLength(parsedObject.length)
                    .build();

                return model;
            };
            parser.parseStormFilmAsset = parseStormFilmAsset;

            var parseStormEpisodeAsset = function (object) {
                var builder = new EpisodeAssetBuilder(),
                    model,
                    parsedObject = __parseStormEpisodeAsset(object);

                __buildStormAsset(builder, parsedObject);

                model = builder.setEpisodeNumber(parsedObject.episodeNumber)
                    .setVideo(parsedObject.video)
                    .setSeasonNumber(parsedObject.seasonNumber)
                    .setSerieTitle(parsedObject.serieTitle)
                    .setSeasonId(parsedObject.seasonId)
                    .setSerieId(parsedObject.serieId)
                    .build();

                return model;
            };
            parser.parseStormEpisodeAsset = parseStormEpisodeAsset;

            var parseStormSeasonAsset = function (object) {

                var builder = new SeasonAssetBuilder(),
                    model,
                    parsedObject = __parseStormSeasonAsset(object),
                    episodes = [];

                __buildStormAsset(builder, parsedObject);

                if (parsedObject.episodes && parsedObject.episodes.length > 0) {
                    episodes = util.map(parsedObject.episodes, function (episode) {
                        episode.season_id = object.id;
                        episode.serie_id = object.serie_id;
                        episode.catalog = object.catalog;
                        return parseStormEpisodeAsset(episode);
                    });
                }

                model = builder.setEpisodes(episodes)
                    .setNumberOfEpisodes(parsedObject.numberOfEpisodes)
                    .setSeasonNumber(parsedObject.seasonNumber)
                    .setSerieId(parsedObject.serieId)
                    .build();

                return model;
            };
            parser.parseStormSeasonAsset = parseStormSeasonAsset;

            var parseStormSerieAsset = function (object) {
                var builder = new SerieAssetBuilder(),
                    model,
                    parsedObject = __parseStormSerieAsset(object),
                    seasons = [];

                __buildStormAsset(builder, parsedObject);

                if (parsedObject.seasons && parsedObject.seasons.length > 0) {
                    seasons = util.map(parsedObject.seasons, function (season) {
                        season.serie_id = object.id;
                        season.catalog = object.catalog;
                        return parseStormSeasonAsset(season);
                    });
                }

                model = builder.setSeasons(seasons)
                    .setNumberOfSeasons(parsedObject.numberOfSeasons)
                    .build();

                return model;
            };
            parser.parseStormSerieAsset = parseStormSerieAsset;

            var parseStormSportAsset = function (object) {
                var builder = new SportAssetBuilder(),
                    model,
                    parsedObject = __parseStormSportAsset(object);

                __buildStormAsset(builder, parsedObject);

                model = builder.setSubtitle(parsedObject.subtitle)
                    .setChannelCode(parsedObject.channelCode)
                    .setChannelName(parsedObject.channelName)
                    .setCurrentType(parsedObject.currentType)
                    .setLicensing(parsedObject.licensing)
                    .setLive(parsedObject.live)
                    .setSimulCast(parsedObject.simulCast)
                    .setLength(parsedObject.length)
                    .setLicense(parsedObject.license)
                    .setVideo(parsedObject.video)
                    .setMediaUrl(parsedObject.mediaUrl)
                    .setMediaUrlHls(parsedObject.mediaUrlHls)
                    .setOnAir(parsedObject.onAir)
                    .setStartTime(parsedObject.startTime)
                    .setEndTime(parsedObject.endTime)
                    .setDate(parsedObject.date)
                    .setPreviewPath(parsedObject.previewPath)
                    .setWebvodCanonicalUrl(parsedObject.webvodCanonicalUrl)
                    .build();

                return model;
            };
            parser.parseStormSportAsset = parseStormSportAsset;

            return parser;
        }()),

        AssetManager = klass.create({
        }, {

            ASSET_TYPES: {
                FILM: "Film",
                EPISODE: "Episode",
                SPORT: "Sport"
            },

            SPORT_ASSET_CURRENT_TYPES: {
                REPLAY : "Replay",
                LIVE : "Live"
            },

            _cache: new Cache({
                ttl: TTL,
                size: CACHE_SIZE
            }),

            /**
             * Generate a cache key based on request information
             * @method __generateCacheKey
             * @param {String} the prefix string of the cache key
             * @param {Object} parameters Request parameters, object containing key-value pairs that are convertible into key1=value1&key2=value2 format with e.g toQueryString() method
             * @return {String} the string for the cache key
             * @memberof tve/mgr/sVODManager#
             * @private
             */
            __generateCacheKey: function (prefix, parameters) {
                var queryString = parameters ? util.toQueryString(parameters) : "",
                    str = prefix + "?" + queryString;

                if (window.btoa) {
                    return window.btoa(str);
                } else {
                    return base64.encode(str);
                }
            },

            /**
             * Get Films/Episodes asset array.
             * @method getAssets
             * @param {Object} [opts] The options object
             * @param {Array}  [opts.ids] the asset models
             * @param {string} [assetType] assetType
             * @public
             * @returns {LocalDatasource.<tvedemo/model/Asset>} a DS of Asset (type Film/Episode) data
             * @memberof tvedemo/mgr/sAssetManager#
             */
            getAssets: function(opts, assetType) {
                opts = opts || {};

                var cacheKey = this.__generateCacheKey(assetType === this.ASSET_TYPES.FILM ? CACHE_KEY_PREFIX.FILMS : CACHE_KEY_PREFIX.EPISODES, opts),
                    cache = this._cache.getCache(cacheKey),
                    ids;

                if (cache) {
                    return cache;
                }

                ids = opts.ids && opts.ids.join ? opts.ids : null;

                var promiseArray = [];

                if (ids) {
                    util.each(ids, function(asset) {
                        promiseArray.push(stormService.getAssetById(asset.get("assetId"), asset.get("catalog")).then(function(res) {

                            // Make sure we catch the catalog for this thing,
                            // The catalog is needed later for add to watchlist, etc..
                            res.asset.catalog = res.product;
                            return res;
                        }, function(e) {
                            console.warn("Get asset promise failed: " + e);
                        }));
                    });

                    var assets= [];
                    return promise.all(promiseArray).then(util.bind(function(res) {

                        util.each(res, util.bind(function(item) {
                            if (item !== undefined) {
                                if (item.asset.asset_type === this.ASSET_TYPES.FILM) {
                                    assets.push(__parser.parseStormFilmAsset(item.asset));
                                } else if (item.asset.asset_type === this.ASSET_TYPES.EPISODE) {
                                    assets.push(__parser.parseStormEpisodeAsset(item.asset));
                                } else if (item.asset.asset_type === this.ASSET_TYPES.SPORT) {
                                    assets.push(__parser.parseStormSportAsset(item.asset));
                                }
                            }

                        }, this));

                        return { data: assets, total: assets.length };

                    }, this), function(error) {
                        //@TODO - throw a TVEError or STORM custom error handler.
                        console.log(error);
                    });
                }
            },

            // get a data loader from an array
            getDataLoaderFromArray: function(objectsArray) {
                return function(from, size) {

                    var dataArr = [],
                        i = from,
                        len = from + size,
                        deferred = promise.defer(),
                        dataItem = objectsArray.data;


                    deferred.resolve({
                        data: dataItem,
                        total: dataItem.length
                    });

                    return deferred.promise;
                };
            },


            /**
             * Retrieves detail information for a asset.
             * @param  {Number} assetId Id of the asset to retrieve detail information for.
             * @return {Promise}        Asset details when fulfilled.
             */
            getAssetById: function (assetId, catalog) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ASSET + assetId),
                    cachedResult = this._cache.getCache(cacheKey);

                if (cachedResult) {
                    return promise.resolve(cachedResult);
                }

                return stormService.getAssetById(assetId, catalog).then(util.bind(function (assetOfSomeKind) {

                    // Make sure we catch the catalog for this asset,
                    // The catalog is needed later for add to watchlist, etc..
                    assetOfSomeKind.asset.catalog = assetOfSomeKind.product;

                    // Sports can be assets too; see SKYSTORM-565.

                    if (assetOfSomeKind.asset.asset_type === "Sport") {
                        assetOfSomeKind = __parser.parseStormSportAsset(assetOfSomeKind.asset);
                    } else {
                        assetOfSomeKind = __parser.parseStormFilmAsset(assetOfSomeKind.asset);
                    }

                    this._cache.setObject(cacheKey, assetOfSomeKind);

                    return assetOfSomeKind;
                }, this));
            },

            /**
             * Retrieves detail information for an episode asset.
             * @param  {Number} episodeId Id of the episode to retrieve detail information for.
             * @return {Promise}          Episode details when fulfilled.
             */
            getEpisodeById: function (episodeId, catalog) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.EPISODE + episodeId),
                    cachedResult = this._cache.getCache(cacheKey);

                if (cachedResult) {
                    return promise.resolve(cachedResult);
                }

                return stormService.getAssetById(episodeId, catalog).then(util.bind(function (episode) {

                    episode.asset.catalog = episode.product;

                    episode = __parser.parseStormEpisodeAsset(episode.asset);

                    this._cache.setObject(cacheKey, episode);

                    return episode;
                }, this));
            },

            /**
             * Retrieves detail information for a sport asset.
             * @param  {Number} assetId Id of the asset to retrieve detail information for.
             * @return {Promise}        Sport Asset details when fulfilled.
             */
            getSportAssetById: function (assetId, catalog) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.SPORT + assetId),
                    cachedResult = this._cache.getCache(cacheKey);

                if (cachedResult) {
                    return promise.resolve(cachedResult);
                }

                return stormService.getAssetById(assetId, catalog).then(util.bind(function (sport) {

                    // Make sure we catch the catalog for this asset,
                    // The catalog is needed later for add to watchlist, etc..
                    sport.asset.catalog = sport.product;

                    sport = __parser.parseStormSportAsset(sport.asset);

                    this._cache.setObject(cacheKey, sport);

                    return sport;
                }, this));
            },

            /**
             * Retrieves a 'best fit' image the asset.
             * @param  {tvedemo/model/Asset} asset      Asset to retrieve image for.
             * @return {Promise <tve/model/Resource>}   Image resource matching the image dimensions and asset.
             */
            getStormAssetImageBySize: function (asset, imageWidth, imageHeight) {
                return stormService.getAssetImageBySize(asset, imageWidth, imageHeight).then(function (image) {
                    image = __parser.parseResource(image);
                    return image;
                });
            },

            /**
             * Retrieves logo image for the channel associated with the asset.
             * @param  {tvedemo/model/Asset} asset    Asset to retrieve channel logo for.
             * @return {Promise <tve/model/Resource>} Channel logo image resource.
             */
            getStormAssetChannelLogo: function (asset) {

                return stormService.getAssetChannelLogo(asset).then(function (image) {

                    image = __parser.parseResource(image);

                    return image;
                });
            },

            /**
             * Retrieves a dvd cover for the asset.
             * @param  {tvedemo/model/Asset} asset      Asset to retrieve image for.
             * @return {Promise <tve/model/Resource>}   Image resource for the specific image type and asset.
             */
            getStormAssetDvdCover: function (asset) {
                return stormService.getAssetDvdCover(asset).then(function (image) {
                    image = __parser.parseResource(image);
                    return image;
                });
            },

            /**
             * Retrieves detail information for a serie asset.
             * @param  {Number} serieAssetId Id of the serie asset to retrieve detail information for.
             * @return {Promise}             Serie details when fulfilled.
             */
            getSerieAssetById: function (serieAssetId, catalog) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.SERIE + catalog + serieAssetId),
                    cachedResult = this._cache.getCache(cacheKey);

                if (cachedResult) {
                    return promise.resolve(cachedResult);
                }

                return stormService.getSerieAssetById(serieAssetId, catalog).then(util.bind(function (result) {
                    var serie = result && result.serieRecap && result.serieRecap.serie;

                    serie.catalog = result.product;

                    serie = __parser.parseStormSerieAsset(serie);

                    this._cache.setObject(cacheKey, serie);

                    return serie;

                }, this));
            },

            /**
             * Retrieves detail information for a season asset.
             * @param  {Number} seasonAssetId Id of the season asset to retrieve detail information for.
             * @return {Promise}             season details when fulfilled.
             */
            getSeasonAssetById: function (seasonAssetId, catalog) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.SEASON + catalog + seasonAssetId),
                    cachedResult = this._cache.getCache(cacheKey);

                if (cachedResult) {
                    return promise.resolve(cachedResult);
                }

                return stormService.getSeasonAssetById(seasonAssetId, catalog).then(util.bind(function (result) {
                    var season = result && result.season;
                    season.catalog = result.product;
                    season = __parser.parseStormSeasonAsset(season);
                    this._cache.setObject(cacheKey, season);
                    return season;
                }, this));
            },

            /**
             * Retrieve related episodes.
             * @param  {Number} serieId                               Serie containing the episodes.
             * @param  {Number} seasonId                              Season containing the episodes.
             * @return {Promise<tvedemo/model/EpisodeAsset>}          Related episodes.
             */
            getRelatedEpisodesBySerieAndSeason: function (serieId, seasonId, catalog) {

                return this.getSerieAssetById(serieId, catalog).then(function (serie) {
                    var seasons = serie.get("seasons"),
                        episodesToReturn;

                    util.each(seasons, function (season) {

                        if (season.get("id") === seasonId) {
                            episodesToReturn = season.get("episodes");
                            return util.breaker;
                        }
                    });

                    return episodesToReturn;
                });
            }

        });

    return new AssetManager();

});

/**
 * TVChannel Builder, for building the TVChannel model
 * @class tve/model/TVChannelBuilder
 */
define("tve/model/TVChannelBuilder", [
    "xdk-base/class", "tve/model/AssetBuilder", "tve/model/TVChannel"
], function (klass, AssetBuilder, TVChannel) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the channel number for building this model.
         * @param {String} value the channel number
         * @returns {tve/model/TVChannelBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/TVChannelBuilder#
         */
        setChannelNumber: function (value) {
            this._attrs.channelNumber = value;
            return this;
        },

        setMobilepc: function(value) {
            this._attrs.mobilepc = value;
            return this;
        },

        setPackageCode: function(value) {
            this._attrs.packageCode = value;
            return this;
        },

        /**
         * Build the TVChannel model.
         * @returns {tve/model/TVChannel} the TVChannel model
         * @public
         * @method
         * @memberof tve/model/TVChannelBuilder#
         */
        build: function () {
            return new TVChannel(this._attrs);
        }
    });

    return Builder;
});
/**
 * ChannelListing Model
 * @class tve/model/ChannelListing
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/ChannelListing", ["xdk-base/class", "tve/model/ImmutableModel"], function (klass, ImmutableModel) {
    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member channelId
             * @memberof tve/model/ChannelListing#
             * @public
             * @type {String}
             */
            "channelId": null,

            /**
             * @member startTime
             * @memberof tve/model/ChannelListing#
             * @public
             * @type {Number}
             */
            "startTime": null,

            /**
             * @member endTime
             * @memberof tve/model/ChannelListing#
             * @public
             * @type {Number}
             */
            "endTime": null,

            /**
             * @member programs
             * @memberof tve/model/ChannelListing#
             * @public
             * @type {tve/model/Program[]}
             */
            "programs": []
        }
    }, {});
});
/**
 * Channel Listing Builder, for building the ChannelListing model
 * @class tve/model/ChannelListingBuilder
 */
define("tve/model/ChannelListingBuilder", ["xdk-base/class", "tve/model/ChannelListing"], function(klass, ChannelListing) {

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tve/model/ChannelListingBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the channel identifier for building this model.
         * @param {String} value the channel identifier
         * @returns {tve/model/ChannelListingBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ChannelListingBuilder#
         */
        setChannelId: function(value){
            this._attrs.channelId = value;
            return this;
        },

        /**
         * Set the start time for building this model.
         * @param {Number} value the start time
         * @returns {tve/model/ChannelListingBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ChannelListingBuilder#
         */
        setStartTime: function(value){
            this._attrs.startTime = value;
            return this;
        },

        /**
         * Set the end time for building this model.
         * @param {Number} value the end time
         * @returns {tve/model/ChannelListingBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ChannelListingBuilder#
         */
        setEndTime: function(value){
            this._attrs.endTime = value;
            return this;
        },

        /**
         * Set the programs for building this model.
         * @param {tve/model/Program[]} value the programs
         * @returns {tve/model/ChannelListingBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ChannelListingBuilder#
         */
        setPrograms: function(value){
            this._attrs.programs = value;
            return this;
        },

        /**
         * Build the ChannelListing model.
         * @return {tve/model/ChannelListing} the ChannelListing model
         * @public
         * @method
         * @memberof tve/model/ChannelListingBuilder#
         */
        build: function(){
            return new ChannelListing(this._attrs);
        }
    });

    return Builder;
});
/**
 * Program Model
 * @class tve/model/Program
 * @augments tve/model/Asset
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tve/model/Program", ["xdk-base/class", "tve/model/Asset", "xdk-base/util"], function (klass, Asset, util) {
    return klass.create(Asset, {

        defaults: util.extend(util.clone(Asset.defaults), {

            /**
             * @member startTime
             * @memberof tve/model/Program#
             * @public
             * @type {Number}
             */
            "startTime": null,

            /**
             * @member endTime
             * @memberof tve/model/Program#
             * @public
             * @type {Number}
             */
            "endTime": null,

            "inlineMetadata": "",

            "epgBlackout": null
        }, true)
    }, {});
});
/**
 * Program Builder, for building the Program model
 * @class tve/model/ProgramBuilder
 */
define("tve/model/ProgramBuilder", [
    "xdk-base/class", "tve/model/AssetBuilder", "tve/model/Program"
], function (klass, AssetBuilder, Program) {

    var Builder = klass.create(AssetBuilder, {}, {

        /**
         * Set the start time for building this model.
         * @param {Number} value the start time
         * @returns {tve/model/ProgramBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ProgramBuilder#
         */
        setStartTime: function (value) {
            this._attrs.startTime = value;
            return this;
        },

        /**
         * Set the end time for building this model.
         * @param {Number} value the end time
         * @returns {tve/model/ProgramBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tve/model/ProgramBuilder#
         */
        setEndTime: function (value) {
            this._attrs.endTime = value;
            return this;
        },

        setInlineMetadata: function (value) {
            this._attrs.inlineMetadata = value;
            return this;
        },

        setEpgBlackout: function(value) {
            this._attrs.epgBlackout = value;
            return this;
        },

        /**
         * Build the Program model.
         * @returns {tve/model/Program} the Program model
         * @public
         * @method
         * @memberof tve/model/ProgramBuilder#
         */
        build: function () {
            return new Program(this._attrs);
        }
    });

    return Builder;
});
/**
 * Sport News Model
 * @class tvedemo/model/SportNews
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/SportNews", ["xdk-base/class", "tve/model/ImmutableModel"], function(klass, ImmutableModel) {
    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {
            /**
             * @member id
             * @memberof tvedemo/model/SportNews#
             * @public
             * @type {Number}
             */
            "id": null,
            /**
             * @member images
             * @memberof tvedemo/model/SportNews#
             * @public
             * @type {Object[]}
             */
            "images": null,
            /**
             * @member title
             * @memberof tvedemo/model/SportNews#
             * @public
             * @type {String}
             */
            "title": null,
            /**
             * @member synopsis
             * @memberof tvedemo/model/SportNews#
             * @public
             * @type {String}
             */
            "synopsis": null,
            /**
             * @member date
             * @memberof tvedemo/model/SportNews#
             * @public
             * @type {String}
             */
            "date": null,
            /**
             * @member category name
             * @memberof tvedemo/model/SportNews#
             * @public
             * @type {String}
             */
            "categoryName": null
        }
    }, {});
});
/**
 * SportNews Builder, for building the SportNews model
 * @class tvedemo/model/SportNewsBuilder
 */
define("tvedemo/model/SportNewsBuilder", ["xdk-base/class", "tvedemo/model/SportNews"], function (klass, SportNews) {

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/SportNewsBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the identifier for building this model.
         * @param {String} value the identifier
         * @return {tvedemo/model/SportNewsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SportNewsBuilder#
         */
        setId: function (value) {
            this._attrs.id = value;
            return this;
        },

        /** 
         * Set the images for building this model.
         * @param {String} value the images
         * @return {tvedemo/model/SportNewsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SportNewsBuilder#
         */
        setImages: function (value) {
            this._attrs.images = value;
            return this;
        },

        /** 
         * Set the title for building this model.
         * @param {String} value the title
         * @return {tvedemo/model/SportNewsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SportNewsBuilder#
         */
        setTitle: function (value) {
            this._attrs.title = value;
            return this;
        },

        /** 
         * Set the synopsis for building this model.
         * @param {String} value the synopsis
         * @return {tvedemo/model/SportNewsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SportNewsBuilder#
         */
        setSynopsis: function (value) {
            this._attrs.synopsis = value;
            return this;
        },

        /** 
         * Set the date for building this model.
         * @param {String} value the date
         * @return {tvedemo/model/SportNewsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SportNewsBuilder#
         */
        setDate: function (value) {
            this._attrs.date = value;
            return this;
        },

        /** 
         * Set the category name for building this model.
         * @param {String} value the category name
         * @return {tvedemo/model/SportNewsBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/SportNewsBuilder#
         */
        setCategoryName: function (value) {
            this._attrs.categoryName = value;
            return this;
        },

        /**
         * Build the SportNews model.
         * @return {tvedemo/model/SportNews} the SportNews model
         * @public
         * @method
         * @memberof tve/model/SportNewsBuilder#
         */
        build: function () {
            return new SportNews(this._attrs);
        }
    });

    return Builder;
});
/**
 * Returns a singleton responsible for Omniture tracking navigation and video plays within the application.
 * @name sTrackingManager
 * @memberof tvedemo/mgr
 * @class tve/mgr/sTrackingManager
 * @author Tom Canter <tom.canter@accedo.tv>
 */
define("tvedemo/mgr/sTrackingManager", [
    "xdk-base/class",
    "tve/sServiceHolder",
    "xdk-ax/mediator",
    "tve/videoPlaybackService/evt/VideoPlaybackStatusEvent",
    "tve/videoPlaybackService/evt/VideoPlaybackControlsEvent",
    "xdk-base/util",
    "xdk-base/device/Media"
], function (klass, 
             sServiceHolder, 
             mediator, 
             VideoPlaybackStatusEvent, 
             VideoPlaybackControlsEvent, 
             util,
             Media) {
    "use strict";
    var instance, TrackingManager;
    TrackingManager = klass.create({
        /**
         * Get the singleton instance of this class.
         */
        singleton: function () {
            if (!instance) {
                instance = new TrackingManager();
            }
            return instance;
        }
    }, {
        _curAsset: null,
        _mediaType: null,
        _duration: null,
        _trackingSessionActive: false,
        _analytics: sServiceHolder.getAnalyticsService(),
        _mediaState: "STOPPED",
        callbacks: {},
        /**
         * Track playback if this is set to true
         * @type {Boolean}
         * @memberof tvedemo/mgr/sTrackingManager
         */
        trackingEnabled: true,
        init: function() { },
        /**
         * Track the beginning of playback
         * asset @type {String} The name of the asset
         * mediatype @type {String} Can be MP4, PlayReady or etc...
         * duration @type {Integer} Duration of the video in seconds
         */
        trackOpenMedia: function (asset, mediatype, duration) {
            //console.log("[sTrackingManager] DEBOUNCING Calling mediaOpen with asset="+asset+" mediaType="+mediatype+" duration="+duration);
            this.__debounce(function() {
                this._curAsset = asset;
                this._mediaType = mediatype;
                this._duration = duration;
                this._trackingSessionActive = true;
                //console.log("[sTrackingManager] DEBOUNCING DONE Calling mediaOpen with asset="+asset+" mediaType="+mediatype+" duration="+duration);
                this._analytics.mediaOpen(asset, mediatype, duration);
                this._mediaState = "PLAYING";
            }, 1000);
        },
        /**
         * Track a play event. Can be called several times in combination with trackStopMedia and trackPlayMedia
         */
        trackPlayMedia: function (currentPlaybackPosition) {
            this.__debounce(function() {
                if (this._trackingSessionActive) {
                    if (this._mediaState !== "STOPPED") {
                        this._analytics.mediaStop(this._curAsset, this._mediaType, currentPlaybackPosition);
                    }
                    this._analytics.mediaPlay(this._curAsset, this._mediaType, currentPlaybackPosition);
                    this._mediaState = "PLAYING";
                }
                else {
                    console.warn("[sTrackingManager: trackPlayMedia] Playback tracking is not activated. Exiting.");
                }
            }, 1000);
        },
            
        trackPauseMedia: function (currentPlaybackPosition) {
            this.__debounce(function() {
                if (this._trackingSessionActive) {
                    this._analytics.mediaStop(this._curAsset, this._mediaType, currentPlaybackPosition);
                    this._mediaState = "STOPPED";
                }
                else {
                    console.warn("[sTrackingManager: trackPauseMedia] Playback tracking is not activated. Exiting");
                }
            }, 1000);
        },
        trackVideoStateChangeSetupCallback: function () {
            this.callbacks = {
                play: util.bind(this.__trackPlayMediaCallback, this),
                pause: util.bind(this.__trackPauseMediaCallback, this),
                timeupdate: util.bind(this.mediaSetPosition, this)
            };
            
            mediator.subscribe(VideoPlaybackStatusEvent.PlayState, this.callbacks.play);
            mediator.subscribe(VideoPlaybackStatusEvent.PauseState, this.callbacks.pause);
            mediator.subscribe(VideoPlaybackStatusEvent.BufferState, this.callbacks.pause);
            var sMedia = Media.singleton();
            sMedia.addEventListener(sMedia.EVT_TIME_UPDATE, this.callbacks.timeupdate);
        },
        __trackCloseMediaCallback: function (playListItem) {
            this.trackPauseMedia(playListItem.currentPlaybackTime);
            this.trackCloseMedia(playListItem.currentPlaybackTime);
        },
        __trackPlayMediaCallback: function (playListItem) {
            this.trackPlayMedia(playListItem.currentPlaybackTime);
        },
        __trackPauseMediaCallback: function (playListItem) {
            this.trackPauseMedia(playListItem.currentPlaybackTime);
        },
        /**
         * End playback tracking for this video
         */
        trackCloseMedia: function (currentPlaybackPosition) {
            this.__debounce(function() {
                this._analytics.mediaClose(this._curAsset, this._mediaType, currentPlaybackPosition);
                this._curAsset = null;
                this._mediaType = null;
                this._duration = null;
                this._trackingSessionActive = false;
            }, 1000);
            mediator.unsubscribe(VideoPlaybackStatusEvent.PlayState, this.callbacks.play);
            mediator.unsubscribe(VideoPlaybackStatusEvent.PauseState, this.callbacks.pause);
            mediator.unsubscribe(VideoPlaybackStatusEvent.BufferState, this.callbacks.pause);
            var sMedia = Media.singleton();
            sMedia.removeEventListener(sMedia.EVT_TIME_UPDATE, this.callbacks.timeupdate);
        },
        mediaSetPosition: function (position) {
            this._analytics.mediaSetPosition(position);
        },
        mediaSetDuration: function(duration) {
            this._analytics.mediaSetDuration(duration);
        },
        trackSearch: function(searchTerm) {
            this._analytics.trackSearch(searchTerm);
        },
        mediaMonitor: function() {
            this._analytics.mediaMonitor();
        },
        /**  Returns a function, that, as long as it continues to be invoked, will not
             be triggered. The function will be called after it stops being called for
             N milliseconds. If "immediate"" is passed, trigger the function on the
             leading edge, instead of the trailing.
         */
         __debounce: function (func, threshold, execAsap) {
            var timeout, 
                obj = this;
            var debounced = function() {
                var args = arguments;
                function delayed () {
                    if (!execAsap)
                        func.apply(obj, args);
                    timeout = null;
                }
                if (timeout)
                    clearTimeout(timeout);
                else if (execAsap)
                    func.apply(obj, args);
                timeout = setTimeout(delayed, threshold);
            };
            debounced();
        }
    });
    TrackingManager.singleton();
    return TrackingManager;
});

/**
 * Returns a singleton responsible to convert metadata as well as assets retrieved from Linear service to desired format (list, ds, etc)
 * @name LinearManager
 * @memberof tve/mgr
 * @class tve/mgr/sLinearManager
 */
define("tve/mgr/sLinearManager", [
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/util",
    "tve/sServiceHolder",
    "tve/util/CacheHelper",
    "xdk-ax/data/LocalDatasource",
    "xdk-base/promise",
    "lib/base64",
    "xdk-base/core",
    "xdk-base/console",
    "tve/TVEError",
    "tve/model/TVChannelBuilder",
    "tve/model/ChannelListingBuilder",
    "tve/model/ProgramBuilder",
    "tve/model/MediaCategoryBuilder",
    "tve/model/ResourceBuilder",
    "require",
    "tve/mgr/sVODManager",
    "tvedemo/helper/sMoment",
    "storm/helper/util",
    "tvedemo/model/SportNewsBuilder",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sAppConfigManager",
    "storm/mgr/sLinearChannelManager",
    "tvedemo/mgr/sEndUserManager",
    "xdk-base/device",
    "tvedemo/mgr/sTrackingManager"
], function (
    klass,
    config,
    util,
    serviceHolder,
    Cache,
    LocalDatasource,
    promise,
    base64,
    core,
    console,
    TVEError,
    TVChannelBuilder,
    ChannelListingBuilder,
    ProgramBuilder,
    MediaCategoryBuilder,
    ResourceBuilder,
    require,
    sVODManager,
    moment,
    stormUtil,
    SportNewsBuilder,
    sLanguageManager,
    sAppConfigManager,
    sLinearChannelManager,
    sEndUserManager,
    device,
    TrackingManager
    ) {

    "use strict";

    var CACHE_KEY_PREFIX = {
            PROGRAM: "program",
            CHANNEL: "channel",
            CHANNELS: "channels",
            CHANNELS_DS: "channels_ds",
            ALL_CHANNELS: "all_channels",
            ALL_CHANNELS_DS: "all_channels_ds",
            ALL_CATEGORIES: "all_categories",
            TV_LISTING: "tv_listing",
            TV_LISTINGS: "tv_listings",
            TV_LISTINGS_DS: "tv_listings_ds",
            CURRENT_PROGRAM: "current_program",

            CHANNEL_LOGO: "channel_logo",
            CHANNEL_STREAM: "channel_stream",

            PROGRAM_THUMBNAIL: "program_thumbnail",
            PROGRAM_CONTENT: "program_content"
        },

        FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,

        TTL = 30 * 60 * 1000, // 30 minutes,

        CACHE_SIZE = 5000,

        PROGRAM_CACHE_SIZE = 5000,

        RESOURCE_CACHE_SIZE = 4000,

        MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000,

        PAGE_SIZE = 50, //define how many data to load every time call the server

        linearContentService = serviceHolder.getLinearContentService(),

        CMS_ROOT,

        __parser = (function () {
            var parser = {},

                __arrayToMapHelper = function (subObj, parseMap) {
                    var ret = {},
                        NAME = parseMap[0],
                        VALUE = parseMap[1],
                        subObjName,
                        subObjValue,
                        subLen,
                        i;

                    subLen = subObj.length;

                    for (i = 0; i < subLen; i++) {
                        subObjName = subObj[i][NAME];
                        subObjValue = subObj[i][VALUE];
                        if (!subObjName || !subObjValue) {
                            continue;
                        }
                        ret[subObjName] = subObjValue;
                    }

                    return ret;
                },

                __parseAssetObj = function (obj) {
                    if (!obj.id || !obj.name) {
                        throw new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INVALID, "The asset cannot be parsed: either id or title is not valid");
                    }

                    var assetObj = {
                        id: obj.id,
                        title: obj.name,
                        description: obj.description || "",
                        publishedDate: obj.publishedDate ? new Date(obj.publishedDate) : null,
                        availableDate: obj.publishedDate ? new Date(obj.availableDate) : null,
                        metadata: {},
                        credits: obj.credits ? __arrayToMapHelper(obj.credits, ["role", "name"]) : [],
                        categories: [],
                        parentalRatings: obj.parentalRatings || [],
                        images: [parseResource({
                            id: obj.id,
                            url: obj.logo ? (CMS_ROOT + obj.logo) : undefined,
                            type: "logo"
                        })]
                    };

                    if (obj.categories) {
                        util.each(obj.categories, function (category) {
                            assetObj.categories.push(parseMediaCategory(category));
                        });
                    }

                    if (obj.mediaurl) {
                        assetObj.videos = [parseResource({
                            id: obj.id,
                            url: obj.mediaurl,
                            mimeType: "ism"
                        })];
                    }

                    return assetObj;
                };

            var parseTVChannel = function (obj) {
                var builder = new TVChannelBuilder(),
                    model,
                    parsedObj = __parseAssetObj(obj);

                parsedObj.channelNumber = obj.channelNumber;

                model = builder.setId(parsedObj.id)
                    .setTitle(parsedObj.title)
                    .setDescription(parsedObj.description)
                    .setMetadata(parsedObj.metadata)
                    .setCategories(parsedObj.categories)
                    .setGeoLock(parsedObj.geoLock)
                    .setImages(parsedObj.images)
                    .setVideos(parsedObj.videos)
                    .setChannelNumber(parsedObj.channelNumber)
                    .setMobilepc(obj.mobilepc)

                    // mobilepc is functioning as package code for linear channels.
                    .setPackageCode(obj.mobilepc)
                    .build();

                return model;
            };
            parser.parseTVChannel = parseTVChannel;

            var parseProgram = function (obj) {
                var builder = new ProgramBuilder(),
                    model,
                    parsedObj = {
                        id: obj.id,
                        title: obj.title,
                        description: obj.subtitle || "",
                        publishedDate: null,
                        availableDate: null,
                        metadata: {},
                        credits: [],
                        categories: [],
                        parentalRatings: [],
                        images: [],
                        epgBlackout: obj.epgBlackout
                    };
                parsedObj.startTime = stormUtil.parseSkyDateTimeToDate(obj.startDate, obj.startTime).getTime();
                parsedObj.endTime = stormUtil.parseSkyDateTimeToDate(obj.endDate, obj.endTime).getTime();
                parsedObj.inlineMetadata = buildMetadata(parsedObj);

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description)
                    .setMetadata(parsedObj.metadata).setImages(parsedObj.images).setStartTime(parsedObj.startTime)
                    .setEndTime(parsedObj.endTime).setVideos(parsedObj.videos).setInlineMetadata(parsedObj.inlineMetadata)
                    .setEpgBlackout(parsedObj.epgBlackout).build();

                return model;
            };
            parser.parseProgram = parseProgram;

            var buildMetadata = function(obj) {
                var inlineMetadata = "";
                if (obj.startTime && obj.endTime) {
                    inlineMetadata += moment(obj.startTime).format(sLanguageManager.getString("ui.format.epgEventTime")) + " - ";
                    inlineMetadata += moment(obj.endTime).format(sLanguageManager.getString("ui.format.epgEventTime"));
                    inlineMetadata += " (" + (moment(obj.endTime).diff(moment(obj.startTime)) | 0) / 60000 + sLanguageManager.getString("ui.format.minutesDurationSuffix") + ")";
                }
                if (obj.category) {
                    inlineMetadata += " | " + obj.category;
                }
                if (obj.country && obj.year) {
                    inlineMetadata += " | " + obj.country + " " + obj.year;
                }
                else if (obj.country) {
                    inlineMetadata += " | " + obj.country;
                }
                else if (obj.year) {
                    inlineMetadata += " | " + obj.year;
                }
                if (obj.fsk) {
                    inlineMetadata += " | " + obj.fsk;
                }
                return inlineMetadata;
            };

            var parseFullProgram = function (program, obj) {
                var fullDescription = obj.title2 ? (obj.title2 + ". ") : "";
                if (obj.detailTxt) {
                    fullDescription += obj.detailTxt;
                }

                obj.startTime = program.get("startTime");
                obj.endTime = program.get("endTime");

                return program.set("id", obj.id)// @TODO: Under what circumstances is this populated?
                        .set("title", obj.title1)
                        .set("description", fullDescription)
                        .set("images", [{file: obj.imageUrl, path: "", /* TODO: Clarify if we should hardcode width and height of image SKYSTORM-349. */ width: 557, height: 313}])
                        .set("inlineMetadata", buildMetadata(obj))

                        // TODO: These are to make sure the model contains necessary information for details page. Perhaps create a separate EpgEvent model.
                        .set("synopsis", obj.detailTxt)
                        .set("country", obj.country)
                        .set("parentalRating", {display: obj.fskInfo})
                        .set("year", obj.year)
                        .set("assetId", obj.assetid)
                        .set("catalog", obj.catalog)
                        .set("licensing", obj.eLicense); // We ignore the possibility of old' style licensing on EHUB data for Storm.
            };
            parser.parseFullProgram = parseFullProgram;

            var parseChannelListing = function (obj) {
                var builder = new ChannelListingBuilder(),
                    model,
                    parsedObj = {};

                parsedObj.channelId = obj.channelId;

                if (obj.programs) {
                    parsedObj.programs = [];
                    util.each(obj.programs, function (program) {
                        parsedObj.programs.push(parser.parseProgram(program));
                    });
                }

                model = builder.setChannelId(parsedObj.channelId).setPrograms(parsedObj.programs).build();

                return model;
            };
            parser.parseChannelListing = parseChannelListing;

            var parseMediaCategory = function (obj) {
                if (!obj.id || !obj.title) {
                    throw new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INVALID, "Cannot parse category: either id or title is not valid");
                }

                var builder = new MediaCategoryBuilder(),
                    model,
                    parsedObj = {
                        id: obj.id,
                        title: obj.title,
                        description: obj.description || "",
                        categories: []
                    };

                if (obj.categories) {
                    util.each(obj.categories, function (category) {
                        parsedObj.categories.push(parseMediaCategory(category));
                    });
                }

                model = builder.setId(parsedObj.id).setTitle(parsedObj.title).setDescription(parsedObj.description).build();

                return model;
            };
            parser.parseMediaCategory = parseMediaCategory;

            var __parseSportNewsObject = function (object) {
                return {
                    id: object.id,
                    title: object.item_title,
                    synopsis: object.item_body,
                    date: object.item_Create_Date,
                    categoryName: object.item_category_name,
                    images: [{
                        file: object.item_image,
                        path: "",

                        // TODO: Clarify if we should hardcode width and height of image SKYSTORM-349.
                        width: 557,
                        height: 313
                    }]

                };
            };

            var parseSportNews = function (sportNews) {
                var builder = new SportNewsBuilder(),
                _parsedObject = __parseSportNewsObject(sportNews),
                model;

                model = builder.setId(_parsedObject.id)
                        .setImages(_parsedObject.images)
                        .setTitle(_parsedObject.title)
                        .setSynopsis(_parsedObject.synopsis)
                        .setDate(_parsedObject.date)
                        .setCategoryName(_parsedObject.categoryName)
                        .build();

                return model;
            };

            var parseSportNewsList = function (sportNewsList) {

                var parsedList = [];

                util.each(sportNewsList, function (sportNews) {
                    parsedList.push(parseSportNews(sportNews));
                });

                return parsedList;
            };
            parser.parseSportNewsList = parseSportNewsList;

            var parseResource = function (obj) {
                var builder = new ResourceBuilder(),
                    model,
                    parsedObj = {
                        id: obj.id,
                        url: obj.url || "",
                        mimeType: obj.format || "",
                        metadata: {},
                        language: obj.language || "",
                        duration: obj.duration || 0,
                        geoLock: obj.geoLock || false,
                        width: obj.width || 0,
                        height: obj.height || 0
                    };


                if (obj.type) {
                    parsedObj.metadata.type = obj.type;
                }

                model = builder.setId(parsedObj.id).setUrl(parsedObj.url).setMimeType(parsedObj.mimeType)
                    .setMetadata(parsedObj.metadata).setDuration(parsedObj.duration).setGeoLock(parsedObj.geoLock)
                    .setWidth(parsedObj.width).setHeight(parsedObj.height).build();

                return model;
            };
            parser.parseResource = parseResource;

            return parser;
        }()),

        LinearManager = klass.create({
            /**
             * Available SORY_BY enum for sorting
             * @name SORT_BY
             * @typedef {Object} SORT_BY
             * @property {String} TITLE sorting by title ascending
             * @property {String} LATEST sorting by publish date descending
             * @public
             * @memberof tve/mgr/sLinearManager
             * @static
             */
            SORT_BY: {
                TITLE: "title|asc",
                LATEST: "publishedDate|desc"
            }
        }, {
            init: function () {
                linearContentService.acquireCMSRoot().then(function(root) {
                    CMS_ROOT = root;
                });
                this.__initializeCache();
            },
            __initializeCache: function() {
                if (device.platform === 'playstation') {
                    CACHE_SIZE = 1000;
                    PROGRAM_CACHE_SIZE = 1000;
                    RESOURCE_CACHE_SIZE = 1000;
                }
                this._programsCache = new Cache({
                    ttl: TTL,
                    size: PROGRAM_CACHE_SIZE
                });
                this._cache = new Cache({
                    ttl: TTL,
                    size: CACHE_SIZE
                });
                this._resourceCache = new Cache({
                    ttl: TTL,
                    size: RESOURCE_CACHE_SIZE
                });
            },

            /**
             * Get one day whole TV Listings in an array format by the given date
             * @method getChannelListingsByDate
             * @param {Date} [date] The date object of the day. If none is specified, current time will be used instead.
             * @public
             * @returns {Promise.<Object>} an array of TV Listings
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getChannelListingsByDate: function (date, channelIds) {
                var opts = {}
                date = date || new Date();

                if(channelIds && channelIds.length > 0){
                    opts.channelId = channelIds;//.toString();
                    // opts.channel_ids = opts.channel_ids.replace(/,/g,";");
                }
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_LISTINGS, {
                        date: date.getTime()
                    }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return ret;
                }

                ret = linearContentService.getAllChannelListings(date.setHours(0, 0, 0, 0), date.setHours(23, 59, 59, 999), opts).then(util.bind(function (channelListings) {
                    var _ret = util.reduce(channelListings.entries, function (prev, curr) {
                            prev.push(__parser.parseChannelListing(curr));
                            return prev;
                        }, []),

                        timestamp = date.setHours(0, 0, 0, 0);


                    for (var i = 0, l = _ret.length; i < l; i++) {
                        var programs = _ret[i].get("programs");

                        var channelListingCacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_LISTING, {
                            channelId: _ret[i].get("channelId"),
                            date: timestamp
                        });
                        this._cache.setObject(channelListingCacheKey, programs);

                        var programCacheKey;
                        for (var j = 0, ll = programs.length; j < ll; j++) {
                            var program = programs[j];
                            programCacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.PROGRAM, {
                                id: program.get("id")
                            });
                            this._programsCache.setObject(programCacheKey, program);
                        }

                    }

                    return _ret;
                }, this));

                this._cache.setObject(cacheKey, ret);

                return ret;
            },

            /**
             * Get TV Listings in an array format by channel ids
             * @method getChannelListingsByChannelIds
             * @param {Array} channelIds the channel IDs
             * @param {Date} [date] The date object of the day. If none is specified, current time will be used instead.
             * @public
             * @returns {Promise.<Object>} an array of TV Listings
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getChannelListingsByChannelIds: function (channelIds, date) {
                date = date || new Date();

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_LISTING, {
                        data: Math.floor(date.getTime() / MILLISECONDS_PER_DAY),
                        channelIds: channelIds.join("")
                    }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return ret;
                }

                ret = linearContentService.getChannelListingsByChannelIds(channelIds, date.setHours(0, 0, 0, 0), date.setHours(23, 59, 59, 999)).then(util.bind(function (channelListings) {
                    return util.reduce(channelListings.entries, function (prev, curr) {
                        prev.push(__parser.parseChannelListing(curr));
                        return prev;
                    }, []);

                }, this));

                this._cache.setObject(cacheKey, ret);

                return ret;
            },

            /**
             * Get channels in an array format
             * @method getChannels
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sLinearManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {Number} [opts.startIndex] the start index of all channels
             * @param {Number} [opts.count] the number of return channels
             * @param {Array}  [opts.channelIds] the channel IDs
             * @public
             * @returns {Promise.<Object>} an array of Channels
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getChannels: function (opts) {
                opts = opts || {};

                if (opts.sortBy) {
                    var sortOptions = opts.sortBy.split("|");
                    opts.sortingKey = sortOptions[0];
                    opts.sortingOrder = sortOptions[1];
                }

                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_CHANNELS, opts),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                var modelCacheHandler = util.bind(function (arr) {
                    var modelCacheKey;
                    for (var i = 0, l = arr.length; i < l; i++) {
                        modelCacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.CHANNEL, {
                            channelId: arr[i].get("id")
                        });
                        this._cache.setObject(modelCacheKey, arr[i]);
                    }
                }, this);

                if (opts.channelIds) {
                    return linearContentService.getChannelsByIds(opts.channelIds, opts).then(util.bind(function (channels) {
                        ret = util.reduce(channels.entries, function (prev, curr) {
                            prev.push(__parser.parseTVChannel(curr));
                            return prev;
                        }, []);

                        modelCacheHandler(ret);

                        if (typeof (opts.startIndex) === "number" && opts.count) {
                            ret = ret.slice(opts.startIndex, opts.startIndex + opts.count);
                        }
                        this._cache.setObject(cacheKey, ret);
                        return ret;
                    }, this));
                }
                
                return linearContentService.getAllChannels(opts).then(util.bind(function (channels) {
                    ret = util.reduce(channels.entries, function (prev, curr) {
                        var channel = __parser.parseTVChannel(curr);
                        prev.push(channel);
                        return prev;
                    }, []);
                    modelCacheHandler(ret);
                    
                    this._cache.setObject(cacheKey, ret);
                    return ret;
                }, this));
            },

            /**
             * Get all getChannels in a datasource format
             * @method getChannelsDs
             * @param {Object} [opts] The options object
             * @param {tve/mgr/sLinearManager.SORT_BY} [opts.sortBy] the parameter should match the SORT_BY properties in constructor
             * @param {Array}  [opts.channelIds] the channel IDs
             * @public
             * @returns {Promise.<Object>} a DS of channels
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getChannelsDs: function (opts) {
                opts = opts || {};

                if (opts.sortBy) {
                    var sortOptions = opts.sortBy.split("|");
                    opts.sortingKey = sortOptions[0];
                    opts.sortingOrder = sortOptions[1];
                }

                var ds = new LocalDatasource(),
                    cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.ALL_CHANNELS_DS, opts),
                    cache = this._cache.getCache(cacheKey),
                    dataLoader;

                if (cache) {
                    return (cache);
                }

                dataLoader = util.bind(function (from) {
                    var parameters = util.extend({
                            pageSize: PAGE_SIZE,
                            pageNumber: 1 + Math.floor(from / PAGE_SIZE)
                        }, opts),

                        channelsHandler = util.bind(function (channels) {
                            return {
                                total: channels.totalCount,
                                data: util.reduce(channels.entries, function (prev, curr) {
                                    prev.push(__parser.parseTVChannel(curr));
                                    return prev;
                                }, [])
                            };
                        }, this);

                    if (opts.channelIds) {
                        return linearContentService.getChannelsByIds(opts.channelIds, parameters).then(channelsHandler);
                    }
                    return linearContentService.getPermittedChannels(parameters).then(channelsHandler);
                }, this);

                ds.setDataLoader(dataLoader);
                this._cache.setObject(cacheKey, ds);

                return ds;
            },

            /**
             * Get channel by given channel ID, from the cache that we need to populate by acquiring all channels at once.
             * The Sky EHUB APIs do not allow us to acquire individual channels, or selections of channels.
             * @method getChannelById
             * @param {String} channelId the ID of the channel
             * @public
             * @returns {Promise.<tve/model/TVChannel>} the channel object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getChannelById: function (channelId) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.CHANNEL, {
                        channelId: channelId
                    }),
                    ret = this._cache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                } else {
                    console.warn("getChannelById(" + channelId + ") failed due to cache miss");
                    return promise.reject();
                }
            },

            /**
             * Get channel logo by given Channel model.
             * An optional _defaultResource_ could be provided. If the associated logo is not found, the given resource will be returned.
             * @method getChannelLogo
             * @param {tve/model/TVChannel} channel the Channel model
             * @param {tve/model/Resource} [defaultResource] The default resource to return if none could be found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for logo
             * @throws {Promise.<tve/TVEError>} no associated logo could be found and no default logo is provided
             * @memberof tve/mgr/sLinearManager#
             */
            getChannelLogo: function (channel, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.CHANNEL_LOGO + channel.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);
                
                //console.log("Cache key for logo of "+channel.get("title")+": "+cacheKey);
                
                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(channel, "logo", cacheKey, defaultResource);
            },

            /**
             * Get the channel logo url for an asset from the manager.
             * @method
             * @param {tve/model/TVChannel} tvChannel The TV channel to get
             * @returns {Promise.<String>} The logo url
             * @memberOf storm/helper/util
             */
            getChannelLogoUrl: function (tvChannel) {
                return this.getChannelLogo(tvChannel).then(function (resource) {
                    return resource.get("url");
                });
            },

            /**
             * Get channel stream by given Channel model
             * @method getChannelStream
             * @param {tve/model/TVChannel} channel the Channel model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for content
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getChannelStream: function (channel) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.CHANNEL_STREAM + channel.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                ret = channel.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INTERNAL, "no stream found"));
            },

            /**
             * Get the current program info by given channel ID
             * @method getCurrentProgramByChannelId
             * @param {String} channelId the ID of the channel
             * @public
             * @returns {Promise.<tve/model/Program>} the program object
             * @throws {Promise.<tve/TVEError>} Internal error object. Will throw an error if cannot get the program.
             * @memberof tve/mgr/sLinearManager#
             */
            getCurrentProgramByChannelId: function (channelId) {
                var currentTime = new Date().getTime(),// @TODO: Verify that this isn't used, since we have to rely no SERVER date/time for Storm!
                    channelListingCacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.TV_LISTING, {
                        channelId: channelId,
                        date: (new Date()).setHours(0, 0, 0, 0)
                    }),
                    programs = this._cache.getCache(channelListingCacheKey),
                    program,
                    getCurrentProgram = function (programs) {
                        for (var i = 0, l = programs.length; i < l; i++) {
                            var program = programs[i],
                                startTime = program.get("startTime"),
                                endTime = program.get("endTime");

                            if (currentTime >= startTime && currentTime < endTime) {
                                return program;
                            }
                        }
                    };

                if (programs) {
                    program = getCurrentProgram(programs);
                    if (program) {
                        return promise.resolve(program);
                    }

                    return promise.reject(new TVEError(TVEError.FACILITY.LINEAR_MANAGER, TVEError.ERROR.INVALID, "Cannot get the program"));
                }

                return this.getChannelListingsByDate().then(util.bind(function () {
                    var programs = this._cache.getCache(channelListingCacheKey),
                        program = getCurrentProgram(programs);
                    if (program) {
                        return program;
                    }

                    throw new TVEError(TVEError.FACILITY.LINEAR_MANAGER, TVEError.ERROR.INVALID, "Cannot get the program");
                }, this));
            },

            /**
             * Get the program info by given channel ID and program start time
             * @method getProgramByChannelId
             * @param {String} channelId the ID of the channel
             * @param {Number} programStartTime the start time of the program
             * @public
             * @returns {Promise.<tve/model/Program>} the program object
             * @throws {Promise.<tve/TVEError>} Internal error object. Will throw an error if cannot get the program.
             * @memberof tve/mgr/sLinearManager#
             */
            getProgramByChannelId: function (channelId, programStartTime) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.PROGRAM, {
                        channelId: channelId,
                        programStartTime: programStartTime
                    }),
                    ret = this._programsCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }
                return linearContentService.getChannelListingByChannelId(channelId, programStartTime, programStartTime + 1000).then(util.bind(function (channelListing) {
                    var programs = channelListing.programs;
                    if (programs && programs.length) {
                        var program = __parser.parseProgram(programs[0]);
                        this._programsCache.setObject(cacheKey, program);
                        return program;
                    }
                    throw new TVEError(TVEError.FACILITY.LINEAR_MANAGER, TVEError.ERROR.INVALID, "Cannot get the program");
                }, this));
            },

            /**
             * Get program by given program ID
             * @method getProgramById
             * @param {String} programId the ID of the program
             * @public
             * @returns {Promise.<tve/model/Program>} the program object
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getProgramById: function (programId, channelId) {
                // Don't cache the placeholder...
                if (programId === 0) {
                    return linearContentService.getEventDetails(programId, channelId).then(util.bind(function (json) {
                        program = new ProgramBuilder().build();
                        return __parser.parseFullProgram(program, json);
                    }, this));
                }

                var cache = this._programsCache,
                    programCacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.PROGRAM, {
                        id: programId
                    }),
                    program = cache.getCache(programCacheKey) || new ProgramBuilder().build();

                if(util.isUndefined(channelId)) {

                    if (program) {
                        return promise.resolve(program);
                    }
                } else {
                    var fullProgramCacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.PROGRAM, {
                            id: programId,
                            channelId: channelId
                        }),
                        fullProgram = cache.getCache(fullProgramCacheKey);

                    if (fullProgram) {
                        return promise.resolve(fullProgram);
                    } else {
                        return linearContentService.getEventDetails(programId, channelId).then(util.bind(function (json) {
                            fullProgram = __parser.parseFullProgram(program, json);
                            cache.setObject(fullProgramCacheKey, fullProgram);
                            return fullProgram;
                        }, this));
                    }
                }
            },

            /**
             * Get program thumbnail by given Program model.
             * An optional parameter _defaultResource_ can be specified, such that it will be returned if no associated thumbnail could be found.
             * @method getProgramThumbnail
             * @param {tve/model/Program} program the Program model
             * @param {tve/model/Resource} [defaultResource] The default thumbnail to return if none is found
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for thumbnail
             * @throws {Promise.<tve/TVEError>} no associated thumbnail could be found and no default resource is provided
             * @memberof tve/mgr/sLinearManager#
             */
            getProgramThumbnail: function (program, defaultResource) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.PROGRAM_THUMBNAIL + program.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                return this.__getImageAndCacheWithFallback(program, "thumbnail", cacheKey, defaultResource);
            },

            /**
             * Get program content by given Program model
             * @method getProgramContent
             * @param {tve/model/Program} program the Program model
             * @public
             * @returns {Promise.<tve/model/Resource>} The Resource model for content
             * @throws {Promise.<tve/TVEError>} Internal error object
             * @memberof tve/mgr/sLinearManager#
             */
            getProgramContent: function (program) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.PROGRAM_CONTENT + program.get("id")),
                    ret = this._resourceCache.getCache(cacheKey);

                if (ret) {
                    return promise.resolve(ret);
                }

                ret = program.get("videos")[0];

                if (ret) {
                    this._resourceCache.setObject(cacheKey, ret);
                    return promise.resolve(ret);
                }
                return promise.reject(new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INTERNAL, "no content found"));
            },

            /**
             * Generate a cache key based on request information
             * @method __generateCacheKey
             * @param {String} the prefix string of the cache key
             * @param {Object} parameters Request parameters, object containing key-value pairs that are convertible into key1=value1&key2=value2 format with e.g toQueryString() method
             * @return {String} the string for the cache key
             * @memberof tve/mgr/sLinearManager#
             * @private
             */
            __generateCacheKey: function (prefix, parameters) {
                var queryString = parameters ? util.toQueryString(parameters) : "",
                    str = prefix + "?" + queryString;

                if (window.btoa) {
                    return window.btoa(str);
                } else {
                    return base64.encode(str);
                }
            },

            __getImageForResourceArrayByType: function (arr, type) {
                var image;
                for (var i = 0, l = arr.length; i < l; i++) {
                    if (arr[i].get("metadata").type === type) {
                        image = arr[i];
                        break;
                    }
                }
                return image;
            },

            /**
             * Get a particular image of an asset by type and then cache it in the resource cache.
             * A fallback could be set as the default if no resource matches the criteria.
             * @method
             * @private
             * @param {tve/model/Asset} asset The asset to search
             * @param {String} type The image type, such as "thumbnail", "cover", etc.
             * @param {String} cacheKey The key used to cache the resource
             * @param {tve/model/Resource} [fallback] The fallback resource object to return as a fallback, in case the target is not found
             * @returns {Promise.<tve/model/Resource>} the matched image
             * @throws {Promise.<tve/TVEError>} the resource is not found, and no fallback is available
             * @memberOf tve/mgr/sLinearManager#
             */
            __getImageAndCacheWithFallback: function (asset, type, cacheKey, fallback) {
                var resource = this.__getImageForResourceArrayByType(asset.get("images"), type);

                if (resource) {
                    this._resourceCache.setObject(cacheKey, resource);
                    return promise.resolve(resource);
                }

                if (fallback) {
                    return promise.resolve(fallback);
                }

                return promise.reject(new TVEError(FACILITY.VOD_MANAGER, ERROR.INTERNAL, type + " not found"));
            },

            /**
             * Retrieve all information about an epg event.
             * @param  {Number} eventId   Id of the event.
             * @param  {Number} channelId Id of the channel where the event is played.
             * @return {Promise}          Event information.
             */
            getEpgEventByEventIdAndChannelId: function (eventId, channelId) {
                return this.getChannels().then(util.bind(function () {

                    return promise.all([
                        this.getProgramById(eventId, channelId),
                        this.getChannelById(channelId)

                    ]).then(util.bind(function (result) {
                        var epgEvent = result && result[0],
                            channel = result && result[1];

                        epgEvent.set("packageCode", channel.get("mobilepc"));
                        epgEvent.set("packageColorCode", channel.get("mobilepc"));
                        epgEvent.set("channel", channel);

                        // Some of the received event information does not contain the id.
                        if (!epgEvent.get("id")) {
                            epgEvent.set("id", eventId);
                        }

                        return epgEvent;
                    }, this));

                }, this));
            },

            //=========================================================
            //====== functions below are added only for TVE Demo ======
            //=========================================================

            /**
             * Get a list of specific channels.
             * (This method is added in product demo.)
             * @method
             * @param {String[]} channelIds The channel IDs.
             * @returns {tve/model/TVChannel[]} the channels
             * @memberOf tve/mgr/sLinearManager#
             */
            getChannelsByIds: function(channelIds) {
                var cacheKey = this.__generateCacheKey(CACHE_KEY_PREFIX.CHANNELS, {
                        channelIds: channelIds.join("")
                    }),
                    ret = this._cache.getCache(cacheKey);

                if(ret){
                    return ret;
                }

                ret = this.getChannels({channelIds: channelIds});

                this._cache.setObject(cacheKey, ret);

                return ret;
            },

            /**
             * Get a Datasource of channel for the specific channels.
             * (This method is added in product demo.)
             * @method
             * @param {String[]} channelIds The channel IDs.
             * @returns {Promise.<ax/af/data/Datasource>} the data source which loads the channels
             * @memberOf tve/mgr/sLinearManager#
             */
            getChannelsDsByIds: function (channelIds) {
                return this.getChannelsDs({
                    channelIds: channelIds
                });
            },

            /**
             * Get a Datasource of channel listings for all available channels within a specific date.
             * (This method is added in product demo.)
             * @method
             * @param {Date} [date] The date to obtain. If omitted, current date will be used.
             * @returns {Promise.<ax/af/data/Datasource>} the data source which loads the channel listings
             * @memberOf tve/mgr/sLinearManager#
             */
            getChannelListingDsByDate: function (date) {
                date = date || new Date();

                var ds = new LocalDatasource(),
                    opts = opts || {},
                    dataLoader = function() {
                        return serviceHolder.getLinearContentService().getAllTVListings(date.setHours(0,0,0,0), date.setHours(23,59,59,999)).then(function(transport) {
                            if (transport.totalCount) {
                                return {
                                    total: transport.totalCount,
                                    data: transport.entries
                                };
                            }

                            throw new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INTERNAL, "The data format is unexpected.");
                        });
                    };

                ds.setDataLoader(dataLoader);
                return ds;
            },

            /**
             * Get a ChannelListingDatasource object for a specific range of channels, to display the channel listing for those channels.
             * (This method is added in product demo.)
             * @method
             * @param {String[]} [channelIds] The channel IDs. All available channel will be used if not supplied.
             * @returns {Promise.<tvedemo/ext/ui/programguide/ChannelListingDatasource>} the data source for the channel listings
             * @throws {Promise.<TVEError>} if ChannelListingDatasource cannot be loaded
             * @memberOf tve/mgr/sLinearManager#
             */
            getProgramGuideDatasource: function (channelIds) {
                var deferred = promise.defer();

                channelIds = channelIds || null;

                require(["tvedemo/ext/ui/programguide/ChannelListingDatasource"], function (ChannelListingDatasource) {
                    deferred.resolve(new ChannelListingDatasource(channelIds));
                }, function (reason) {
                    deferred.reject(new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INTERNAL, "ChannelListingDatasource cannot be loaded"));
                });

                return deferred.promise;
            },

            /**
             * Get the corresponding VOD asset of a program if applicable.
             * (This method is added in product demo.)
             * @method
             * @param {tve/model/Program} program The program to query
             * @returns {Promise.<tve/model/Asset} the VOD asset associated to the program
             * @throws {tve/TVEError} if the query fail
             * @memberOf tve/mgr/sLinearManager#
             */
            getVODAsset: function (program) {
                var metadata = program.get("metadata"),
                    type = metadata.VOD$type;

                switch (type) {
                case "movie":
                    return sVODManager.getMovieById(metadata.VOD$movie);
                case "episode":
                    return sVODManager.getEpisodeById(metadata.VOD$episode);
                default:
                    return promise.reject(new TVEError(FACILITY.LINEAR_MANAGER, ERROR.INTERNAL, "No associated VOD asset"));
                }
            },

            getCurrentlyRunningEvents: function() {
                return linearContentService.getCurrentlyRunningEvents().then(function (datalist) {
                    return sAppConfigManager.getPermittedLinearChannels().then(function (permittedChannelsArray) {
                        var permittedChannelsArrayAsString = "|" + permittedChannelsArray.join("|") + "|";

                        // Filter out 'currently running' items, according to SKYSTORM-250.
                        datalist = datalist.filter(function (data) {
                            try {
                                var isPermitted = (permittedChannelsArrayAsString.indexOf("|" + data.channel.id + "|") !== -1);

                                if (isPermitted && !data.event.epgBlackout && util.isString(data.channel.mediaurl) && (data.channel.mediaurl.length > 4)) {
                                    // Sky think of a channel with such a mediaurl as 'streamable'...
                                    return true;
                                } else {
                                    // For non-streamed (or non-permitted, or blacked out) channels, only show items that appear to have some associated VOD...
                                    if (!util.isUndefined(data.event.assetid) && (data.event.assetid > 0)) {
                                        return true;
                                    } else {
                                        return false;
                                    }
                                }
                            } catch (e) {
                                // Exclude anything that can't be inspected successfully (eg AppGrid points to wrong type of back end).
                                console.warn("Filtering out an event that can't be inspected successfully: " + e);
                                return false;
                            }
                        });
                        return datalist;
                    });
                });
            },

            getAssetListing: function(path) {
                if (!path || !path.length) {
                    console.error("path is empty");
                    return promise.reject("path is empty");
                }
                return linearContentService.getAssetList(path);
            },

            getLetterHeaderListing: function(path) {
                if (!path || !path.length) {
                    console.error("path is empty");
                    return promise.reject("path is empty");
                }
                return linearContentService.getLetterList(path);
            },

            constructCMSUrlPromise: function(path) {
                if (!path || !path.length) {
                    return promise.resolve("");
                }
                return linearContentService.acquireCMSRoot().then(function (root) {
                    return root + path;
                });
            },

            /**
             * Retrieve a  list of sport news for a spcified sport news category.
             * @param  {Number} categoryId                  Id of the sport new category to retrieve.
             * @return {Promise<tvedemo/model/NewsAsset[]}  List of news for the category.
             */
            getSportNewsAssetsByCategory: function (categoryId) {
                return linearContentService.getSportNewsByCategory(categoryId).then(util.bind(function (sportNews) {
                    var sportNewsList = sportNews && sportNews.listing && sportNews.listing.listing && sportNews.listing.listing.item;

                    sportNewsList = __parser.parseSportNewsList(sportNewsList);

                    return sportNewsList;
                }, this));
            },

            /**
             * Get search results.
             * @method getSearchResults
             * @param {String}  [searchKey] search key
             * @param {string} [catalog] asset catalog (sg, sn, web)
             * @memberof tvedemo/mgr/sLinearManager
             */
            getSearchResults: function(searchKey, catalog){
                if (!searchKey || !searchKey.length) {
                    console.error("empty keyword!");
                    return promise.reject("empty keyword!");
                }
                new TrackingManager().trackSearch(searchKey);
                return linearContentService.searchFor(searchKey, {
                    catalog: catalog
                });
            }
        });

    return new LinearManager();
});

define('css!tvedemo/wgt/css/AssetButton',[],function(){});
/**
 * AssetButton is a widget that represent an asset by showing the asset thumbnail. A typical usage of this class would be showing an array of assets in a collection view.
 * The asset button consists of a container, which is corresponding to show the metadata of the asset.
 *
 * @name AssetButton
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/AssetButton
 * @extends ax/ext/ui/Container
 */
define("tvedemo/wgt/AssetButton", [
    "xdk-base/class", "xdk-base/core", "xdk-ax/Container", 
    "xdk-ui-basic/Image", "xdk-ui-basic/Label",
    "xdk-base/util", "xdk-ax/Component",
    "tvedemo/helper/sMoment", "xdk-ax/evt/type",
    "tve/model/Resource", "tve/model/Asset", "tvedemo/wgt/ChannelLogo", 
    "tve/model/Episode", "tve/model/TVShow", "tve/model/TVChannel",
    "xdk-base/console", "tve/mgr/sVODManager", "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sAssetManager",
    "tve/mgr/sLinearManager",
    "xdk-base/promise",
    "css!./css/AssetButton"
], function(klass, core, Container, 
                Image, Label,
                util, Component,
                moment, evtType,
                ImageModel, Asset, ChannelLogo,
                Episode, TVShow, TVChannel,
                console, sVODManager, sEndUserManager,
                sAssetManager,
                sLinearManager,
                promise) {

    "use strict";

    var TRANSPARENT_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAA1JREFUCNdjYGBgMAYAADgANNF/knAAAAAASUVORK5CYII=",
        TV_SHOW_PLACE_HOLDER_IMAGE = "img/placeholders/show_placeholder.png",
        MOVIE_PLACE_HOLDER_IMAGE = "img/placeholders/movie_placeholder.png",
        ASSET_TYPE = {
            EPISODE: "episode",
            MOVIE: "movie",
            TV_SHOW: "tvShow",
            PROGRAM: "program",
            TV_CHANNEL: "tvChannel"
        },

        getAssetType = function (asset) {
            var type = ASSET_TYPE.MOVIE;

            if (asset instanceof Episode) {
                type = ASSET_TYPE.EPISODE;
            } else if (asset instanceof TVShow) {
                type = ASSET_TYPE.TV_SHOW;
            } else if (asset instanceof TVChannel) {
                type = ASSET_TYPE.TV_CHANNEL;
            }

            return type;
        };

    return klass.create(Container, {}, {
        _asset: null,
        __title: "",

        _thumbnailImage: null,
        _labelContainer: null,
        _titleLabel: null,
        _thumbnail: null,
        _showEpisodeNumber: false,
        _showPrice: false,
        _showExpiry: false,

        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} opts Options
         * @param {Media} opts.asset The media asset
         * @param {Boolean} [opts.transition=true] Opacity transition when display the button
         * @param {Boolean} [opts.showEpisodeNumber=false] Define if the episode number should be shown, if applicable
         * @param {Boolean} [opts.showPrice=false] Define if the asset price should be shown, if applicable
         * @param {Boolean} [opts.showExpiry=false] Define if the expiry of the asset should be shown, if applicable
         * @param {Boolean} [opts.icon=false] Show the icon above the button
         * @memberof tvedemo/wgt/AssetButton#
         */
        init: function (opts) {
            if (!opts.asset || !opts.asset instanceof Asset) {
                throw core.createException("IncorrectParam", "opts.asset must be an instance of tve/model/Asset.");
            }

            opts.focusable = true;
            opts.clickable = true;

            this._super(opts);
            this.addClass("wgt-assetbtn");

            this._asset = opts.asset;
            this.__title = this._asset.get("title");
            this.__assetType = getAssetType(this._asset);

            this._showEpisodeNumber = opts.showEpisodeNumber || false;
            this._showSeasonNumber = opts.showSeasonNumber || false;
            this._showPrice = opts.showPrice || false;
            this._showExpiry = opts.showExpiry || false;
            this._icon = opts.icon || false;
            this._transition = opts.transition || true;

            this._labelContainer = new Container({
                css: "wgt-assetbtn-container"
            });

            if (this._transition) {
                this.addClass("transparent");
                this.__attachedToDom = util.defer().then(util.bind(function () {
                    this.removeClass("transparent");

                    this.removeEventListener(evtType.ATTACHED_TO_DOM, this.__attachedToDom);
                }, this));

                this.addEventListener(evtType.ATTACHED_TO_DOM, this.__attachedToDom);
            }

            if (this.__assetType === ASSET_TYPE.TV_CHANNEL) {
                this._thumbnailImage = new ChannelLogo({
                    css: "wgt-assetbtn-thumbnail",
                    src: TRANSPARENT_IMAGE
                });
            } else {
                this._thumbnailImage = new Image({
                    css: "wgt-assetbtn-thumbnail",
                    src: TRANSPARENT_IMAGE
                });
            }

            this._getThumbnail();

            this.attach(this._thumbnailImage);
            this.attach(this._labelContainer);

            this._setupContainer();
        },

        /**
         * Get the image that is decided to be the thumbnail, from the asset.
         * @method
         * @protected
         * @param {Media} asset The media object
         * @memberof tvedemo/wgt/AssetButton#
         */
        _getThumbnail: function () {
            sAssetManager.getStormAssetDvdCover(this._asset).fail(util.bind(function (reason) {
                console.warn("[AssetButton] failed to get thumbnail for " + this._asset.get("title") + ": " + reason);
                return this._getPlaceholder();
            }, this)).then(util.bind(function (src) {
                this._thumbnail = src;
                this._thumbnailImage.setSrc(this._thumbnail);
            }, this)).done();
        },

        /**
         * Get the placeholder image, depends on Asset Type.
         * @method
         * @protected
         * @returns {String} the source of the image.
         * @memberof tvedemo/wgt/AssetButton#
         */
        _getPlaceholder: function () {
            var placeHolderSrc;

            switch(this.__assetType) {
            case ASSET_TYPE.TV_SHOW: // intended
            case ASSET_TYPE.EPISODE:
                placeHolderSrc = TV_SHOW_PLACE_HOLDER_IMAGE;
                break;
            case ASSET_TYPE.MOVIE:
                placeHolderSrc = MOVIE_PLACE_HOLDER_IMAGE;
                break;
            default:
                placeHolderSrc = TRANSPARENT_IMAGE;
                break;
            }

            return placeHolderSrc;
        },

        /**
         * Set up the container.
         * This function put the asset title to the container through a Label.
         * @method
         * @protected
         * @memberof tvedemo/wgt/AssetButton#
         */
        _setupContainer: function () {
            // episode number
            if (this._showEpisodeNumber && this.__assetType === ASSET_TYPE.EPISODE) {
                var episode = this._asset.get("episodeNumber");

                if (episode) {
                    new Label({
                        css: "wgt-assetbtn-episode",
                        text: "Episode " + episode,
                        parent: this._labelContainer
                    });
                }
            }

            // title
            this._titleLabel = new Label({
                css: "wgt-assetbtn-title",
                text: this.__title,
                parent: this._labelContainer
            });

            // season number
            if (this._showSeasonNumber && this.__assetType === ASSET_TYPE.TV_SHOW) {
                this._setUpSeasonNumberLabel();
            }


            // icon
            if (this._icon) {
                new Component({
                    css: "wgt-assetbtn-icon",
                    parent: this
                });
            }
        },

        _setUpSeasonNumberLabel: function () {
            var seasonLabel,
                seasonIds,
                i,
                len,
                seasonPromises,
                latestSeason,
                latestSeasonNumber,
                container = this._labelContainer;

            seasonIds = this._asset.get("seasonIds");
            len = seasonIds.length;

            if (len > 0) {
                seasonLabel = new Label({
                    css: "wgt-assetbtn-season",
                    text: "",
                    parent: this._labelContainer
                });

                seasonPromises = [];
                for (i = 0; i < len; i++) {
                    seasonPromises.push(sVODManager.getTVSeasonById(seasonIds[i]));
                }

                promise.all(seasonPromises).then(function (seasons) {
                    len = seasons.length;
                    latestSeason = seasons[0];
                    latestSeasonNumber = latestSeason.get("seasonNumber") || 0;

                    if (latestSeason) {
                        for (i = 1; i < len; i++) {
                            if (seasons[i].get("seasonNumber") > latestSeasonNumber) {
                                latestSeason = seasons[i];
                                latestSeasonNumber = latestSeason.get("seasonNumber");
                            }
                        }

                        seasonLabel.setText("Season " + latestSeasonNumber);
                        container.addClass("with-season");
                    }
                });
            }
        }
    });
});

/**
 * AssetGrid is a widget that displays a grid of AssetButtons. The edge arrows are handles internally as well.
 *
 * @name AssetGrid
 * @class tvedemo/wgt/AssetGrid
 * @extends tvedemo/wgt/BasicGrid
 */
define("tvedemo/wgt/AssetGrid", [
    "xdk-base/class", "tvedemo/wgt/BasicGrid", "tvedemo/wgt/AssetButton", "xdk-base/util"
], function (klass, BasicGrid, AssetButton, util) {

    return klass.create(BasicGrid, {}, {

        //The image widgets to indicate the scrolling state.
        _arrows: [],

        //The alignment of the grid.
        _alignment: 0,

        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} opts Options
         * @param {String} [opts.buttonOpts=true] set the option for the asset button created inside the grid. {@link  tvedemo/wgt/AssetButton}
         * @memberof tvedemo/wgt/AssetGrid#
         */
        init: function (opts) {
            this._super(opts);

            this.addClass("wgt-assetgrid");

            this.setButton(opts.button);
        },

        /**
         * Override the function to update the arrows button after the original setDatasource() functions finished.
         * @method
         * @Override
         * @param {ax/af/data/Datasource} ds datasource to set
         * @public
         * @memberof tvedemo/wgt/AssetGrid#
         */
        setDatasource: function (ds) {
            return this._super(ds).then(util.bind(this._updateArrows, this));
        },

        /**
         * Set the key of the thumbnail, which should appear in the metadata.
         * @method setButton
         * @public
         * @param {String} opts The image key for AssetButtons {@link  tvedemo/wgt/AssetButton}
         * @memberof tvedemo/wgt/AssetGrid#
         */
        setButton: function (opts) {
            this.setDisplayStgy(function (asset) {
                var option = {
                    css: "wgt-assetbutton",
                    asset: asset
                };

                //extend the options
                if (opts) {
                    option = util.extend(option, opts);
                }

                return new AssetButton(option);
            });
        }
    });
});

/**
 * Epg event details view's template
 * @name epgEvent
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/epgEvent
 */
define("tvedemo/tmpl/epgEvent", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "storm/wgt/Image",
    "xdk-ax/Container",
    "xdk-ui-basic/Button",
    "tvedemo/wgt/AssetGrid",
    "tvedemo/wgt/ScrollLabel",
    "tvedemo/wgt/ImageButton",
    "storm/mgr/sAppConfigManager"
], function (
    Layout,
    Label,
    Image,
    Container,
    Button,
    AssetGrid,
    ScrollLabel,
    ImageButton,
    sAppConfigManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#epgEvent",
            children: [{
                klass: Layout,
                alignment: Layout.VERTICAL,
                children: [{
                    klass: Layout,
                    id: "#upContainer",
                    children: [{
                        klass: Image,
                        id: "#thumbnail",
                        placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                    }, {
                        klass: Layout,
                        id: "#blackoutMessageContainer",
                        children: [{
                            klass: Label,
                            id: "#blackoutMessage"
                        }]
                    }, {
                        klass: Container,
                        css: "informationContainer",
                        children: [{
                            klass: Label,
                            id: "#title"
                        }, {
                            klass: Layout,
                            id: "#metaDataContainer",
                            alignment: Layout.HORIZONTAL
                        }, {
                            klass: Image,
                            id: "#channelLogo"
                        }, {
                            klass: Container,
                            id: "missingPackage",
                            css: "missingPackage",
                            children: [{
                                klass: Image,
                                id: "missingPackageLogo",
                                css: "missingPackageLogo"
                            }, {
                                klass: Label,
                                id: "missingPackageText",
                                css: "missingPackageText"
                            }]
                        }]
                    }]
                }, {
                    klass: Layout,
                    alignment: Layout.HORIZONTAL,
                    id: "#videoButtonContainer",
                    children: [{
                        klass: ImageButton,
                        id: "epgEventTuneIn",
                        text: "",
                        nextRight: "detailDescription"
                    },{
                        klass: ImageButton,
                        id: "epgEventStartVod",
                        text: "",
                        nextRight: "detailDescription",
                        nextLeft: "epgEventStartVod"
                    }, {
                        klass: ImageButton,
                        id: "epgEventWatchTrailer",
                        text: "",
                        nextLeft: "epgEventWatchTrailer",
                        nextRight: "detailDescription"
                    }, {
                        klass: ImageButton,
                        id: "addToWatchlist",
                        text: "",
                        nextRight: "detailDescription",
                        nextLeft: "addToWatchlist"
                    }]
                }, {
                    klass: ScrollLabel,
                    id: "detailDescription",
                    scrollStep: 72,
                    nextLeft: "videoButtonContainer",
                    nextUp: "header",
                    nextDown: "detailDescription"
                }]
            }]
        };
    };
});
/**
 * The custom button used in footer.
 * @name FooterButton
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/FooterButton
 * @extends ax/ext/ui/Layout
 */
define("tvedemo/wgt/FooterButton", [
    "xdk-base/class", "xdk-base/util", "xdk-ui-basic/Layout",
    "xdk-base/Element", "xdk-ui-basic/Image", "xdk-ui-basic/Label"
], function (klass, util, Layout,
    Element, Img, Label) {

    return klass.create(Layout, {}, {
        /**
         * The internal label widget to show button text
         * @protected
         * @name _label
         * @memberof tvedemo/wgt/FooterButton#
         */
        _label: null,
        /**
         * The internal image widget to show button icon
         * @protected
         * @name _icon
         * @memberof tvedemo/wgt/FooterButton#
         */
        _icon: null,

        /**
         * override parent"s init() method
         * @method
         * @memberof tvedemo/wgt/FooterButton#
         * @protected
         */

        init: function (opts) {
            opts.focusable = opts.focusable || false;
            opts.clickable = false;
            opts.children = [];

            //only create the image icon when providing enough information
            if (opts.icon) {
                this._icon = new Img({
                    src: opts.icon
                });
                opts.children.push(this._icon);
            }

            this._label = new Label({
                text: opts.text || "",
                isPureText: opts.isPureText || false
            });

            opts.children.push(this._label);

            this._super(opts);
            this.getRoot().addClass("footer-button");

        },

        setText: function (text, isPureText) {
            this._label.setText(text, isPureText);
        }
    });
});
/**
 * The footer widget, providing to feature
 *
 * 1. Rendering the layout out the footer, allow dynamic hide and show of hints
 * 2. isCaptureKey function - to check if the key mapped to the footer is enabled, therefore should be captured. Actual
 *    integration in done within Main.
 * 3. update - to enable and show the hints, missing items will be hidden
 *
 * @name Footer
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/Footer
 * @extends ax/ext/ui/Layout
 */

define("tvedemo/wgt/Footer", [
    "xdk-base/class", "xdk-ui-basic/Layout", "xdk-base/util",
    "xdk-ui-basic/Image", "tvedemo/wgt/FooterButton", "xdk-ax/evt/type",
    "xdk-base/device", "xdk-base/device/vKey"
], function (klass, Layout, util,
    Img, FooterButton, evtType,
    device, vKey) {

    return klass.create(Layout, {}, {
        // e.g. use tvedemo/wgt/FooterIconSet.DEFAULT
        _iconSet: null,
        _buttons: {},
        // all buttons disabled by default
        _enabled: [],

        init: function (opts) {
            opts = opts || {};

            if (opts.iconSet) {
                this._iconSet = opts.iconSet;
            } else {
                throw new Error("icon set not defined");
            }

            var btnTextMap = opts.btnTextMap || {};

            this._createBtns();
            this.update(btnTextMap);

            opts.children = util.values(this._buttons);

            this._super(opts);

        },

        _createBtns: function () {
            // init and setup (if any text is provided)
            util.each(this._iconSet.keys, util.bind(function (pair) {
                var key = pair.key,
                    iconImg = null;
                //some button may not have the icon
                if (this._iconSet.imgs[key]) {
                    iconImg = "img/nav_bar/" + this._iconSet.imgs[key] + ".png";
                }
                this._buttons[key] = new FooterButton({
                    icon: iconImg,
                    text: ""
                });
                this._buttons[key].hide();

            }, this));
        },

        isCaptureKey: function (keyEvt) {

            var found = false;

            util.each(this._enabled, util.bind(function (key) {

                if (util.indexOf(this._iconSet.keys[key], keyEvt.id) > -1) {
                    found = true;
                    return util.breaker;
                }

            }, this));

            return found;
        },

        update: function (btnTextMap) {

            //reset the enabled list
            this._enabled = [];

            util.each(this._iconSet.keys, util.bind(function (pair) {
                var key = pair.key,
                    btn = this._buttons[key],
                    btnText = btnTextMap[key];

                btn.hide();

                if (btnText) {
                    btn.setText(btnText);
                    btn.show();
                    //push into enabled list
                    this._enabled.push(key);
                }

            }, this));
        }
    });
});
/**
 * Some configuration for footer
 * @name FooterIconMap
 * @memberof tvedemo/wgt
 * @moudule tvedemo/wgt/FooterIconMap
 * @extends ax/ext/ui/Layout
 */
define("tvedemo/wgt/FooterIconMap", ["xdk-base/device","xdk-base/device/vKey"], function (device, vKey) {

    var footerMapping = {

        DEFAULT: {

            keys: {
                colorRed: [vKey.RED.id],
                colorGreen: [vKey.GREEN.id],
                colorYellow: [vKey.YELLOW.id],
                colorBlue: [vKey.BLUE.id],
                // Switched the order of playPause and prevNext based on fullscreen footer.
                playPause: [vKey.PLAY.id, vKey.PAUSE.id, vKey.PLAY_PAUSE.id, vKey.STOP.id, vKey.FF.id, vKey.RW.id],
                controls: [vKey.PLAY.id, vKey.PAUSE.id, vKey.STOP.id, vKey.RW.id, vKey.FF.id],
                liveControls: [vKey.STOP.id],
                // add P and N keys for simulation on workstation
                prevNext: [vKey.PREV.id, vKey.NEXT.id, "device:kb-vkey:p", "device:kb-vkey:n", vKey.FF.id, vKey.RW.id],
                // direct mapping to samsung id string to avoid AMD dependency issue
                // add M key for simmulation on workstation
                menu: ["samsung:vkey:tools", "device:kb-vkey:m"],
                arrowAll: [vKey.UP.id, vKey.DOWN.id, vKey.LEFT.id, vKey.RIGHT.id],
                arrowUpDown: [vKey.UP.id, vKey.DOWN.id],
                arrowLeftRight: [vKey.LEFT.id, vKey.RIGHT.id],
                num: [
                    vKey.KEY_0.id, vKey.KEY_1.id, vKey.KEY_2.id,
                    vKey.KEY_3.id, vKey.KEY_4.id, vKey.KEY_5.id,
                    vKey.KEY_6.id, vKey.KEY_7.id, vKey.KEY_8.id, vKey.KEY_9.id
                ],
                enter: [vKey.OK.id],
                back: [vKey.BACK.id],
                exit: [vKey.EXIT.id]
            },

            imgs: {
                colorRed: "red",
                colorGreen: "green",
                colorBlue: "blue",
                colorYellow: "yellow",
                prevNext: "prev_next",
                playPause: "video_control",
                menu: "top",
                arrowAll: "move",
                arrowUpDown: "up_down",
                arrowLeftRight: "left_right",
                num: "num",
                enter: "enter",
                back: "back",
                exit: "exit",
                controls: "fs-controls",
                liveControls: "fs-live-controls"
            }
        },

        ALERT: {
            keys: {
                enter: [vKey.OK.id],
                back: [vKey.BACK.id]
            },
            imgs: {
                enter: "enter",
                back: "back"
            }
        },

        CONFIRM: {
            keys: {
                enter: [vKey.OK.id],
                back: [vKey.BACK.id]
            },
            imgs: {
                enter: "enter",
                back: "back"
            }
        },

        DIALOG: {
            keys: {
                arrowAll: [vKey.UP.id, vKey.DOWN.id, vKey.LEFT.id, vKey.RIGHT.id],
                arrowUpDown: [vKey.UP.id, vKey.DOWN.id],
                arrowLeftRight: [vKey.LEFT.id, vKey.RIGHT.id],
                enter: [vKey.OK.id],
                back: [vKey.BACK.id]
            },
            imgs: {
                arrowAll: "move",
                arrowUpDown: "up_down",
                arrowLeftRight: "left_right",
                enter: "enter",
                back: "back"
            }
        },

        SORT: {
            keys: {
                enter: [vKey.OK.id],
                back: [vKey.BACK.id]
            },
            imgs: {
                enter: "enter",
                back: "back"
            }
        }

    };

    // Change DEFAULT if platform is playstation since it does not contains all the samsung/lg buttons.
    if (device.platform === "playstation") {
        footerMapping = {

            DEFAULT: {
                keys: {
                    colorYellow: ["playstation:vkey:triangle"],
                    arrowLeftRight: [vKey.LEFT.id, vKey.RIGHT.id],
                    enter: [vKey.OK.id],
                    back: [vKey.BACK.id]
                },

                imgs: {
                    colorYellow: "triangle",
                    arrowLeftRight: "left_right",
                    enter: "cross",
                    back: "circle"
                }
            },

            ALERT: {
                keys: {
                    enter: [vKey.OK.id],
                    back: [vKey.BACK.id]
                },
                imgs: {
                    enter: "cross",
                    back: "circle"
                }
            },

            CONFIRM: {
                keys: {
                    enter: [vKey.OK.id],
                    back: [vKey.BACK.id]
                },
                imgs: {
                    enter: "cross",
                    back: "circle"
                }
            },

            DIALOG: {
                keys: {
                    arrowAll: [vKey.UP.id, vKey.DOWN.id, vKey.LEFT.id, vKey.RIGHT.id],
                    arrowUpDown: [vKey.UP.id, vKey.DOWN.id],
                    arrowLeftRight: [vKey.LEFT.id, vKey.RIGHT.id],
                    enter: [vKey.OK.id],
                    back: [vKey.BACK.id]
                },
                imgs: {
                    arrowAll: "move",
                    arrowUpDown: "up_down",
                    arrowLeftRight: "left_right",
                    enter: "cross",
                    back: "circle"
                }
            },

            SORT: {
                keys: {
                    enter: [vKey.OK.id],
                    back: [vKey.BACK.id]
                },
                imgs: {
                    enter: "enter",
                    back: "back"
                }
            }
        };
    }

    return footerMapping;
});
define("xdk-ui-grid/ScrollingGrid", ["xdk-base/class","xdk-ui-grid/Grid","xdk-ui-grid/gridStgy","xdk-base/util","css!./css/Grid"], function (klass, Grid, gridStgy, util) {

    "use strict";
    return klass.create(Grid, {}, {
                init: function (opts) {
            this._super(opts);

            var isVerticalAlign = opts.alignment === Grid.VERTICAL;

            this.setPrereadyStgy(gridStgy.BASIC_PREREADY_STGY);
            this.setCheckScrollableStgy(gridStgy.BASIC_CHECK_SCROLLABLE_STGY);
            this.setCheckSelectableStgy(gridStgy.BASIC_CHECK_SELECTABLE_STGY);
            this.setDataMappingStgy(gridStgy.BASIC_DATA_MAPPING_STGY);

            this.setScrollEntranceStgy(util.bind(gridStgy.BASIC_SCROLL_ENTRANCE_STGY, this, isVerticalAlign));

            this.setScrollShiftStgy(gridStgy.BASIC_SCROLL_SHIFT_STGY);
            this.setScrollExitStgy(gridStgy.BASIC_SCROLL_EXIT_STGY);

            this.setOnUpdateStgy(gridStgy.BASIC_ONUPDATE_STGY);

            this.setKeyNavigationStgy(
                isVerticalAlign ? gridStgy.BASIC_VERTICAL_KEY_NAVIGATION_STGY : gridStgy.BASIC_HORIZONTAL_KEY_NAVIGATION_STGY);

            this.setDsRangeCalculationStgy(gridStgy.BASIC_DS_RANGE_CALCULATION_STGY);
        }
    });
});
/**
 * TextSelectionList is a widget that displays a list of options and allows the user to select among them.
 * A valid data object in the data source should at least consist of a *text* property (for display purpose).
 * @name TextSelectionList
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/TextSelectionList
 * @extends ax/ext/ui/ScrollingGrid
 */
define("tvedemo/wgt/TextSelectionList",
[
    "xdk-base/class",
    "xdk-ui-grid/ScrollingGrid",
    "xdk-ui-basic/Button"
], function (
    klass,
    Grid,
    Button
    ) {

    "use strict";

    var FIXED_COLS = 1,
        DEFAULT_ROWS = 5;

    return klass.create(Grid, {}, {
        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} opts Options
         * @param {int} rows The number of rows of the list
         * @memberof tvedemo/wgt/TextSelectionList#
         */
        init: function (opts) {
            opts.rows = opts.rows || DEFAULT_ROWS;
            opts.cols = FIXED_COLS;
            opts.forwardFocus = true;
            opts.alignment = Grid.HORIZONTAL;

            this._super(opts);
            this.addClass("wgt-selectionlist");

            this.setDisplayStgy(function (option) {
                var ret = new Button({
                    css: "wgt-selectionlist-option",
                    text: option.text
                });

                return ret;
            });
        },

        getSelectionState: function() {
            return {
                row: this._selectedGridRow,
                col: this._selectedGridCol,
                canScrollForward: this.getDatasource().getTotalCount() - this._firstSlotDsIndex > this._rows,
                canScrollBackward: this._firstSlotDsIndex !== 0
            };
        }
    });
});

/**
 * TextSelectionListDialog is a dialog that maintain a {@link tvedemo/wgt/TextSelectionList} inside it, allowing the user to select an item from the list.
 * The arrows which indicate the scrolling availability are handled by the dialog.
 *
 * @name TextSelectionListDialog
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/TextSelectionListDialog
 */
define("tvedemo/wgt/TextSelectionListDialog", [
    "xdk-base/class", "fix/Dialog", "xdk-base/util", "xdk-ax/Container",
    "tvedemo/wgt/Footer", "tvedemo/wgt/FooterIconMap", "tvedemo/wgt/TextSelectionList",
    "storm/helper/util", "xdk-ui-basic/Label", "xdk-ui-basic/Image",
    "xdk-ax/focusManager", "xdk-ax/evt/type"
], function (klass, Dialog, util, Container,
    Footer, FooterIconMap, TextSelectionList,
    helperUtil, Label, Image,
    focusManager, evtType) {

    return klass.create(Dialog, {
        EVT_SELECTED: "evt:selected"
    }, {
        init: function (opts) {

            opts = opts || {};
            opts.items = opts.items || [];
            opts.size = opts.size || 5;
            opts.headerText = opts.headerText || "Sort by";
            opts.footerIcon = opts.footerIcon || {
                arrowUpDown: "Move",
                enter: "Select",
                back: "Back"
            };

            //handle the header
            opts.header = this._createHeader(opts);

            //handle the content
            opts.content = this._createContent(opts);

            //handle the footer
            opts.footer = this._createFooter(opts);

            this._super(opts);

            this.setOption("forwardFocus", "list");
            this.addClass("wgt-textselection-dialog");
        },
        _createHeader: function (opts) {
            return new Container({
                css: "header-container",
                children: [
                    new Label({
                        css: "header-text",
                        text: opts.headerText
                    }),
                    new Image({
                        css: "header-line",
                        src: "img/popup_date_sortby/divider.png"
                    })
                ]
            });
        },
        /**
         * Create the list displayed inside the dialog as the main content.
         * @method
         * @protected
         * @param {Object} opts The init options
         * @returns {ax/ext/ui/Grid} a nx1 (single column) grid
         */
        _createList: function (opts) {
            return new TextSelectionList({
                id: "list",
                rows: opts.size
            });
        },
        _createContent: function (opts) {
            var upArrow, downArrow,
                ds = helperUtil.arrayToDs(opts.items),
                list = this._createList(opts);

            list.setDatasource(ds).then(function () {
                focusManager.focus(list);
            });

            list.addEventListener(evtType.CLICK, util.bind(function () {
                this.dispatchEvent(this.constructor.EVT_SELECTED, list.getSelectedDsIndex());
            }, this));

            upArrow = new Image({
                css: "arrow_up",
                src: "img/arrow_up.png"
            });

            downArrow = new Image({
                css: "arrow_down",
                src: "img/arrow_down.png"
            });

            list.addEventListener(evtType.SELECTION_CHANGED, function (evt) {
                var state = list.getSelectionState();

                if (state.canScrollForward) {
                    downArrow.enable();
                } else {
                    downArrow.disable();
                }

                if (state.canScrollBackward) {
                    upArrow.enable();
                } else {
                    upArrow.disable();
                }
            });

            return new Container({
                css: "content-container",
                children: [upArrow, list, downArrow]
            });
        },
        _createFooter: function (opts) {
            var footer = new Footer({
                css: "footer",
                iconSet: FooterIconMap.SORT
            });

            // set footer
            footer.update(opts.footerIcon);

            return new Container({
                css: "footer-container",
                children: [
                    new Image({
                        css: "footer-line",
                        src: "img/popup_date_sortby/divider.png"
                    }),
                    footer
                ]
            });
        },
        open: function () {
            this._super();
            //since it won't store the lastFocus in the dialog when there is no button. So save the lastFocus here
            this._lastFocus = focusManager.getCurFocus();
        },
        close: function () {
            this._super();
            //since close mean deinit everything, so try to remove EventListener by this
            this.deinit();
        }
    });
});
/**
 * Serie episode details view's template
 * @name episode
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/episode
 */
define("tvedemo/tmpl/episode", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "storm/wgt/Image",
    "xdk-ax/Container",
    "xdk-ui-basic/Button",
    "tvedemo/wgt/AssetGrid",
    "tvedemo/wgt/ScrollLabel",
    "tvedemo/wgt/ImageButton",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sAppConfigManager"
], function (
    Layout,
    Label,
    Image,
    Container,
    Button,
    AssetGrid,
    ScrollLabel,
    ImageButton,
    sLanguageManager,
    sAppConfigManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#episode",
            children: [{
                klass: Layout,
                alignment: Layout.VERTICAL,
                children: [{
                    klass: Layout,
                    id: "#upContainer",
                    children: [{
                        klass: Image,
                        id: "#thumbnail",
                        placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                    }, {
                        klass: Layout,
                        id: "#blackoutMessageContainer",
                        children: [{
                            klass: Label,
                            id: "#blackoutMessage"
                        }]
                    }, {
                        klass: Container,
                        css: "informationContainer",
                        children: [{
                            klass: Label,
                            id: "#title"
                        }, {
                            klass: Layout,
                            id: "#metaDataContainer",
                            alignment: Layout.HORIZONTAL
                        }, {
                            klass: Image,
                            id: "#channelLogo"
                        }, {
                            klass: Container,
                            id: "missingPackage",
                            css: "missingPackage",
                            children: [{
                                klass: Image,
                                id: "missingPackageLogo",
                                css: "missingPackageLogo"
                            }, {
                                klass: Label,
                                id: "missingPackageText",
                                css: "missingPackageText"
                            }]
                        }]
                    }]
                }, {
                    klass: Layout,
                    alignment: Layout.HORIZONTAL,
                    id: "#videoButtonContainer",
                    children: [{
                        klass: ImageButton,
                        id: "episodeStartFromVod",
                        text: "",
                        nextRight: "detailDescription",
                        nextLeft: "episodeStartFromVod"
                    }, {
                        klass: ImageButton,
                        id: "episodeWatchTrailer",
                        text: "",
                        nextLeft: "episodeWatchTrailer",
                        nextRight: "detailDescription"
                    }, {
                        klass: ImageButton,
                        id: "addToWatchlist",
                        text: "",
                        nextRight: "detailDescription",
                        nextLeft: "addToWatchlist"
                    }]
                }, {
                    klass: Layout,
                    alignment: Layout.HORIZONTAL,
                    id: "#episodeSelectionButtonContainer",
                    children: [{
                        klass: ImageButton,
                        id: "viewAllEpisodes",
                        text: sLanguageManager.getString("DetailPage.DetailPage_labelAllEpisodes"),
                        nextUp: "addToWatchlist",
                        nextDown: "previousEpisode",
                        nextRight: "detailDescription",
                        nextLeft: "addToWatchlist"
                    }, {
                        klass: ImageButton,
                        id: "previousEpisode",
                        css: "previousEpisode",
                        text: "",
                        nextUp: "viewAllEpisodes",
                        nextDown: "nextEpisode",
                        nextRight: "nextEpisode",
                        nextLeft: "addToWatchlist"
                    }, {
                        klass: ImageButton,
                        id: "nextEpisode",
                        css: "nextEpisode",
                        text: "",
                        nextUp: "viewAllEpisodes",
                        nextDown: "nextEpisode",
                        nextRight: "detailDescription",
                        nextLeft: "previousEpisode"
                    }]
                }, {
                    klass: ScrollLabel,
                    id: "detailDescription",
                    scrollStep: 72,
                    nextLeft: "videoButtonContainer",
                    nextUp: "header",
                    nextDown: "detailDescription"
                }]
            }]
        };
    };
});
/**
 * Returns a singleton responsible for determining the physical location of the client.
 * @name sGeolocationManager
 * @memberof storm/mgr
 * @class storm/mgr/sGeolocationManager
 */
define("storm/mgr/sGeolocationManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "xdk-base/ajax",
    "storm/mgr/sAppConfigManager"
], function (
    klass,
    util,
    promise,
    console,
    ajax,
    sAppConfigManager
    ) {

    "use strict";

    /**
     * _parseResponseHeaders is based on https://gist.github.com/monsur/706839 @ 20th Oct 2014.
     */

    var _parseResponseHeaders = function(headerStr) {
            console.log("_parseResponseHeaders " + headerStr);
            var headers = {};
            if (headerStr) {
                try {
                    // Using unicode values throughout, to align with the formal specs.
                    var headerPairs = headerStr.split("\u000d\u000a");
                    for (var i = 0; i < headerPairs.length; i++) {
                        var headerPair = headerPairs[i];
                        // Using index rather than split() in case ': ' appears in a header value.
                        var index = headerPair.indexOf("\u003a\u0020");
                        if (index > 0) {
                            var key = headerPair.substring(0, index);
                            var val = headerPair.substring(index + 2);
                            headers[key] = val;
                        }
                    }
                } catch (e) {
                    console.warn("Problem parsing response headers: " + e);
                }
            }
            return headers;
        },

        GeolocationManager = klass.create({
    }, {
        getLocationCode: function() {
            if (!this._getLocationCodePromise) {
                this._getLocationCodePromise = sAppConfigManager.getGeolocationSettings().then(function (settings) {
                
                /*
                    THIS WHOLE BLOCK IS TEMPORARILLY REMOVED
                    ...due to the geolocation URL not being "managed by Sky" -> SDSLS-43
                    
                    var __opts = {
                        method: "get"
                    };

                    //
                    // Note use of 'raw' AJAX request, so that we gain access to the response header.
                    //
                    
                    var url = settings.get("root");
                    
                    // DEV:
                    var config      = amd.require("xdk-base/config");
                    var proxy       = config.get("dev.proxy");
                    var proxyHosts  = config.get("dev.proxyHosts");
                    if(proxy && proxyHosts.length) 
                    {
                        // If the url host matches one of the predefined proxy hosts we strip away the host part and let apache rewrite do the job
                        var proxyHost = null;
                        for (var i=0; i<proxyHosts.length; i++)
                        {
                            if (url.indexOf(proxyHosts[i]) > 0)
                            {
                                proxyHost = proxyHosts[i];
                                break;
                            }
                        }
                        if (proxyHost)
                        {
                            var proxyServer = config.get("dev.proxyPath");
                            url = proxyServer+encodeURIComponent(url);
                        }
                    }
                    //

                    return ajax.request(url, __opts).then(function (outcome) {
                        var responseHeaders = _parseResponseHeaders(outcome.getAllResponseHeaders()),
                            locationCode = responseHeaders.localization_code,
                            locationMapping = settings.get("mapping");

                        // On the test environment, at least, we're going to be scuppered if we can't lie about our location...

                        if (locationMapping && locationMapping.hasOwnProperty(locationCode)) {

                            //
                            // See AppGrid for a list of mappings currently active.
                            // For reference, at 10th October 2014 they are, for test environment:
                            //  GB -> DE
                            //  SE -> DE
                            //

                            locationCode = locationMapping[locationCode];
                        }
                        // DEV TMP:
                        locationCode = "DE";
                        return locationCode;
                    });
                    */
                    
                    var locationCode = "DE";
                    return locationCode;
                    
                }, function(problem){
                    console.warn("Trouble getting geo-location settings: " + problem);
                    // No need to propagate this failure more explicitly.
                });
            }

            return this._getLocationCodePromise;
        }

    });

    return new GeolocationManager();
});
/**
 * Returns a singleton responsible for verifying whether content is licenced for this device / connection / region.
 * Note that this is NOT closely related to DRM licensing, and is also NOT related to areas of the UI that list licensors.
 * @name sLicensingManager
 * @memberof storm/mgr
 * @class storm/mgr/sLicensingManager
 */
define("storm/mgr/sLicensingManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "tve/TVEError",
    "storm/helper/util",
    "storm/mgr/sEditorialManager",
    "storm/mgr/sGeolocationManager"
], function (
    klass,
    util,
    promise,
    console,
    TVEError,
    stormUtil,
    sEditorialManager,
    sGeolocationManager
    ) {

    "use strict";

    var DEVICE_TYPE = "IPAD",
        ALL_REGIONS_REGION = "ALL",

        LicensingManager = klass.create({}, {

            //
            // Pass in a description of the licenceScope.
            //
            // Receive a promise that's rejected if the licence conditions are not met, and resolved happily otherwise.
            //
            // Accepts both old and new styles of license scope description.
            //

            getContentLicence: function(licenseScope) {

                //
                // Sky's reply re SKYSTORM-210 c. 7th October confirms that for Storm on Smart TV:
                //  We ignore connection quality (3G, WIFI etc) when checking licensing
                //  We treat the Smart TV as being device type IPAD
                //  If no license data of any kind is presented, we assume the content can be played.
                //

                if (!licenseScope || licenseScope.length === 0) {
                    return promise.resolve("No licence scope means automatically licensed");
                }

                if (licenseScope.indexOf("&") !== -1) {
                    // The old (non 'eLicense') style is only for Sport clips, as far as we can tell.
                    // Implementation here is therefore not needed yet. See SKYSTORM-302,
                    return promise.reject("Old-style license scope descriptions not yet supported");
                }

                var licenseChunks = licenseScope.split(",");

                return sGeolocationManager.getLocationCode().then(function(locationCode) {
                    return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.PLATFORM_LICENSES).then(function (response) {
                        var licenseDescriptions = response.responseJSON,
                            matchingChunk;

                        //
                        // Here are some typical licenseDescriptions, mapped to chunk codes like 2B...
                        //      "2B": "ALL/3G/IPAD",
                        //      "32": "ALL/3G/IPHONE",
                        //      "3B": "DE/WIFI/IPAD",
                        //      "3E": "DE/WIFI/IPHONE",
                        //      "40": "DE/WIFI/STB",
                        //

                        util.each(licenseChunks, function (oneChunk) {
                            var oneDescription = licenseDescriptions[oneChunk];

                            if (oneDescription) {
                                var descriptionChunks = oneDescription.split("/");

                                // Is this chunk for a relevant region?

                                if ((descriptionChunks[0] === ALL_REGIONS_REGION) || (descriptionChunks[0] === locationCode)) {

                                    // Is this chunk for the right device?

                                    if (descriptionChunks[2] === DEVICE_TYPE) {
                                        matchingChunk = oneChunk;
                                        return util.each.breaker;
                                    }

                                }
                            }
                        });

                        if (matchingChunk) {
                            return promise.resolve("Licensed, thanks to matching chunk " + matchingChunk);
                        } else {
                            return promise.reject("Not licensed; no matching chunk found in " + licenseChunks);
                        }
                    });
                });
            }
        });

    return new LicensingManager();
});
/**
 * Module that returns an singleton EHUB data manager.
 * @name sEhubDataManager
 * @memberof storm/mgr
 * @module storm/mgr/sEhubDataManager
 * @author Mathias Pedersen<mathias.pedersen@.accedo.tv>
 */
define("storm/mgr/sEhubDataManager", [
    "xdk-base/ax",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/class",
    "xdk-base/promise",
    "tve/sServiceHolder",
    "tvedemo/helper/sMoment",
    "storm/mgr/sLanguageManager"
], function (
    ax,
    core,
    util,
    klass,
    promise,
    sServiceHolder,
    moment,
    sLanguageManager
    ) {

    "use strict";

    var linearContentService = sServiceHolder.getLinearContentService(),
        dateTimeService = sServiceHolder.getDateTimeService(),
        EhubDataManager = klass.create({}, {

            /**
             * Check if any program is currently running on the specified channel.
             * @param  {String} channelId   Id of the channel to check for any on air program.
             * @return {Promise<boolean>}   True if any program is currently on air on the channel, otherwise false.
             */
            checkIfChannelIsOnAir: function (channelId) {
                
                /*
                return linearContentService.onAirRequest([channelId]).then(function(result){
                    
                });
                */

                return dateTimeService.getServerDateTime().then(function (dateTime) {
                    var serverTime =  moment(dateTime).format(sLanguageManager.getString("ui.format.epgEventTime"));

                    return linearContentService.getChannelListingsByChannelIds([channelId], dateTime, dateTime).then(function (channelListing) {
                        var programs = channelListing && channelListing.entries && channelListing.entries[0] && channelListing.entries[0][channelId],
                            isOnAir = false;

                        util.each(programs, function (program) {

                            // This check may be unreliable at daylight-saving switchover.
                            if (program.startTime <= serverTime &&  serverTime < program.endTime) {
                                isOnAir = true;
                                return util.breaker;
                            }

                        });

                        return promise.resolve(isOnAir);
                    }, function () {

                        // If it is not possible to guarantee that any program is on,
                        // take the defensive approach and return that channel is not on air at the moment.
                        return promise.resolve(false);
                    });
                }, function () {

                    // If it is not possible to guarantee that any program is on,
                    // take the defensive approach and return that channel is not on air at the moment.
                    return promise.resolve(false);
                });
            }
        });

    return new EhubDataManager();
});
/**
 * Module that returns an singleton Live support manager.
 * This manager should be used to return information about supported features.
 * @name sLiveFeatureManager
 * @memberof storm/mgr
 * @module storm/mgr/sLiveFeatureManager
 * @author Markus Lysn<markus.lysen@accedo.tv>
 */
define("storm/mgr/sLiveFeatureManager", [
    "xdk-base/ax",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/class",
    "xdk-base/promise",
    "xdk-base/device",
    "storm/mgr/sAppConfigManager"
], function (
    ax,
    core,
    util,
    klass,
    promise,
    device,
    sAppConfigManager
    ) {

    "use strict";

    var ALL = "all";

    var LiveSupportManager = klass.create({}, {

            /**
            * There is a problem with live stream for samsung 2012 and 2013.
            * This function will check the current platform and it's year model is supporting live TV.
            * Can be configured in appgrid.
            *
            * @return {Promise<Boolean>} True if LiveTV is not supported.
            */
            isLiveSupported: function() {
                return sAppConfigManager.getLiveFeatureStatus().then(
                    function(liveSupport) {

                        var platformList = liveSupport && liveSupport.platform ? liveSupport.platform : {},
                            platform = platformList[device.platform],
                            firmwareYear = device.id.getFirmwareYear() + "";

                        if (platform && platform.disabled === true && (platform.yearModel.indexOf(firmwareYear) >= 0 || platform.yearModel.indexOf(ALL) >= 0)) {
                            return false;
                        }

                        return true;
                    },
                    function() {
                        return false;
                    }
                );
            }
        });

    return new LiveSupportManager();
});
/**
 * The details base controller. Contains common functionality for all detail view controllers.
 * @name DetailsBase
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/DetailsBase
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/DetailsBase", [
    "xdk-base/ax",
    "xdk-base/class",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/episode",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/mediator",
    "tvedemo/wgt/TextSelectionListDialog",
    "xdk-base/promise",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/AlertDialog",
    "storm/mgr/sAppConfigManager",
    "xdk-base/console",
    "storm/mgr/sLanguageManager",
    "tvedemo/mgr/sAssetManager",
    "storm/mgr/sLicensingManager",
    "storm/helper/util",
    "xdk-base/device",
    "storm/mgr/sLinearChannelManager",
    "storm/mgr/sEhubDataManager",
    "storm/mgr/sSilkMessagesManager",
    "storm/helper/silkResponseHelper",
    "lib/moment",
    "tvedemo/wgt/Loading",
    "tvedemo/mgr/sNavigationManager",
    "storm/mgr/sLiveFeatureManager"
], function (
    ax,
    klass,
    RoutableController,
    view,
    movieTmpl,
    evtType,
    focusManager,
    vKey,
    util,
    mediator,
    TextSelectionListDialog,
    promise,
    Label,
    moment,
    sEndUserManager,
    sHistoryManager,
    dialogHelper,
    AlertDialog,
    sAppConfigManager,
    console,
    sLanguageManager,
    sAssetManager,
    sLicensingManager,
    stormUtil,
    device,
    sLinearChannelManager,
    sEhubDataManager,
    sSilkMessagesManager,
    silkResponseHelper,
    momentMIT,
    sLoading,
    sNavigationManager,
    sLiveFeatureManager
    ) {

    "use strict";

    return klass.create(RoutableController, {
        getDefaultState: function() {
            return {
                __forceReload: true
            };
        }
    }, {
        IMAGE_MIN_WIDTH: 300,// Sizes based on UI design / likely CSS specification.
        IMAGE_MIN_HEIGHT: 200,
        RECENTLYWATCHED_IMAGE_HEIGHT: 383,
        RECENTLYWATCHED_IMAGE_WIDTH: 680,
        __HTMLNewLine: "<br>",
        __detailInformation: {},

        // TODO: Maybe this constant should be configurable from AppGrid? See SKYSTORM-387.
        // Age limit used to determine if content requires fsk pin check before user can watch or not.
        __adultContent: 16,

        assetBookmark: null,

        init: function () {
            this._super();
        },

        setup: function (context) {
            this._super(context);


            var currentView = this.getView(),
                blackoutMessageContainer = currentView.find("blackoutMessageContainer");

            if (blackoutMessageContainer) {
                blackoutMessageContainer.hide();
            }

            this.setButtonContainersVisible(false);
            this.updateButtons = util.wrap(this.updateButtons, util.bind(function(wrapped, args) {
                this.setButtonContainersVisible(true);
                wrapped(args);
            }, this));
            if(context.historyBack && context.__menuClone && context.__menuClone.navigationTrace.length === 0){
                sNavigationManager.triggerResetMenu(true);
            }

        },

        setButtonContainersVisible: function(state) {
            var view = this.getView();
            util.each(["serieButtonContainer", "seasonSelectionButtonContainer", "episodeSelectionButtonContainer", "videoButtonContainer"], function(item) {
                (item = view.find(item)) && item[state ? "show" : "hide"]();
            });
        },

        /**
         * Parse a date to correct format in order to be displayed as on air date.
         * @param  {Number} date The date that should be formatted.
         * @return {String}      Correctly formatted string representing the date.
         */
        parseOnAirDate: function (date) {

            if (!date) {
                return "";
            }

            var formattedDate = moment(date).format(sLanguageManager.getString("ui.format.onAirDate"));

            return formattedDate;
        },

        /**
         * Parse a date to correct format to be displayed as on air time.
         * @param  {Number} date Date to format into a time string.
         * @return {String}      Correctly formatted string representing the time.
         */
        parseOnAirTime: function (date) {

            if (!date) {
                return "";
            }

            var formattedDate = moment(date).format(sLanguageManager.getString("ui.format.onAirTime"));

            return formattedDate;
        },

        parseEventTime: function(date) {
            return date ? moment(date).format(sLanguageManager.getString("ui.format.epgEventTime")) : "";
        },

        parseNewsTime: function(date) {
            return date ? moment(date).format(sLanguageManager.getString("ui.format.newsTime")) : "";
        },

        /**
         * Create a string representation of start and endtime for an event.
         * @param  {Number} startTime Event start time.
         * @param  {Number} endTime   Event end time.
         * @return {String}           String representing event start to end.
         */
        parseStartTimeEndTime: function (startTime, endTime) {
            return this.parseOnAirDate(startTime) + "; " + this.parseEventTime(startTime) + " - " + this.parseEventTime(endTime);
        },

        /**
         * Check if a channel is playable (permitted, has an on air program and has a stream url) at the moment.
         * @param  {tvedemo/model/Asset} channel Channel to be checked if it is playable.
         * @return {Promise<boolean>}         True if channel is playable, otherwise false.
         */
        __checkIfChannelIsPlayable: function (channel) {

            if (!channel) {
                return promise.resolve(false);
            }

            var deferred = promise.defer(),
                video = channel.get("videos") && channel.get("videos")[0],
                videoUrl = video && video.get("url"),
                onAir,
                permitted,
                liveSupported;

            promise.all([
                sEhubDataManager.checkIfChannelIsOnAir(channel.get("id")).then(function(isOnAir) {
                    onAir = isOnAir;
                }),
                sLinearChannelManager.checkIfChannelIdPermitted(channel.get("id")).then(function (isPermitted) {
                    permitted = isPermitted;
                }, function () {
                    permitted = false;
                })

            ]).then(function () {

                if (permitted && onAir && videoUrl) {
                    deferred.resolve(true);

                } else {
                    deferred.resolve(false);
                }

            });

            return deferred.promise;


        },

        /**
         * Check if a channel is permitted
         * @param  {tvedemo/model/Asset} channel Channel to be checked for permission.
         * @return {Promise<boolean>}            True if channel is permitted, otherwise false.
         */
        __checkIfChannelIsPermitted: function (channel) {

            if (!channel) {
                return promise.resolve(false);
            }

            return sLinearChannelManager.checkIfChannelIdPermitted(channel.get("id")).then(function (isPermitted) {
                return true;
            }, function () {
                return false;
            }).fail(function () {
                return false;
            });
        },

        __isLiveSupported: function() {
            return sLiveFeatureManager.isLiveSupported();
        },

        __checkContentLicensing: function (asset) {
            var licenseScope = asset.get("licensing");

            return sLicensingManager.getContentLicence(licenseScope).then(null, function(reason) {
                var checkDeferred = promise.defer();

                //
                // If content is not licensed for here / this, then prohibit playback with a popup.
                // We're not certain that this is the required user experience! See SKYSTORM-210.
                //

                dialogHelper.error({
                    title: sLanguageManager.getString("Player.Player_LicensingCheckTitle"),
                    reason: sLanguageManager.getString("Player.Player_LicensingCheckText"),
                    closeAction: util.bind(function () {
                        // Disallow user to view content.
                        checkDeferred.reject(reason);
                    }, this),
                    buttonText: sLanguageManager.getString("Global.Global_Continue")
                });

                return checkDeferred.promise;
            });
        },

        /**
         * Check the user privileges in respect to a specific asset.
         * @param  {tvedemo/model/Asset} asset Asset to check privileges for.
         * @return {Promise<boolean>}          True if user has the right to watch asset, otherwise false.
         */
        __checkUserPrivileges: function (asset) {
            return sEndUserManager.checkUserPrivileges(asset);
        },

        /**
         * Check if fsk pin is required to view content, if so display pin enter popup to the user.
         * @param  {tvedemo/model/Asset} asset Asset to check fsk for.
         * @return {Promise<boolean>}       True if user is allowed to view content, otherwise false.
         */
        __checkFsk: function (asset, remainingAttempts, checkDeferred) {
            if (!checkDeferred) {
                checkDeferred = promise.defer();
            }

            if (asset.get("parentalRating") && asset.get("parentalRating").value >= this.__adultContent) {

                var message,
                    title;
                    
                console.log("Remaining attempts: "+remainingAttempts);

                switch (remainingAttempts) {
                    case 1:
                        title = sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_3_hl");
                        message = sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_3_message");
                        break;

                    case 2:
                        title = sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_2_hl");
                        message = sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_2_message");
                        break;

                    default:
                        title = sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_1_hl");
                        message = sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_ge1_message");
                        break;
                }

                dialogHelper.input({
                    dialogCss: "pin-dialog",
                    finishedTextInput: util.bind(function (fskPin) {

                        if (!fskPin) {
                            var lastActiveFocus = focusManager.getLastActiveFocus();
                            focusManager.focus(lastActiveFocus);
                            
                            // Adult content but no PIN entered, user should not be allowed to view content.
                            checkDeferred.reject("No PIN entered");

                        } else {
                            sEndUserManager.checkFskPin(fskPin).then(util.bind(function (result) {

                                // Adult content and user has entered a correct PIN, allow user to view content.
                                checkDeferred.resolve("PIN correct");

                            }, this), util.bind(function (result) {

                                if (result && result.remainingAttempt > 0) {

                                    // Adult content and user has entered incorrect PIN but still have remaining attempts to enter pin.
                                    this.__checkFsk(asset, result.remainingAttempt, checkDeferred);

                                } else if (result && result.remainingAttempt <= 0) {

                                    // Adult content and user has entered wrong PIN to many times.
                                    // Inform the user and then disallow to view content.
                                    dialogHelper.error({
                                        title: sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_4_hl"),
                                        reason: sLanguageManager.getString("PinEntry.PinEntry_YP_labelpin_entry_4_message"),
                                        closeAction: util.bind(function () {

                                            // Disallow user to view content.
                                            checkDeferred.reject("PIN not entered correctly");
                                        }, this),
                                        buttonText: sLanguageManager.getString("Global.Global_Continue")
                                    });

                                } else {
                                    var resultCode = result && result.resultCode;

                                    // Backend failed to execute the login attempt.
                                    sSilkMessagesManager.getSilkMessageForCode(resultCode).then(function (silkMessage) {
                                        var title = silkMessage && silkMessage.get("title"),
                                            reason = silkMessage && silkMessage.get("description");

                                        dialogHelper.error({
                                            title: title,
                                            reason: reason,
                                            closeAction: util.bind(function () {

                                                // Disallow user to view content.
                                                checkDeferred.reject("PIN not entered correctly");
                                            }, this),
                                            buttonText: sLanguageManager.getString("Global.Global_Continue")
                                        });

                                    }, function () {

                                        dialogHelper.error({
                                            reason: sLanguageManager.getString("Global.Global_generalError"),
                                            closeAction: util.bind(function () {

                                                // Disallow user to view content.
                                                checkDeferred.reject("PIN not entered correctly");
                                            }, this),
                                            buttonText: sLanguageManager.getString("Global.Global_Continue")
                                        });
                                    });
                                }

                            }, this));
                        }

                    }, this),

                    canceledTextInput: util.bind(function () {
                        var lastActiveFocus = focusManager.getLastActiveFocus();
                            focusManager.focus(lastActiveFocus);
                            
                        // Adult content but no PIN entered, user should not be allowed to view content.
                        checkDeferred.reject("PIN entry cancelled");
                    }, this),

                    title: title,

                    message: message,

                    maxLength: 4,
                    isPassword: true,
                    inputCss: "keyboard-number",
                    keyMap: "number",

                    positiveText: sLanguageManager.getString("Global.Global_Continue"),
                    negativeText: sLanguageManager.getString("Global.Global_buttonBack_button")
                });
            } else {

                // If a FSK check is performed the session validity will be checked that way.
                // If FSK check is not required, make a round trip to the server to check the session validity.
                sEndUserManager.checkUserSessionIsValid().then(function () {
                    return checkDeferred.resolve("No FSK required");

                }, function () {
                    return checkDeferred.resolve("No FSK required");
                });
            }

            return checkDeferred.promise;
        },

        /**
         * Determine if an asset contains a trailer or not.
         * @param {tvedemo/model/Asset} asset Asset to check for trailer.
         * @return {boolean}                  True if the asset contains a trilaer, otherwise false.
         */
        __hasTrailer: function (asset) {
            var trailerUrl = asset.get("trailer") && asset.get("trailer").get("url"),
                hasTrailer = (trailerUrl && trailerUrl !== "") ? true : false;

            return hasTrailer;
        },

        /**
         * Check if an asset si present in a user's watchlist.
         * @param  {tvedemo/model/Asset} asset Asset to check if is present in watchlist.
         * @return {Promise<boolean>}          True if asset is present, otherwise false.
         */
        __checkIfAssetIsPresentInWatchlist: function (asset) {

            if (!asset) {
                return promise.resolve(false);
            }

            return sEndUserManager.checkIfAssetIsInUserWatchList([asset.get("id").toString()]);
        },

        /**
         * Check if a serie season is present in a user's watchlist.
         * @param  {tvedemo/model/SeasonAsset} season Season to check if is present in watchlist.
         * @return {Promise<boolean>}          True if asset is present, otherwise false.
         */
        __checkIfSeasonIsPresentInWatchlist: function (season) {

            var currentSeasonEpisodes = season && season.get("episodes"),
                episodeIds = [];

                util.each(currentSeasonEpisodes, function (episode) {

                    episodeIds.push(episode.get("id").toString());

                });

            return sEndUserManager.checkIfAssetIsInUserWatchList(episodeIds);

        },

        __updateWatchList: function (options) {
            sLoading.open();
            
            var updateWatchlistPromise;

            if (options.remove) {
                updateWatchlistPromise = this.__removeFromWatchlist(options);

            } else if (options.add) {
                updateWatchlistPromise = this.__addToWatchlist(options);
            }

            return updateWatchlistPromise.then(util.bind(function (action, successfullyUpdated) {
                sLoading.close();

                if (successfullyUpdated) {
                    return {
                        added: action.add,
                        removed: action.remove
                    };

                } else {
                    return {
                        added: false,
                        removed: false
                    };
                }

            }, {}, options)).fail(function(e){
                sLoading.close();
                console.warn("updateWatchlistPromise error:"+e);
            });

        },

        /**
         * Add asset to user's watchlist.
         * @return {void}
         */
        __addToWatchlist: function (options) {

            return sEndUserManager.loginCheck().then(function() {
                return sEndUserManager.addAssetToUserWatchList(options);
            });
        },

        /**
         * Add asset to user's watchlist.
         * @return {void}
         */
        __removeFromWatchlist: function (options) {

            return sEndUserManager.loginCheck().then(function() {
                return sEndUserManager.removeAssetFromWatchList(options);
            });
        },

        __sequencePermissionPromises: function (asset) {
            sLoading.close();
            // Split this up rather than chaining tightly, to facilitate diagnostic code insertion.
            var interim = this.__checkContentLicensing(asset);
            interim = interim.then(util.bind(this.__checkFsk, this, asset));
            interim = interim.then(util.bind(this.__checkUserPrivileges, this, asset));
            // Promising to return a final true / false for privileges (or an earlier rejection).
            stormUtil.probePromise(interim);
            //
            // probePromise() helps us to resolve 'dangling promise' issue; see TODO in InputDialog.js.
            //
            // Let's leave it in - it is side-effect free - until that's sorted.
            //
            return interim;
        },

        /**
         * Check if an asset has a media url and thus is playable.
         * @param  {tvedemo/model/Asset} asset Asset to be checked if it is playable.
         * @return {boolean}                   True if asset is playable, otherwise false.
         */
        __assetIsPlayable: function (asset) {
            var isSport = asset && asset.get("type") === sAssetManager.ASSET_TYPES.SPORT,
                video = asset && asset.get("video"),
                videoUrl = video && video.get("url");

            if (isSport && asset.get("currentType") === sAssetManager.SPORT_ASSET_CURRENT_TYPES.REPLAY) {
                console.warn("Sport events do not allow Replays to be watched"); // SKYSTORM-742
                return false;
            }

            if (videoUrl && videoUrl !== "") {
                return true;
            }

            return false;
        },

        /**
         * Watch movie in case it is live on channel.
         * @return {void}
         */
        __tuneIn: function (asset) {
            var channel = asset && asset.get("channel"),
                video = channel && channel.get("videos") && channel.get("videos")[0],
                videoUrl = video && video.get("url"),
                apixId = asset && asset.get("id");

            if (videoUrl) {

                // Check that the channel is permitted before prompting user for any input (Login, FSK).
                sLinearChannelManager.checkIfChannelIdPermitted(channel.get("id")).then(util.bind(function () {
                    sEndUserManager.loginCheck().then(util.bind(function() {
                        this.__sequencePermissionPromises(asset).then(util.bind(function (result) {

                            if (result) {

                                // Adding to recently watched here. Since at this point Entitlement, FSK PIN and geo licensing has been approved.
                                // Which is the to be considered as the user has watched the content.
                                // TODO: Outcommented since at the moment we don't handle adding linear channels to recently watched.
                                // This will just cause an api call that will fail.
                                // this.__addToRecentlyWatched(asset);

                                this.__playVideo({
                                    url: videoUrl,
                                    useDrm: true,
                                    apixId: apixId,
                                    isMovie: true,
                                    isLinear: true,
                                    channelId: channel.get("id"),
                                    videoAsset: channel
                                });
                            }

                        }, this), function(reason){
                            console.log("Not tuning in, because " + reason);
                        });
                    }, this));

                }, this), function (reason) {
                    console.log("Not tuning in, because " + reason);
                });

            } else {
                console.log("Not tuning in, because no video available for this channel");

                dialogHelper.error({
                    reason: sLanguageManager.getString("Errormessages.Errormessages_labelVideoNotAvailable"),
                    buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                });
            }
        },
        __getBookmarkForAsset: function(assetId) {

            return sEndUserManager.getCustomerBookmarks(assetId).then(util.bind(function(bookmark) {
                this.assetBookmark = bookmark;

                return bookmark;
            }, this));
        },

        /**
         * Watch trailer of an asset.
         * @return {void}
         */
        __watchTrailer: function (asset) {
            sLoading.open();

            if (asset) {
                var trailer = asset.get("trailer"),
                    trailerUrl = trailer && trailer.get("url"),
                    trailerFsk = trailer && trailer.get("parentalRating").value;

                if (trailerUrl) {

                    if (trailerFsk >= this.__adultContent) {
                        sLoading.close();
                        sEndUserManager.loginCheck().then(util.bind(function() {
                            this.__checkFsk(trailer).then(util.bind(function (result) {
                                this.__playVideo({
                                    url: trailerUrl,
                                    useDrm: false,
                                    isMovie: false,
                                    videoAsset: asset
                                });
                            }, this));
                        }, this));

                    } else {
                        this.__playVideo({
                            url: trailerUrl,
                            useDrm: false,
                            isMovie: false,
                            videoAsset: asset
                        });
                    }

                } else {
                    sLoading.close();
                    // TODO: Implement proper error handling.
                    // console.warn("[Movie] failed to play the trailer: " + reason);

                    // dialogHelper.error({
                    //     reason: "Sorry, the video is not available now"
                    // });

                }
            } else {
                sLoading.close();
            }
        },

        _showResumePopup: function(asset, startTime) {
            sLoading.close();
            dialogHelper.confirm({
                dialogCss: 'resume-dialog',
                title: sLanguageManager.getString("CustomerMessages.CustomerMessages_labelBasicBookmarkingAlertTitle"),
                message: sLanguageManager.getString("CustomerMessages.CustomerMessages_labelBasicBookmarkingAlertMessage"),
                positiveText: sLanguageManager.getString("CustomerMessages.CustomerMessages_labelBasicBookmarkingAlertConfirm"),
                negativeText: sLanguageManager.getString("CustomerMessages.CustomerMessages_labelBasicBookmarkingAlertCancel"),
                positiveAction: util.bind(function() {
                    sLoading.open();
                    this.__continueVodFlow(asset, startTime);
                }, this),
                negativeAction: util.bind(function() {
                    sLoading.open();
                    this.__continueVodFlow(asset, 0);
                }, this),
                buttonLayout: dialogHelper.VERTICAL_BUTTON_LAYOUT
            });
        },

        _checkBookmark: function(asset) {
            console.log("[detailsBase] _checkBookmark - getting bookmark");
            this.__getBookmarkForAsset(asset.get('id')).then(util.bind(function(bookmark) {
                // If start time is a value > 0, that means that a resume has been called from details page.
                if (bookmark == 0) {
                    this.__continueVodFlow(asset, 0);
                } else if (bookmark > 0) {
                    this._showResumePopup(asset, bookmark);
                }
            }, this)), 
            util.bind(function() {
                console.error("[detailsBase] error checking bookmark, promise was rejected");
                this.__continueVodFlow(asset, 0);
            }, this);
        },

        __continueVodFlow: function(asset, startTime) {
            this.__sequencePermissionPromises(asset).then(util.bind(function (result) {
                if (result) {
                    if (asset) {
                        var video = asset.get("video"),
                            videoUrl = video && video.get("url"),

                            // For some reason the SKY backend requires that event id is used as apix id even though the asset contains an apix id.
                            apixId = asset.get("eventId");

                        if (videoUrl) {

                            var urlReplacePromise;

                            // Needed since playstation can't play the supplied manifests.
                            if (device.platform === 'playstation') {

                                urlReplacePromise = sAppConfigManager.getPlaystationSpecificConfig().then(util.bind(
                                    function(playstationSettings) {

                                        if (playstationSettings.vodurloverride === true && playstationSettings.vodurlreplace.find) {
                                            // Insert _Samsung before '.ism'
                                            var findString = playstationSettings.vodurlreplace.find,
                                                replaceValue = playstationSettings.vodurlreplace.replace_value;

                                            videoUrl = replaceValue ? videoUrl.replace(findString, replaceValue) : videoUrl;
                                        }
                                    }, this));
                            } else {
                                urlReplacePromise = promise.resolve();
                            }

                            urlReplacePromise.then(util.bind(
                                function() {
                                    this.__playVideo({
                                        url: videoUrl,
                                        useDrm: true,
                                        apixId: apixId,
                                        isMovie: true,
                                        videoAsset: asset,
                                        startTime: startTime
                                    }).then(util.bind(function(playAttempted) {
                                        //
                                        // Adding to recently watched only if __playVideo promise resolves true.
                                        //
                                        // Even though Entitlement, FSK PIN and geo licensing has been approved, playback may
                                        // still be rejected if too many devices are registered (perhaps for other reasons).
                                        //
                                        // We do add to RWL right at the start of playback, but only when we're confident it will have begun.
                                        // Note that if playback is aborted straight away (device count edge case, or some back end
                                        // or video streaming error) the add to RWL will have happened, and we're ok with that.
                                        //
                                        if (playAttempted === true) {
                                            this.__addToRecentlyWatched(asset);
                                        }
                                    }, this));
                                }, this));

                        } else {
                            sLoading.close();
                            dialogHelper.error({
                                reason: sLanguageManager.getString("Errormessages.Errormessages_labelVideoNotAvailable"),
                                buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                            });

                        }
                    } else {
                        sLoading.close();
                    }
                } else {
                    sLoading.close();
                } 

            }, this), function(reason){
                sLoading.close();
                console.log("Not playing VOD, because " + reason);
            });
        },

        /**
         * Watch a VOD movie.
         * @return {void}
         */
        __watchVod: function (asset, bookmark) {
            sLoading.open();
            sEndUserManager.loginCheck().then(util.bind(function() {

                // User has pressed resume.
                if (bookmark) {
                    this.__continueVodFlow(asset, bookmark);
                    return;
                }

                this._checkBookmark(asset);
            }, this), function(reason){
                sLoading.close();
                console.log("loginCheck fail, because " + reason);
            });
        },

        __addToRecentlyWatched: function (asset) {
            sAssetManager.getStormAssetImageBySize(asset, this.RECENTLYWATCHED_IMAGE_WIDTH, this.RECENTLYWATCHED_IMAGE_HEIGHT).then(util.bind(function (cover) {
                return cover.get("url");

            }, this)).fail(function () {
                return "";

            }).done(function (imageUrl) {
                var titleFormatter = function(asset) {
                    var string = "";
                    if (asset.get("seasonNumber")) {
                        string += "S" + asset.get("seasonNumber");
                    }
                    if (asset.get("episodeNumber")) {
                        if (string.length) {
                            string += " ";
                        }
                        string += "E" + asset.get("episodeNumber");
                    }
                    if (string.length) {
                        string += ": ";
                    }
                    if (asset.get("title")) {
                        string += asset.get("title");
                    }
                    return string;
                };
                sEndUserManager.addAssetToRecentlyWatched({

                    // For some reason the SKY backend requires that event id is used as apix id even though the asset contains an apix id.
                    apixId: asset.get("eventId"),
                    assetId: asset.get("id"),
                    title: titleFormatter(asset),
                    color: asset.get("packageCode"),
                    isHD: asset.get("isHD"),
                    fsk: asset.get("parentalRating").display,
                    imageUrl: imageUrl,
                    type: asset.get("type")
                });
            });
        },

        /**
         * Attempt to initiate video playback.
         * @return {Promise<boolean>} True if video playback was really attempted, not-true if it was abandoned _by the UI_ for some reason.
         * @return {Boolean}
         */
        __playVideo: function (options) {

            if (!options) {
                return promise.resolve(false);
            }

            var drmAttributes = {};
            var getDRMPromise = options.useDrm?sAppConfigManager.getDRMSettings():ax.promise.resolve(false),
                getSamsungConfigPromise = sAppConfigManager.getSamsungSpecificConfig(),
                playbackAttemptedPromise = promise.defer();

            promise.all([
                getDRMPromise,
                getSamsungConfigPromise
            ])
            .then(util.bind(function(result) {
                var drmModel = result[0],
                    samsungConfig = result[1],
                    drmAttributes = {},
                    currentDeviceId = device.id.getUniqueID(),
                    startBitrate;

                if (drmModel) { // Only if we wanted DRM detail, AND got it.
                    var customData = "sessionId=" + sEndUserManager.getUserSessionId() + "&apixId=" + options.apixId + "&deviceId=" + currentDeviceId + "&platformId=" +
                            drmModel.get("platformId") + "&product=" + drmModel.get("product") +
                            "&download=N&DeviceFriendlyName=" + drmModel.get("deviceFriendlyName") + ( options.isLinear ? ("&channelId=" + options.channelId) : "");

                    drmAttributes = util.extend(drmAttributes, {
                        drm: "playready",
                        drmUrl: drmModel.get("root"),
                        denseServiceId: drmModel.get("denseServiceId"),
                        serviceId: drmModel.get("serviceId"),
                        serviceIdFormat: drmModel.get("serviceIdFormat"),
                        customData: customData
                    });

                    if (samsungConfig && samsungConfig.videoInitialValues && util.isString(samsungConfig.videoInitialValues.startBitrate)) {
                        drmAttributes = util.extend(drmAttributes, {
                            startBitrate: samsungConfig.videoInitialValues.startBitrate
                        });
                    }
                }

                // Make sure that movie type has actively been set to "trailer".
                if (options && options.isMovie === false) {

                    // Trailers that does not contain adult content should be playable regardless if the user is logged in or not.
                    // Without any logged in user it is not possible to check any device domain.
                    // Thus allowing trailers to be played without checking any device domain.
                    // Login and FSK check for trailers with adult content has been made before this point,
                    // thus it is safely to start playback of all trailers that reach this point.

                    sLoading.close();
                    mediator.publish("navigate", {
                        path: "FullscreenPlayer",
                        state: {
                            isLinear: options.isLinear,
                            mediaTitle: options.title,
                            mediaUrl: options.url,
                            mediaType: options.isMovie ? "movie" : "trailer",
                            startTime: options.startTime,
                            drmAttributes: options.useDrm ? drmAttributes : null,
                            asset: options.videoAsset
                        }
                    });

                    return promise.resolve(true);
                }

                sEndUserManager.getDeviceDetails().then(function (deviceDetails) {
                    var numberOfFreeDeviceSlots = deviceDetails && deviceDetails.get("freeSlots"),
                        deviceList = deviceDetails && deviceDetails.get("deviceList"),
                        isPlaybackPossible = false;

                    // Current device id must be of type String in order for the comparison with
                    // device ids in the device list to function as expected.
                    currentDeviceId = util.isString(currentDeviceId) ? currentDeviceId : currentDeviceId.toString();

                    // If there are no available device slots, it will not be possible to join user's device domain.
                    // Thus playback will not be possible unless the current device is not already existent in the user's device domain.
                    // Note that the 'uninitialised' device list for a brand new account has an empty device list but no valid 'free slots' value...

                    if (util.isArray(deviceList)) {

                        if ((deviceList.length > 0) && (numberOfFreeDeviceSlots <= 0)) {

                            // Check if the user's device domain contains the current device.
                            util.each(deviceList, function (device) {

                                if (device.get("id") === currentDeviceId) {

                                    // Playback is possible since current device is already existent in the user's device domain.
                                    isPlaybackPossible = true;

                                    return util.breaker;
                                }
                            });

                        } else {

                            // If there are device slots available in the user's device domain, join domain is possible.
                            // Thus playback will be possible regardless if the current device is already in the device domain or not.
                            // We have assumed that an empty device list means at least one slot is available.

                            isPlaybackPossible = true;
                        }
                    }

                    if (isPlaybackPossible) {
                        sLoading.close();
                        mediator.publish("navigate", {
                            path: "FullscreenPlayer",
                            state: {
                                isLinear: options.isLinear,
                                mediaTitle: options.title,
                                mediaUrl: options.url,
                                mediaType: options.isMovie ? "movie" : "trailer",
                                startTime: options.startTime,
                                drmAttributes: options.useDrm ? drmAttributes : null,
                                asset: options.videoAsset
                            }
                        });

                    } else {
                        sLoading.close();
                        // If the user's device domain is full and the current device is not existent within the domain,
                        // display proper error message to the user.
                        sSilkMessagesManager.getSilkMessageForCode(silkResponseHelper.SILK_CODE.USER_HAS_TOO_MANY_DEVICES_REGISTERED).then(function (silkMessage) {

                            dialogHelper.error({
                                title: silkMessage.get("title"),
                                reason: silkMessage.get("description"),
                                buttonText: sLanguageManager.getString("Global.Global_Continue")
                            });

                        }, function () {

                            // In case the app fails to retrieve the proper error message,
                            // the app should at least display a general error in correct language.
                            dialogHelper.error({
                                reason: sLanguageManager.getString("Global.Global_generalError"),
                                buttonText: sLanguageManager.getString("Global.Global_Continue")
                            });
                        });
                    }

                    playbackAttemptedPromise.resolve(isPlaybackPossible);
                }, function() {
                    sLoading.close();
                    // Failed to get device details; highly surprising.
                    console.error("[detailsBase] playVideo - Could not play the video");
                    playbackAttemptedPromise.resolve(false);
                });

            }, this), function () {
                sLoading.close();
                // Assuming that most users have not filled their device quotas,
                // playback would function as expected even though device domain has not been checked.
                // If user's device quota has been filled, starting playback will yield a general error message.
                // Assuming that failure to retrieve user's device list is only temporary and that the user will
                // be given a "device quota filled" error message on next attempt to start any playback.

                mediator.publish("navigate", {
                    path: "FullscreenPlayer",
                    state: {
                        isLinear: options.isLinear,
                        mediaTitle: options.title,
                        mediaUrl: options.url,
                        mediaType: options.isMovie ? "movie" : "trailer",
                        startTime: options.startTime,
                        drmAttributes: options.useDrm ? drmAttributes : null,
                        asset: options.videoAsset
                    }
                });

                playbackAttemptedPromise.resolve(true);
            });

            return playbackAttemptedPromise.promise;
        },

        updateCommonDetailInformation: function (asset, detailInformation) {
            var synopsisText = "",
                missingPackageContainer = this.getView().find("missingPackage");

            if (missingPackageContainer) {
                missingPackageContainer.addClass("hidden"); // Presume the user has the package.
                //
                // Only show the 'package needed' info for logged-in users; SST-57 / SKYSTORM-588.
                //
                if (this.checkIfUserIsLoggedIn()) {
                    //
                    // Sky business rules unclear (for phase 1 at least), but let's assume...
                    // We show the 'missing entitlement' only if there's NO kind of entitlement here.
                    //
                    if (!detailInformation.userHasPrivileges && // @TODO: Some rationalisation possible here!
                        !detailInformation.userHasPrivilegeForAsset &&
                        !detailInformation.userHasPrivilegeForChannel &&
                        !detailInformation.userHasPrivilegeToWatchVod &&
                        !detailInformation.userHasPrivilegeToWatchChannel) {
                        this.setMissingPackage(detailInformation.packageCode).then(util.bind(function() {
                            missingPackageContainer.removeClass("hidden");
                            var wrap = document.createElement("div");
                            wrap.appendChild(missingPackageContainer.getRoot().getHTMLElement());
                            this.setSynopsis(wrap.innerHTML + synopsisText);
                        }, this));
                    }
                }
            }

            if (util.isArray(detailInformation.cast) && detailInformation.cast.length > 0) {

                synopsisText += (sLanguageManager.getString("DetailPage.DetailPage_labelcast") + this.__HTMLNewLine);

                util.each(detailInformation.cast, util.bind(function (actor, arrayIndex) {

                    if (actor && actor.content) {
                        synopsisText += ((arrayIndex < detailInformation.cast.length - 1) ? actor.content + ", " : actor.content);
                    }

                }, this));

                synopsisText += (this.__HTMLNewLine + this.__HTMLNewLine);
            }

            synopsisText += detailInformation.synopsis;

            this.setSynopsis(synopsisText);

            this.setMetadata(detailInformation);

            this.setThumbnail(asset);

            this.setLogo(asset, detailInformation.fallbackChannelLogo);

            if (detailInformation.isBlackedOut) {
                this.displayBlackedOutMessage();
            }

        },

        /**
         * Display blacked out message.
         * @return {void}
         */
        displayBlackedOutMessage: function () {
            var currentView = this.getView(),
                blackoutMessageContainer = currentView.find("blackoutMessageContainer"),
                blackoutMessage = currentView.find("blackoutMessage");

            blackoutMessage.setText(sLanguageManager.getString("Epg.blackoutShort"));
            blackoutMessageContainer.show();
        },

        setMissingPackage: function(packageCode) {
            var currentView = this.getView(),
                logoElement = currentView.find("missingPackageLogo"),
                textElement = currentView.find("missingPackageText"),
                missingPackageLookup = "DetailPage.DetailPage_MissingEntitlement_" + packageCode,
                missingPackageMessage = sLanguageManager.getString(missingPackageLookup);

            if (missingPackageMessage ===  missingPackageLookup) {
                missingPackageMessage = sLanguageManager.getString("DetailPage.DetailPage_MissingEntitlement_OTHER");
            }
            textElement.setText(missingPackageMessage);

            return sAppConfigManager.getPackageImageForCode(packageCode).then(function(logo) {
                logoElement.setSrc(logo);
                logoElement.removeClass("hidden");
            }, function() {
                // We failed to get a corresponding logo so hide it.
                logoElement.addClass("hidden");
            });
        },

        /**
         * Set thumbnail for current asset.
         * @param {tvedemo/model/Asset} asset Asset to display thumbnail for.
         * @return {void}
         */
        setThumbnail: function (asset) {
            var currentView = this.getView(),
                thumbnail = currentView.find("thumbnail");

            sAssetManager.getStormAssetImageBySize(asset, this.IMAGE_MIN_WIDTH, this.IMAGE_MIN_HEIGHT).then(util.bind(function (cover) {
                thumbnail.setSrc(cover.get("url"));
            }, this)).fail(function (reason) {
                console.warn("[Movie] failed to get the cover image for " + asset.get("title") + ": " + reason);
                thumbnail.fallback();
            }).done();
        },

        /**
         * Set logo of the current assets channel.
         * @param {tvedemo/model/Asset} asset Asset to display channel logo for.
         * @return {void}
         */
        setLogo: function (asset, fallbackChannelLogo) {
            var currentView = this.getView(),
                channelLogo = currentView.find("channelLogo");

            sAssetManager.getStormAssetChannelLogo(asset).then(function (parsedLogo) {
                channelLogo.setSrc(parsedLogo.get("url"));
            }).fail(function () {
                if (fallbackChannelLogo) {
                    channelLogo.setSrc(fallbackChannelLogo);
                } else {
                    channelLogo.fallback();
                }
            });
        },

        /**
         * Set synopsis text.
         * @return {void}
         */
        setSynopsis: function (synopsisText) {
            var currentView = this.getView(),
                detailDescription = currentView.find("detailDescription");

            detailDescription.setText(synopsisText);
        },

        /**
         * Set metadata to be displayed.
         * @param {Object} metadata Metadata to be displayed.
         * @return {void}
         */
        setMetadata: function (metadata) {
            var currentView = this.getView(),
                title = currentView.find("title"),
                metaContainer = currentView.find("metaDataContainer");

            title.setText(metadata.title.toUpperCase());

            // Meta data container.
            metaContainer.detachAll();

            if (metadata.onAirDate || (metadata.startTime && metadata.endTime) || metadata.newsDate) {
                var dateLabel = metadata.newsDate ? this.parseNewsTime(metadata.newsDate)
                                                  : metadata.onAirDate ? this.parseOnAirDate(metadata.onAirDate)
                                                                       : this.parseStartTimeEndTime(metadata.startTime, metadata.endTime);

                new Label({
                    css: "on-air",
                    text: dateLabel,
                    parent: metaContainer
                });

                if (!metadata.length && metadata.startTime && metadata.endTime) {
                    metadata.length = metadata.endTime - metadata.startTime;
                }

            }

            if (metadata.parentalRating) {
                new Label({
                    text: metadata.parentalRating.display,
                    parent: metaContainer
                });
            }

            if (metadata.length) {
                new Label({
                    text: momentMIT.duration(metadata.length).asMinutes() + sLanguageManager.getString("ui.format.minutesDurationSuffix"),
                    parent: metaContainer
                });
            }

            if (metadata.country) {
                new Label({
                        text: metadata.country,
                        parent: metaContainer
                });
            }

            if (metadata.year) {
                try {
                    new Label({
                        text: metadata.year.toString(),
                        parent: metaContainer
                    });
                } catch (ex) {

                    // Most likely the date is not valid and can't be formatted.
                    console.warn("[Movie] " + ex);
                }
            }

            if (metadata.genres) {
                var genresArray = [];

                // The genre list retrieved form the api is sometimes an Array and sometimes an object.
                if (util.isArray(metadata.genres)) {

                    util.each(metadata.genres, function (genre) {
                        if (genresArray.indexOf(genre.content) === -1) {
                            genresArray.push(genre.content);
                        }
                    });

                } else {
                    var mainGenre = metadata.genres.main,
                        secondGenre = metadata.genres.second;

                    if (mainGenre && mainGenre.content) {
                        genresArray.push(mainGenre.content);
                    }

                    if (secondGenre && secondGenre.content) {
                        if (genresArray.indexOf(secondGenre.content) === -1) {
                            genresArray.push(secondGenre.content);
                        }
                    }
                }

                if (genresArray.length) {
                    new Label({
                        css: "category",
                        text: genresArray.join(" & "),
                        parent: metaContainer
                    });
                }
            }

            if (metadata.isHD) {
                new Label({
                    text: sLanguageManager.getString("Settings.Settings_PackageHD"),
                    parent: metaContainer
                });
            }
        },

        /**
         * Set focus on the first visible component within the list of compnents.
         * @param  {Array} components Array with components.
         * @return {void}
         */
        focusFirstVisibleComponent: function (components) {
            var currentView = this.getView(),
                menu = currentView.getParent().getParent().find("list-main-menu"),
                componentToFocus;

            util.each(components, function (component) {
                var isHidden = component.isHidden && component.isHidden(),
                    isInactive = component.isInactive && component.isInactive();

                if (!isHidden && !isInactive) {
                    componentToFocus = component;
                    return util.breaker;
                }
            });

            if (componentToFocus) {
                focusManager.focus(componentToFocus);
            } else {

                // This will render the page greyed out. Need to figure out a better way to handle when no component is focusable.
                focusManager.focus(menu);
            }
        },

        /**
         * Set navigation between related buttons.
         * @param  {ImageButton[]} buttonList       List containing the buttons that should be navigated between.
         *                                           - The buttons should be placed in vertical line.
         *                                           - The first button in the list is considered as the topmost button.
         * @param  {Component}     buttonContainer  Conatiner of the buttons.
         * @return {void}
         */
        setButtonNavigation: function (buttonList, buttonContainer) {

            if (!buttonList) {
                return;
            }

            var currentAbove,
                currentBelow,
                currentButton;

            // Set next up and hide/greyout each button.
            for (var index = 0, numbersOfButtons = buttonList.length; index < numbersOfButtons; index++) {
                currentButton = buttonList[index];

                if (currentButton.hidden) {
                    currentButton.button.hide();

                } else if (currentButton.greyedOut) {
                    currentButton.button.show();
                    currentButton.button.inactivate();

                } else {

                    if (currentButton.button) {
                        currentButton.button.show();
                        currentButton.button.activate();

                        if (currentAbove) {
                            currentButton.button.setOption("nextUp", currentAbove);
                        } else {
                            // Let the container handle nextUp.
                            // This is needed to make sure that disabled buttons are disabled when coming back from login.
                            currentButton.button.setOption("nextUp", false);
                        }

                        // Rember this button to be used as next up for next downward available button.
                        currentAbove = currentButton.button;
                    }
                }
            }

            // Set next down for each button.
            for (index = buttonList.length - 1; index >= 0; index--) {
                currentButton = buttonList[index];

                if (!currentButton.hidden && !currentButton.greyedOut && currentButton.button) {

                    if (currentBelow) {
                        currentButton.button.setOption("nextDown", currentBelow);
                    }

                    // Rember this button to be used as next down for next upward available button.
                    currentBelow = currentButton.button;
                }
            }

            if (buttonContainer) {

                // At this point currentBelow will be the topmost available button.
                buttonContainer.setOption("forwardFocus", currentBelow);
            }

        },

        /**
         * Check if any  user is logged in.
         * @return {boolean} True if user is logged in otherwise false.
         */
        checkIfUserIsLoggedIn: function () {
            var userIsLoggedIn = false;

            if (sEndUserManager.getUserSessionId()) {
                userIsLoggedIn = true;
            }

            return userIsLoggedIn;
        },

        reset: function (context) {

            this._super(context);
        }
    });
});
/**
 * The epgEvent details view's controller.
 * @name EpgEvent
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/EpgEvent
 * @extends tvedemo/ctrl/DetailBase
 */
define("tvedemo/ctrl/EpgEvent", [
    "xdk-base/ax",
    "xdk-base/class",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/epgEvent",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/mediator",
    "tvedemo/wgt/TextSelectionListDialog",
    "xdk-base/promise",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/AlertDialog",
    "storm/mgr/sAppConfigManager",
    "xdk-base/console",
    "storm/mgr/sLanguageManager",
    "tvedemo/mgr/sAssetManager",
    "tvedemo/ctrl/DetailsBase",
    "tve/mgr/sLinearManager",
    "storm/event/UserEvent",
    "storm/helper/util"
], function (
    ax,
    klass,
    view,
    epgEventTmpl,
    evtType,
    focusManager,
    vKey,
    util,
    mediator,
    TextSelectionListDialog,
    promise,
    Label,
    moment,
    sEndUserManager,
    sHistoryManager,
    dialogHelper,
    AlertDialog,
    sAppConfigManager,
    console,
    sLanguageManager,
    sAssetManager,
    DetailsBase,
    sLinearManager,
    UserEvent,
    stormUtil
    ) {

    "use strict";

    return klass.create(DetailsBase, {
        getDefaultState: function () {
            return {};
        }
    }, {
        __epgEvent: null,

        init: function () {
            this._super();
            this.setView(view.render(epgEventTmpl));
        },

        setup: function (context) {
            this._super(context);

            var epgEvent = context && context.context && context.context.get("data");

            this.__handleUserDataUpdate = util.bind(function () {
                // Update buttons and entitlement indication according to the users new data.
                if (this.__epgEvent && this.__detailInformation.hasVodAsset) {
                    this.displayDetailInformation(this.__epgEvent, this.__detailInformation.hasVodAsset);
                }

            }, this);

            mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            this.setupButtons();

            if (context.historyBack) {
                this.displayDetailInformation(this.__epgEvent, this.__detailInformation.hasVodAsset);
                return;
            }

            // If we're coming from the Home page we have some optional epgExcerptEvent information...

            context.setupPending = this.setupDetailsInformation(epgEvent.eventId, epgEvent.channelId, epgEvent.epgExcerptEvent);
        },

        /**
         * Check more deeply whether the asset is playable. For 'Sport' things shown as EPG events, we only allow tune to channel (SKYSTORM-687).
         * @return {bool}
         */
        assetIsPlayable: function(asset) {
            if (asset && asset.get("type") === sAssetManager.ASSET_TYPES.SPORT) {
                console.warn("Sport EPG events do not allow the 'VOD' to be played");
                return false;
            } else {
                return this.__assetIsPlayable(asset);
            }
        },

        /**
         * Setup buttons on the page, add click event handlers.
         * @return {void}
         */
        setupButtons: function () {
            var currentView = this.getView(),
                tuneInEpgEvent = currentView.find("epgEventTuneIn"),
                watchEpgEvent = currentView.find("epgEventStartVod"),
                watchTrailer = currentView.find("epgEventWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist");

            this.__tuneInRef = util.bind(function () {
                this.__tuneIn(this.__epgEvent);
            }, this);

            this.__watchVodRef = util.bind(function () {
                this.__watchVod(this.__epgEvent.get("asset"));
            }, this);

            this.__watchTrailerRef = util.bind(function () {
                this.__watchTrailer(this.__epgEvent.get("asset"));
            }, this);

            this.__addToWatchlistRef = util.bind(function () {
                var asset = this.__epgEvent.get("asset");

                this.__updateWatchList({
                    remove: this.__detailInformation.isInWatchlist ? true : false,
                    add: this.__detailInformation.isInWatchlist ? false : true,
                    catalog: asset.get("catalog"),
                    assetId: asset.get("id"),
                    assetType: asset.get("type")
                })
                .then(util.bind(function (successFully) {

                    if (successFully.added) {
                        this.__detailInformation.isInWatchlist = true;

                    } else if (successFully.removed) {
                            this.__detailInformation.isInWatchlist = false;
                    }

                    this.updateButtons({
                        epgEvent: this.__epgEvent,
                        channelPermitted: this.__detailInformation.channelPermitted,
                        channelPlayable: this.__detailInformation.channelPlayable,
                        userHasPrivilegeForChannel: this.__detailInformation.userHasPrivilegeForChannel,
                        hasVodAsset: this.__detailInformation.hasVodAsset,
                        userHasPrivilegeForAsset: this.__detailInformation.userHasPrivilegeForAsset,
                        assetIsPlayable: this.assetIsPlayable(this.__epgEvent.get("asset")),
                        isInWatchlist: this.__detailInformation.isInWatchlist,
                        userIsLoggedIn: this.checkIfUserIsLoggedIn()
                    });

                }, this));

            }, this);

            tuneInEpgEvent.addEventListener(evtType.CLICK, this.__tuneInRef);
            watchEpgEvent.addEventListener(evtType.CLICK, this.__watchVodRef);
            watchTrailer.addEventListener(evtType.CLICK, this.__watchTrailerRef);
            addToWatchlist.addEventListener(evtType.CLICK, this.__addToWatchlistRef);
        },

        /**
         * Setup all asset specific data of the page.
         * @param  {Number}  eventId   Id of the asset that is currently displayed on the page.
         * @param  {Number}  channelId Id of the channel where the event is played.
         * @param  {Object}  epgExcerptEvent Object describing the epgExcerpt item that led us here.
         * @return {void}
         */
        setupDetailsInformation: function (eventId, channelId, epgExcerptEvent) {
            var setupPromise;

            if (!eventId || !channelId) {
                setupPromise = ax.promise.reject().fail(function () {
                    util.defer().then(function() {
                        dialogHelper.error({
                            reason: sLanguageManager.getString("Global.Global_NoResults"),
                            closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                            buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                        });
                    });
                });

                return setupPromise;
            }

            setupPromise = sLinearManager.getEpgEventByEventIdAndChannelId(eventId, channelId);

            return setupPromise.then(util.bind(function (epgEvent) {
                //
                // The epgEvent might be a bit 'thin' until full channel listings have been retrieved.
                // Used to mean no start/end shown when coming from the Home page 'currently running' carousel...
                // ... but we have to override the running times anyway, since cached events are retrieved
                // only by their id, which is potentially a fail when events are on more than once.
                //

                if (epgExcerptEvent && epgExcerptEvent.startDate && epgExcerptEvent.startTime && epgExcerptEvent.endDate && epgExcerptEvent.endTime) {
                    console.warn("Overriding running times from epgExcerptEvent");
                    epgEvent.set("startTime", stormUtil.parseSkyDateTimeToDate(epgExcerptEvent.startDate, epgExcerptEvent.startTime).getTime());
                    epgEvent.set("endTime", stormUtil.parseSkyDateTimeToDate(epgExcerptEvent.endDate, epgExcerptEvent.endTime).getTime());
                }

                // Epg event has an associated VOD asset. Retrieve that associated asset in order to display UI for an epg event with an associated VOD asset.
                if (epgEvent.get("assetId") && epgEvent.get("catalog")) {

                    sAssetManager.getAssetById(epgEvent.get("assetId"), epgEvent.get("catalog")).then(util.bind(function (asset) {
                        epgEvent.set("asset", asset);

                        // Associated asset found, display UI.
                        this.displayDetailInformation(epgEvent, true);
                    }, this)).fail(util.bind(function () {

                        // Associated asset not found, display same UI as for an epg event without an associated asset.
                        this.displayDetailInformation(epgEvent, false);
                    }, this));

                } else {

                    // Display UI for epg event without associated VOD asset.
                    this.displayDetailInformation(epgEvent, false);
                }

            }, this)).fail(function() {
                util.defer().then(function() {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Global.Global_NoResults"),
                        closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                });
            });
        },

        /**
         * Display detail information about an event.
         * @param  {tvedemo/model/Asset} event       Event to be displayed.
         * @param  {boolean}             hasVodAsset True if the epg event has an associated Vod asset.
         * @return {void}
         */
        displayDetailInformation: function (epgEvent, hasVodAsset) {
            promise.all([
                // Check if channel is permitted.
                this.__checkIfChannelIsPermitted(epgEvent.get("channel")),

                // Check if channel is playable
                this.__checkIfChannelIsPlayable(epgEvent.get("channel")),

                // Check if user is entitled to watch channel.
                this.__checkUserPrivileges(epgEvent.get("channel")),

                // Check if user is entitled to watch associated asset.
                this.__checkUserPrivileges(epgEvent.get("asset")),

                // Check if associated asset is in watchlist
                this.__checkIfAssetIsPresentInWatchlist(epgEvent.get("asset")),

                // Obtain the logo url for the channel
                sLinearManager.getChannelLogoUrl(epgEvent.get("channel"))
                
            ])
            .then(util.bind(function (result) {
                    var channelPermitted = result[0],
                        channelPlayable = result[1],
                        userHasPrivilegeForChannel = result[2],
                        userHasPrivilegeForAsset = result[3],
                        assetIsInWatchlist = result[4],
                        fallbackChannelLogo = result[5];

                    this.__epgEvent = epgEvent;

                    this.__detailInformation.title = this.__epgEvent.get("title");
                    this.__detailInformation.synopsis = (this.__epgEvent.get("synopsis") !== "") ? this.__epgEvent.get("synopsis") : sLanguageManager.getString("Global.Global_NoResults");
                    this.__detailInformation.cast = this.__epgEvent.get("cast");
                    this.__detailInformation.parentalRating = this.__epgEvent.get("parentalRating");
                    this.__detailInformation.length = this.__epgEvent.get("length");
                    this.__detailInformation.year = this.__epgEvent.get("year");
                    this.__detailInformation.genres = this.__epgEvent.get("genreList");
                    this.__detailInformation.onAirDate = this.__epgEvent.get("date");
                    this.__detailInformation.startTime = this.__epgEvent.get("startTime");
                    this.__detailInformation.endTime = this.__epgEvent.get("endTime");
                    this.__detailInformation.packageCode = this.__epgEvent.get("packageCode");
                    this.__detailInformation.packageColorCode = this.__epgEvent.get("packageColorCode");
                    this.__detailInformation.isHD = this.__epgEvent.get("isHD");

                    this.__detailInformation.channelPermitted = channelPermitted;
                    this.__detailInformation.channelPlayable = channelPlayable;
                    this.__detailInformation.userHasPrivilegeForChannel = userHasPrivilegeForChannel;
                    this.__detailInformation.userHasPrivilegeForAsset = userHasPrivilegeForAsset;
                    this.__detailInformation.isInWatchlist = assetIsInWatchlist;
                    this.__detailInformation.hasVodAsset = hasVodAsset;
                    
                    this.trackPage(this.__epgEvent.get("title"), epgEvent.get("channel")._attrs.title);

                    this.__detailInformation.fallbackChannelLogo = fallbackChannelLogo; // To use if no more specific logo is associated with the event (or its VOD asset).

                    this.updateCommonDetailInformation(this.__epgEvent.get("asset") || this.__epgEvent, this.__detailInformation);

                    this.updateButtons({
                        epgEvent: this.__epgEvent,
                        channelPermitted: this.__detailInformation.channelPermitted,
                        channelPlayable: this.__detailInformation.channelPlayable,
                        userHasPrivilegeForChannel: this.__detailInformation.userHasPrivilegeForChannel,
                        hasVodAsset: this.__detailInformation.hasVodAsset,
                        userHasPrivilegeForAsset: this.__detailInformation.userHasPrivilegeForAsset,
                        assetIsPlayable: this.assetIsPlayable(this.__epgEvent.get("asset")),
                        isInWatchlist: this.__detailInformation.isInWatchlist,
                        userIsLoggedIn: this.checkIfUserIsLoggedIn(),
                        liveSupported: true // Just set it to true since the disabled feature was cancelled at the last minute.
                    });

            }, this));
        },

        /**
         * Display correct set of buttons.
         * @param {Object}  epgEvent                      EpgEvent that is currently displayed.
         * @param {boolean} hasVodAsset                   True if the epg event has an associated Vod asset.
         * @param {boolean} onNow                         True if the event is on air now, otherwise false.
         * @param {boolean} userHasPrivilegeToViewContent True if user is allowed to watch the content, otherwise false.
         * @return {void}
         */
        updateButtons: function (options) {
            if (!options) {
                return;
            }
            
            // Buttons.
            var currentView = this.getView(),
                tuneInEpgEvent = currentView.find("epgEventTuneIn"),
                watchEpgEvent = currentView.find("epgEventStartVod"),
                watchTrailer = currentView.find("epgEventWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist"),
                detailDescription = currentView.find("detailDescription"),
                videoButtonContainer = currentView.find("videoButtonContainer"),

                // Display options.
                epgEvent = options.epgEvent,
                userIsLoggedIn = options.userIsLoggedIn,

                // Tune in button display options.
                channelPlayable = options.channelPlayable,
                userHasPrivilegeForChannel = options.userHasPrivilegeForChannel,
                channelPermitted = options.channelPermitted,

                // Watch button display options.
                hasVodAsset = options.hasVodAsset,
                userHasPrivilegeForAsset = options.userHasPrivilegeForAsset,
                assetIsPlayable = options.assetIsPlayable,

                // Watch trailer button display options.
                hasTrailer = this.__hasTrailer(epgEvent),

                // Add to watchlist button display options.
                isInWatchlist = options.isInWatchlist,

                liveSupported = options.liveSupported || true,

                asset = this.__epgEvent.get("asset"),

                isVodLive = asset && asset.get("currentType") === sAssetManager.SPORT_ASSET_CURRENT_TYPES.LIVE;

            tuneInEpgEvent.setText(sLanguageManager.getString("DetailPage.DetailPage_labelTuneIn"));
            watchEpgEvent.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_now_label"));
            watchTrailer.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_trailer_label"));
            addToWatchlist.setText(isInWatchlist ?
                                    sLanguageManager.getString("DetailPage.DetailPage_removeWatchlist") :
                                    sLanguageManager.getString("DetailPage.DetailPage_labeladd_to_watchlist"));


            // Make sure navigation between buttons work as expected.
            this.setButtonNavigation([
                {
                    button: tuneInEpgEvent,
                    hidden: channelPermitted ? false : true,
                    greyedOut: (channelPlayable && userHasPrivilegeForChannel && liveSupported) ? false : (userIsLoggedIn || !liveSupported ? true : false)
                },
                {
                    button: watchEpgEvent,
                    hidden: (hasVodAsset && assetIsPlayable) ? false : true,
                    greyedOut: (!liveSupported && isVodLive) ? true : (userHasPrivilegeForAsset ? false : (userIsLoggedIn  ? true : false))
                },
                {
                    button: watchTrailer,
                    hidden: hasTrailer ? false : true,
                    greyedOut: false
                },
                {
                    button: addToWatchlist,
                    hidden: hasVodAsset ? false : true,
                    greyedOut: false
                }

            ], videoButtonContainer);

            if (channelPermitted || hasTrailer || hasVodAsset) {
                detailDescription.setFocusable(false);
            }

            // Make sure that a visible button is focused.
            this.focusFirstVisibleComponent([
                tuneInEpgEvent,
                watchEpgEvent,
                watchTrailer,
                addToWatchlist,
                detailDescription
            ]);
        },

        reset: function (context) {
            var currentView = this.getView(),
                tuneInEpgEvent = currentView.find("epgEventTuneIn"),
                watchEpgEvent = currentView.find("epgEventStartVod"),
                watchTrailer = currentView.find("epgEventWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist");

            this._super(context);

            tuneInEpgEvent.removeEventListener(evtType.CLICK, this.__tuneInRef);
            watchEpgEvent.removeEventListener(evtType.CLICK, this.__watchVodRef);
            watchTrailer.removeEventListener(evtType.CLICK, this.__watchTrailerRef);
            addToWatchlist.removeEventListener(evtType.CLICK, this.__addToWatchlistRef);

            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);
        }
    });
});
/**
 * The episode details view's controller. Setup the episode details info.
 * @name Episode
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Episode
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Episode", [
    "xdk-base/ax",
    "xdk-base/class",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/episode",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/mediator",
    "tvedemo/wgt/TextSelectionListDialog",
    "xdk-base/promise",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/AlertDialog",
    "storm/mgr/sAppConfigManager",
    "xdk-base/console",
    "storm/mgr/sLanguageManager",
    "tvedemo/mgr/sAssetManager",
    "tvedemo/ctrl/DetailsBase",
    "storm/helper/util",
    "storm/event/UserEvent"
], function (
    ax,
    klass,
    view,
    movieTmpl,
    evtType,
    focusManager,
    vKey,
    util,
    mediator,
    TextSelectionListDialog,
    promise,
    Label,
    moment,
    sEndUserManager,
    sHistoryManager,
    dialogHelper,
    AlertDialog,
    sAppConfigManager,
    console,
    sLanguageManager,
    sAssetManager,
    DetailsBase,
    stormUtil,
    UserEvent) {

    "use strict";

    return klass.create(DetailsBase, {
        getDefaultState: function () {
            return {};
        }
    }, {
        __episode: null,
        __currentlySelectedIndex: null,
        __episodes: null,

        init: function () {
            this._super();
            this.setView(view.render(movieTmpl));
        },
        setup: function (context) {
            this._super(context);

            this.__handleUserDataUpdate = util.bind(function () {

                // Update buttons and entitlement indication according to the users new data.
                if (this.__episode) {
                    this.isInitialized = false;
                    this.displayDetailInformation(this.__episode);
                }

            }, this);

            mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            this.setupButtons();

            if (context.historyBack) {

                // Make sure that a button that is no longer visible has focus.
                this.isInitialized = false;
                this.displayDetailInformation(this.__episode);
                return;
            }

            this._autoPlayRef = util.bind(function() {
                this.__watchVod(this.__episode);
            }, this);

            if (context.autoPlay === true) {
                mediator.subscribe("navigated", this._autoPlayRef, true);
            }

            // TODO: Assuming that assetId and assetType will be passed in the context object.
            context.setupPending = this.setupDetailsInformation(context.selectedEpisodeId, context.catalog, context.seasonEpisodes);

        },

        setupButtons: function () {
            var currentView = this.getView(),
                watchEpisode = currentView.find("episodeStartFromVod"),
                watchTrailer = currentView.find("episodeWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist"),
                selectPreviousEpisode = currentView.find("previousEpisode"),
                selectNextEpisode = currentView.find("nextEpisode"),
                viewAllEpisodes = currentView.find("viewAllEpisodes");

            this.__watchTrailerRef = util.bind(function () {
                this.__watchTrailer(this.__episode);
            }, this);

            this.__watchEpisodeRef = util.bind(function () {
                this.__watchVod(this.__episode);
            }, this);

            this.__addToWatchlistRef = util.bind(function () {

                this.__updateWatchList({
                    remove: this.__detailInformation.isInWatchlist ? true : false,
                    add: this.__detailInformation.isInWatchlist ? false : true,
                    catalog: this.__detailInformation.catalog,
                    assetId: this.__episode.get("id"),
                    assetType: this.__episode.get("type")
                })
                .then(util.bind(function (successFully) {

                    if (successFully.added) {
                        this.__detailInformation.isInWatchlist = true;

                    } else if (successFully.removed) {
                            this.__detailInformation.isInWatchlist = false;
                    }

                    this.updateButtons({
                        episode: this.__episode,
                        userHasPrivileges: this.__detailInformation.userHasPrivileges,
                        isBlackedOut: this.__detailInformation.isBlackedOut,
                        isPlayable: this.__assetIsPlayable(this.__episode),
                        userIsLoggedIn: this.checkIfUserIsLoggedIn(),
                        isInWatchlist: this.__detailInformation.isInWatchlist
                    });

                }, this));

            }, this);

            this.__displayPreviousEpisodeRef = util.bind(this.__displayPreviousEpisode, this);
            this.__displayNextEpisodeRef = util.bind(this.__displayNextEpisode, this);
            this.__gotoViewAllEpisodesRef = util.bind(this.__gotoViewAllEpisodes, this);

            watchTrailer.addEventListener(evtType.CLICK, this.__watchTrailerRef);
            watchEpisode.addEventListener(evtType.CLICK, this.__watchEpisodeRef);
            addToWatchlist.addEventListener(evtType.CLICK, this.__addToWatchlistRef);
            selectPreviousEpisode.addEventListener(evtType.CLICK, this.__displayPreviousEpisodeRef);
            selectNextEpisode.addEventListener(evtType.CLICK, this.__displayNextEpisodeRef);
            viewAllEpisodes.addEventListener(evtType.CLICK, this.__gotoViewAllEpisodesRef);
        },

        /**
         * Setup all asset specific data of the page.
         * @param  {Number}              episodeId  Id of the asset that is currently displayed on the page.
         * @param  {String}              catalog  The catalog (meaning Snap, or SkyGo) that the asset is from.
         * @param  {tvedemo/model/Asset} episodes List of related episodes
         * @return {void}
         */
        setupDetailsInformation: function (episodeId, catalog, episodes) {
            var setupPromise;

            if (!episodeId || !catalog) {

                setupPromise = ax.promise.reject().fail(function () {
                    util.defer().then(function() {
                        dialogHelper.error({
                            reason: sLanguageManager.getString("Global.Global_NoResults"),
                            closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                            buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                        });
                    });
                });

                return setupPromise;
            }

            setupPromise = sAssetManager.getEpisodeById(episodeId, catalog).then(util.bind(function (episode) {
                var serieId = episode.get("serieId"),
                    seasonId = episode.get("seasonId"),
                    episodesPromise = episodes ? promise.resolve(episodes) : sAssetManager.getRelatedEpisodesBySerieAndSeason(serieId, seasonId, catalog);

                return episodesPromise.then(util.bind(function (episodes) {
                    this.__episodes = episodes;
                    util.each(episodes, util.bind(function (episode, arrayIndex) {

                        if (stormUtil.areAssetIdsEqual(episode.get("id"), episodeId)) {
                            this.__currentlySelectedIndex = arrayIndex;
                            return util.breaker;
                        }

                    }, this));

                    if (this.isEpisodeIndexAvailable(this.__currentlySelectedIndex)) {
                        return this.displayDetailInformation(this.__episodes[this.__currentlySelectedIndex]);
                    }

                }, this));

            }, this), function () {
                util.defer().then(function() {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Global.Global_NoResults"),
                        closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                });
            });

            return setupPromise.fail(function() {
                util.defer().then(function() {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Global.Global_NoResults"),
                        closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                });
            });
        },

        /**
         * Retrieve information to be displayed for an episode.
         * @param  {tvedemo/model/EpisodeAsset} episode   Episode to retrieve display information for.
         * @return {void}
         */
        _getEpisodeInformation: function (episode) {
            return sAssetManager.getEpisodeById(episode.get("id"), episode.get("catalog")).then(util.bind(function (episodeInformation) {
                return episodeInformation;
            }, this), util.bind(function () {
                return episode;
            }, this));
        },

        /**
         * Display information for an episode.
         * @param  {tvdedemo/model/EpisodeAsset} episode The information to display information for.
         * @return {void}
         */
        displayDetailInformation: function (episode) {

            return this._getEpisodeInformation(episode).then(util.bind(function (episodeInformation) {

                return promise.all([
                    this.__checkUserPrivileges(episodeInformation),
                    this.__checkIfAssetIsPresentInWatchlist(episodeInformation),
                    this.__getBookmarkForAsset(episode.get('id'))
                ]).then(util.bind(function (result) {

                    var userHasPrivileges = result[0],
                        assetIsInWatchlist = result[1],
                        bookmark = result[2];

                    this.__episode = episodeInformation;
                    
                    this.__detailInformation.title = this.__episode.get("serieTitle") + this.__wrapEpisodeTitle(this.__episode);;
                    this.__detailInformation.season = this.__episode.get("seasonNumber");
                    this.__detailInformation.episode = this.__episode.get("episodeNumber");
                    this.__detailInformation.serieTitle = this.__episode.get("serieTitle");
                    this.__detailInformation.synopsis = this.__episode.get("synopsis");
                    this.__detailInformation.cast = this.__episode.get("cast");
                    this.__detailInformation.parentalRating = this.__episode.get("parentalRating");
                    this.__detailInformation.length = this.__episode.get("length");
                    this.__detailInformation.year = this.__episode.get("year");
                    this.__detailInformation.genres = this.__episode.get("genreList");
                    this.__detailInformation.onAirDate = this.__episode.get("date");
                    this.__detailInformation.packageCode = this.__episode.get("packageCode");
                    this.__detailInformation.packageColorCode = this.__episode.get("packageColorCode");
                    this.__detailInformation.isBlackedOut = this.__episode.get("blackedOut");
                    this.__detailInformation.isInWatchlist = assetIsInWatchlist;
                    this.__detailInformation.userHasPrivileges = userHasPrivileges;
                    this.__detailInformation.catalog = this.__episode.get("catalog");
                    this.__detailInformation.isHD = this.__episode.get("isHD");
                    
                    var combinedTitle = this.__episode.get("serieTitle") + " S" + episode.get("seasonNumber") + " E" + episode.get("episodeNumber") + ": " + episode.get("title");
                    this.trackPage(combinedTitle);
                
                    this.updateCommonDetailInformation(this.__episode, this.__detailInformation);

                    this.updateButtons({
                        episode: this.__episode,
                        userHasPrivileges: this.__detailInformation.userHasPrivileges,
                        isBlackedOut: this.__detailInformation.isBlackedOut,
                        isPlayable: this.__assetIsPlayable(this.__episode),
                        userIsLoggedIn: this.checkIfUserIsLoggedIn(),
                        isInWatchlist: this.__detailInformation.isInWatchlist,
                        bookmark: bookmark
                    });

                }, this));
            }, this));
        },

        /**
         * Setup correct set of buttons.
         * @param  {Object}  asset                         Asset that is currently displayed.
         * @param  {boolean} userHasPrivilegeToViewContent True if user is allowed to watch the content, otherwise false.
         * @return {void}
         */
        updateButtons: function (options) {

            if (!options) {
                return;
            }

            // Buttons.
            var currentView = this.getView(),
                watchEpisode = currentView.find("episodeStartFromVod"),
                watchTrailer = currentView.find("episodeWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist"),
                detailDescription = currentView.find("detailDescription"),
                viewAllEpisodes = currentView.find("viewAllEpisodes"),
                videoButtonContainer = currentView.find("videoButtonContainer"),

                // Display options.
                episode = options.episode,
                userHasPrivileges = options.userHasPrivileges,
                isBlackedOut = options.isBlackedOut,
                isPlayable = options.isPlayable,
                userIsLoggedIn = options.userIsLoggedIn,
                isInWatchlist = options.isInWatchlist,
                hasTrailer = this.__hasTrailer(episode);

            watchEpisode.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_now_label"));
            watchTrailer.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_trailer_label"));
            addToWatchlist.setText(isInWatchlist ?
                                    sLanguageManager.getString("DetailPage.DetailPage_removeWatchlist") :
                                    sLanguageManager.getString("DetailPage.DetailPage_labeladd_to_watchlist"));

            // Make sure navigation between buttons work as expected.
            this.setButtonNavigation([
                {
                    button: watchEpisode,
                    hidden: (isBlackedOut || !isPlayable) ? true : false,
                    greyedOut: userHasPrivileges ? false : (userIsLoggedIn ? true : false)
                },
                {
                    button: watchTrailer,
                    hidden: hasTrailer ? false : true,
                    greyedOut: false
                },
                {
                    button: addToWatchlist,
                    hidden: isBlackedOut ? true : false,
                    greyedOut: false
                },
                {
                    button: viewAllEpisodes,
                    hidden: false,
                    greyedOut: false
                }

            ], videoButtonContainer);

            detailDescription.setFocusable(false);
            
            if (!this.isInitialized) {

                // Make sure that a visible button is focused.
                this.focusFirstVisibleComponent([
                    watchEpisode,
                    watchTrailer,
                    addToWatchlist,
                    viewAllEpisodes,
                    detailDescription
                ]);
                this.isInitialized = true;
            }
        },

        isEpisodeIndexAvailable: function(index) {
            var currentView = this.getView(),
                selectPreviousEpisode = currentView.find("previousEpisode"),
                selectNextEpisode = currentView.find("nextEpisode"),
                viewAllEpisodes = currentView.find("viewAllEpisodes"),
                detailDescription = currentView.find("detailDescription"),
                episodeIndexAvailable = true;

            if (index < 0 || index >= (this.__episodes && this.__episodes.length) ) {
                episodeIndexAvailable = false;
            }

            if (index <= 0) {
                selectPreviousEpisode.hide();
            } else {
                selectPreviousEpisode.show();
            }

            if (index >= (this.__episodes && this.__episodes.length -1) ) {
                selectNextEpisode.hide();
                selectPreviousEpisode.setOption("nextRight", "detailDescription");
            } else {
                selectNextEpisode.show();
                selectPreviousEpisode.setOption("nextRight", "selectNextEpisode");
            }

            // Only one episode which means we should not swap.
            if (!this.__episodes || this.__episodes.length <= 1) {
                selectPreviousEpisode.hide();
                selectNextEpisode.hide();

                viewAllEpisodes.setOption("nextDown", viewAllEpisodes);
            }

            if (selectNextEpisode.isHidden() && !selectPreviousEpisode.isHidden()) {

                if (focusManager.isCompFocused(selectNextEpisode)) {
                    focusManager.focus(selectPreviousEpisode);
                }

                viewAllEpisodes.setOption("nextDown", selectPreviousEpisode);

            }

            if (selectPreviousEpisode.isHidden() && !selectNextEpisode.isHidden()) {

                if (focusManager.isCompFocused(selectPreviousEpisode)) {
                    focusManager.focus(selectNextEpisode);
                }

                viewAllEpisodes.setOption("nextDown", selectNextEpisode);

            }

            return episodeIndexAvailable;
        },

        __displayNextEpisode: function () {

            if (this.isEpisodeIndexAvailable(this.__currentlySelectedIndex + 1)) {
                this.__currentlySelectedIndex++;

                var episodeToDisplay = this.__episodes && this.__episodes[this.__currentlySelectedIndex];

                this.displayDetailInformation(episodeToDisplay);
            }
        },

        __displayPreviousEpisode: function () {

            if (this.isEpisodeIndexAvailable(this.__currentlySelectedIndex - 1)) {
                this.__currentlySelectedIndex--;

                var episodeToDisplay = this.__episodes && this.__episodes[this.__currentlySelectedIndex];

                this.displayDetailInformation(episodeToDisplay);
            }
        },

        /**
         * Go to page were all episodes are displayed.
         * @return {void}
         */
        __gotoViewAllEpisodes: function () {
            var serieId = this.__episode.get("serieId"),
                catalog = this.__episode.get("catalog");

            mediator.publish("navigate", {
                path: "Main/TVShow",
                state: {
                    serieId: serieId,
                    catalog: catalog
                }
            });
        },

        /**
         * Wrap the episodes title, including season and episode number, within a container.
         * @param {tvedemo/model/EpisodeAsset} episode Episode to wrap the title for.
         * @return {String} Episode title.
         */
        __wrapEpisodeTitle: function (episode) {

            if (!episode) {
                return "";
            }

            return "<span>" + " S" + episode.get("seasonNumber") + " E" + episode.get("episodeNumber") + ": " + episode.get("title") + "</span>";
        },

        reset: function (context) {
            this._super(context);

            var currentView = this.getView(),
                watchEpisode = currentView.find("episodeStartFromVod"),
                watchTrailer = currentView.find("episodeWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist"),
                selectPreviousEpisode = currentView.find("previousEpisode"),
                selectNextEpisode = currentView.find("nextEpisode"),
                viewAllEpisodes = currentView.find("viewAllEpisodes");

            watchTrailer.removeEventListener(evtType.CLICK, this.__watchTrailerRef);
            watchEpisode.removeEventListener(evtType.CLICK, this.__watchEpisodeRef);
            addToWatchlist.removeEventListener(evtType.CLICK, this.__addToWatchlistRef);
            selectPreviousEpisode.removeEventListener(evtType.CLICK, this.__displayPreviousEpisodeRef);
            selectNextEpisode.removeEventListener(evtType.CLICK, this.__displayNextEpisodeRef);
            viewAllEpisodes.removeEventListener(evtType.CLICK, this.__gotoViewAllEpisodesRef);

            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            mediator.unsubscribe("navigated", this._autoPlayRef);
        }


    });
});
define("xdk-ui-grid/loopedGridStgy", ["xdk-base/device/vKey", "xdk-ax/data/interface/Datasource"], function (vKey, IDatasource) {
    "use strict";
    var mod = function (number, divisor) { // modulo operation
            return ((number % divisor) + divisor) % divisor;
        },
        strategies = {};

    // ======== pre-ready strategies ========
    strategies.LOOPED_PREREADY_STGY = function (frontBoundary, state) {
        state.selectedDsIndex = frontBoundary * state.cols;
        state.selectedGridRow = frontBoundary;
    };
        // ======== check scrollable strategies ========
    strategies.LOOPED_CHECK_SCROLLABLE_STGY = function (curState, toState) {
        return true;
    };
        // ======== onupdate strategies ========
    strategies.LOOPED_ONUPDATE_STGY = function (evt, state, ds) {
        if (evt.action === "reset") {
            //no need to change state and redraw directly.
            return true;
        }
        var dataCount = ds.getTotalCount(),
            firstSlotDsIndex = state.firstSlotDsIndex,
            lastSlotDsIndex = firstSlotDsIndex + state.cols * state.rows - 1,
            updatedFrom = evt.index,
            updatedTo = evt.index + evt.length;

        //when it is fetch and no looped and updatedTo is both less than the first item and last item (assume no total count change)
        if (evt.action === "fetch" &&
            dataCount > state.cols * state.rows &&
            ((updatedTo < mod(firstSlotDsIndex, dataCount) &&
                    updatedTo < mod(lastSlotDsIndex, dataCount)) ||
                (updatedFrom > mod(firstSlotDsIndex, dataCount) &&
                    updatedFrom > mod(lastSlotDsIndex, dataCount)))
        ) {
            return false;
        }

        //since it is loop and there are always has item at the position unless it is empty
        state.selectedDsIndex = firstSlotDsIndex + state.selectedGridRow * state.cols + state.selectedGridCol;

        //no item inside then return
        if (dataCount === 0) {
            state.selectedGridRow = -1;
            state.selectedDsIndex = -1;
        }

        //to ensure after remove all and insert to run the preready stgy which then set the correct first selected index and thus focus on the right item
        if (evt.action === "insert" && dataCount === evt.newData.length) {
            this._prereadyStgy(state);
        }
        return true;
    };
    // ======== onupdate for finite datasource strategies ========
    strategies.LOOPED_FINITEDS_ONUPDATE_STGY = function (evt, state, ds) {

        if (evt.action === IDatasource.ACTION.RESET) {
            //no need to change state and redraw directly.
            return true;
        }
        var dataCount = ds.getTotalCount(),
            firstSlotDsIndex = state.firstSlotDsIndex,
            lastSlotDsIndex = firstSlotDsIndex + state.cols * state.rows - 1,
            updatedFrom,
            updatedTo,
            i, segments = [],
            modFirstSlotDsIndex,
            modLastSlotDsIndex;

        // perform checking when the datacount is larger than the screen size which may not appear on the screen
        if (evt.action === IDatasource.ACTION.FETCH && dataCount > state.cols * state.rows) {
            segments = evt.segments;
            //check if updatedFrom updatedTo is outside the first item and last item
            for (i = 0; i < segments.length; i++) {

                updatedFrom = segments[i].index;
                updatedTo = updatedFrom + segments[i].length;
                modFirstSlotDsIndex = mod(firstSlotDsIndex, dataCount);
                modLastSlotDsIndex = mod(lastSlotDsIndex, dataCount);

                if ((modFirstSlotDsIndex > modLastSlotDsIndex && updatedFrom < modFirstSlotDsIndex && updatedFrom > modLastSlotDsIndex &&
                        updatedTo > modLastSlotDsIndex && updatedTo < modFirstSlotDsIndex) ||
                    (modFirstSlotDsIndex < modLastSlotDsIndex && updatedFrom > modFirstSlotDsIndex && updatedFrom > modLastSlotDsIndex &&
                        updatedTo > modFirstSlotDsIndex && updatedTo > modLastSlotDsIndex)) {
                    return false;
                }

            }
        }

        //since it is loop and there are always has item at the position unless it is empty
        state.selectedDsIndex = firstSlotDsIndex + state.selectedGridRow * state.cols + state.selectedGridCol;

        //no item inside then return
        if (dataCount === 0) {
            state.selectedGridRow = -1;
            state.selectedDsIndex = -1;
        }

        //to ensure after remove all and insert to run the preready stgy which then set the correct first selected index and thus focus on the right item
        if (evt.action === IDatasource.ACTION.INSERT && dataCount === evt.newData.length) {
            this._prereadyStgy(state);
        }
        return true;
    };
        // ======== check selectable strategies ========
    strategies.LOOPED_CHECK_SELECTABLE_STGY = function (frontBoundary, endBoundary, curState, toState) {
        //if no more item then it is not selectable
        if (curState.ds.getTotalCount() <= 0) {
            return false;
        }
        return true;
    };
    // ======== data mapping strategies ========
    strategies.LOOPED_DATA_MAPPING_STGY = function (curState, dataArr, gridRow, gridCol, dsIndex) {
        var idx = mod(gridRow * curState.cols + gridCol, dataArr.length);
        return dataArr[idx];
    };
        // ======== key navigation strategies ========
    strategies.LOOPED_BOUNDARY_KEY_NAVIGATION_STGY = function (isVertical, frontBoundary, endBoundary, key, state) {
        var rowStep, curDsIndex = state.selectedDsIndex,
            dataCount = state.ds.getTotalCount(),
            curGridRow = state.selectedGridRow,
            toGridRow, lastDsRow, toDsRow;

        if (isVertical) {
            switch (key) {
            case vKey.UP.id:
                return {
                    colChange: -1
                };
            case vKey.DOWN.id:
                return {
                    colChange: 1
                };
            case vKey.LEFT.id:
                rowStep = -1;
                break;
            case vKey.RIGHT.id:
                rowStep = 1;
                break;
            default:
                break;
            }
        } else {
            switch (key) {
            case vKey.UP.id:
                rowStep = -1;
                break;
            case vKey.DOWN.id:
                rowStep = 1;
                break;
            case vKey.LEFT.id:
                return {
                    colChange: -1
                };
            case vKey.RIGHT.id:
                return {
                    colChange: 1
                };
            default:
                break;
            }
        }


        if (frontBoundary <= 0 && endBoundary <= 0) { // no boundary actually
            return {
                rowChange: rowStep
            };
        }

        toGridRow = curGridRow + rowStep;
        toDsRow = Math.floor(curDsIndex / state.cols) + rowStep;
        lastDsRow = Math.floor((dataCount - 1) / state.cols);

        // inside the forbidden boundary
        if (toGridRow < frontBoundary || toGridRow >= state.rows - endBoundary) {
            return {
                scroll: rowStep
            };
        }

        return {
            rowChange: rowStep
        };
    };


    return strategies;
});
/**
 * Finite Datasource has implemented datasource interface and inherit from the {@link xdk-ax/data/interface/Datasource} which provides extend feature for datasource with overflow.
 * It can be used in the {@link xdk-ui-grid/LoopedGrid} which support overflow data.
 * Since it supports overflow data, developers need to setTotalCount first before any implementation or usage on the datasource.
 *
 * For example, the totalCount is 100.
 * Developer can getRange(50,140) which will return the data with dsIndex [50,51...98,99,0,1,...39].
 * When getRange with overflow data, it will separate into 2 segments (which are 0 to 39 and 50 to 99) and then load them via the dataLoader.
 * After that, it will concatenate the data and return back the data to developers.
 *
 * Apart from the previous example,
 * Developer can also getRange(98,5) which will return the data with dsIndex [98,99,0,1,2,3,4].
 * When getRange with the above case, it will separate into 2 segments (which are 0 to 4 and 98 to 99) and then load them via the dataLoader.
 * After that, it will concatenate the data and return back the data to developers.
 *
 *
 * Meanwhile, fetch, remove, insert function will also support the overflow data.
 * Since it may involve more than one range, finite datasource will dispatch another event with segments as properties providing each segments information.
 * For example, when fetch(98,5). It will load 2 segments of data like 98 to 99 and 0 to 4. And then it will dispatch the event for the handler such as loopedGrid.
 * The handler will receive one event instead of 2 events in the original  {@link xdk-ax/data/interface/Datasource}.
 *
 * @class xdk-ax/data/FiniteDatasource
 */
define("xdk-ax/data/FiniteDatasource", ["xdk-base/class", "xdk-base/core", "xdk-base/util", "xdk-base/promise", "xdk-base/console", "xdk-base/exception", "xdk-ax/data/Datasource", "xdk-ax/data/interface/Datasource"],
    function (klass, core, util, promise, console, exception, Ds, IDatasource) {
        "use strict";

        function mod(number, divisor) { // modulo operation
            //in wiiU 1%0 is 0, so we try to standardize the %0 which should be NaN in all the platform
            if (divisor === 0) {
                return NaN;
            }
            return ((number % divisor) + divisor) % divisor;
        }

        return klass.create(Ds, {
            /**
             * Dispatched when datasource update {@see xdk-ax/data/Datasource.EVT_UPDATED}
             * @event
             * @type {Object}
             * @property {String} action which dispatch
             * @memberof xdk-ax/data/FiniteDatasource
             */
            EVT_UPDATED: Ds.EVT_UPDATED,
            /**
             * Dispatched when datasource update for the finiteds
             * @event EVT_FINITEDS_UPDATED
             * @type {Object}
             * @property {IDatasource.ACTION} action which dispatch like FETCH, REMOVE, INSERT, RESET
             * @property {xdk-ax/data/FiniteDatasource.NewSegment[] | xdk-ax/data/FiniteDatasource.RemoveSegment[]} [segments] the possible segments for the remove, fetch, insert
             * @memberof xdk-ax/data/FiniteDatasource
             * @example
             * ds.addEventListener(ds.EVT_FINITEDS_UPDATED, function(evt){
             *     switch(evt.action){
             *     case IDatasource.ACTION.FETCH:
             *     case IDatasource.ACTION.INSERT:
             *        //NewSegment
             *        var i, segments = evt.segments;
             *        for(i = 0 ; i < segments.length ; i++){
             *           //do sth or checking
             *           //segments.newData
             *           //segments.index
             *           //segments.length
             *        }
             *     break;
             *     case IDatasource.ACTION.REMOVE:
             *         //RemoveSegment
             *        for(i = 0 ; i < segments.length ; i++){
             *            //do sth or checking
             *           //segments.removedData
             *           //segments.index
             *           //segments.length
             *        }
             *     break;
             *     case IDatasource.ACTION.RESET:
             *         //do sth
             *     break;
             *     }
             * });
             *
             */
            /**
             * The insert/fetch segment
             * @typedef {Object} NewSegment
             * @property {Number} index The from index of the segment
             * @property {Object[]} newData the data array
             * @property {Number} length
             * @memberof xdk-ax/data/FiniteDatasource
             */
            /**
             * The remove segment
             * @typedef {Object} RemoveSegment
             * @property {Number} index The from index of the segment
             * @property {Object[]} removedData the data array
             * @property {Number} length
             * @memberof xdk-ax/data/FiniteDatasource
             */
            EVT_FINITEDS_UPDATED: "ui:finiteds:updated"
        }, {
            /**
             * Override the original to load data. It is different from the original which automtically set the fetched data into datasource directly.
             * Developer need to set the data into finite datasource after this function.
             * @method
             * @param {Number} from the start index of fetching
             * @param {Number} size the original size to requested fetch
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} when dataloader is not set
             * @protected
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            _load: function (from, size) {

                if (!util.isFunction(this._dataLoader)) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, "Datasource: invalid data loader function."));
                }

                from = from || 0;

                size = size || 0;

                return this._dataLoader(from, size);
            },
            /**
             * Get a range of data.
             * @method
             * @param {Number} from from index
             * @param {Number} to to index exclusively. If it is undefined, all the data from index will be obtained.
             * @returns {Promise.<Object[]>} the data in range
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} When the total count is not set or the totalcount is 0.
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>} when dataloader is not set
             * @public
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            getRange: function (from, to) {
                var totalCount = this.getTotalCount(),
                    self = this,
                    newRange = [],
                    notFetchedRange = [],
                    i, getRangePromise, pendingProcessedData = [];

                if (util.isUndefined(to)) {
                    to = totalCount;
                }

                //handle data part

                try {
                    //update the range, it will separate into 2 ranges when it consists exceeds the range
                    newRange = this.__updateRange(from, to);
                } catch (ex) {
                    return promise.reject(ex);
                }

                //the first checking
                util.each(newRange, function (range) {

                    notFetchedRange = notFetchedRange.concat(self.__checkFetchedData(range.from, range.to));

                });


                //create a promise which store for each range, it will fetch range by range
                getRangePromise = promise.resolve();

                for (i = 0; i < notFetchedRange.length; i++) {

                    getRangePromise = getRangePromise.then(util.bind(function (fromIndex, toIndex) {
                        var actualFrom, fetchSize;

                        //to prevent the data is already included into previous load
                        if (self.hasData(fromIndex, toIndex)) {
                            return promise.resolve();
                        }

                        actualFrom = fromIndex;
                        fetchSize = toIndex - actualFrom;

                        //to load the data
                        return self._load(actualFrom, fetchSize).then(util.bind(function (from, size, loadedObj) {

                            //which is for setFetch data after all the _load
                            pendingProcessedData.push(

                                {
                                    "fetchOpts": {
                                        "from": from,
                                        "size": size
                                    },
                                    "loadedObj": loadedObj
                                }

                            );
                        }, this, actualFrom, fetchSize));

                    }, null, notFetchedRange[i].from, notFetchedRange[i].to));

                }

                return getRangePromise.then(function () {

                    //set the fetched data at the end of the getRange
                    util.each(pendingProcessedData, function (eachRange) {

                        self._processFetchedData(eachRange.fetchOpts, eachRange.loadedObj);

                    });

                }).then(util.bind(this.__getOverflowFetchedData, this, from, to));

            },
            /**
             * Obtain the overflowed data array from the overflowed from and to
             * @method
             * @param {Number} from index of the data to check
             * @param {Number} to the end index of the data to check exclusively
             * @returns {Object[]} The data array
             * @private
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            __getOverflowFetchedData: function (from, to) {
                //handle return data part which may concat the data based on the getRange
                var total = this.getTotalCount(),
                    resultArr = [],
                    tempFrom = from,
                    tempTo = to,
                    modFrom = mod(tempFrom, total),
                    modTo = mod(tempTo, total);

                //convert the `to` into the bigger number
                if (tempFrom > tempTo) {
                    tempTo = total + tempTo;
                }

                //after loaded all data, get back all the data
                if (tempTo < total) {
                    resultArr = resultArr.concat(this.__getFetchedData(modFrom, tempTo));
                    return resultArr;
                }

                resultArr = resultArr.concat(this.__getFetchedData(modFrom, total));
                tempFrom = tempFrom + total - modFrom;

                while (tempTo - tempFrom >= total) {
                    modFrom = mod(tempFrom, total);
                    resultArr = resultArr.concat(this.__getFetchedData(0, total));
                    tempFrom += total;
                }

                if (tempTo > tempFrom) {
                    modFrom = mod(tempFrom, total);
                    resultArr = resultArr.concat(this.__getFetchedData(modFrom, modTo));
                }

                return resultArr;
            },
            /**
             * Checks if data of specific index exists
             * @method
             * @param {Number} from index of the data to check
             * @param {Number} [to] the end index of the data to check exclusively
             * @returns {Boolean} if it exists
             * @public
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            hasData: function (from, to) {
                var ret = true,
                    newRange = [];

                //check the range if available
                if (!this.__checkRange(from, to)) {
                    return false;
                }

                //update the range, it will separate into 2 ranges when it exceeds the range e.g 98 - 2.
                try {
                    newRange = this.__updateRange(from, to);
                } catch (ex) {
                    return false;
                }

                //check for every newRange to find if data exists and return.
                util.each(newRange, util.bind(function (curRange) {

                    ret = this.__hasFetchedData(curRange.from, curRange.to);

                    if (!ret) {
                        return util.breaker;
                    }

                }, this));

                return ret;
            },
            /**
             * Fetch a number of data into datasource, regardless whether data is loaded before
             * Emits a {@link xdk-ax/data/FiniteDatasource.EVT_FINITEDS_UPDATED} event with "action" property equals to IDatasource.ACTION.FETCH
             * @method
             * @param {Number} from the index to start fetching
             * @param {Number} [size=1] the size to fetch
             * @returns {Promise.<Undefined>}
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>}  When the toal count or the dataloader are not set
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>}  When the range is not valid
             * @public
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            fetch: function (from, size) {
                var to, fetchPromise = [],
                    newRange = [],
                    i, curFrom, curSize, pendingProcessedData = [],
                    fetchedSegments = [],
                    self = this,
                    totalCount = this.getTotalCount();

                //if  the range is invalid, throw exception
                if (totalCount === -1) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, "Datasource: Total count is not set."));
                }

                if (!util.isNumber(size)) {
                    size = 1;
                }

                if (from >= totalCount || size > totalCount || from < 0) {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Datasource: invalid range."));
                }

                to = from + size;

                try {
                    //update the range, it will separate into 2 ranges when it consists the range
                    newRange = this.__updateRange(from, to, true);
                } catch (ex) {
                    return promise.reject(ex);
                }

                for (i = 0; i < newRange.length; i++) {
                    curFrom = newRange[i].from;
                    curSize = newRange[i].to - curFrom;

                    fetchPromise.push(this._load(curFrom, curSize).then(util.bind(function (from, size, loadedObj) {
                        //which is the for setFetchdata after load
                        pendingProcessedData.push({
                            "fetchOpts": {
                                "from": from,
                                "size": size
                            },
                            "loadedObj": loadedObj
                        });

                        //which is for event dispatcher
                        fetchedSegments.push({
                            index: from,
                            newData: loadedObj.data,
                            length: loadedObj.data.length
                        });

                    }, this, curFrom, curSize)));

                }

                return promise.all(fetchPromise).then(function () {

                    //set the fetched data at the end of the getRange
                    util.each(pendingProcessedData, function (eachRange) {

                        self._processFetchedData(eachRange.fetchOpts, eachRange.loadedObj);

                    });

                    //dispatch the first segment
                    if (fetchedSegments.length > 0 && fetchedSegments[0]) {

                        self.dispatchEvent(self.constructor.EVT_UPDATED, util.extend({
                            action: IDatasource.ACTION.FETCH
                        }, fetchedSegments[0]));

                    }

                    //dispatches updated assuming data is updated from source
                    self.dispatchEvent(self.constructor.EVT_FINITEDS_UPDATED, {
                        action: IDatasource.ACTION.FETCH,
                        segments: fetchedSegments
                    });

                });

            },
            /**
             * Remove a range of items from the current data fetched. If the totalcount is not set, it is unable to remove.
             * Emits a {@link xdk-ax/data/FiniteDatasource.EVT_FINITEDS_UPDATED} event with "action" property equals to IDatasource.ACTION.REMOVE
             * @method
             * @param {Number} from starting index of items to be removed (0-th indexed)
             * @param {Number} [to] end index of items to be removed, removes only one item is not provided
             * @returns {Promise.<Undefined>}
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>}  When the range is not valid
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>}  When the toal count or the dataupdater are not set
             * @memberof xdk-ax/data/FiniteDatasource#
             * @public
             */
            remove: function (from, to) {
                var newRange = [],
                    removeRangePromise,
                    removedData = [],
                    removedSegments = [],
                    self = this,
                    i, ret;


                if (!util.isFunction(this._dataUpdater)) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, "Datasource: invalid data updater function."));
                }

                if (!util.isNumber(from)) {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Datasource: invalid from index"));
                }

                if (!util.isNumber(to)) {
                    to = from + 1;
                }

                try {
                    ret = this.__checkRange(from, to);
                } catch (ex) {
                    return promise.reject(ex);
                }

                if (!ret) {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Datasource: invalid range."));
                }

                try {
                    //update the range, it will separate into 2 ranges when it exceeds the range
                    newRange = this.__updateRange(from, to);
                } catch (ex) {
                    return promise.reject(ex);
                }

                //create a promise which store for each range, it will fetch range by range
                removeRangePromise = promise.resolve();

                //to start with descending order
                for (i = newRange.length - 1; i > -1; i--) {

                    removeRangePromise = removeRangePromise.then(util.bind(this._dataUpdater, this, IDatasource.ACTION.REMOVE, {
                        from: newRange[i].from,
                        to: newRange[i].to
                    })).then(function (removedObj) {
                        if (!removedObj) {
                            throw core.createException("Datasource: invalid data update via remove: no removed data received");
                        }

                        var updatedFrom = removedObj.from,
                            updatedTo = removedObj.to;

                        if (util.isNumber(updatedFrom)) {
                            removedData = self.__removeFetchedData(updatedFrom, updatedTo);
                        }

                        removedSegments.push({
                            index: updatedFrom,
                            removedData: removedData,
                            length: removedData.length
                        });

                    });

                }

                if (newRange.length > 0) {
                    return removeRangePromise.then(function () {

                        //emit event
                        self.dispatchEvent(self.constructor.EVT_UPDATED, util.extend({
                            action: IDatasource.ACTION.REMOVE
                        }, removedSegments[0]));


                        //emit event when finished remove
                        self.dispatchEvent(self.constructor.EVT_FINITEDS_UPDATED, {
                            action: IDatasource.ACTION.REMOVE,
                            segments: removedSegments
                        });
                    });
                }

                return promise.resolve();
            },
            /**
             * Insert an array of data into currently fetch data. If the totalcount is not set, it is unable to insert.
             * Emits a {@link xdk-ax/data/FiniteDatasource.EVT_FINITEDS_UPDATED} event with "action" property equals to IDatasource.ACTION.INSERT
             * @method
             * @param {Array} newData An array of items to be inserted
             * @param {Number} [index] position of the insertion
             * @returns {Promise.<Undefined>} no actual return value
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>}  When the range is not valid
             * @throws {Promise.<module:xdk-base/exception.ILLEGAL_STATE>}  When the toal count or the dataupdater are not set
             * @memberof xdk-ax/data/FiniteDatasource#
             * @public
             */
            insert: function (newData, index) {
                var totalCount = this.getTotalCount();

                if (!util.isFunction(this._dataUpdater)) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, "Datasource: invalid data updater function."));
                }

                if (totalCount === -1) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, "Datasource: Total count is not set."));
                }

                if (index > totalCount || index < 0) {
                    return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Datasource: invalid index."));
                }

                if (!util.isArray(newData)) {
                    newData = [newData];
                }

                if (!util.isNumber(index)) {
                    index = totalCount;
                }

                return this._dataUpdater(IDatasource.ACTION.INSERT, {
                    newData: newData,
                    from: index
                }).then(util.bind(function (insertedObj) {

                    if (!insertedObj) {
                        throw core.createException("Datasource: invalid data update via insert: no new data received");
                    }

                    var updatedData = insertedObj.newData,
                        updatedIndex = insertedObj.index;

                    if (util.isArray(updatedData)) {
                        this.__insertFetchedData(updatedIndex, updatedData);
                    }

                    // emit event
                    this.dispatchEvent(this.constructor.EVT_UPDATED, {
                        action: IDatasource.ACTION.INSERT,
                        index: updatedIndex,
                        length: updatedData.length,
                        newData: updatedData
                    });

                    this.dispatchEvent(this.constructor.EVT_FINITEDS_UPDATED, {
                        action: IDatasource.ACTION.INSERT,
                        index: updatedIndex,
                        length: updatedData.length,
                        newData: updatedData
                    });


                }, this));

            },
            /**
             * Removes all data and resets this datasource.
             * @method
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            reset: function () {
                this._super();
                this.dispatchEvent(this.constructor.EVT_FINITEDS_UPDATED, {
                    action: IDatasource.ACTION.RESET
                });
            },
            /**
             * The return type of the data loader.
             * @typedef {Object} Segment
             * @property {Number} from The from index of the segment
             * @property {Number} to the end index of the segment
             * @memberof xdk-ax/data/FiniteDatasource
             */
            /**
             * To find the related range involved
             * @private
             * @param {Number} fromRange the start index
             * @param {Number} toRange the end index exclusively.
             * @param {Boolean} [originalOrder=false] If original order is true, it will give [{from:98,to:99}, {from:0,to:2}] instead of [{from:0,to:2}, {from:98,to:99}]
             * @returns {xdk-ax/data/FiniteDatasource.Segment[]} Array of the segment of related item in ascending order.
             * @method
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            __updateRange: function (fromRange, toRange, originalOrder) {
                var totalCount = this.getTotalCount(),
                    resultArr = [],
                    newFromRange, newToRange;

                //if  the range is invalid, throw exception
                if (totalCount === -1) {
                    throw core.createException(exception.ILLEGAL_STATE, "Datasource: Total count is not set.");
                }

                if (totalCount === 0) {
                    throw core.createException(exception.ILLEGAL_STATE, "Datasource: No more data.");
                }

                //if toRange smaller, it will be the case when size is 100, from:99, to: 2.. Then convert to become 102 which will be easier to map with and find the desired range.
                if (toRange < fromRange) {
                    toRange += totalCount;
                }

                //since it is over the total count size, it need to fetch all the item
                if (toRange - fromRange >= totalCount) {

                    resultArr.push({
                        from: 0,
                        to: totalCount
                    });

                    return resultArr;
                }

                newFromRange = mod(fromRange, totalCount);
                newToRange = mod(toRange, totalCount);

                //if the toRange exceed the limit, it will automatically mod the toRange
                if (toRange > totalCount) {

                    //separate into 2 ranges with ascending order
                    if (originalOrder) {

                        resultArr.push({
                            from: fromRange,
                            to: totalCount
                        });

                        resultArr.push({
                            from: 0,
                            to: newToRange
                        });

                        return resultArr;

                    }


                    resultArr.push({
                        from: 0,
                        to: newToRange
                    });

                    resultArr.push({
                        from: fromRange,
                        to: totalCount
                    });

                    return resultArr;
                }

                //when there is no change, return the originally range via array of range.

                resultArr.push({
                    from: fromRange,
                    to: toRange
                });

                return resultArr;

            },
            /**
             * To check if the range is available. It only allows parameter within the the totalcount size. E.g totalCount is 100. from and to can only be within 0-99.
             * from is 99, to is 3 / from is 3, to is 99 are possible cases
             * @private
             * @param {Number} from the start index
             * @param {Number} to the end index exclusively
             * @returns {Boolean} true if it is an available range.
             * @method
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            __checkRange: function (from, to) {

                var total = this.getTotalCount();

                //fail to check range when the total count is -1
                if (total === -1) {
                    throw core.createException(exception.ILLEGAL_STATE, "Datasource: Total count is not set.");
                }

                //since to is exclusively, minus-1 is the last dsIndex
                if (!this.__checkIndex(from) || !this.__checkIndex(to - 1)) {
                    return false;
                }

                return true;

            },
            /**
             * To check if the index is within the range. Total count must be set before any action.
             * @private
             * @param {Number} no the index
             * @returns {Boolean} true if it is an valid index
             * @method
             * @memberof xdk-ax/data/FiniteDatasource#
             */
            __checkIndex: function (no) {
                var total = this.getTotalCount();

                if (total === -1) {
                    return false;
                }

                if (no < 0 || no >= total) {
                    return false;
                }

                return true;
            },
            /**
             * Return object of fetched data in the datasource
             * @method getFetchedData
             * @param {Number} index the index of data
             * @returns {Object|null} required data object or null when it is not valid index like negative index or datasource total count is less than 1.
             * @memberof xdk-ax/data/FiniteDatasource#
             * @public
             */
            getFetchedData: function (index) {
                var total = this.getTotalCount();
                if (index < 0 || total < 1) {
                    return null;
                }

                index = mod(index, total);

                return this._data[index];
            }
        });
    });
define("xdk-ui-grid/LoopedGrid", ["xdk-base/class","xdk-ui-grid/Grid","xdk-ui-grid/gridStgy","xdk-ui-grid/loopedGridStgy","xdk-base/util","xdk-ax/data/Datasource","xdk-ax/data/FiniteDatasource","xdk-base/promise","xdk-base/core","xdk-base/exception","xdk-base/console","css!./css/Grid"], function (klass, Grid, gridStgy, loopedGridStgy, util, Datasource, FiniteDatasource, promise, core, exception, console) {
    "use strict";
    var mod = function (number, divisor) { // modulo operation
            //in wiiU 1%0 is 0, so we try to standardize the %0 which should be NaN in all the platform
            if (divisor === 0) {
                return NaN;
            }
            return ((number % divisor) + divisor) % divisor;
        },
        getRejectedPromiseWithMessage = function (message) {
            console.info(message);
            return promise.reject(message);
        };

    return klass.create(Grid, {}, {
        __isFiniteDatasource: false,
                init: function (opts) {
            this._super(opts);

            var isVerticalAlign = opts.alignment === Grid.VERTICAL,
                frontBoundary = opts.scrollFrontBoundary || 0,
                endBoundary = opts.scrollEndBoundary || 0;

            this.setPrereadyStgy(util.bind(loopedGridStgy.LOOPED_PREREADY_STGY, this, frontBoundary));
            this.setCheckScrollableStgy(loopedGridStgy.LOOPED_CHECK_SCROLLABLE_STGY);
            this.setCheckSelectableStgy(util.bind(loopedGridStgy.LOOPED_CHECK_SELECTABLE_STGY, this, frontBoundary, endBoundary));
            this.setDataMappingStgy(loopedGridStgy.LOOPED_DATA_MAPPING_STGY);

            this.setScrollEntranceStgy(util.bind(gridStgy.BASIC_SCROLL_ENTRANCE_STGY, this, isVerticalAlign));

            this.setScrollShiftStgy(gridStgy.BASIC_SCROLL_SHIFT_STGY);
            this.setScrollExitStgy(gridStgy.BASIC_SCROLL_EXIT_STGY);


            this.setOnUpdateStgy(this.__onUpdateStgy);
            this.setKeyNavigationStgy(
                util.bind(loopedGridStgy.LOOPED_BOUNDARY_KEY_NAVIGATION_STGY, this, isVerticalAlign, frontBoundary, endBoundary));

            this.setDsRangeCalculationStgy(gridStgy.BASIC_DS_RANGE_CALCULATION_STGY);
        },
                __onUpdateStgy: function () {
            if (this.__isFiniteDatasource) {
                return loopedGridStgy.LOOPED_FINITEDS_ONUPDATE_STGY.apply(this, arguments);
            }

            return loopedGridStgy.LOOPED_ONUPDATE_STGY.apply(this, arguments);
        },
                setDatasource: function (ds) {

            if (!(ds instanceof Datasource)) {
                return getRejectedPromiseWithMessage("Cannot set an invalid datasource");
            }

            //If the given datasource is already registered for this grid, do nothing
            if (this._ds === ds) {
                return getRejectedPromiseWithMessage("Unable to set set the same datasource");
            }

            if (this.__isFiniteDatasource) {
                //Remove the previous datasource, if any
                if (this._ds && this.__datasourceListener) {
                    this._ds.removeEventListener(FiniteDatasource.EVT_FINITEDS_UPDATED, this.__datasourceListener);
                }
            } else {
                //Remove the previous datasource, if any
                if (this._ds && this.__datasourceListener) {
                    this._ds.removeEventListener(Datasource.EVT_UPDATED, this.__datasourceListener);
                }

            }

            //Remove all the current children
            this.reset();

            this._ready = false;
            //Register the new datasource
            this._ds = ds;

            if (ds instanceof FiniteDatasource) {
                this.__isFiniteDatasource = true;
            } else {
                this.__isFiniteDatasource = false;
            }

            var range, state;

            // see if need to change anything
            state = {
                selectedDsIndex: this._selectedDsIndex,
                selectedGridRow: this._selectedGridRow,
                cols: this._cols,
                rows: this._rows,
                ds: this._ds
            };

            this._prereadyStgy(state);

            this._selectedDsIndex = state.selectedDsIndex;
            this._selectedGridRow = state.selectedGridRow;

            range = this._dsRangeCalculationStgy(this._selectedDsIndex, this._selectedGridRow, state);

            // updated the grid state in case strategy have updated it
            this._selectedGridCol = mod(this._selectedDsIndex, this._cols);
            this._firstSlotDsIndex = range.from;


            //private listner ref for removal
            if (!this.__datasourceListener) {
                this.__datasourceListener = util.bind(this._onDatasourceUpdated, this);
            }

            //private listner ref for removal
            if (this.__isFiniteDatasource) {
                this._ds.addEventListener(FiniteDatasource.EVT_FINITEDS_UPDATED, this.__datasourceListener);

                if (this._ds.getTotalCount() === -1) {
                    return promise.reject(core.createException(exception.ILLEGAL_STATE, "Datasource Total count is not set."));
                }

                return this.select(this._selectedDsIndex, this._selectedGridRow);
            }

            //listen for more the data source if there is any update
            this._ds.addEventListener(Datasource.EVT_UPDATED, this.__datasourceListener);



            //ds not ready
            if (this._ds.getTotalCount() === -1) {
                return this._ds.getRange(range.from, range.to).then(util.bind(function () {

                    if (this._ds.getTotalCount() === -1) {
                        return getRejectedPromiseWithMessage("Unable to initialize the datasource, totalCount still equals -1");
                    }

                    return this.select(this._selectedDsIndex, this._selectedGridRow);

                }, this));
            }

            //reject with exception if trying to set an empty datasource;
            if (this._ds.getTotalCount() === 0) {
                console.warn("tried to set an datasource 0 total count, grid can will only be updated if it's notified by EVT_UPDATED from datasource with new total count");
            }

            return this.select(this._selectedDsIndex, this._selectedGridRow);

        }
    });
});
/**
 *
 * The is a looped grid widget with a 'scrolling boundary' at both ends.
 * ###CSS
 * ####Structural CSS
 *     // to hide the extra element
 *     .wgt-grid-scroll {
 *          overflow: hidden;
 *      }
 *      //to make the row display correctly
 *      .wgt-grid-scroll > .wgt-grid-row-h {
 *          float: none;
 *          clear: both;
 *      }
 *      //to make the element display correctly
 *      .wgt-grid-scroll > .wgt-grid-row-h > * {
 *          float: left;
 *      }
 *      //to make the row display correctly
 *      .wgt-grid-scroll > .wgt-grid-row-v {
 *          float: left;
 *      }
 *      //to make the element display correctly
 *      .wgt-grid-scroll > .wgt-grid-row-v > * {
 *          float: none;
 *          clear: both;
 *      }
 *
 * @class tvedemo/ext/ui/grid/LoopedGrid
 * @extends ax/ext/ui/grid/LoopedGrid
 * @param {Object} opts The options object
 * @param {Integer} opts.rows number of rows in the grid
 * @param {Integer} opts.cols number of columns in the grid
 * @param {ax/ext/ui/grid/Grid} [opts.alignment grid] item alignment direction
 * @param {Integer} [opts.scrollFrontBoundary]
 *     the boundray at the beginning of the grid, to start scrolling instead of moving selection
 * @param {Integer} [opts.scrollEndBoundary]
 *     the boundray at the end of the grid, to start scrolling instead of moving selection
 */
define("tvedemo/ext/ui/grid/LoopedGrid", ["xdk-base/class", "xdk-ui-grid/LoopedGrid", "xdk-ui-grid/Grid", "xdk-ax/evt/type", "xdk-ui-grid/gridStgy", "xdk-ui-grid/loopedGridStgy", "xdk-base/util", "xdk-ax/data/Datasource", "xdk-ax/data/FiniteDatasource", "xdk-base/promise", "xdk-base/core", "xdk-base/exception", "xdk-base/console","xdk-ax/evt/eventManager","xdk-base/device/vKey", "css!xdk-ui-grid/css/Grid"], function (klass, LoopedGrid, Grid, evtType, gridStgy, loopedGridStgy, util, Datasource, FiniteDatasource, promise, core, exception, console, evtMgr, vKey) {
    "use strict";

    return klass.create(LoopedGrid, {}, {
        
        /**
         * If true this is the currently focused component
         * @memberof tvedemo/ext/ui/grid/LoopedGrid#
         */
        __focused: false,
        
        /**
         * This will temporarily be set to false for a short while after a wheel scroll action
         * @memberof tvedemo/ext/ui/grid/LoopedGrid#
         */
        __okToScroll: true,
        
        /**
         * The number of milliseconds to wait until a scroll wheel action is allowed again.
         * @memberof tvedemo/ext/ui/grid/LoopedGrid#
         */
        __scrollWheelThreshold: 125,
        
        /**
         * Overrides parent init() function.
         * @method
         * @protected
         * @memberof tvedemo/ext/ui/grid/LoopedGrid#
         */
        init: function (opts) {
            this._super(opts);
            
            this._onFocusRef = util.bind(this._onFocus, this);
            this.addEventListener(evtType.FOCUS, this._onFocusRef);
            
            this._onBlurRef = util.bind(this._onBlur, this);
            this.addEventListener(evtType.BLUR, this._onBlurRef);

            this.getRoot().addEventListener("mousewheel", util.bind(this._onScrollWheel, this));
        },

        /**
         * Handling When the widget gets focus
         * @param  {Object} event Event information.
         * @return {boolean} true if event has been handled.
         */
        _onFocus: function (event) {
            this.__focused = true;
        },

        /**
         * Handling When the widget loses focus
         * @param  {Object} event Event information.
         * @return {boolean} true if event has been handled.
         */
        _onBlur: function (event) {
            this.__focused = false;
        },

        /**
         * Handling Scroll Wheel Events.
         * @param  {Object} scrollEvent Scroll event information.
         * @return {boolean} true if event has been handled.
         */
        _onScrollWheel: function (scrollEvent) {
            if (this.__focused && this.__okToScroll)
            {
                this.__okToScroll = false;
                setTimeout(util.bind(function(){
                    this.__okToScroll = true;
                },this), this.__scrollWheelThreshold);
                
                var evt      = scrollEvent || window.event;
                var delta    = evt.detail ? evt.detail*(-120) : evt.wheelDelta;
                var curFocus = require("xdk-ax/focusManager").getCurFocus();
                // if not focus, at least have default action
                curFocus = curFocus || this.getView();
                
                if (delta > 0)
                {
                    // Scroll forward
                    console.log("Scroll forward");
                    evtMgr.trigger(evtType.KEY, curFocus, {id:vKey.LEFT.id});
                }
                else
                {
                    // Scroll backward
                    console.log("Scroll backward");
                    evtMgr.trigger(evtType.KEY, curFocus, {id:vKey.RIGHT.id});
                }
            }
        },

        reset: function(options) {
            this._super();

            // Update option variable with new settings.
            for (var opt in options) {
                this._opts[opt] = options[opt];
            }

            // Reset all the strategies.
            var isVerticalAlign = this._opts.alignment === Grid.VERTICAL,
                frontBoundary = this._opts.scrollFrontBoundary,
                endBoundary = this._opts.scrollEndBoundary;

            this.setPrereadyStgy(util.bind(loopedGridStgy.LOOPED_PREREADY_STGY, this, frontBoundary));
            this.setCheckScrollableStgy(loopedGridStgy.LOOPED_CHECK_SCROLLABLE_STGY);
            this.setCheckSelectableStgy(util.bind(loopedGridStgy.LOOPED_CHECK_SELECTABLE_STGY, this, frontBoundary, endBoundary));
            this.setDataMappingStgy(loopedGridStgy.LOOPED_DATA_MAPPING_STGY);

            this.setScrollEntranceStgy(util.bind(gridStgy.BASIC_SCROLL_ENTRANCE_STGY, this, isVerticalAlign));

            this.setScrollShiftStgy(gridStgy.BASIC_SCROLL_SHIFT_STGY);
            this.setScrollExitStgy(gridStgy.BASIC_SCROLL_EXIT_STGY);

            this.setOnUpdateStgy(this.__onUpdateStgy);
            this.setKeyNavigationStgy(
                util.bind(loopedGridStgy.LOOPED_BOUNDARY_KEY_NAVIGATION_STGY, this, isVerticalAlign, frontBoundary, endBoundary));

            this.setDsRangeCalculationStgy(gridStgy.BASIC_DS_RANGE_CALCULATION_STGY);
        }
    });
});
/**
 * Fullscreen Player view's template
 * @name fullscreenPlayer
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/fullscreenPlayer
 */
define("tvedemo/tmpl/fullscreenPlayer", [
    "xdk-ax/Container",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Image",
    "xdk-ui-basic/Label",
    "xdk-ui-basic/Layout",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "xdk-ui-basic/Checkbox",
    "tvedemo/wgt/Footer",
    "tvedemo/wgt/FooterIconMap"
], function (
    Container,
    Button,
    Image,
    Label,
    Layout,
    ScrollingGrid,
    Checkbox,
    Footer,
    FooterIconMap
    ) {

    "use strict";

    return function () {
        return {
            klass: Container,
            id: "#fullscreenPlayerView",
            width: 1,
            alignment: Layout.HORIZONTAL,
            focusable: true,
            nextDown: "footer-container",
            children: [{
                klass: Container,
                id: "playerControllerContainer",
                css: "player-controller-container",
                width: 3,
                alignment: Layout.HORIZONTAL,
                children: [{
                    klass: Button,
                    id: "playAndPause",
                    css: "play-and-pause",
                    nextDown: "footer-container",
                }, {
                    klass: Container,
                    id: "progressBarContainer",
                    css: "progress-bar-container",
                    children: [{
                        klass: Container,
                        id: "progressBar",
                        css: "progress-bar"
                    }]
                }, {
                    klass: Label,
                    id: "time",
                    css: "time"
                }, {
                    klass: Label,
                    id: "title",
                    css: "title"
                },{
                    klass: Image,
                    id: "channel-logo",
                    css: "channel-logo"
                }]
            }, {
                klass: Layout,
                id: "footer-container",
                css: "footer-container",
                alignment: Layout.HORIZONTAL,
                nextUp: "playAndPause",
                forwardFocus: true,
                children: [{
                    klass: Image,
                    id: "footerline",
                    src: "img/vod_fullscreen/nav_bar.png"
                }, {
                    klass: Footer,
                    id: "footer",
                    css: "footer",
                    iconSet: FooterIconMap.DEFAULT
                },
                {
                    klass: Layout,
                    css: "playback-controls-container",
                    children: [
                        {
                            klass: Button,
                            id: "playcta",
                            css: "playcta"
                        },
                        {
                            klass: Button,
                            id: "pausecta",
                            css: "pausecta"
                        },
                        {
                            klass: Button,
                            id: "stopcta",
                            css: "stopcta"
                        },
                        {
                            klass: Button,
                            id: "rewindcta",
                            css: "rewindcta"
                        },
                        {
                            klass: Button,
                            id: "forwardcta",
                            css: "forwardcta"
                        },
                        {
                            klass: Label,
                            id: "playback-controls-text",
                            css: "playback-controls-text"
                        },
                        {
                            klass: Button,
                            id: "backcta",
                            css: "backcta"
                        },
                        {
                            klass: Label,
                            id: "playback-back-text",
                            css: "playback-back-text"
                        }
                    ]
                }]
            }]
        };
    };
});
/**
 * @name sPlaybackManager
 * @memberof tve/mgr
 * @class tve/mgr/sPlaybackManager
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("tve/mgr/sPlaybackManager", [
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/util",
    "tve/sServiceHolder",
    "xdk-base/core",
    "xdk-base/promise",
    "storm/helper/silkResponseHelper",
    "tvedemo/mgr/sEndUserManager"
], function(
    klass,
    config,
    util,
    serviceHolder,
    core,
    promise,
    silkResponseHelper,
    sEndUserManager) {

    "use strict";

    var PlaybackManager = klass.create({}, {

        playSessionToken: null,
        playSessionHeartbeat: null,
        _playedTime: null,
        _duration: null,

        setHeartbeatPlayedTime: function(playedTime) {
            this._playedTime = playedTime;
        },
        
        setHeartbeatDuration: function(duration) {
            this._duration = duration;
        },
        /**
         * Call heartbeat service.
         * @param  {Number} assetId        Id of the asset that is played
         * @param  {Boolean} callOnlyOnce  If the API call should only be done once
         * @return {promise}               Fulfilled when heartbeat is killed. Result conatins stop video message
         */
        heartbeat: function (assetId, callOnlyOnce) {
            
            callOnlyOnce = callOnlyOnce || false
            
            var MILLISECONDS = 1000,
                service = serviceHolder.getLinearContentService(),
                heartbeatRecursion,
                heartbeatDefer;

            if (service) {

                heartbeatDefer = promise.defer();

                heartbeatRecursion = util.bind(function () {
                    service.heartbeat({
                        assetId: assetId,
                        skygoSessionId: sEndUserManager.getUserSessionId(),
                        playSessionToken: this.playSessionToken,
                        playedTime: this._playedTime,
                        duration: this._duration
                    }).then(util.bind(function (result) {

                        if (callOnlyOnce === true) {
                            heartbeatDefer.resolve({
                                stopVideo: false 
                            });

                            return;
                        }

                        silkResponseHelper.skimSilkResponse(result, silkResponseHelper.MODE.SILENT).then(util.bind(function () {

                            if (result && (result.resultCode === silkResponseHelper.SILK_CODE.NO_ERRORS)) {

                                // Delay in result is in seconds.
                                var delay = result.delay * MILLISECONDS;
                                this.playSessionToken = result.playSessionToken;

                                // Call heartbeatrequest recursively after delay.
                                this.playSessionHeartbeat = setTimeout(heartbeatRecursion, delay);
                            } else {

                                heartbeatDefer.resolve({
                                    stopVideo: true,
                                    reason: result && result.resultCode
                                });
                            }

                        }, this));

                    }, this))

                }, this);

                heartbeatRecursion();

                return heartbeatDefer.promise;

            } else {
                return promise.resolve({
                    stopVideo: true,
                    reason: "Heartbeat service unavailable."
                });
            }
        },

        resetVariables: function() {
            this._playedTime = null;
            this._duration = null;
        },

        /**
         * Stop heartbeat service.
         * @return {void}
         */
        killHeartbeat: function () {

            if (!this.playSessionHeartbeat) {
                return;
            }

            clearTimeout(this.playSessionHeartbeat);
            this.playSessionHeartbeat = null;
            this.playSessionToken = null;
        }
    });

    return new PlaybackManager();
});
/**
 * The loading / busy animation
 * @name Loading
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/Loading
 */
define("tvedemo/wgt/vLoading", [
    "xdk-ax/Container",
    "xdk-ui-basic/Image",
    "xdk-base/class",
    "xdk-base/Env",
    "xdk-ax/mvc/AppRoot"
], function (
    Container,
    Image,
    klass,
    Env,
    AppRoot
    ) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        sEnv = Env.singleton(),

        Loading = klass.create(Container, {

        _shared: null,

        getShared: function () {

            if (!this._shared) {
                this._shared = new Loading();
            }

            return this._shared;

        },

        open: function () {
            return this.getShared().open();

        },
        close: function () {
            return this.getShared().close();
        }


    }, {

        init: function (opts) {

            opts = opts || {};

            opts.css = opts.css || "";
            opts.css += "wgt-dialog-modal wgt-loading";

            opts.parent = sAppRoot.getView();

            this._super(opts);

            this._overlay = new Container({
                parent: this,
                css: "wgt-dialog-overlay"
            });

            new Image({
                klass: Image,
                css: "load",
                src: "img/loading/load.gif",
                parent: this._overlay
            });

        },

        open: function () {
            this.show();
            sEnv.blockKeys();
        },

        close: function () {
            sEnv.unblockKeys();
            this.hide();
        }
    });

    return Loading;
});
/**
 * The Conviva stub interface which tracks error reporting to the 3rd party Conviva service on devices which support it
 * @name Conviva
 * @memberof tvedemo/ext/device/shared
 * @class tvedemo/ext/device/shared/ConvivaDefault
 */
define("tvedemo/ext/device/shared/ConvivaDefault", [
], function () {
    return {
        init: function () {},
        createSession: function (videoData, resumeTime) {},
        cleanUpSession: function () {},
        reportError: function(errorToShow) {},
        __setPlayerName: function() {},
        __enableTouchstone: function() {}
    }
});
/**
 * The Conviva interface for Playstation 4 which tracks error reporting to the 3rd party Conviva service
 * @name Conviva
 * @memberof tvedemo/ext/device
 * @class tvedemo/ext/device/playstation/Conviva
 */
define("tvedemo/ext/device/playstation/Conviva", [
    "xdk-base/util"
], function (util) {
    return {
        // Prerequisites
        customerId: 'c3.Sky-DE-Test',
        customerKey: '8b32f9655e8cb16b9a0a3a02871869983a1944c2',
        serviceUrl: 'http://sky-de-test.testonly.conviva.com',

        //Test
        //customerKey: '64449f67f642c456ad455eee8e5cd9a37ebd5418',
    
        // References to the current sessionId and streamer
        sessionId: null,
        streamer: null,
        playerName: '',
        touchstoneEnabled: false,

        /**
         * Must be called before anything else
         */
        init: function () {
            this.config = require("xdk-base/config");
            this.sEndUserManager = require("tvedemo/mgr/sEndUserManager");
            this.console = require("xdk-base/console");

            // One-time initialization call: must happen before any other Conviva calls
            console.info('[Conviva.js] PS init');
            console.info('[Conviva.js] init - customerKey = ' + this.customerKey);

            // Turn on Conviva library debug
            //Conviva.LivePass.toggleTraces( true );

            if (this.touchstoneEnabled) {
                // Touchstone test settings
                Conviva.LivePass.initWithSettings(this.customerKey, { gatewayUrl: this.serviceUrl });
            }
            else {
                // Production settings
                Conviva.LivePass.init(this.customerKey);
            }

            console.info('[Conviva.js] init done');
        },
        __setPlayerName: function (playerName) {
            this.playerName = playerName;
        },
        __enableTouchstone: function () {
            this.touchstoneEnabled = true;
        },
        // As soon as the user clicks play (even before ads)
        createSession: function (videoData, resumeTime, rawData) {
            if (!videoData || !videoData.meta) {
                return;
            }
            
            
            // Clean up previous session
            this.cleanUpSession();

            // Begin: Set up metadata
            console.info("*** CONVIVA createSession *** = " + videoData.url);
            console.info("---------------------------------------");
            console.info(JSON.stringify(videoData));
            console.info("---------------------------------------");

            var resumed = false;
            if (resumeTime && resumeTime !== 0) {
                resumed = true;
            }

            // For debugging only
            //console.log(JSON.stringify(rawData, null, 4));
            var media = this._getMediaProperties(rawData, videoData);
            
            var isSeries = "no";
            var resume = "play";
            var contentId = this._getProperty("asset._attrs.id", rawData);
            var assetName = contentId + ' ' + this._getProperty("asset._attrs.title", rawData);
            var mediaTags = this._populateMediaTags(rawData, isSeries, "SmoothStream", media.contentClass, videoData, media.liveContent, resume, media.contentCategory, contentId, this.config);
            
            if (media.contentClass === "Episode") {
                var seriesTitle = this._getProperty("asset._attrs.serieTitle", rawData);
                var seasonNumber = this._getProperty("asset._attrs.seasonNumber", rawData);
                var episodeNumber = this._getProperty("asset._attrs.episodeNumber", rawData);
                var title = this._getProperty("asset._attrs.title", rawData);
                
                if (seriesTitle !== undefined) {
                    assetName = contentId + ' ' + seriesTitle + " S" + seasonNumber + 
                                " E" + episodeNumber + ": " + title;
                }
                isSeries = "yes";
                mediaTags = this._populateMediaTags(rawData, isSeries, "SmoothStream", media.contentClass, videoData, media.liveContent, resume, media.contentCategory, contentId, this.config);
            }
            
            if (media.contentClass === "Live") { 
                mediaTags = this._populateMediaTags(rawData, isSeries, "SmoothStream", media.contentClass, videoData, media.liveContent, resume, media.contentCategory, contentId, this.config);
            }
            
            if (media.contentClass === "Trailer") {
                mediaTags = this._populateMediaTags(rawData, isSeries, "MP4", media.contentClass, videoData, media.liveContent, resume, media.contentCategory, contentId, this.config);
            }
            
            var convivaMetadata = new Conviva.ConvivaContentInfo(assetName, mediaTags);
            convivaMetadata.isLive = media.liveContent;
            convivaMetadata.defaultReportingCdnName = this._extractCDNName(videoData.url);
            convivaMetadata.streamUrl = mediaTags["asset_media_url"] = videoData.url;
            convivaMetadata.playerName = this.playerName;
            convivaMetadata.viewerId = "I2-C9EZXV1";

            if (this.streamer === null) {
                this.streamer = new Conviva.PlayStationWebmafStreamerProxy();
            }

            console.info('[Conviva.js] createSession - streamer = ' + this.streamer);
            console.info('[Conviva.js] createSession - convivaMetadata = ' + convivaMetadata);
            this.sessionId = Conviva.LivePass.createSession(this.streamer, convivaMetadata);
            console.info('[Conviva.js] createSession - sessionId = ' + this.sessionId + " assetName = " + assetName);
            console.info('[Conviva.js] createSession - END');
        },

        // When the stream is done with playback
        cleanUpSession: function () {
            console.info('[Conviva.js] cleanUpSession');
            if (this.sessionId != null) {
                Conviva.LivePass.cleanupSession(this.sessionId);
                this.sessionId = null;
                this.streamer = null;
            }

        },
        reportError: function(errorToShow) {
            Conviva.LivePass.reportError(this.sessionId, "A video playback error occoured: " + errorToShow );
        },
        /**
         * Tests whether an object has the required key (without throwing an exception)
         * @method _getProperty
         * @memberof module:tvedemo/ext/device/playstation/Conviva
         * @param {String} key Key to find
         * @param {Object} obj Object to check
         * @return {Object} the Object if it exists, undefined otherwise
         * @private
         */
        _getProperty: function (key, obj) {
            var objUnderTest = obj;
            var properties = key.split(".");
            for (var i=0; i < properties.length; i++) {
                if (!objUnderTest || !objUnderTest.hasOwnProperty(properties[i])) {
                    console.warn("[Conviva.js] Could not find property: " + key);
                    return undefined;
                }
                objUnderTest = objUnderTest[properties[i]];
            }
            return objUnderTest;
        },
        /**
         * Converts a boolean to the string "yes" otherwise "no" 
         * @method _convertToYesNo
         * @memberof module:tvedemo/ext/device/playstation/Conviva
         * @param {Boolean} obj Boolean to convert
         * @return {String} "yes" or "no"
         * @private
         */
        _convertToYesNo: function (obj) {
            if (obj === true) return "yes";
            return "no"; 
        },
        /**
         * Turns the streaming URL into the symbolic URL name
         * @method _extractCDNName
         * @memberof module:tvedemo/ext/device/playstation/Conviva
         * @param {String} url A video URL from a CDN
         * @return {String} The Conviva CDN constant to use
         * @private
         */
        _extractCDNName: function (url) {
            var domainNameToCDN = {
                "akamai": Conviva.ConvivaContentInfo.CDN_NAME_AKAMAI,
                "amazon":Conviva.ConvivaContentInfo.CDN_NAME_AMAZON,
                "att":Conviva.ConvivaContentInfo.CDN_NAME_ATT,
                "bitgravity":Conviva.ConvivaContentInfo.CDN_NAME_BITGRAVITY,
                "cdnnetworks":Conviva.ConvivaContentInfo.CDN_NAME_CDNETWORKS,
                "cdnvideo":Conviva.ConvivaContentInfo.CDN_NAME_CDNVIDEO,
                "chinacache":Conviva.ConvivaContentInfo.CDN_NAME_CHINACACHE,
                "chinanetcenter":Conviva.ConvivaContentInfo.CDN_NAME_CHINANETCENTER,
                "comcast":Conviva.ConvivaContentInfo.CDN_NAME_COMCAST,
                "edgecast":Conviva.ConvivaContentInfo.CDN_NAME_EDGECAST,
                "fastly":Conviva.ConvivaContentInfo.CDN_NAME_FASTLY,
                "highwinds":Conviva.ConvivaContentInfo.CDN_NAME_HIGHWINDS,
                "internap":Conviva.ConvivaContentInfo.CDN_NAME_INTERNAP,
                "iponly":Conviva.ConvivaContentInfo.CDN_NAME_IPONLY,
                "level3":Conviva.ConvivaContentInfo.CDN_NAME_LEVEL3,
                "limelight":Conviva.ConvivaContentInfo.CDN_NAME_LIMELIGHT,
                "microsoft":Conviva.ConvivaContentInfo.CDN_NAME_MICROSOFT,
                "mirrorimage":Conviva.ConvivaContentInfo.CDN_NAME_MIRRORIMAGE,
                "ngenix":Conviva.ConvivaContentInfo.CDN_NAME_NGENIX,
                "nice":Conviva.ConvivaContentInfo.CDN_NAME_NICE,
                "octoshape":Conviva.ConvivaContentInfo.CDN_NAME_OCTOSHAPE,
                "qbrick":Conviva.ConvivaContentInfo.CDN_NAME_QBRICK,
                "swarmcast":Conviva.ConvivaContentInfo.CDN_NAME_SWARMCAST,
                "talktalk":Conviva.ConvivaContentInfo.CDN_NAME_TALKTALK,
                "telefonica":Conviva.ConvivaContentInfo.CDN_NAME_TELEFONICA,
                "telenor":Conviva.ConvivaContentInfo.CDN_NAME_TELENOR,
                "telia":Conviva.ConvivaContentInfo.CDN_NAME_TELIA,
                "velocix":Conviva.ConvivaContentInfo.CDN_NAME_VELOCIX,
                "bt":Conviva.ConvivaContentInfo.CDN_NAME_BT
            };
            
            for (var key in domainNameToCDN) {
                if (url.indexOf(key) !== -1) {
                    return domainNameToCDN[key];
                }    
            }
            return Conviva.ConvivaContentInfo.CDN_NAME_OTHER;
        },
        /**
         * Populates a Conviva media tags structure 
         * @method _populateMediaTags
         * @memberof module:tvedemo/ext/device/playstation/Conviva
         * @return {Object} The Conviva data to pass to the library
         * @private
         */
        _populateMediaTags: function(rawData, isSeries, protocol, contentClass, videoData, liveContent, resume, contentCategory, contentId, config) {
            return {
                "asset_asset_type": contentClass, // e.g. "Film"
                "asset_category_main_id": this._getProperty("asset._attrs.genreList.main.content", rawData), // e.g. 'Basketball';
                "asset_genre_main_id": this._getProperty("asset._attrs.genreList.main.content", rawData), // e.g. 'Basketball';
                "asset_category_other_id": this._getProperty("asset._attrs.genreList.second.content", rawData), // e.g. 'Action';
                "asset_genre_second_id": this._getProperty("asset._attrs.genreList.second.content", rawData), // e.g. 'Action';
                "asset_genre_sub1_id": this._getProperty("asset._attrs.genreList.sub1.content", rawData), // e.g. 'Familienfilm';
                "asset_genre_sub2_id": this._getProperty("asset._attrs.genreList.sub2.content", rawData), // e.g. 'Zeichentrick/Animation';
                "asset_channel_code": this._getProperty("asset._attrs.packageCode", rawData), // e.g. 'PSN_SPAT';
                "asset_channel_name": undefined, // e.g. 'SKY Sport Austria';
                "asset_current_type": contentClass, // e.g. "Film"
                "asset_episode_number": undefined, // e.g. '1';
                "asset_flag_series": isSeries,
                "asset_on_air_end_date": undefined, // e.g. '2012/12/17';
                "asset_on_air_end_time": undefined, // e.g. '21:15';
                "asset_on_air_start_date": undefined, // e.g. '2012/12/17';
                "asset_on_air_start_time": undefined, // e.g. "18:45";
                "asset_season": undefined, // e.g. '31052';
                "asset_season_number": undefined, // e.g. '1';
                "asset_serie": undefined, // e.g. '63031';
                "asset_series_title": undefined, // e.g. "XIII - Die Verschwrung";
                "asset_subtitle": undefined, // e.g. "Basketball: Xion Dukes Klosterneuburg - Redwell Gunners Oberwart, 12. Runde ...";
                "asset_title": this._getProperty("asset._attrs.title", rawData), // e.g. "Planet der Affen: Prevolution";
                "asset_type": contentClass, // e.g. "Film"
                "streamProtocol": protocol,
                "show": undefined, // e.g. videoData.meta.brandTitle;
                "episodeName": this._getProperty("meta.episodeTitle", videoData), // e.g. "Planet der Affen: Prevolution";
                "asset_flag_live": this._convertToYesNo(liveContent),
                "duration": videoData.meta.duration.toString(),
                "resume": resume.toString(),
                "site": 'Sky-DE',
                "contentCategory": contentCategory,
                "contentId": contentId.toString(),
                "playerVersion": config.get("version"),
                "viewerAgreement": 'N/A',
                "connectionType": 'N/A',
                "asset_flag_simulcast": 'no',
                "asset_hd": this._getProperty("asset._attrs.isHD", rawData) ? "yes" : "no",
                "asset_id": this._getProperty("asset._attrs.id", rawData).toString(), // e.g. '91506'
                "asset_length": videoData.meta.duration.toString(), // e.g. '150';
                "asset_license_internet": '0',
                "asset_license_mobile": '0'
            };
        },
        /**
         * Figure out some common properties from the videos metadata
         * @method _getMediaProperties
         * @memberof module:tvedemo/ext/device/playstation/Conviva
         * @return {Object} The content type, if its a live stream, if it's a VOD item or from the archive
         * @private
         */
        _getMediaProperties: function(rawData, videoData) {
            var contentClass = this._getProperty("asset._attrs.type", rawData); // This is only set for VOD content
            
            var liveContent = false;
            if (this._getProperty("isLinear", rawData) !== undefined && this._getProperty("isLinear", rawData) === true) {
                liveContent = this._getProperty("isLinear", rawData);
                contentClass = "Live";
            }
            else if (this._getProperty("asset._attrs.live", rawData) !== undefined && this._getProperty("asset._attrs.live", rawData) === true) {
                liveContent = this._getProperty("asset._attrs.live", rawData);
                contentClass = "Live";
            }
            else if (this._getProperty("mediaType", rawData) !== undefined && rawData.mediaType === "trailer") {
                contentClass = "Trailer";
            }
            
            var contentCategory;
            var isCatchup = this._getProperty("meta.isCatchUp", videoData);
            var isArchive = this._getProperty("meta.isArchive", videoData);
            if (isCatchup !== undefined) {
                if (isCatchup) {
                    contentCategory = "Catchup";
                }
                else {
                    if (isArchive) {
                        contentCategory = "Archive";
                    }
                    else {
                        contentCategory = "On-Demand";
                    }
                }
            }
            
            return {
                "contentClass": contentClass,
                "liveContent": liveContent,
                "contentCategory": contentCategory,
                "isCatchup": isCatchup,
                "isArchive": isArchive
            }
        }
    };
});

/*jshint unused:false*/
/* This extra if statement is needed for the requireJS optimised build step
 as it evaluates the javascript, but doesn't have a DOM, so there's no navigator object
 */
if (typeof navigator != "object") {
    define("tvedemo/ext/device/shared/ConvivaLoader", [
            "tvedemo/ext/device/shared/ConvivaDefault",
            "tvedemo/ext/device/playstation/Conviva"
        ],
        function (defaultConviva, conviva) {
            return {
                load: function (resourceId, require, onload) {
                    onload(defaultConviva);
                }
            };
        }
    );
}
else {
    define("tvedemo/ext/device/shared/ConvivaLoader", [
            "tvedemo/ext/device/shared/ConvivaDefault",
            "tvedemo/ext/device/playstation/Conviva",
            "xdk-base/config",
            "xdk-base/console",
            "xdk-base/Env",
            "xdk-base/util",
            "xdk-base/device",
            "require"
        ], function (defaultConviva, conviva, config, console, env, util, device) {
            "use strict";
            return {

                load: function (resourceId, require, onload) {
                    var sEnv = env.singleton();
                    
                    // Wait until the device has been detection in order to know
                    // the platform we're running on or 2 seconds have passed
                    // there is a bug in XDK that you can miss the ONDETECT event
                    // so it needs to be protected with a timeout for non-minified builds
                    this._onload = onload;
                    this._timeoutId = window.setTimeout(util.bind(this.__XDKDeviceLoadTimeout, this), 2000);
                    sEnv.addEventListener(sEnv.EVT_ONDETECT, util.bind(this.__XDKDeviceHasLoadedCallback, this));
                },
                
                __XDKDeviceLoadTimeout: function(platform) {
                    console.warn("[ConvivaLoader] Waited for ONDETECT event but it didn't arrive... Trying a different way to get the platform");
                    this.__XDKDeviceHasLoadedCallback(device.platform);
                },
                
                __XDKDeviceHasLoadedCallback: function(platform) {
                    window.clearTimeout(this._timeoutId);
                    var settings = this.__getSettings(platform);
                    if (settings === null || settings === undefined) {
                        this._onload(defaultConviva);
                        return;
                    }
                    
                    this.__loadJavascript(settings.convivaLibraryURL, util.bind(this.__convivaLibraryLoadedIntoWindow(settings), this));
                },
                __loadJavascript: function (javascripURL, onSuccess) {
                    var head = document.getElementsByTagName("head")[0];
                    var node = document.createElement("script");
                    var readyRegExp = navigator.platform === "PLAYSTATION 3" ? /^complete$/ : /^(complete|loaded)$/;
                    node.type = "text/javascript";
                    node.charset = "utf-8";
                    node.async = true;

                    node.onreadystatechange = node.onload = function () {
                        if (!node.readyState || readyRegExp.test(node.readyState)) {
                            node.onload = node.onreadystatechange = null;
                            node.onerror = null;
                            onSuccess();
                        }
                    };

                    node.onerror = function (msg, url, line) {
                        node.onload = node.onreadystatechange = null;
                        node.onerror = null;
                        console.error('[ConvivaLoader] Unable to load ' + javascripURL + ' check the XDK config under device.tracking. Message: ' + msg);
                        this._onload(defaultConviva);
                    };

                    node.src = javascripURL;
                    head.appendChild(node);
                },
                
                __convivaLibraryLoadedIntoWindow: function(settings) {
                    return function() {
                        conviva.__setPlayerName(settings.convivaPlayerName);
    
                        if (settings.convivaEnableTouchstoneDebugging === true) {
                            conviva.__enableTouchstone();
                        }
                        
                        this._onload(conviva);
                    }
                },

                __getSettings: function (platform) {
                    var tracking;
                    tracking = config.get("device.tracking");
                    
                    // This is hacky but XDK has issues with a minified build
                    // that fires an ONDETECT event where it will pass the 
                    // module name of the platform instead of the platform name, so 
                    // it will send "xdk-ext-device-playstation" or "xdk-base/device/workstation/detection" instead of "playstation"
                    // so replace everything up to the trailing slash with an empty string
                    platform = platform.replace(/.*\/device\//i, "");
                    platform = platform.replace(/\/detection.*/i, "");
                    
                    if (tracking.hasOwnProperty(platform) === false) {
                        console.log('[ConvivaLoader] platform ' + platform +
                            ' not found in device.tracking config, use the default stub.');
                        return null;
                    }

                    console.log('[ConvivaLoader] using device "' + platform + '" with config ' + JSON.stringify(tracking[platform]));
                    return tracking[platform];
                }
            }
        }
    );
}

;

/**
 * The fullscreen player view's controller. Setup fullscreen video play with basic control buttons.
 * @name FullscreenPlayer
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/FullscreenPlayer
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/FullscreenPlayer", [
    "xdk-base/ax",
    "xdk-base/Env",
    "xdk-base/config",
    "xdk-ax/mvc/AppRoot",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/fullscreenPlayer",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-ax/mediator",
    "xdk-base/util",
    "xdk-base/device/vKey",
    "tve/videoPlaybackService/model/Playlist",
    "tve/videoPlaybackService/model/PlaylistItem",
    "tve/videoPlaybackService/evt/VideoPlaybackControlsEvent",
    "tve/videoPlaybackService/evt/VideoControlsStatusEvent",
    "storm/mgr/sVideoManager",
    "xdk-base/console",
    "tve/mgr/sPlaybackManager",
    "tve/videoPlaybackService/evt/VideoPlaybackStatusEvent",
    "tvedemo/helper/dialogHelper",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sSilkMessagesManager",
    "tvedemo/mgr/sEndUserManager",
    "storm/helper/silkResponseHelper",
    "storm/event/UserEvent",
    "xdk-mouse/mouseHandler",
    "tvedemo/wgt/vLoading",
    "xdk-base/device",
    "tvedemo/ext/device/shared/ConvivaLoader!",
    "tvedemo/mgr/sTrackingManager",
    "tvedemo/mgr/sHistoryManager"
], function (
    ax,
    Env,
    config,
    AppRoot,
    RoutableController,
    view,
    tmpl,
    evtType,
    focusManager,
    mediator,
    util,
    vKey,
    Playlist,
    PlaylistItem,
    VideoPlaybackControlsEvent,
    VideoControlsStatusEvent,
    VideoManager,
    console,
    sPlaybackManager,
    VideoPlaybackStatusEvent,
    dialogHelper,
    sLanguageManager,
    sSilkMessagesManager,
    sEndUserManager,
    silkResponseHelper,
    UserEvent,
    mouseHandler,
    vLoading,
    device,
    conviva,
    TrackingManager,
    sHistoryManager) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        sEnv = Env.singleton(),
        SIXTYSECONDS = 60,
        TENSECONDS = 10,
        ONESECOND = 1,
        delayUnBlock = "id-delayUnBlock",
        // These are the CSS classes to display the appropriate icon (potentially need PREV and NEXT?)
        PAUSED = "paused",
        FF = "ff",
        RW = "rw",
        BUFFERING = 5,
        CONNECTING = 6;

    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {};
        }
    }, {

        milliSecondsToSeconds: 1000,
        _sTrackingManager: null,
        _analyticsOpenTracked: false,
        _playbackHasinitiated: false,

        init: function () {
            this.setView(view.render(tmpl));
            this._sTrackingManager = new TrackingManager();
        }, 
        __setupConvivaStatsTracking: function (context) {
            this.closeMediaSetupCallback();
            var videoData = {
                url: context.mediaUrl,
                meta: {
                    programmeNumber: context.asset.get("episodeNumber"),
                    brandTitle: "",
                    episodeTitle: context.asset.get("title"),
                    duration: context.duration / this.milliSecondsToSeconds,
                    isCatchUp: true,
                    isArchive: false
                }
            }
            conviva.init();
            conviva.createSession(videoData, 0, context);
        },
        closeMediaSetupCallback: function () {
            var trackingManager = this._sTrackingManager;
            mediator.subscribe(VideoPlaybackStatusEvent.StopState, function (playListItem) {
                trackingManager.trackCloseMedia();
                conviva.cleanUpSession();
            });
        },

        /*
         *    mediaTitle: "",
         *    mediaUrl: "",
         *    mediaType: null,
         *    assetId: "",
         *    startTime: 0
         */
        setup: function (context) {
            sAppRoot.getView().addClass("fullscreen-video-mode");

            this.__play = util.bind(this.play, this)
            this.__pause = util.bind(this.pause, this)
            this.__stop = util.bind(this.stop, this)
            this.__rewind = util.bind(this.rewind, this)
            this.__forward = util.bind(this.forward, this)
            this.__back = util.bind(this.back, this)

            this.__footerButtonFocus = util.bind(this.__showUI, this)

            sPlaybackManager.resetVariables();

            var currentView = this.populateVariables(context);

            // Hiding what we don't need for linear streaming.
            if (this.__isLinear) {
                currentView.find("progressBarContainer").hide();
                this.__timeLabel.hide();

                this.__channelLogo.setSrc(context.asset.get("images")[0].get("url"));
            }
            this.__onKeyRef = util.bind(this.onKey, this);
            currentView.addEventListener(evtType.KEY, this.__onKeyRef);

            focusManager.focus(this.playPauseButton);

            this.__setPlayback(context);
            this._setFooter("");

            this.__handleUserDataUpdated = util.bind(function () {

                // Geo-licensing will not change with the user information, neither does the FSK.
                // Therefore is entitlement the only check that is needed after the user data has been updated.
                sEndUserManager.checkUserPrivileges(this.__currentAsset).then(util.bind(function (userIsEntitledToWatch) {

                    // If the user is no longer entitled to watch the content, stop playback and navigate back to detail page.
                    if (!userIsEntitledToWatch) {
                        this.__transitionToPlayingStoppedEvent();
                    }

                    // No action is needed if the user is still allowed to watch the content.
                }, this));

            }, this);
            mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdated);

            this.__userHasBeenLoggedOutHandler = util.bind(function () {

                // This is to make sure that the video does not continue to play but the user is not presented wih a black screen.
                this.__transitionToPausedState();

                this.displayErrorDialog(sLanguageManager.getString("Errormessages.Errormessages_labelSessionExpired"));
                conviva.reportError("Users session has expired and has been logged out");
                this._sTrackingManager.trackCloseMedia();
                conviva.cleanUpSession();
            }, this);

            mediator.subscribe(UserEvent.UserHasBeenLoggedOut, this.__userHasBeenLoggedOutHandler);


            this.__mouseOnRef = util.bind(this.__mouseOn, this);
            this.__mouseOffRef = util.bind(this.__mouseOff, this);
            mediator.subscribe("mouseOn", this.__mouseOnRef);
            mediator.subscribe("mouseOff", this.__mouseOffRef);
            this.__setupConvivaStatsTracking(context);
            this._sTrackingManager.trackVideoStateChangeSetupCallback();
            this._analyticsOpenTracked = false;
        },
        populateVariables: function(context) {
            var currentView = this.getView();
            this.playPauseButton = currentView.find("playAndPause");
            this.playcta = currentView.find("playcta");
            this.pausecta = currentView.find("pausecta");
            this.stopcta = currentView.find("stopcta");
            this.rewindcta = currentView.find("rewindcta");
            this.forwardcta = currentView.find("forwardcta");
            this.backcta = currentView.find("backcta");
            this.controlInfoText = currentView.find("playback-controls-text");
            this.backInfoText = currentView.find("playback-back-text");

            this.__fullscreenPlayerView = currentView.find("fullscreenPlayerView");
            this.__playerControllerContainer = currentView.find("playerControllerContainer");
            this.__progressBar = currentView.find("progressBar");
            this.__timeLabel = currentView.find("time");
            this.__title = currentView.find("title");
            this.__footer = currentView.find("footer");
            this.__footerContainer = currentView.find("footer-container");
            this.__mediaType = context.mediaType;
            this.__isLinear = context.isLinear;
            this.__channelLogo = currentView.find("channel-logo");

            this.__numberOfAudioTracks = 1; // Presume single audio track.

            return currentView;
        },
        setCtaListeners: function() {
            this.playcta.addEventListener(evtType.CLICK, this.__play);
            this.pausecta.addEventListener(evtType.CLICK, this.__pause);
            this.stopcta.addEventListener(evtType.CLICK, this.__stop);
            this.rewindcta.addEventListener(evtType.CLICK, this.__rewind);
            this.forwardcta.addEventListener(evtType.CLICK, this.__forward);
            this.backcta.addEventListener(evtType.CLICK, this.__back);

            // This is needed to make sure overlay UI is shown when navigating between buttons
            this.playcta.addEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.pausecta.addEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.stopcta.addEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.rewindcta.addEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.forwardcta.addEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.backcta.addEventListener(evtType.FOCUS, this.__footerButtonFocus);
        },
        removeCtaListeners: function() {
            this.playcta.removeEventListener(evtType.CLICK, this.__play);
            this.pausecta.removeEventListener(evtType.CLICK, this.__pause);
            this.stopcta.removeEventListener(evtType.CLICK, this.__stop);
            this.rewindcta.removeEventListener(evtType.CLICK, this.__rewind);
            this.forwardcta.removeEventListener(evtType.CLICK, this.__forward);
            this.backcta.removeEventListener(evtType.CLICK, this.__back);

            this.playcta.removeEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.pausecta.removeEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.stopcta.removeEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.rewindcta.removeEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.forwardcta.removeEventListener(evtType.FOCUS, this.__footerButtonFocus);
            this.backcta.removeEventListener(evtType.FOCUS, this.__footerButtonFocus);
        },
        play: function(){
            this.__videoManager.playResume();
        },
        pause: function(){
            this.__videoManager.pause();
        },
        stop: function(){
            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();
            sEnv.dispatchEvent(sEnv.EVT_ONKEY, {
                id: vKey.BACK.id
            });
        },
        rewind: function(){
            this.__videoManager.seek(this.__currentTime - 5);
        },
        forward: function(){
            this.__videoManager.seek(this.__currentTime + 5);
        },
        back: function(){
            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();
            sEnv.dispatchEvent(sEnv.EVT_ONKEY, {
                id: vKey.BACK.id
            });
        },
        generateButtonPress: function(buttonCode) {
            var event = document.createEvent("Event");
            event.initEvent('keydown', true, true);
            event.target = document;
            event.currentTarget = document;
            event.isSimulated = true;
            event.keyCode = buttonCode;
            event.keyCodeVal = buttonCode;
            document.dispatchEvent(event);
        },
        __setPlayback: function (context) {
            this.__setControlsInErrorState = util.bind(this._setControlsInErrorState, this);
            this.__setControlsInPlayStateRef = util.bind(this._setControlsInPlayState, this);
            this.__setControlsInPauseStateRef = util.bind(this._setControlsInPauseState, this);
            this.__updatePlayheadStateRef = util.bind(this._updatePlayheadState, this);
            this.__dismissControlsRef = util.bind(this._dismissControls, this);
            this.__playStateRef = util.bind(function (asset) {
                this.__currentAsset = asset && asset.metadata && asset.metadata.asset;
                this.__mediaType = asset && asset.metadata && asset.metadata.mediaType;

                var mediaType = asset && asset.metadata && asset.metadata.mediaType,
                    currentAssetId = this.__currentAsset && this.__currentAsset.get("id"),
                    duration = this.__currentAsset && this.__currentAsset.get("duration");
                    if (duration === undefined) {
                        duration = 0;
                    }

                this.setUIForState();

                // Make sure no old heartbeat is still alive.
                this.killHeartbeat();

                // Trailers without adult content do not require login.
                // Heartbeat would stop a trailer directly in case no user is logged in.
                // Therefore start heartbeat only in case the media type is movie, which would require a logged in user for playback.
                if (mediaType === "movie") {

                    // Start new heartbeat.
                    this.startHeartbeat(currentAssetId);
                }

                vLoading.close();

            }, this);
            this.__stopStateRef = util.bind(function () {
                this._sTrackingManager.trackCloseMedia();
                conviva.cleanUpSession();
                vLoading.close();
            }, this);
            this.__pauseStateRef = util.bind(function () {
                this.setUIForState(PAUSED);
                vLoading.close();
            }, this);
            this.__bufferStateRef = util.bind(function () {
                vLoading.open();
            }, this);

            // Listening for information about available audio tracks.
            this.__audioTracksRef = util.bind(function (trackCount) {
                this.__numberOfAudioTracks = trackCount;
                console.info("Number of audio tracks: "+trackCount);
                // If we have more than one, try setting the default.
                if (this.__numberOfAudioTracks > 1) {
                    this.__videoManager.setDefaultAudioLanguage();
                }
            }, this);
            // Listen for audio track changes and update footer to reflect it.
            this.__audioTracksChangeRef = util.bind(function (newLanguage) {
                this._setFooter(newLanguage);
            }, this);

            mediator.subscribe(VideoPlaybackControlsEvent.SetControlsInPlayState, this.__setControlsInPlayStateRef);
            mediator.subscribe(VideoPlaybackControlsEvent.SetControlsInPauseState, this.__setControlsInPauseStateRef);
            mediator.subscribe(VideoPlaybackControlsEvent.UpdatePlayheadState, this.__updatePlayheadStateRef);
            mediator.subscribe(VideoPlaybackControlsEvent.DismissControls, this.__dismissControlsRef);
            mediator.subscribe(VideoPlaybackControlsEvent.NotifyError, this.__setControlsInErrorState);
            mediator.subscribe(VideoPlaybackStatusEvent.PlayState, this.__playStateRef);
            mediator.subscribe(VideoPlaybackStatusEvent.StopState, this.__stopStateRef);
            mediator.subscribe(VideoPlaybackStatusEvent.PauseState, this.__pauseStateRef);
            mediator.subscribe(VideoPlaybackStatusEvent.BufferState, this.__bufferStateRef);
            mediator.subscribe("onAudioTracks", this.__audioTracksRef);
            mediator.subscribe("onAudioTrackChange", this.__audioTracksChangeRef);

            this.setCtaListeners();
            this.__playPauseButtonPressedRef = util.bind(this.__playPauseButtonPressed, this);
            this.playPauseButton.addEventListener(evtType.CLICK, this.__playPauseButtonPressedRef);

            this.__videoManager = new VideoManager();
            var items = [new PlaylistItem({
                    url: context.mediaUrl,
                    metadata: {
                        title: context.asset.get("title"),
                        duration: context.duration / this.milliSecondsToSeconds,
                        seasonNo: context.asset.get("seasonNumber"),
                        episodeNo: context.asset.get("episodeNumber"),
                        asset: context.asset,
                        mediaType: context.mediaType
                    },
                    drmAttributes: context.drmAttributes
                })];
            var playlist = new Playlist({
                    items: items
                });
            this.__videoManager.setVideoLoadedCallback(util.bind(this.closeLoadingCallback, this));
            vLoading.open();

            this.__videoManager.setPlaylist(playlist);            
            this.__videoManager.playPlaylistItem(items[0], context.startTime);
        },

        closeLoadingCallback: function(){
            vLoading.close();
        },
        /**
         * Update footer, along with current audio language being played to show alongside Yellow button icon.
         * @param lang - The language of the current audio. Icon is hidden if no lang is passed.
         * @private
         */
        _setFooter: function (lang) {
            // Do not do this for LG since we want focusable buttons in the footer.
            if (device.platform !== "lg") {
                this.__footerContainer.setOption("forwardFocus", false)
                this.__footerContainer.setOption("focusable", false)

                this.playcta.hide();
                this.pausecta.hide();
                this.stopcta.hide();
                this.rewindcta.hide();
                this.forwardcta.hide();
                this.backcta.hide();

                var buttons = {
                    colorYellow: lang,
                    back: sLanguageManager.getString("Global.Global_buttonBack_button")
                };
                if (this.__isLinear) {
                    buttons.liveControls = sLanguageManager.getString("Player.Player_Control_UI_Text");
                }
                else {
                    buttons.controls = sLanguageManager.getString("Player.Player_Control_UI_Text");
                }
                this.__footer.update(buttons);
            } else {
                this.controlInfoText.setText(sLanguageManager.getString("Player.Player_Control_UI_Text"));
                this.backInfoText.setText(sLanguageManager.getString("Global.Global_buttonBack_button"))

                if (this.__isLinear) {
                    this.playcta.hide();
                    this.pausecta.hide();
                    this.rewindcta.hide();
                    this.forwardcta.hide();
                }
            }
        },

        _setControlsInErrorState: function (data) {
            vLoading.close();
            var error = data && data.error,
                errorCode = error && error.errorCode,
                errorMessage = error && error.errorMessage,
                errorToShow = sLanguageManager.getString("Player.Player_labelPlaybackFailed");

            if (errorCode === this.__videoManager.ERROR_CODES.FIRMWARE_UPDATE_REQUIRED) {
                errorToShow = sLanguageManager.getString("ui.maintenance.firmware");
            }

            try {
                var environment = config.get("environment"); // eg "test", "production";
                
                errorMessage = data.error.errorMessage;
                errorCode = data.error.errorCode;

                if (environment === "test") {

                    if (errorMessage) {
                        errorToShow = errorToShow + " (" + errorMessage + ")";
                    } else {
                        if (errorCode) {
                            errorToShow = errorToShow + " (" + errorCode + ")";
                        }
                    }
                }
            } catch (e) {
                console.warn("Unable to get error detail: " + e);
            }

            this.displayErrorDialog(errorToShow);
            conviva.reportError(errorToShow);
            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();
        },

        _setControlsInPlayState: function (data) {
            this.__transitionToPlayingStateNotFiringEvent();

            if (data && data.metadata) {
                var titlePrefix = "";
                if (data.metadata.seasonNo) {
                    titlePrefix += "S" + data.metadata.seasonNo;
                }
                if (data.metadata.episodeNo) {
                    if (titlePrefix.length) {
                        titlePrefix += " ";
                    }
                    titlePrefix += "E" + data.metadata.episodeNo;
                }
                if (titlePrefix.length) {
                    titlePrefix += ": ";
                }
                if (data.metadata.title) {
                    this.__title.setText(titlePrefix + data.metadata.title);
                }
            }
        },

        _setControlsInPauseState: function () {
            this.__transitionToPausedStateNotFiringEvent();
        },

        _debounceTimeUpdateEvent: function(fn, threshhold, scope) {
            threshhold || (threshhold = 1000);
            var last,
                deferTimer;
            return function () {
                var context = scope || this;
        
                var now = new Date,
                    args = arguments;
                if (last && now < last + threshhold) {
                    // hold on to it
                    clearTimeout(deferTimer);
                    deferTimer = setTimeout(function () {
                        last = now;
                        fn.apply(context, args);
                    }, threshhold);
                } else {
                    last = now;
                    fn.apply(context, args);
                }
            };
        },

        _updatePlayheadState: function (data) {
            // Make sure playstate has been updated so currentAsset is set.
            if (!this.__currentAsset) {
                return
            }

            this.updateTime(data.pos);
            this._sTrackingManager.mediaSetDuration(data.duration);
            
            // Workaround for incorrect duration metadata from Sky servers, 
            // we must wait for the video decoder to report the duration
            if (this._analyticsOpenTracked === false) {
                this._sTrackingManager.trackOpenMedia(this.__currentAsset, this.__mediaType, data.duration);
                this._analyticsOpenTracked = true;
            }
            
            if (data.duration && !this.__duration) {
                this.__duration = data.duration;
            }
        },

        _dismissControls: function () {
            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();
            this.setUIForStoppedState();
            this.updateTime(0);
        },

        __playPauseButtonPressed: function () {
            if (this.__videoIsPlaying && !this.__isLinear) {
                this.__transitionToPausedState();
            } else {
                this.__transitionToPlayingState();
            }
        },

        __transitionToPlayingStoppedEvent: function () {
            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();
            mediator.publish(VideoControlsStatusEvent.DismissSelected);
            this.setUIForStoppedState();
            this.updateTime(0);
        },

        __transitionToPlayingState: function () {
            mediator.publish(VideoControlsStatusEvent.PlaySelected);
            this.__transitionToPlayingStateNotFiringEvent();
        },

        __transitionToPlayingStateNotFiringEvent: function () {
            this.__videoIsPlaying = true;
        },

        __transitionToPausedState: function () {
            mediator.publish(VideoControlsStatusEvent.PauseSelected);
            this.__transitionToPausedStateNotFiringEvent();
        },

        __transitionToPausedStateNotFiringEvent: function () {
            this.__videoIsPlaying = false;
        },

        __finished: function () {
            console.info("perform history back when receiving the stop status");
            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();

            this.handleBackEvent();
        },

        __setProgressBar: function (rate) {
            if (rate >= 0 && rate <= 1) {
                this.__progressBar.getRoot().getHTMLElement().style.width = rate * 100 + "%";
            }
        },

        __setTime: function (time) {
            this.__currentTime = time;
            if (this.__duration) {
                this.__timeLabel.setText(this.__formatTime(time) + " / " + this.__formatTime(this.__duration));
            }
        },

        __formatTime: function (time) {
            time = ~~time % (99 * 60 * 60); //double tilde can convert the number from float to integer.

            var h = ~~ (time / 3600),
                m = ~~ (time % 3600 / 60),
                s = time % 60;

            return (h < 10 ? "0" : "") + h + ":" + (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
        },

        __showUI: function () {
            if (this.__status && this.__status === "hidden") {
                this.__playerControllerContainer.show();
                this.__footerContainer.show();
                //this.__footer.show();
                this.__status = "show";
                focusManager.focus(this.playPauseButton);
            }

            clearTimeout(this.__hideUITimer);

            this.__hideUITimer = setTimeout(util.bind(function () {
                this.__hideUI();
            }, this), 5000);
        },

        __hideUI: function () {
            if ((!this.__status || this.__status === "show") && !mouseHandler.isMouseOn()) {
                this.__playerControllerContainer.hide();
                this.__footerContainer.hide();
                //this.__footer.hide();
                this.__status = "hidden";
                focusManager.focus(this.__fullscreenPlayerView);
            }
        },

        __mouseOn: function() {
            this.__showUI();
        },

        __mouseOff: function() {
            clearTimeout(this.__hideUITimer);
            this.__hideUITimer = setTimeout(util.bind(function () {
                this.__hideUI();
            }, this), 5000);
        },

        updateTime: function (pos) {
            this.__setTime(pos);
            this.__setProgressBar(this.__duration ? (pos / this.__duration) : 0);

            // Update time for heartbeat handling
            if (this.__duration && pos) {
                sPlaybackManager.setHeartbeatPlayedTime(pos);
                sPlaybackManager.setHeartbeatDuration(this.__duration);
            }
        },

        // Displaying the icon for the current state.
        setUIForState: function(state) {
            this.playPauseButton.removeClass(PAUSED);
            this.playPauseButton.removeClass(FF);
            this.playPauseButton.removeClass(RW);
            // Set state icon if we have one (otherwise it shows default 'playing').
            if (state) {
                this.playPauseButton.addClass(state);
            }
            this.__showUI();
        },

        setUIForStoppedState: function () {
            this.__finished();
        },

        displayErrorDialog: function (errorMessage) {
            
            // Make sure that mutiple dialog are not displayed,
            // since that will cause a loss of focus.
            if (this._errorDialogIsOpen) {
                return false;
            }

            this._errorDialogIsOpen = true;

            dialogHelper.error({
                reason: errorMessage,
                closeAction: util.bind(function () {
                    this._errorDialogIsOpen = false;
                    this.__transitionToPlayingStoppedEvent();
                }, this),
                buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
            });

            return true;
        },

        /**
         * Start calling the heartbeat api to keep videostream alive.
         * @param  {Number} assetId         Id of the playing asset.
         * @return {void}
         */
        startHeartbeat: function (assetId) {
            sPlaybackManager.heartbeat(assetId).then(util.bind(function (result) {
                if (result.stopVideo) {

                    this.killHeartbeat();

                    // This is to make sure that the video does not continue to play but the user is not presented wih a black screen.
                    this.__transitionToPausedState();

                    switch (result.reason) {

                        case silkResponseHelper.SILK_CODE.PLAY_SESSION_TOKEN_LIFESPAN_REACHED:
                            sSilkMessagesManager.getSilkMessageForCode(silkResponseHelper.SILK_CODE.PLAY_SESSION_TOKEN_LIFESPAN_REACHED).then(util.bind(function (silkMessage) {

                                this.displayErrorDialog(silkMessage.get("description"));

                            }, this));
                            break;
                        default:
                            this.displayErrorDialog(sLanguageManager.getString("Player.Player_labelPlaybackFailed"));
                            break;

                    }
                }

            }, this));
        },

        /**
         * Kill heartbeat api calls.
         * @return {void}
         */
        killHeartbeat: function () {
            sPlaybackManager.killHeartbeat();
        },

        isFooterFocused: function() {

            if (this.__footerContainer && (focusManager.isCompChildFocused(this.__footerContainer) || focusManager.isCompFocused(this.__footerContainer))) {
                return true
            }

            return false
        },

        doHistoryBack: function() {
            sHistoryManager.back();        
        },

        handleBackEvent: function() {
            var mediaType = this.__mediaType;
            var currentAssetId = this.__currentAsset && this.__currentAsset.get("id");

            // Trailers without adult content do not require login.
            // Heartbeat would stop a trailer directly in case no user is logged in.
            // Therefore start heartbeat only in case the media type is movie, which would require a logged in user for playback.
            if (mediaType && mediaType === "movie" && currentAssetId) {
                sPlaybackManager.heartbeat(currentAssetId, true).then(util.bind(function() {
                    this.doHistoryBack();
                }, this));
            } else {
                this.doHistoryBack();
            }
        },

        onKey: function (evt) {
            var videoState = this.__videoManager.getState();
            if (evt.id !== vKey.BACK.id) {
                this.__showUI();
            }

            switch (evt.id) {
                case vKey.YELLOW.id:
                case 'playstation:vkey:triangle':
                    // Only allow toggle if we have more than one track.
                    // @TODO: This is ignored on live streams, we may want to support this (SKYSTORM-440).
                    if ((this.__numberOfAudioTracks > 1) && (!this.__isLinear)) {
                        this.__videoManager.toggleAudio();
                    }
                    break;
            case vKey.PLAY_PAUSE.id:
                this.__playPauseButtonPressed();
                break;
            case vKey.PLAY.id:
                if (!this.__videoIsPlaying) {
                    this.__transitionToPlayingState();
                }
                break;
            case vKey.PAUSE.id:
                if (!this.__isLinear && this.__videoIsPlaying) {
                    this.__transitionToPausedState();
                }
                break;
            case vKey.STOP.id:
            case "device:kb-vkey:s":
                this.__transitionToPlayingStoppedEvent();
                break;
            case vKey.BACK.id:
                mediator.publish(VideoControlsStatusEvent.DismissSelected);
                this.handleBackEvent()
                return false;
            case vKey.RW.id:
            case vKey.LEFT.id:

                if (evt.id === vKey.LEFT.id && this.isFooterFocused()) {
                    return true
                }

                if (!this.__isLinear && (videoState !== BUFFERING && videoState !== CONNECTING)) {
                    var delaySeconds = (device.platform === "playstation") ? 0.5 : ONESECOND,
                        skipSeconds = (this.__currentTime < TENSECONDS) ? this.__currentTime : TENSECONDS; // ensure it doesn't seek out of video range. 
                    
                    this.setUIForState(RW);
                    this.__videoManager.skip({
                        sec: (-skipSeconds),
                        delaySec: delaySeconds,
                        progressive: true
                    });
                }
                return true;
            case vKey.PREV.id:
                this.setUIForState(RW);
                this.__videoManager.skip({
                    sec: (-SIXTYSECONDS),
                    delaySec: ONESECOND,
                    progressive: true
                });
                return true;
            case vKey.FF.id:
            case vKey.RIGHT.id:

                if (evt.id === vKey.RIGHT.id && this.isFooterFocused()) {
                    return true
                }

                if (!this.__isLinear && (videoState !== BUFFERING && videoState !== CONNECTING)) {
                    var delaySeconds = (device.platform === "playstation") ? 0.5 : ONESECOND,
                        remainSeconds = this.__duration - this.__currentTime,
                        skipSeconds = (remainSeconds < TENSECONDS) ? remainSeconds : TENSECONDS; // ensure it doesn't seek out of video range.

                    this.setUIForState(FF);
                    this.__videoManager.skip({
                        sec: skipSeconds,
                        delaySec: delaySeconds,
                        progressive: true
                    });
                }
                return true;
            case vKey.NEXT.id:
                this.setUIForState(FF);
                this.__videoManager.skip({
                    sec: (SIXTYSECONDS),
                    delaySec: ONESECOND,
                    progressive: true
                });
                return true;
            default:
                return true;
            }
            return false;
        },

        reset: function () {

            this.setUIForState();

            this.killHeartbeat();

            mediator.publish(VideoControlsStatusEvent.DismissSelected);

            mediator.unsubscribe(VideoPlaybackControlsEvent.SetControlsInPlayState, this.__setControlsInPlayStateRef);
            mediator.unsubscribe(VideoPlaybackControlsEvent.SetControlsInPauseState, this.__setControlsInPauseStateRef);
            mediator.unsubscribe(VideoPlaybackControlsEvent.UpdatePlayheadState, this.__updatePlayheadStateRef);
            mediator.unsubscribe(VideoPlaybackControlsEvent.DismissControls, this.__dismissControlsRef);
            mediator.unsubscribe(VideoPlaybackControlsEvent.NotifyError, this.__setControlsInErrorState);
            mediator.unsubscribe(VideoPlaybackStatusEvent.PlayState, this.__playStateRef);
            mediator.unsubscribe(VideoPlaybackStatusEvent.StopState, this.__stopStateRef);
            mediator.unsubscribe(VideoPlaybackStatusEvent.PauseState, this.__pauseStateRef);
            mediator.unsubscribe(VideoPlaybackStatusEvent.BufferState, this.__bufferStateRef);
            mediator.unsubscribe("onAudioTracks", this.__audioTracksRef);
            mediator.unsubscribe("onAudioTrackChange", this.__audioTracksChangeRef);
            mediator.unsubscribe("mouseOn", this.__mouseOnRef);
            mediator.unsubscribe("mouseOff", this.__mouseOffRef);
            this.__videoManager.deinit();

            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdated);
            mediator.unsubscribe(UserEvent.UserHasBeenLoggedOut, this.__userHasBeenLoggedOutHandler);

            clearTimeout(this.__hideUITimer);
            sAppRoot.getView().removeClass("fullscreen-video-mode");
            this.getView().removeEventListener(evtType.KEY, this.__onKeyRef);

            this.removeCtaListeners();

            this._sTrackingManager.trackCloseMedia();
            conviva.cleanUpSession();

        }
    });
});

/**
 * Submenu is a widget that controls the submenu appears on screen.
 * The submenu accepts array of JSON and render a list of buttons. Each object is a JSON object, where a _text_ property is mandatory.
 * This widget also handles the selection state of the items.
 * The other component can listen to the CLICK event of this widget and get the selected state inside the handler for subsequent actions.
 * @name HighlightsMenu
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/HighlightsMenu
 * @extends ax/ext/ui/Layout
 */
define("tvedemo/wgt/HighlightsMenu", ["xdk-base/class", "xdk-base/core", "xdk-ui-basic/Layout", "xdk-ax/evt/type", "xdk-ui-basic/Button", "xdk-base/util"], function (klass, core, Layout, evtType, Button, util) {

    return klass.create(Layout, {}, {

        //Array of submenu items
        _items: [],

        //Index of the selected item
        _selectedIndex: -1,

        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} opts Options
         * @param {Array} items The menu items' object array
         * @memberof tvedemo/wgt/Submenu#
         */
        init: function (opts) {
            opts.alignment = Layout.HORIZONTAL;
            opts.forwardFocus = true;

            this._super(opts);
            //this.addClass("wgt-submenu");

            if (opts.items) {
                this.setItems(opts.items);
            }

            // listen in the capturing phase to preceed others
            this.addEventListener(evtType.CLICK, this._onClick, false);
        },

        setItems: function (items) {
            this._items = items;
            this._initUI();
        },

        /**
         * Initiate the widget UI.
         * @method
         * @protected
         * @memberof tvedemo/wgt/Submenu#
         */
        _initUI: function () {
            // remove all existing menu items
            this.detachAll();

            // attach new items according to the pre-defined sequence
            for (var i = 0, len = this._items.length; i < len; i++) {
                new Button({
                    css: "wgt-highlightsMenu-item",
                    text: this._items[i].text ? this._items[i].text : this._items[i],
                    parent: this
                })/*.removeClass("wgt-button").addClass("menu-button")*/;
            }
        },

        /**
         * Get the selected item.
         * @method
         * @public
         * @memberof tvedemo/wgt/Submenu#
         */
        getSelection: function () {
            return this._items[this._selectedIndex];
        },

        /**
         * Get the selected index.
         * @method
         * @public
         * @memberof tvedemo/wgt/Submenu#
         */
        getSelectedIndex: function () {
            return this._selectedIndex;
        },

        /**
         * Select an item using the index.
         * @method
         * @public
         * @param {int} index The target selected index
         * @memberof tvedemo/wgt/Submenu#
         */
        select: function (index) {
            if (index < 0 || index >= this._items.length) {
                throw core.createException("Invalid param", "Array index out of bound");
            }

            this._select(index);
        },

        /**
         * Select the submenu item by updating the selectedIndex and CSS of the DOM elements.
         * @method
         * @protected
         * @param {int} index The target selected index
         * @memberof tvedemo/wgt/Submenu#
         */
        _select: function (index) {
            var children = this.getChildren();

            if (this._selectedIndex >= 0 && children[this._selectedIndex]) {
                children[this._selectedIndex].removeClass("selected");
            }

            this._selectedIndex = index;
            children[this._selectedIndex].addClass("selected");
        },

        /**
         * Handle the CLICK event.
         * This function modify the selected index and the css of the children.
         * @method
         * @protected
         * @param {Event} evt The key event sent from XDK
         * @memberof tvedemo/wgt/Submenu#
         */
        _onClick: function (evt) {
            var childIndex = util.indexOf(this.getChildren(), evt.target);
            this._select(childIndex);
        }
    });
});
/**
 * Home view's template
 * When open the app, home view is the first view after splash video/page.
 * @name home
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/home
 */
define("tvedemo/tmpl/home", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/BasicGrid",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "tvedemo/wgt/AssetGrid",
    "tvedemo/wgt/HighlightsMenu",
    "xdk-ax/Container",
    "storm/mgr/sLanguageManager"
], function (
    Layout,
    Label,
    BasicGrid,
    LoopedGrid,
    AssetGrid,
    HighlightsMenu,
    Container,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            id: "#homeView",
            width: 1,
            alignment: Layout.HORIZONTAL,
            css: "subcontrollerPage",
            children: [{
                klass: Label,
                id: "homePanelLabel",
                css: "home-panel-label",
                text: sLanguageManager.getString("Startscreen.Startscreen_NowOnSky").toUpperCase()
            },{
                klass: LoopedGrid,
                alignment: LoopedGrid.VERTICAL,
                scrollFrontBoundary: 1,
                scrollEndBoundary: 3,
                id: "homePanelGrid",
                css: "home-panel-grid",
                rows: 5,
                cols: 1
            },{
                klass: Container,
                id: "#homeOverlay",
                css: "overlay"
            },{
                klass: Layout,
                alignment: Layout.HORIZONTAL,
                css: "highlightsBar",
                id: "highlightsBar",
                children:[{
                    klass: Label,
                    id: "homePanelHighlightsLabel",
                    css: "home-panel-label",
                    text: sLanguageManager.getString("Landingpages.Landingpages_Highlights_Title").toUpperCase()
                },{
                    klass: Container,
                    css: "highlightsMenu",
                    children: [{
                        klass: HighlightsMenu,
                        id: "highlightsMenu"
                    }]
                }]
            },{
                klass: Container,
                id: "#highlightsContainer",
                css: "highlightsContainer"
            }]
        };
    };
});
/**
 * HomeGridButton is a widget that appear in the grid inside home screen.
 *
 * @name HomeGridButton
 * @class tvedemo/wgt/HomeGridButton
 * @extends ax/ext/ui/Container
 */
define("tvedemo/wgt/HomeGridButton", [
    "xdk-base/class",
    "xdk-base/core",
    "xdk-ax/Container",
    "storm/wgt/Image",
    "xdk-ui-basic/Label",
    "storm/mgr/sAppConfigManager",
    "xdk-base/util",
    "tve/mgr/sLinearManager"
], function (
    klass,
    core,
    Container,
    Image,
    Label,
    sAppConfigManager,
    util,
    sLinearManager
    ) {

    "use strict";

    var TRANSPARENT_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAA1JREFUCNdjYGBgMAYAADgANNF/knAAAAAASUVORK5CYII=";

    return klass.create(Container, {}, {
        init: function (opts) {
            opts = opts || {};
            opts.focusable = true;
            opts.clickable = true;

            this._super(opts);
            this.addClass("wgt-homegridbtn");

            this._imageContainer = new Container({
                css: "wgt-homegridbtn-imgDiv",
                parent: this
            });

            this._image = new Image({
                css: "wgt-homegridbtn-bg",
                parent: this._imageContainer,
                placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
            });

            if (opts.image) {
                sLinearManager.constructCMSUrlPromise(opts.image).then(util.bind(function (url) {
                    this._image.setSrc(url);
                }, this));
            } else {
                this._image.fallback();
            }

            this._imageTime = new Container({
                css: "wgt-homegridbtn-tint",
                parent: this._imageContainer
            });

            this._channelImage = new Image({
                css: "wgt-homegridbtn-channel",
                parent: this._imageContainer
            });

            if (opts.channelImage) {
                sLinearManager.constructCMSUrlPromise(opts.channelImage).then(util.bind(function (url) {
                    this._channelImage.setSrc(url);
                }, this));
            } else {
                this._channelImage.fallback();
            }

            if (opts.category && opts.category.length) {
                this._categoryLabel = new Label({
                    css: "wgt-homegridbtn-category",
                    text: opts.category,
                    parent: this._imageContainer
                });
            }

            this._textContainer = new Container({
                css: "wgt-homegridbtn-text-block",
                parent: this
            });

            this._label = new Label({
                css: "wgt-homegridbtn-title",
                text: opts.title || "",
                parent: this._textContainer
            });

            this._periodLabel = new Label({
                css: "wgt-homegridbtn-period",
                text: opts.period,
                parent: this._textContainer
            });

            this._fskLabel = new Label({
                css: "wgt-homegridbtn-fsk",
                text: opts.fsk,
                parent: this._textContainer
            });

            if (opts.metadata && opts.metadata.length) {
                this._metaDataLabel = new Label({
                    css: "wgt-homegridbtn-meta",
                    text: opts.metadata,
                    parent: this._textContainer
                });
            }
        }
    });
});

/**
 * HightlightsButton is a widget that appears in the highlights grid on the home screen.
 *
 * @name HighlightsButton
 * @class tvedemo/wgt/HighlightsButton
 * @extends ax/ext/ui/Container
 */
define("tvedemo/wgt/HighlightsButton", [
    "xdk-base/class",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-ax/Container",
    "storm/wgt/Image",
    "xdk-ui-basic/Label",
    "tve/mgr/sLinearManager",
    "tvedemo/mgr/sAssetManager",
    "xdk-base/Element",
    "storm/mgr/sAppConfigManager"
], function (
    klass,
    core,
    util,
    Container,
    Image,
    Label,
    sLinearManager,
    sAssetManager,
    Element,
    sAppConfigManager
    ) {

    "use strict";

    var TRANSPARENT_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAA1JREFUCNdjYGBgMAYAADgANNF/knAAAAAASUVORK5CYII=";
    var HIGHLIGHT_IMAGE_TYPE = "gallery"; // 270 x 152 16:9 image

    return klass.create(Container, {}, {
        trimSportTitle: function(title) {
          var titleArr = title.split(": ");
          if (titleArr.length > 1) {
            titleArr[0] = null;
          }
          return titleArr.join("");
        },
        init: function (opts) {
            // To check the content we're making a button of
            // console.log(opts);
            opts = opts || {};
            opts.focusable = true;
            opts.clickable = true;
            opts.root = new Element("div"); // To enable the looping, but there must be a better way?
            this._super(opts);
            this.addClass("wgt-assetbtn");

            this._imageContainer = new Container({
                parent: this
            });

            // Determine which picture to show.
            var image, title, category, rating, isNaturallyLandscape, extraInfo = "";

            if (opts.type === "Film") {
                isNaturallyLandscape = false;
                title = opts.title;
                category = opts.category.main.content;
                rating = opts.parental_rating.display;
            }
            else if (opts.type === "Episode") {
                isNaturallyLandscape = true;
                title = opts.serie_title;
                category = opts.category.main.content;
                rating = opts.parental_rating.display;
            }
            else if (opts.type === "Series") {
                isNaturallyLandscape = true;
                title = opts.title;
                category = opts.category.main.content;
                rating = opts.parental_rating.display;
            }
            else if (opts.type === "Sport") {
                isNaturallyLandscape = true;
                title = this.trimSportTitle(opts.title);
                category = opts.category.main.content;
                rating = opts.parental_rating.display;
                extraInfo = opts.on_air.start_time + " - " + opts.on_air.end_time;
            }
            else if (opts.type === "sportsNews") {
                image =  opts.image;
                title = opts.title;
                category = opts.category;
                rating = "";
            }
            else if (opts.type === "redirect") {
                image =  '';
                title = 'Alle ' + opts.page_type;
            }

            // Use image shape explicitly configured, if we can...

            if (util.isUndefined(opts._isLandscape)) {
                opts._isLandscape = isNaturallyLandscape;
            }

            if (opts._isLandscape === true) {

                if (!opts || !opts.main_picture || !opts.main_picture.picture || !opts.main_picture.picture.length) {
                    image = null;
                    console.warn("Could not find a 16:9 image to display");
                }
                else {
                    image = opts.main_picture.picture[0].path + "/" + opts.main_picture.picture[0].file;

                    util.each(opts.main_picture.picture, function (imageJSON) {
                        if (!imageJSON.path || !imageJSON.file) {
                            return;
                        }
                        if (imageJSON.type === HIGHLIGHT_IMAGE_TYPE) {   // @TODO: SKYSTORM-233  // @TODO: enumeration/configurable
                            image = imageJSON.path + "/" + imageJSON.file;
                            return util.breaker;
                        }
                    });
                }
            }

            if (opts._isLandscape === false) {
                if (opts.dvd_cover && opts.dvd_cover.path && opts.dvd_cover.file) {
                    image = opts.dvd_cover.path + "/" + opts.dvd_cover.file;
                }
            }

            this._image = new Image({
                css: "wgt-assetbtn-thumbnail",
                parent: this._imageContainer,
                placeHolderPromise: opts._isLandscape ? sAppConfigManager.getPlaceholderLandscape : sAppConfigManager.getPlaceholderPortrait
            });

            if (image) {
                sLinearManager.constructCMSUrlPromise(image).then(util.bind(function (url) {
                    this._image.setSrc(url);
                }, this));
            }
            else {
                this._image.fallback();
            }

            this._textContainer = new Container({
                css: "wgt-assetbtn-container",
                parent: this
            });

            this._label = new Label({
                css: "wgt-assetbtn-title",
                text: title.toUpperCase() || "",
                parent: this._textContainer
            });

            var colourCode = opts.package_code;
            if (!colourCode) {
                colourCode = opts.package_color_code;
            }

            this._categoryLabel = new Label({
                text: category,
                css: "wgt-assetbtn-category",
                parent: this._textContainer
            });

            this._extraInfoLabel = new Label({
                text: extraInfo,
                css: "wgt-assetbtn-extrainfo",
                parent: this._textContainer
            });

            this._ratingLabel = new Label({
                text: rating,
                css: "wgt-assetbtn-rating",
                parent: this._textContainer
            });

        }
    });
});

/**
 * Context Model. Used to pass context information when navigating between different pages within the app.
 * @class tvedemo/model/Context
 * @author Mathias Pedersen <mathias.pedersen@accedo.tv>
 */
define("tvedemo/model/Context", ["xdk-base/class", "tve/model/ImmutableModel"], function(klass, ImmutableModel) {
    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {
            /**
             * @member data
             * @memberof tvedemo/model/Context#
             * @public
             * @type {Object}
             */
            "data": null,
            /**
             * @member diagnosticData
             * @memberof tvedemo/model/Context#
             * @public
             * @type {String}
             */
            "diagnosticData": null
        }
    }, {});
});
/**
 * Context Builder, for building the Context model
 * @class tvedemo/model/ContextBuilder
 */
define("tvedemo/model/ContextBuilder", ["xdk-base/class", "tvedemo/model/Context"], function (klass, Context) {

    var Builder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof tvedemo/model/ContextBuilder#
         * @protected
         */
        _attrs: {},

        /** 
         * Set the data for building this model.
         * @param {String} value the data
         * @return {tvedemo/model/ContextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/ContextBuilder#
         */
        setData: function (value) {
            this._attrs.data = value;
            return this;
        },

        /** 
         * Set the diagnostic data for building this model.
         * @param {String} value the diagnostic data
         * @return {tvedemo/model/ContextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof tvedemo/model/ContextBuilder#
         */
        setDiagnosticData: function (value) {
            this._attrs.diagnosticData = value;
            return this;
        },

        /**
         * Build the Context model.
         * @return {tvedemo/model/Context} the Context model
         * @public
         * @method
         * @memberof tve/model/ContextBuilder#
         */
        build: function () {
            return new Context(this._attrs);
        }
    });

    return Builder;
});
/**
 * The Home page's controller.
 * @name Home
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Home
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Home", [
    "xdk-base/ax",
    "tvedemo/helper/sMoment",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "xdk-ax/data/LocalDatasource",
    "tvedemo/tmpl/home",
    "storm/mgr/sAppConfigManager",
    "tve/mgr/sVODManager",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/mediator",
    "xdk-ax/mvc/AppRoot",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/promise",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/ConfirmDialog",
    "tvedemo/wgt/HomeGridButton",
    "xdk-base/console",
    "tve/sServiceHolder",
    "tve/mgr/sLinearManager",
    "tvedemo/wgt/HighlightsButton",
    "tvedemo/model/ContextBuilder",
    "tvedemo/mgr/sNavigationManager",
    "storm/helper/util",
    "storm/event/LifecycleEvent",
    "storm/mgr/sLanguageManager",
    "tvedemo/mgr/deepLinkingManager"
], function (
    ax,
    moment,
    RoutableController,
    view,
    LocalDatasource,
    homeTmpl,
    sAppConfigManager,
    sVODManager,
    util,
    evtType,
    mediator,
    AppRoot,
    focusManager,
    vKey,
    promise,
    LoopedGrid,
    dialogHelper,
    ConfirmDialog,
    HomeGridButton,
    console,
    sServiceHolder,
    sLinearManager,
    HighlightsButton,
    ContextBuilder,
    sNavigationManager,
    stormUtil,
    LifecycleEvent,
    sLanguageManager,
    deepLinkingManager
    ) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        SIXTEEN_NINE = "16:9",
        SSN_CHANNEL_NAME = "Sky Sport News HD",// See SKYSTORM-684.
        MAX_HIGHLIGHTS_DS = 20,// See SKYSTORM-554.

        EXCERPT_FOCUS_COLUMN = 1,// See SKYSTORM-719

    // Highlights grid asset types...
        HIGHLIGHTS = {
            MOVIE : "Film",
            EPISODE : "Episode",
            SERIES : "Series",
            SPORT_EVENT : "Sport",
            SPORT_NEWS : "sportsNews", // Deprecated; we don't expect to see these based on the hardcoded data URLs Sky supply now / wireframes.
            REDIRECT : "redirect"
        },

    //
        hasHomeInitialisedBefore = false;

    return ax.klass.create(RoutableController, {}, {

        init: function () {
            this.setView(view.render(homeTmpl));
        },

        setup: function (context) {
            var currentView = this.getView();

            this.trackLevel(1, "Home");

            this.homePanelGrid = currentView.find("homePanelGrid");
            this.subContainer = currentView.find("highlightsContainer");
            this.subBar = currentView.find("highlightsBar");
            this.submenu = currentView.find("highlightsMenu");
            this.overlay = currentView.find("homeOverlay");

            // Highlights grid.
            this.__boundHighlightsGridClickHandler = util.bind(this._highlightsGridClickHandler, this);
            this.subContainer.addEventListener(evtType.CLICK, this.__boundHighlightsGridClickHandler);

            this.__boundKeyHandler = util.bind(this.keyHandler,this);
            this.__boundSubMenuBlur = util.bind(this.subMenuBlur,this);
            this.__boundSubMenuFocus = util.bind(this.subMenuFocus,this);
            this.__boundSubMenuClick = util.bind(this.subMenuClick,this);

            currentView.addEventListener(evtType.KEY, this.__boundKeyHandler);
            this.submenu.addEventListener(evtType.BLUR, this.__boundSubMenuBlur);
            this.submenu.addEventListener(evtType.FOCUS, this.__boundSubMenuFocus);
            this.submenu.addEventListener(evtType.CLICK, this.__boundSubMenuClick);

            this.__boundHomePanelGridClickHandler = util.bind(this.homePanelGridClickHandler, this);
            this.homePanelGrid.addEventListener(evtType.CLICK, this.__boundHomePanelGridClickHandler);

            sNavigationManager.triggerResetMenu(true);
            if (context.historyBack) {
                if (this.subBar && this.subBar.getRoot() && this.subBar.getRoot().hasClass("focused")) {
                    //sAppRoot.getView().addClass("show-overlay");
                    this.showOverlay();
                }
                if (!focusManager.isCompChildFocused(this.getView()) && !focusManager.focus(this.homePanelGrid)) {
                    focusManager.focus(this.subBar);
                }
                return;
            }

            this._curIndexGrid = 0;
            this._highlightsCatalog = undefined;

            // Populating the tabs of the highlight panel.
            var highlightsPromise = sServiceHolder.getLinearContentService().getHomePageHighlights().then(util.bind(function(highlights){
                var tabTitles = [];
                for (var i=0; i<highlights.length; i++) {
                    tabTitles.push(highlights[i].title);
                }
                this.submenu.setItems(tabTitles);
                this.submenu.select(this._curIndexGrid);
                return this.updateHighlightsGrid(this._curIndexGrid);
            },this), function(problem) {
                console.warn("Unable to get home page highlights due to " + problem);
            });

            this.homePanelGrid.setDisplayStgy(function (data) {
                var bIsSkySportsNews = (data && data.channel && (data.channel.name === SSN_CHANNEL_NAME));
                return new HomeGridButton({
                    id: data.event.id,
                    title: data.event.title,
                    metadata: bIsSkySportsNews?"":data.event.subtitle,
                    period: data.event.startTime + "-" + data.event.endTime,
                    image: data.event.image,
                    channelImage: data.channel.logo,
                    channelColour: data.channel.mobilepc,
                    fsk: data.event.fskInfo
                });
            });

            this._handleDeeplinkRef = util.bind(function() {
                deepLinkingManager.navigate(context.deepLinkData.contentType, context.deepLinkData.assetId);

                mediator.unsubscribe("navigated", this._handleDeeplinkRef);
            }, this);

            if (context && context.deepLinkData && context.deepLinkData.contentType && context.deepLinkData.assetId) {
                mediator.subscribe("navigated", this._handleDeeplinkRef);
            }

            context.setupPending = stormUtil.allPromises([this.setupHomePanelGrid(context), highlightsPromise]).then(util.bind(function() {
                if (!focusManager.focus(this.homePanelGrid)) {
                    focusManager.focus(this.subBar);
                }

                if (!hasHomeInitialisedBefore) {
                    hasHomeInitialisedBefore = true;
                    mediator.publish(LifecycleEvent.HomePageInitialised);
                }
            }, this));
        },

        setupHomePanelGrid: function () {
            return promise.all([
                sLinearManager.getCurrentlyRunningEvents(),
                sServiceHolder.getLinearContentService().getAllChannelIds()
            ]).spread(util.bind(function(eventList, channelIdList) {
                //
                // For this area of the UI we sort the current events list according to the associated channel LCNs, according to SKYSTORM-212.
                //
                // Note that the corresponding business requirement for the Sport home page is different.
                //
                eventList = eventList.sort(function(a, b) {
                    var indexOfA = channelIdList.indexOf(a.channel.id),
                        indexOfB = channelIdList.indexOf(b.channel.id);

                    return (indexOfA > indexOfB);
                });

                var ds = new LocalDatasource(),
                    dataLoader = function () {
                        var defer = promise.defer();
                        defer.resolve({
                            total: eventList.length,
                            data: eventList
                        });
                        return defer.promise;
                    };

                ds.setDataLoader(dataLoader);

                if (!eventList.length) {
                    this.homePanelGrid.setOption("focusable", false);
                    this.subBar.setOption("nextUp", "header");
                }

                return this.homePanelGrid.setDatasource(ds).then(util.bind(function() {
                    this.homePanelGrid.select(0, EXCERPT_FOCUS_COLUMN); // Zeroth data to appear in a specific column.
                }, this));
            }, this));
        },

        homePanelGridClickHandler: function () {
            var selectedData = this.homePanelGrid.getSelectedData(),
                contextBuilder = new ContextBuilder(),
                context = contextBuilder.setData({
                    channelId: selectedData.channel.id,
                    eventId: selectedData.event.id,
                    epgExcerptEvent: selectedData.event
                }).build();

            mediator.publish("navigate", {
                path: "Main/EpgEvent",
                state: {
                    context: context
                }
            });
        },

        makeHighlightsGrid: function(imgSize) {
            var css, rows, bounds;
            if (imgSize === SIXTEEN_NINE) {
                css = "movie-grid wide";
                rows = 5;
                bounds = 2;
            } else {
                css = "movie-grid";
                rows = 7;
                bounds = 3;
            }

            if (this.highlightsGrid) {
                this.highlightsGrid.detach();
            }

            this.highlightsGrid = new LoopedGrid({
                css: css,
                id: "moviesAssetGrid",
                rows: rows,
                cols: 1,
                alignment: LoopedGrid.VERTICAL,
                scrollFrontBoundary: bounds,
                scrollEndBoundary: bounds,
                parent: this.subContainer
            });

            this.highlightsGrid.setDisplayStgy(function (data) {
                data._isLandscape = (imgSize === SIXTEEN_NINE);
                return new HighlightsButton(data);
            });

            return bounds;
        },

        _highlightsGridClickHandler: function() {
            // Remove the dark overlay, else it persists over the new details page.
            //sAppRoot.getView().removeClass("show-overlay");
            this.hideOverlay();
            var asset = this.highlightsGrid.getSelectedData();

            if (asset.type === HIGHLIGHTS.MOVIE) {
                mediator.publish("navigate", {
                    path: "Main/Movie",
                    state: {
                        assetId: asset.id,
                        catalog: this._highlightsCatalog
                    }
                });
            }
            else if (asset.type === HIGHLIGHTS.EPISODE) {
                mediator.publish("navigate", {
                    path: "Main/Episode",
                    state: {
                        selectedEpisodeId: asset.id,
                        catalog: this._highlightsCatalog
                    }
                });
            }
            else if (asset.type === HIGHLIGHTS.SERIES) {
                mediator.publish("navigate", {
                    path: "Main/TVShow",
                    state: {
                        serieId: asset.id,
                        catalog: this._highlightsCatalog
                    }
                });
            }
            else if (asset.type === HIGHLIGHTS.SPORT_EVENT) {
                mediator.publish("navigate", {
                    path: "Main/Sport",
                    state: {
                        assetId: asset.id,
                        catalog: this._highlightsCatalog
                    }
                });
            }
            else if (asset.type === HIGHLIGHTS.SPORT_NEWS) {
                mediator.publish("navigate", {
                    path: "Main/News",
                    state: {
                        selectedNewsId: asset.id,
                        selectedNewsCategory: asset.category_id
                    }
                });
            }
            else if (asset.type === HIGHLIGHTS.REDIRECT) {
                mediator.publish("navigate", {
                    path: "Main/" + asset.page_type + 'Home',
                    state: {
                        selectedNewsId: asset.id,
                        selectedNewsCategory: asset.category_id
                    }
                });
            }
            else {
                console.warn("Clicked on unexpected type " + asset.type);
            }
            return false;
        },

        updateHighlightsGrid: function (index) {
            this._curIndexGrid = index;
            var ds;

            // Getting the highlights information.
            return sServiceHolder.getLinearContentService().getHomePageHighlights().then(util.bind(function(highlights) {
                // Setting the datasource based on the tab we selected.
                ds = new LocalDatasource();

                ds.setDataLoader(util.bind(function () {
                    return sLinearManager.getAssetListing(highlights[index].url).then(util.bind(function (assetListObject) {
                        var assetList = assetListObject.listing;
                        this._highlightsCatalog = assetListObject.catalog;
                        if (assetList.length > MAX_HIGHLIGHTS_DS) {
                            assetList = assetList.slice(0, MAX_HIGHLIGHTS_DS);
                        }

                        var extendedHighlights = this.extendHighlighAssets(assetList, highlights[index].title);
                        return {
                            data: extendedHighlights,
                            total: extendedHighlights.length
                        };
                    }, this));
                }, this));

                if (!ds) {
                    console.warn("No available datasource");
                    return false;
                }

                // Make the appropriate grid.
                var gridBounds = this.makeHighlightsGrid(highlights[index].displayType);
                return this.highlightsGrid.setDatasource(ds).then(util.bind(function(){
                    this.highlightsGrid.select(0, gridBounds); // Zeroth data to appear in a specific column.
                }, this));
            }, this));
        },

        extendHighlighAssets: function(highlights, tabTitle) {
          return [{
            type: 'redirect',
            page_type: tabTitle,
            title: ''
          }].concat(highlights)
        },

        hideHighlights: function () {
            this.subBar.removeClass("focused");
            this.subContainer.removeClass("focused");
            //sAppRoot.getView().removeClass("show-overlay");
            this.hideOverlay();
        },

        subMenuBlur: function (e) {
            console.log(e.relatedTarget);
            if (!e.relatedTarget.isDescendantOf(this.subContainer)) {
                //Contracts the highlights menu when focusing away from it
                this.hideHighlights();
            }
        },

        subMenuFocus: function () {
            //expand the highlights menu when focusing on it
            this.subBar.addClass("focused");
            this.subContainer.addClass("focused");
            this.showOverlay();
            //sAppRoot.getView().addClass("show-overlay");
        },

        subMenuClick: function () {
            if (this._curIndexGrid !== this.submenu.getSelectedIndex()) {
                this.updateHighlightsGrid(this.submenu.getSelectedIndex());
            }
        },

        showOverlay: function() {
            this.overlay.addClass("visible");
        },

        hideOverlay: function() {
            this.overlay.removeClass("visible");
        },

        keyHandler: function (evt) {
            switch (evt.id) {
                case vKey.UP.id:
                    //Automatically focus the selected item in the Highlights menu
                    if (focusManager.getCurFocus().getParent() === this.submenu) {
                        focusManager.focus(this.submenu.getChildren()[this.submenu.getSelectedIndex()]);
                    }
                    else {
                        return true;
                    }
                    break;

                default:
                    return true;
            }
            return false;
        },

        reset: function () {
            if (this.subBar && this.subBar.getRoot() && this.subBar.getRoot().hasClass("focused")) {
                //sAppRoot.getView().removeClass("show-overlay");
                this.hideOverlay();
            }

            this.getView().removeEventListener(evtType.KEY, this.__boundKeyHandler);
            this.submenu.removeEventListener(evtType.BLUR, this.__boundSubMenuBlur);
            this.submenu.removeEventListener(evtType.FOCUS, this.__boundSubMenuFocus);
            this.submenu.removeEventListener(evtType.CLICK, this.__boundSubMenuClick);

            this.homePanelGrid.removeEventListener(evtType.CLICK, this.__boundHomePanelGridClickHandler);
            this.subContainer.removeEventListener(evtType.CLICK, this.__boundHighlightsGridClickHandler);

            mediator.unsubscribe("navigated", this._handleDeeplinkRef);

            this._super();
        }
    });
});

/**
 * Login view's template
 * @name login
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/login
 */

define("tvedemo/tmpl/login", [
    "xdk-ui-basic/Image",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Button",
    "tvedemo/wgt/input/Input",
    "xdk-ui-basic/Label",
    "xdk-ax/Container",
    "tvedemo/wgt/Keyboard",
    "storm/mgr/sLanguageManager"
], function (
    Img,
    Layout,
    Button,
    Input,
    Label,
    Container,
    Keyboard,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Container,
            css: "fullscreen-controller login",
            children: [
                {
                    klass: Container,
                    css: "main-view",
                    children: [
                        {
                            klass: Container,
                            id: "form",
                            css: "login-form",
                            forwardFocus: true,
                            children: [{
                                klass: Label,
                                css: "title",
                                text: sLanguageManager.getString("Login.Login_labelHeadline").toUpperCase()
                            },
                                {
                                    klass: Label,
                                    css: "input-header",
                                    text: sLanguageManager.getString("Login.Login_labelCustomerIDLabel"),
                                    id: "userNameLabel"
                                },
                                {
                                    klass: Input,
                                    id: "usernameButton",
                                    maxLength: 100,
                                    focusable: true,
                                    nextDown: "passwordButton"
                                },
                                {
                                    klass: Label,
                                    css: "input-header",
                                    text: sLanguageManager.getString("Login.Login_labelPINLabel"),
                                    id: "passwordLabel"
                                },
                                {
                                    klass: Input,
                                    id: "passwordButton",
                                    isPassword: true,
                                    focusable: true,
                                    maxLength: 4,
                                    hideTimeout: 0,
                                    nextUp: "usernameButton",
                                    nextDown: "buttonContainer"
                                },
                                {
                                    klass: Layout,
                                    id: "buttonContainer",
                                    css: "button-container",
                                    forwardFocus: true,
                                    nextUp: "passwordButton",
                                    children: [{
                                        klass: Button,
                                        id: "loginButton",
                                        text: sLanguageManager.getString("Login.Login_buttonSignIn")
                                    }]
                                },
                                {
                                    klass: Label,
                                    css: "forgottenText",
                                    text: sLanguageManager.getString("Login.Login_labelForgottenPIN")
                                }]
                        },
                        {
                            klass: Container,
                            id: "registerText",
                            css: "registerText",
                            children: [
                                {
                                    klass: Label,
                                    css: "title",
                                    text: sLanguageManager.getString("Settings.Settings_labelRegister").toUpperCase()
                                },
                                {
                                    klass: Label,
                                    css: "content",
                                    text: sLanguageManager.getString("Login.Login_registerMessage")
                                }
                            ]
                        },
                        {
                            klass: Container,
                            id: "keyboardPatch2012",
                            css: "keyboardPatch2012"
                        }
                    ]
                }
            ]
        };

    };
});
/**
 * SettingsText Model
 * @class storm/model/SettingsText
 */
define("storm/model/SettingsText", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member title - Some text to show in a heading at the top
             * @memberof storm/model/SettingsText#
             * @public
             * @type {String}
             */
            "title": "",

            /**
             * @member label - Some text to show on an associated button or menu item
             * @memberof storm/model/SettingsText#
             * @public
             * @type {String}
             */
            "label": "",

            /**
             * @member body - the main text itself, with markup in it
             * @memberof storm/model/SettingsText#
             * @public
             * @type {String}
             */
            "body": ""
        }
    }, {});
});
/**
 * TermsText Model
 * @class storm/model/TermsText
 */
define("storm/model/TermsText", [
    "xdk-base/class",
    "xdk-base/util",
    "storm/model/SettingsText"
], function (
    klass,
    util,
    SettingsText
    ) {

    "use strict";

    return klass.create(SettingsText, {

        defaults: util.extend(util.clone(SettingsText.defaults), {

            /**
             * @member checkboxTextA - Some text to show next to the first checkbox (We have to be careful to get them wired up the right way round!)
             * @memberof storm/model/TermsText#
             * @public
             * @type {String}
             */
            "checkboxTextA": "",

            /**
             * @member checkboxTextB - Some text to show next to the second checkbox (Same issue!)
             * @memberof storm/model/TermsText#
             * @public
             * @type {String}
             */
            "checkboxTextB": "",

            /**
             * @member acceptButtonText - Text to be displayed on the acceptance button.
             * @memberof storm/model/TermsText#
             * @public
             * @type {String}
             */
            "acceptButtonText": ""

        }, true)

    }, {});
});
/**
 * SettingsText Builder, for building the SettingsText model
 * @class storm/model/SettingsTextBuilder
 */
define("storm/model/SettingsTextBuilder", [
    "xdk-base/class",
    "storm/model/SettingsText"
], function (
    klass,
    SettingsText
    ) {

    "use strict";

    var SettingsTextBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/SettingsTextBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the title for building the model.
         * @param {String} title
         * @returns {storm/model/SettingsTextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/SettingsTextBuilder#
         */
        setTitle: function (title) {
            this._attrs.title = title;
            return this;
        },

        /**
         * Set the label for building the model.
         * @param {String} label
         * @returns {storm/model/SettingsTextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/SettingsTextBuilder#
         */
        setLabel: function (label) {
            this._attrs.label = label;
            return this;
        },

        /**
         * Set the body for building this model.
         * @param {String} body
         * @returns {storm/model/SettingsTextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/SettingsTextBuilder#
         */
        setBody: function (body) {
            this._attrs.body = body;
            return this;
        },

        /**
         * Build the SettingsText model.
         * @returns {storm/model/SettingsText} the SettingsText model
         * @public
         * @method
         * @memberof storm/model/SettingsTextBuilder#
         */
        build: function () {
            return new SettingsText(this._attrs);
        }
    });

    return SettingsTextBuilder;
});
/**
 * TermsText Builder, for building the TermsText model
 * @class storm/model/TermsTextBuilder
 */
define("storm/model/TermsTextBuilder", [
    "xdk-base/class",
    "storm/model/TermsText",
    "storm/model/SettingsTextBuilder"
], function (
    klass,
    TermsText,
    SettingsTextBuilder
    ) {

    "use strict";

    var TermsTextBuilder = klass.create(SettingsTextBuilder, {}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/TermsTextBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the checkboxTextA for building the model.
         * @param {String} checkboxTextA
         * @returns {storm/model/TermsTextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/TermsTextBuilder#
         */
        setCheckboxTextA: function (checkboxTextA) {
            this._attrs.checkboxTextA = checkboxTextA;
            return this;
        },

        /**
         * Set the checkboxTextB for building the model.
         * @param {String} checkboxTextB
         * @returns {storm/model/TermsTextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/TermsTextBuilder#
         */
        setCheckboxTextB: function (checkboxTextB) {
            this._attrs.checkboxTextB = checkboxTextB;
            return this;
        },

        /**
         * Set the acceptButtonText for building the model.
         * @param {String} acceptButtonText
         * @returns {storm/model/TermsTextBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/TermsTextBuilder#
         */
        setAcceptanceButtonText: function (acceptButtonText) {
            this._attrs.acceptButtonText = acceptButtonText;
            return this;
        },

        setMarketingTexts: function(title, body) {
            this._attrs.marketingTitle = title;
            this._attrs.marketingBody = body;

            return this;
        },

        setAGBTexts: function(title, body) {
            this._attrs.AGBTitle = title;
            this._attrs.AGBBody = body;

            return this;
        },

        /**
         * Build the TermsText model.
         * @returns {storm/model/TermsText} the TermsText model
         * @public
         * @method
         * @memberof storm/model/TermsTextBuilder#
         */
        build: function () {
            return new TermsText(this._attrs);
        }
    });

    return TermsTextBuilder;
});
/**
 * Module that returns an singleton class for managing large blobs of legal text
 * @name sLegalTextManager
 * @memberof storm/mgr
 * @module storm/mgr/sLegalTextManager
 * @author Jason Newman<jason.newman@ext.accedo.tv>
 */
define("storm/mgr/sLegalTextManager", [
    "xdk-base/ax",
    "xdk-base/core",
    "xdk-base/class",
    "storm/mgr/sEditorialManager",
    "storm/model/TermsTextBuilder",
    "storm/model/SettingsTextBuilder"
], function (
    ax,
    core,
    klass,
    sEditorialManager,
    TermsTextBuilder,
    SettingsTextBuilder
    ) {

    "use strict";

    //
    // By default we use German as the user's language, but they may specify otherwise...
    //

    var _useAustrian = function (optionalRegion) {
            return (optionalRegion && (optionalRegion.toUpperCase() === "AT"));
        },

        _emboldenHeader = function (someHeaderText) {
            return "<STRONG>" + someHeaderText + "</STRONG>";
        },

        LegalTextManager = klass.create({}, {

            //
            // In every case we return a promise to a SettingsText model (or a TermsText, which inherits from SettingsText)...
            //

            getImpressum: function (optionalRegion) {
                var source = _useAustrian(optionalRegion)?sEditorialManager.CONTENT.IMPRESSUM_AT:sEditorialManager.CONTENT.IMPRESSUM_DE;

                return sEditorialManager.getEditorialContent(source).then(function(response) {
                    var impressum = response.responseJSON.impressum,
                        theBuilder = new SettingsTextBuilder()
                            .setTitle(impressum.article_name)
                            .setLabel(impressum.article_name)
                            .setBody(impressum.article_body);

                    return theBuilder.build();
                });
            },

            getPrivacy: function (optionalRegion) {
                var source = _useAustrian(optionalRegion)?sEditorialManager.CONTENT.PRIVACY_AT:sEditorialManager.CONTENT.PRIVACY_DE;

                return sEditorialManager.getEditorialContent(source).then(function(response) {
                    var privacy = response.responseJSON.datenschutz,
                        theBuilder = new SettingsTextBuilder()
                            .setTitle(privacy.article_name)
                            .setLabel(privacy.article_name)
                            .setBody(privacy.article_body);

                    return theBuilder.build();
                });
            },

            //
            // We display the terms in two different ways; see SKYSTORM-334...
            //

            getTermsForReview: function (optionalRegion) {
                var source = _useAustrian(optionalRegion)?sEditorialManager.CONTENT.TERMS_AT:sEditorialManager.CONTENT.TERMS_DE;

                return sEditorialManager.getEditorialContent(source).then(function(response) {
                    var terms = response.responseJSON.termsAndConditions,
                        theBuilder = new SettingsTextBuilder()
                            .setTitle(terms.page_agb.agb_title)
                            .setLabel(terms.page_agb.agb_title)
                            .setBody(terms.page_agb.agb_body);

                    return theBuilder.build();
                });
            },

            getTermsForAgreement: function (optionalRegion) {
                var source = _useAustrian(optionalRegion)?sEditorialManager.CONTENT.TERMS_AT:sEditorialManager.CONTENT.TERMS_DE;

                return sEditorialManager.getEditorialContent(source).then(function(response) {
                    var terms = response.responseJSON.termsAndConditions,
                        theBuilder = new TermsTextBuilder()
                            .setTitle(terms.acceptance.tc_title)
                            .setLabel(terms.acceptance.tc_text1)
                            .setMarketingTexts(_emboldenHeader(terms.page_marketing.marketing_title), terms.page_marketing.marketing_body)
                            .setAGBTexts(_emboldenHeader(terms.page_agb.agb_title), terms.page_agb.agb_body)
                            .setBody(_emboldenHeader(terms.acceptance.tc_title) +
                                terms.acceptance.tc_text1 +
                                terms.acceptance.tc_text2 +
                                terms.acceptance.tc_text3)
                            .setCheckboxTextA(terms.acceptance.tc_checkbox2_text)
                            .setCheckboxTextB(terms.acceptance.tc_checkbox1_text)
                            .setAcceptanceButtonText(terms.acceptance.tc_acceptbutton_text);

                    return theBuilder.build();
                });
            }

        });

    return new LegalTextManager();
});
/**
 * The login view's controller, setup user name and password field and the keyboard
 *
 * @name Login
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Login
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Login", [
    "xdk-base/ax",
    "xdk-base/promise",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/login",
    "xdk-ax/focusManager",
    "xdk-ax/mediator",
    "xdk-ax/evt/type",
    "xdk-base/device/vKey",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "xdk-base/util",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/wgt/AlertDialog",
    "xdk-base/console",
    "xdk-base/device",
    "tvedemo/wgt/Keyboard",
    "storm/mgr/sAppConfigManager",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sLocalStorageManager",
    "storm/mgr/sLegalTextManager",
    "storm/helper/silkResponseHelper",
    "tvedemo/wgt/Loading"
], function (
    ax,
    promise,
    RoutableController,
    view,
    tmpl,
    focusManager,
    mediator,
    evtType,
    vKey,
    sHistoryManager,
    dialogHelper,
    util,
    sEndUserManager,
    AlertDialog,
    console,
    device,
    Keyboard,
    sAppConfigManager,
    sLanguageManager,
    sLocalStorageManager,
    sLegalTextManager,
    silkResponseHelper,
    sLoading
    ) {

    "use strict";

    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {};
        }
    }, {
        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },
        //override getState to handle latest state from the menu
        getState: function () {
            return this._super();
        },

        setup: function (context) {
            this.context = context || {};
            var currentView = this.getView(),
                logo = currentView.find("logo"),
                storedUsername = sLocalStorageManager.getStoredValue(sLocalStorageManager.KEYS.USERNAME);

            if (context.historyBack === true) {
                if (sEndUserManager.getLoginStatus()) {
                    sHistoryManager.back();
                    return;
                }
            }

            sAppConfigManager.getLogo().then(function (img) {
                logo.setSrc(img);
            });

            this._usernameButton = currentView.find("usernameButton");
            this._passwordButton = currentView.find("passwordButton");
            this._keyboardPatch = currentView.find("keyboardPatch2012");
            this._loginButton = currentView.find("loginButton");
            this._keyboard = currentView.find("keyboard");

            //
            // Pre-populate the username if we can...
            //

            if (storedUsername) {
                this._usernameButton.setText(storedUsername);
                focusManager.focus(this._passwordButton);
            } else {
                focusManager.focus(this._usernameButton);
            }

            this._usernameButton.__impl.updateLeft && this._usernameButton.__impl.updateLeft();
            this._passwordButton.__impl.updateLeft && this._passwordButton.__impl.updateLeft();

            var inputField = this._usernameButton.getRoot()._dom.getElementsByTagName("input")[0];

            // This is to make sure no issues are caused if useNative is not used for the input field for the current device.
            if (inputField) {
                inputField.blur();
            }

            this.__boundUsernameClick = util.bind(function() {
                this._keyboard = new Keyboard({ id: "keyboard", type: "text", forwardFocus: true });
                this._input = this._usernameButton;
                this._nextFocus = this._passwordButton;
                this._keyboard.getReadyPromise().then(util.bind(function() {
                    this._keyboard.setInputName(sLanguageManager.getString("Login.Login_labelCustomerIDLabel"));
                    this._keyboard.showKeyboard({ text: this._input.getText() });
                    focusManager.focus(this._keyboard);
                    this._keyboardOnClose();
                    currentView.attach(this._keyboard);
                    if (device.id.getFirmwareYear() === 2012) { // This is Storm, so assume Samsung.
                        this._keyboardPatch.addClass("madeVisible");
                    }
                }, this), function(e) {
                    console.warn("Keyboard cannot be ready due to " + e);
                });
            }, this);

            this.__boundPasswordClick = util.bind(function() {
                this._keyboard = new Keyboard({ id: "keyboard", type: "password", forwardFocus: true, maxLength: 4, isPassword: true, inputCss: 'keyboard-number' });
                this._input = this._passwordButton;
                this._nextFocus = this._loginButton;
                this._keyboard.getReadyPromise().then(util.bind(function() {
                    this._keyboard.setInputName(sLanguageManager.getString("Login.Login_labelPINLabel"));
                    this._keyboard.showKeyboard({ text: this._input.getText(), keyMap: 'number' });
                    focusManager.focus(this._keyboard);
                    this._keyboardOnClose();
                    currentView.attach(this._keyboard);
                    if (device.id.getFirmwareYear() === 2012) { // This is Storm, so assume Samsung.
                        this._keyboardPatch.addClass("madeVisible");
                    }
                }, this), function(e) {
                    console.warn("Keyboard cannot be ready due to " + e);
                });
            }, this);

            this.__boundUsernameKey = util.bind(this._fieldKeyHandler, this, this.__boundUsernameClick);
            this.__boundPasswordKey = util.bind(this._fieldKeyHandler, this, this.__boundPasswordClick);
            this.__boundLoginButtonClick = util.bind(this._login, this);

            this._usernameButton.addEventListener(this._usernameButton.CLICK, this.__boundUsernameClick);
            this._passwordButton.addEventListener(this._passwordButton.CLICK, this.__boundPasswordClick);
            this._usernameButton.addEventListener(this._usernameButton.KEY, this.__boundUsernameKey);
            this._passwordButton.addEventListener(this._passwordButton.KEY, this.__boundPasswordKey);

            this._loginButton.addEventListener(evtType.CLICK, this.__boundLoginButtonClick);
        },

        /**
         * A user has hit a key while the field focused. Maybe show the keyboard?
         * @method
         * @protected
         * @memberOf tvedemo/ctrl/Login#
         */
        _fieldKeyHandler: function(clickHandler, keyEvent) {
            switch(keyEvent.id)  {
                case vKey.KEY_0.id:
                case vKey.KEY_1.id:
                case vKey.KEY_2.id:
                case vKey.KEY_3.id:
                case vKey.KEY_4.id:
                case vKey.KEY_5.id:
                case vKey.KEY_6.id:
                case vKey.KEY_7.id:
                case vKey.KEY_8.id:
                case vKey.KEY_9.id:
                    clickHandler();
            }
        },

        _loginSuccess: function() {
            if (this.context.redirection && this.context.redirection.cmd) {
                this.context.redirection.cmd.historySkip = true;
                mediator.publish("navigate", this.context.redirection.cmd);
            }
            else if (this.context.intermediateLogin) {
                if (promise.isPromise(this.context.intermediateLogin.promise) && util.isFunction(this.context.intermediateLogin.resolve)) {
                    this.context.intermediateLogin.resolve();
                }
                sHistoryManager.back();
            }
            else {
                // We used to go back, but that's a problem. Fram!
                // @TODO: Allow a context to go forwards to to be passed in with the login request.
                mediator.publish("navigate", {
                    path: "Main/Home"
                });
            }
        },

        /**
         * Read the credentials from the input fields, then log in using the end user manager.
         * @method
         * @protected
         * @memberOf tvedemo/ctrl/Login#
         */
        _login: function (evt, forceLogout) {
            sLoading.open();

            var username = this._usernameButton.getText(),
                password = this._passwordButton.getText();

            console.info("Login with [" + username + ":" + password + "] ...");

            sEndUserManager.login(username, password, forceLogout).then(util.bind(function (user) {
                sLoading.close();
                console.info("Logged in: ", user);

                return sEndUserManager.checkTermsAndConditions(user).then(util.bind(function (userHasAcceptedTermsAndConditions) {

                    if (!userHasAcceptedTermsAndConditions) {

                        return this.openTermsAndConditionsDialog(user);

                    } else {

                        this._loginSuccess();
                    }

                }, this));

            }, this)).fail(util.bind(function (reason) {
                sLoading.close();
                
                // @TODO: This remains weak because a user can navigate around before the popup is shown (asynchronous)?
                if (promise.isPromise(reason)) {
                    reason.then(util.bind(function (silkMessage) { // @TODO: Turn the silkMessage into a generic 'Storm error thing'.
                        if (silkMessage.get("code") === silkResponseHelper.SILK_CODE.ALREADY_LOGGED_IN) {
                            dialogHelper.confirm({
                                title: silkMessage.get("title"),
                                // Override the SILK message with something more on-brand...
                                message: sLanguageManager.getString("Login.Login_AlreadyLoggedInOnOtherDevice_message"),
                                positiveText: sLanguageManager.getString("Global.Global_Continue"),
                                negativeText: sLanguageManager.getString("Global.Global_Cancel_Button"),
                                positiveAction: util.bind(function() {
                                    this._login(null, true);
                                }, this)
                            });
                        } else {
                            if (this.context.intermediateLogin && promise.isPromise(this.context.intermediateLogin.promise) && util.isFunction(this.context.intermediateLogin.reject)) {
                                this.context.intermediateLogin.reject();
                            }
                            dialogHelper.error({
                                title: silkMessage.get("title"),
                                reason: silkMessage.get("description")
                            });
                        }
                    }, this));
                } else if (!reason || reason.noErrorPopup === false) {
                    if (this.context.intermediateLogin && promise.isPromise(this.context.intermediateLogin.promise) && util.isFunction(this.context.intermediateLogin.reject)) {
                        this.context.intermediateLogin.reject();
                    }
                    dialogHelper.error({
                        title: sLanguageManager.getString("Errormessages.Errormessages_GenericErrorMessageHeadline"),
                        reason: sLanguageManager.getString("Global.Global_genericBackendError")
                    });
                }
            }, this));
        },

        openTermsAndConditionsDialog: function (user, deferred) {
            var reconfirmDialog = util.bind(function (user, deferred) {
                    dialogHelper.confirm({
                        // TODO: Make sure these texts are the correct ones ot use.
                        title: sLanguageManager.getString("Login.Login_labelTCpermission_is_not_accepted_hl"),
                        message: sLanguageManager.getString("Login.Login_labelTCpermission_is_not_accepted_message"),
                        positiveText: sLanguageManager.getString("Global.Global_buttonConfirm"),
                        negativeText: sLanguageManager.getString("Global.Global_buttonClose"),
                        positiveAction: util.bind(function () {
                            this.openTermsAndConditionsDialog(user, deferred);
                        }, this),
                        negativeAction: function () {
                            deferred.reject({ noErrorPopup: true });
                            // Log out to make sure the user can not use the app as a logged in user when terms and conditions are not accepted.
                            sEndUserManager.logout(sEndUserManager.LOGOUT.RETAIN_USERNAME);
                        }
                    });
                }, this);

            deferred = deferred || promise.defer();

            sLegalTextManager.getTermsForAgreement(user.get("country")).then(util.bind(function (termsAndConditions) {

                dialogHelper.termsAndConditions({
                    title: termsAndConditions.get("title"),
                    message: termsAndConditions.get("label"),

                    firstCheckboxLabel: termsAndConditions.get("checkboxTextA"),
                    secondCheckboxLabel: termsAndConditions.get("checkboxTextB"),

                    showMarketingButton: sLanguageManager.getString("Settings.Settings_Datenschutz"),
                    showAGBButton: sLanguageManager.getString("Settings.Settings_labelTermsAndConditions"),

                    marketingTitle: termsAndConditions.get("marketingTitle"),
                    marketingBody: termsAndConditions.get("marketingBody"),

                    AGBTitle: termsAndConditions.get("AGBTitle"),
                    AGBBody: termsAndConditions.get("AGBBody"),

                    confirmButtonText: termsAndConditions.get("acceptButtonText"),
                    confirmAction: util.bind(function (privacyCheckboxValue, termsAndConditionsCheckboxValue) {
                        sEndUserManager.acceptTermsAndConditions(user, termsAndConditionsCheckboxValue, privacyCheckboxValue).then(util.bind(function (userAcceptedTermsAndConditions) {

                            if (userAcceptedTermsAndConditions) {
                                deferred.resolve();
                                this._loginSuccess();
                            } else {
                                reconfirmDialog(user, deferred);
                            }

                        }, this)).fail(function () {
                            deferred.reject();
                        });
                    }, this),

                    cancelButtonText: sLanguageManager.getString("Global.Global_buttonClose"),
                    cancelAction: function () {
                        deferred.reject({ noErrorPopup: true });
                        // Log out to make sure the user can not use the app as a logged in user when terms and conditions are not accepted.
                        sEndUserManager.logout(sEndUserManager.LOGOUT.RETAIN_USERNAME);
                    }
                });
            }, this)).fail(function () {
                deferred.reject();
            });
            return deferred.promise;
        },

        reset: function () {
            if (this.context.intermediateLogin && promise.isPromise(this.context.intermediateLogin.promise) && util.isFunction(this.context.intermediateLogin.reject)) {
                this.context.intermediateLogin.reject();
            }

            this._input = this._nextFocus = undefined;
            this._usernameButton.removeEventListener(evtType.CLICK, this.__boundUsernameClick);
            this._passwordButton.removeEventListener(evtType.CLICK, this.__boundPasswordClick);
            this._usernameButton.removeEventListener(evtType.KEY, this.__boundUsernameKey);
            this._passwordButton.removeEventListener(evtType.KEY, this.__boundPasswordKey);

            this._usernameButton.removeInputListeners();
            this._passwordButton.removeInputListeners();

            this._loginButton.removeEventListener(evtType.CLICK, this.__boundLoginButtonClick);
        },

        _keyboardOnClose: function() {
            this._keyboard.setOnClose(util.bind(function(text) {
                console.log("TEXT: " + text);
                this._keyboardClosed = true;
                if(text !== false) {
                    this._input.setText(text);
                }
                this._keyboard.removeAllListeners();
                this._keyboard.detach();
                this._keyboardPatch.removeClass("madeVisible");
                this._input.__impl.__input && this._input.__impl.__input.getHTMLElement().blur(); //  Deactivate the cursor on <input> element
                focusManager.focus(this._nextFocus);
            }, this));
        }


    });
});
/**
 * The image button widget for main menu
 * @name MainMenuButton
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/MainMenuButton
 * @param {Object} opts The options object
 * @param {String} opts.icon the button icon image link
 * @param {String|ax/af/mvc/ModelRef} opts.text The text displayed on this button
 * @param {String} [opts.isPureText] whether the button text to set is pure text or html
 */
define("tvedemo/wgt/MainMenuButton", [
    "xdk-base/class", "xdk-base/util", "xdk-ax/Container",
    "xdk-base/Element", "xdk-ui-basic/Image", "xdk-ui-basic/Label",
    "xdk-ax/focusManager", "xdk-ax/evt/type", "xdk-base/device",
    "xdk-base/console"
], function (klass, util, Container,
    Element, Img, Label,
    fm, evtType, device,
    console) {

    return klass.create(Container, {}, {
        /**
         * The internal label widget to show button text
         * @protected
         * @name _label
         * @memberof tvedemo/wgt/MainMenuButton#
         */
        _label: null,
        /**
         * The internal image widget to show button icon
         * @protected
         * @name _icon
         * @memberof tvedemo/wgt/MainMenuButton#
         */
        _icon: null,
        /**
         * The internal image widget to show button icon, when selected
         * @protected
         * @name _selectedIcon
         * @memberof tvedemo/wgt/MainMenuButton#
         */
        _selectedIcon: null,

        _isSelected: false,
        /**
         * override parent"s init() method
         * @method
         * @memberof tvedemo/wgt/MainMenuButton#
         * @protected
         */
        init: function (opts) {
            opts.focusable = true;
            opts.clickable = true;
            opts.root = opts.root || new Element("div");

            this._super(opts);

            this.getRoot().addClass("main-menu-button");
            //this.getRoot().addClass("menu-button");
			
			/*
            if (opts.icon) {
                this._icon = new Img({
                    src: opts.icon,
                    parent: this
                });
            }
			
            if (opts.selectedIcon) {
                this._selectedIcon = new Img({
                    src: opts.selectedIcon,
                    parent: this
                }).hide();
            }
			*/
			
            if (opts.text) {
                this._label = new Label({
                    text: opts.text,
                    isPureText: opts.isPureText || false,
                    parent: this
                });
            }

            if (opts.selectable === false) {
                this.getRoot().addClass("non-selectable");
            }

        },
        select: function () {
            console.info("select");
            this.addClass("selected");
            this._isSelected = true;
            //this._icon.hide();
            //this._selectedIcon.show();
        },

        unselect: function () {
            console.info("unselect");
            this.removeClass("selected");
            this._isSelected = false;
            //this._icon.show();
            //this._selectedIcon.hide();
        }

    });
});
/**
 * The main menu of the app, will be set dynamically by user login/logout.
 * @name MainMenu
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/MainMenu
 * @extends ax/ext/ui/grid/LoopedGrid
 */
define("tvedemo/wgt/MainMenu", [
    "xdk-base/class",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "tvedemo/wgt/MainMenuButton",
    "xdk-base/console",
    "storm/helper/util",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-ax/focusManager"

], function (
    klass,
    LoopedGrid,
    MainMenuButton,
    console,
    stormUtil,
    util,
    promise,
    focusManager
    ) {

    "use strict";

    return klass.create(LoopedGrid, {}, {
        HOME: 0,
        DEFAULT_ROWS: 6,
        DEFAULT_BG_X: 358,
        DEFAULT_LEFT: 189,
        CENTERED_LEFT: 615,
        DEFAULT_FOCUS_POSITION: 1,
        FOCUS_POSITION: 1,
        _savedState: null,
        init: function (opts) {
            opts = opts || {};
            opts.scrollFrontBoundary = typeof(opts.scrollFrontBoundary) === "undefined" ? 2 : opts.scrollFrontBoundary;
            opts.scrollEndBoundary = typeof(opts.scrollEndBoundary) === "undefined" ? 3 : opts.scrollEndBoundary;
            opts.alignment = LoopedGrid.VERTICAL;
            this._super(opts);
            this.setDisplayStgy(function (data) {
                if (!data || !data.text) {
                    throw new Error("missing parameter in creating menu elements");
                }
                return new MainMenuButton({
                    selectable: data.selectable,
                    text: data.text
                });
            });
        },

        /**
         * Add a style attribute to this component
         * @method
         * @public
         * @param {Object} styles A object containing CSS name/value pairs
         * @return {tvedemo/wgt/MainMenu} The component itself, for chaining
         * @memberof tvedemo/wgt/MainMenu#
         */
        setStyle: function (styles) {
            if (!this._root) {
                return this;
            }
            this._root.__setStyle(styles);
            return this;
        },

        saveFirstState: function() {
            console.debug("Menu  Save first state");
            if (!this._savedState) this.saveState();
        },
        saveState: function() {
            console.debug("Menu  Save state");
            var state = {
                selectedDsIndex: this._selectedDsIndex,
                selectedGridRow: this._selectedGridRow,
                selectedGridCol: this._selectedGridCol,
                hidden: this._hidden
            };
            this._savedState = state;
            console.log("Saved state",this._savedState);
        },
        restoreState: function(_subController) {
            console.debug("Menu  Restore state");
            var state = {
                selectedDsIndex: this._selectedDsIndex
            };
            console.log("Menu state",state);
            if (this._savedState){
                console.log("Saved state",this._savedState);
                // There is a saved state
                if (this._savedState.selectedDsIndex !==  state.selectedDsIndex){
                    console.warn("Selected should be "+this._savedState.selectedDsIndex+" but is "+state.selectedDsIndex);
                    var focusComponent = this._gridComponents[this._savedState.selectedGridRow][this._savedState.selectedGridCol];
                    focusManager.focus(focusComponent, {noActive: false, skipForwardFocus: false});
                    return this.select(this._savedState.selectedDsIndex, this.FOCUS_POSITION).then(util.bind(function(){

                        this.saveState();
                        if(_subController){
                            console.log("Focus to _subController");
                            focusManager.focus(_subController, {noActive: true, skipForwardFocus: false});
                        }
                        deferred.resolve();

                    },this),
                    function(reason){
                        console.error(reason);
                    });
                }
                else{
                    console.log("Selection is fine");
                }
            }
            else{
                console.log("No state saved.");
            }
            return promise.resolve();
        },
        delayForwardFocus: function(_subController){
            console.debug("delayForwardFocus()");
            return function(){
                clearInterval(this.forwardFocusDelay);
                focusManager.focus(_subController);
            };
        },
        clearState: function() {
            console.debug("Menu  Clear state");
            this._savedState = null;
        }
    });
});

/**
 * Main view's template
 * This view includes the main menu, the changeable sub view (occupied by Home page view when init).
 * @name main
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/main
 */
define("tvedemo/tmpl/main", [
    "xdk-ui-basic/Image",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "xdk-ui-basic/Button",
    "xdk-ax/Container",
    "tvedemo/wgt/MainMenu",
    "tvedemo/ctrl/Home"
], function (
    Img,
    Layout,
    Label,
    Button,
    Container,
    MainMenu,
    HomeCtrl
    ) {

    "use strict";

    return function () {

        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#main-view",
            forwardFocus: true,
            children: [{
                klass: Layout,
                id: "header",
                css: "headerMenu",
                forwardFocus: true,
                alignment: Layout.VERTICAL,
                nextDown: "subCtlrContainer",
                children: [{
                    klass: MainMenu,
                    forwardFocus: true,
                    id: "#list-main-menu",
                    rows: 6,
                    cols: 1
                }, {
                    klass: Button,
                    id: "#breadcrumb",
                    css: "breadcrumb",
                    focusable: false,
                    text: ""
                }, {
                    klass: MainMenu,    // initial hidden
                    forwardFocus: true,
                    id: "#list-sub-menu",
                    rows: 6,
                    cols: 1
                }, {
                    klass: Img,
                    css: "fadeout-upper",
                    src: "img/skystorm/fadeout_upper.png"
                }, {
                    klass: Img,
                    id: "submenuFading",
                    css: "fadeout-lower",
                    src: "img/skystorm/fadeout_lower.png"
                },{
                    klass: Container,
                    id: "#subCtlrOverlay"
                }]
            }, {
                klass: Container,
                id: "#subCtlrContainer",
                forwardFocus: true,
                nextUp: "header",
                children: [{
                    controller: HomeCtrl
                }]
            }, {
                klass: Img, // Put the logo at the front, so that it interacts nicely with the menu fade-outs and content
                id: "#logo"
            }]
        };
    };

});
/**
 * The main view's controller, setup the main menu, the subcontroller and the footer.
 * @name Main
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Main
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Main", [
    "xdk-base/class",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/main",
    "xdk-ax/focusManager",
    "xdk-ax/data/LocalDatasource",
    "tve/sServiceHolder",
    "xdk-ax/evt/type",
    "xdk-ax/mediator",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "storm/mgr/sAppConfigManager",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sNavigationManager",
    "xdk-base/promise",
    "tve/mgr/sLinearManager",
    "xdk-base/console",
    "tvedemo/helper/dialogHelper",
    "storm/mgr/sLanguageManager",
    "storm/event/UserEvent",
    "tve/TVEError",
    "storm/helper/util"
], function (
    klass,
    RoutableController,
    view, mainTmpl,
    focusManager,
    LocalDatasource,
    sServiceHolder,
    evtType,
    mediator,
    vKey,
    util,
    sAppConfigManager,
    sEndUserManager,
    sNavigationManager,
    promise,
    sLinearManager,
    console,
    dialogHelper,
    sLanguageManager,
    UserEvent,
    TVEError,
    stormUtil
    ) {

    "use strict";

    var FACILITY = TVEError.FACILITY,
        ERROR = TVEError.ERROR,

        RIGHT_NAVIGATION = 1,
        LEFT_NAVIGATION = -1,
        NULL_NAVIGATION = 0,
        UP_NAVIGATION = 2;

    return klass.create(RoutableController, {
        // approuter: getDefaultState
        getDefaultState: function () {
            return {};
        }
    }, {
        //private vars
        _menu: null,
        _submenu: null,
        _submenuLoaded: false,
        _lastKeyNavigation: null,
        _subController: null,
        _header: null,
        _level: 1,
        _subMenuLevel: 0,
        _shouldSelectSubMenu: true,

        init: function () {
            this.setView(view.render(mainTmpl));
            this._super();
        },

        //override getState to handle latest state from the menu
        getState: function () {
            this.__state.menuSelectedDsIndex = this._menu.getSelectedDsIndex();
            return this._super();
        },

        setup: function (context) {
            var currentView = this.getView(),
                logo = currentView.find("logo"),
                menu = currentView.find("list-main-menu"),
                submenu = currentView.find("list-sub-menu"),
                breadcrumb = currentView.find("breadcrumb"),
                submenuFading = currentView.find("submenuFading"),
                subController = currentView.find("subCtlrContainer"),
                header = currentView.find("subCtlrContainer");

            this._onMenuUpdate = stormUtil.debounce(this.__onMenuUpdate, sNavigationManager.MENU_RESPOND_TIME);
            this.__onMenuUpdateRef = util.bind(this._onMenuUpdate, this);
            this.__subControllerFocusHandlerRef = util.bind(this.__onSubControllerFocus, this);
            this.__headerFocusRef = util.bind(this.__onHeaderFocus, this);
            this.__menuClickHandlerRef = util.bind(this.__menuClickHandler, this);
            this.__menuKeyHandlerRef = util.bind(this.__menuKeyHandler, this);
            this.__submenuClickHandlerRef = util.bind(this.__submenuClickHandler, this);
            this.__submenuKeyHandlerRef = util.bind(this.__submenuKeyHandler, this);
            this.__submenuSelectableCheckerRef = util.bind(this.__submenuSelectableChecker, this);
            this.__menuSelectionFocusRef = util.bind(this.__menuSelectionFocus, this);
            this.__menuFocusRef = util.bind(this.__menuFocus, this);
            this.__menuBlurRef = util.bind(this.__menuBlur, this);
            this.__submenuFocusRef = util.bind(this.__submenuFocus, this);
            this.__submenuBlurRef = util.bind(this.__submenuBlur, this);
            this.__breadcrumbClickHandlerRef = util.bind(this.__breadcrumbClickHandler, this);

            this.__onKeyRef = util.bind(this.onKey, this);

            // pass key event to subcontroller
            this.getView().addEventListener(evtType.KEY, this.__onKeyRef);

            menu.addEventListener(evtType.CLICK, this.__menuClickHandlerRef);
            menu.addEventListener(evtType.KEY, this.__menuKeyHandlerRef);
            menu.addEventListener(evtType.SELECTION_CHANGED, this.__menuSelectionFocusRef);
            menu.addEventListener(evtType.FOCUS, this.__menuFocusRef);
            menu.addEventListener(evtType.BLUR, this.__menuBlurRef);

            submenu.addEventListener(evtType.CLICK, this.__submenuClickHandlerRef);
            submenu.addEventListener(evtType.KEY, this.__submenuKeyHandlerRef);
            submenu.addEventListener(evtType.SELECTION_CHANGED, this.__submenuSelectableCheckerRef);
            submenu.addEventListener(evtType.FOCUS, this.__submenuFocusRef);
            submenu.addEventListener(evtType.BLUR, this.__submenuBlurRef);

            breadcrumb.addEventListener(evtType.CLICK, this.__breadcrumbClickHandlerRef);
            breadcrumb.setOption("focusable", false);

            menu.addEventListener(evtType.FOCUS, this.__headerFocusRef);
            submenu.addEventListener(evtType.FOCUS, this.__headerFocusRef);
            subController.addEventListener(evtType.FOCUS, this.__subControllerFocusHandlerRef);

            // subscribe to menu update
            mediator.subscribe(sNavigationManager.MENU_UPDATE, this.__onMenuUpdateRef);

            // navigation focus
            this.__onMenuNavigatedRef = util.bind(this.__onMenuNavigated, this);
            mediator.subscribe("navigated", this.__onMenuNavigatedRef);
            this.__onHistoryNavigatedRef = util.bind(this.__onHistoryNavigated, this);
            mediator.subscribe(sNavigationManager.MENU_RECONSTRUCT_COMPLETE, this.__onHistoryNavigatedRef);

            this.__userHasBeenLoggedOutHandler = util.bind(function () {

                dialogHelper.error({
                    reason: sLanguageManager.getString("Errormessages.Errormessages_labelSessionExpired"),
                    buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                });

            }, this);

            mediator.subscribe(UserEvent.UserHasBeenLoggedOut, this.__userHasBeenLoggedOutHandler);

            if (!context.historyBack) {
                sAppConfigManager.getLogo().then(function (img) {
                    logo.setSrc(img);
                });

                // Initialization
                submenu.hide();
                breadcrumb.hide();
                submenuFading.hide();
            }

            this._menu = menu;
            this._submenu = submenu;
            this._submenuFading = submenuFading;
            this._breadcrumb = breadcrumb;
            this._subController = subController;
            this._header = header;

            this._menu.saveFirstState();
        },

        __onMenuUpdate: function (notification) {
            if (!notification.list || !notification.list.length) {
                return console.error("__onMenuUpdate failed");
            }
            if (notification.target === sNavigationManager.MAIN_MENU) {
                var ds = stormUtil.arrayToDs(notification.list);
                this._menu.setDatasource(ds).then(util.bind(function() {
                    this._level = 1;
                    this._submenuLoaded = false;
                    this._shouldSelectSubMenu = true;
                    this._submenuFading.hide();
                    this._breadcrumb.hide();
                    this._submenu.hide();
                    this._menu.show();
                    if (notification.promise && promise.isPromise(notification.promise.promise) && util.isFunction(notification.promise.resolve)) {
                        notification.promise.resolve();
                    }
                    return this._menu.select(notification.selection, this._menu.FOCUS_POSITION).then(util.bind(function() {
                        if (notification.obtainFocus) {
                            focusManager.focus(this._menu);
                        }
                    }, this));
                }, this)).fail(function (error) {
                    console.error("Menu cannot be configured due to "+error);
                    if (notification.promise && promise.isPromise(notification.promise.promise) && util.isFunction(notification.promise.reject)) {
                        notification.promise.reject();
                    }
                });
            } else if (notification.target === sNavigationManager.SUB_MENU) {
                this._submenu.clearState();
                this.__updateSubmenu(notification);
            }
        },

        __updateSubmenu: function(notification) {
            console.log('***************** LEVEL: ', this._subMenuLevel);
            var ds = stormUtil.arrayToDs(notification.list);
            var currentSubMenuLevel = this._subMenuLevel;
            this._lastKeyNavigation = NULL_NAVIGATION;  // Disable submenuSelectableChecker() on submenu initiation

            var submenuOptions = {};

            if (notification.list.length < 4) {
                submenuOptions.scrollEndBoundary = Math.ceil(notification.list.length / 2);
                submenuOptions.scrollFrontBoundary = Math.ceil(notification.list.length / 2) - 1;
            } else {
                submenuOptions.scrollFrontBoundary = this._submenu.DEFAULT_FOCUS_POSITION;
                submenuOptions.scrollEndBoundary = this._submenu.DEFAULT_FOCUS_POSITION + 1;
            }

            // Default styles
            var styles = {
                left:                   this._submenu.DEFAULT_LEFT+'px',
                marginLeft:             '0px'
            };
            if (notification.list.length < 4)
            {
                // The submenu has too few items to be looped
                this._submenu._rows          = notification.list.length;
                this._submenu.FOCUS_POSITION = Math.ceil(notification.list.length / 2) - 1;
                console.log("Focus",this._submenu.FOCUS_POSITION);
                console.log("Rows",this._submenu._rows);
                console.log("Length",notification.list.length);
                // Left: 615px
                // Left-margin: 0 - (170 * number of items / 2)
                var submenuMargin   = 0 - Math.ceil(170 * notification.list.length / 2);
                var focusHighlightX = this._submenu.FOCUS_POSITION * 170 + 20;
                styles = {
                    left:                   this._submenu.CENTERED_LEFT+'px',
                    marginLeft:             submenuMargin+'px'
                };
            }
            else
            {
                this._submenu._rows          = this._submenu.DEFAULT_ROWS;
                this._submenu.FOCUS_POSITION = this._submenu.DEFAULT_FOCUS_POSITION;
            }

            // Reset the submenu
            this._submenu.reset(submenuOptions);


            this._submenu.setStyle(styles);
            this._submenu.setDatasource(ds).then(util.bind(function() {
                this._level++;
                this._subMenuLevel++;
                this._submenuLoaded = true;
                this._breadcrumb.setText(sNavigationManager.getBreadcrumb());
                this._submenuFading.show();
                this._breadcrumb.show();
                this._submenu.show();
                this._menu.hide();
                if (notification.promise && promise.isPromise(notification.promise.promise) && util.isFunction(notification.promise.resolve)) {
                    notification.promise.resolve();
                }
                return this._submenu.select(notification.selection, this._submenu.FOCUS_POSITION).then(util.bind(function() {
                    if (notification.obtainFocus) {
                        focusManager.focus(this._submenu);
                    }
                    this._lastKeyNavigation = RIGHT_NAVIGATION; // Set default non-selectable navigation direction
                    this.__submenuSelectableChecker();      // HARD handling
                    if(this._shouldSelectSubMenu) {
                      this.__submenuClickHandler();
                      console.log('***************** SUBMENU SELECT');
                    }
                    this._shouldSelectSubMenu = true;

                }, this));
            }, this)).fail(function (error) {
                console.error("Submenu cannot be configured due to "+error);
                if (notification.promise && promise.isPromise(notification.promise.promise) && util.isFunction(notification.promise.reject)) {
                    notification.promise.reject();
                }
            });
        },

        /**
        * The following two methods keeps track of whether one of the menus or if the subcontroller has focus,
        * so that we can switch the highlight of the menu(s) back to the selection on mouse out
        */
        __lastFocusOnHeader: false,
        __onHeaderFocus: function(e) {
            if (!this.__lastFocusOnHeader)
            {
                console.warn("Header focus");
                this.__lastFocusOnHeader = true;
            }
        },
        __onSubControllerFocus: function(e) {
            var target    = e.target;
            //if (target)   stormUtil.traceObject(target._opts, "Current target");
            if (this.__lastFocusOnHeader)
            {
                // Restore the state of the menus (if they have moved since being selected)
                if (this._submenuLoaded && !this._submenu._hidden)
                {
                    // Existing and visible submenu
                    this._menu.restoreState(false).then(util.bind(function(){
                        this._submenu.restoreState(this._subController);
                    },this));
                }
                else if (this._submenuLoaded && this._submenu._hidden)
                {
                    // Existing and hidden submenu

                    // Check if submenu should be visible
                    if (this._submenu._savedState && this._submenu._savedState.hidden === false)
                    {
                        // Submenu should be restored and focus returned to it
                        this._menu.restoreState(false).then(util.bind(function(){
                            this._submenu.restoreState(false);
                            this._submenuFading.show();
                            this._submenu.show();
                            // Add menu item to navigation again, but without actions
                            var menuItem = this._submenu.getSelectedData();
                            sNavigationManager._handleMenu(menuItem, true, true);
                        },this));
                    }
                    else
                    {
                        // Focus should go to _subController
                        this._menu.restoreState(false).then(util.bind(function(){
                            this._submenu.restoreState(this._subController);
                        },this));
                    }
                }
                else {
                    this._menu.restoreState(this._subController);
                }
                this.__lastFocusOnHeader = false;
            }
        },

        __menuClickHandler: function () {
            // Get data for selected item
            var menuItem = this._menu.getSelectedData();
            // Track the page hit
            this.trackLevel(this._level,menuItem.text);
            // Save the state of the menu before proceeding (for future snap-back)
            this._menu.saveState();
            if (this._submenu) this._submenu.clearState();

            sNavigationManager.handleMenu(menuItem).fail(util.bind(function (err) {
                console.error("Navigation failed due to: " + err);

                if (err instanceof TVEError && err.getFacility() === FACILITY.NAVIGATION_MANAGER && err.getErrorCode() === ERROR.NOT_FOUND) {
                    this.__menuErrorNoResult();
                }

                throw err;
            }, this));

            return false;
        },
        __menuKeyHandler: function (evt) {
            if(evt.id === vKey.OK.id){
                if (this._lastKeyNavigation === UP_NAVIGATION) {
                    sNavigationManager.returnUpperLevelMenu(true);
                }

                this._lastKeyMainNavigation = false;
                this._lastKeySubmenNavigationSideways = false;
                return this.__menuClickHandler(evt);
            }
            else if(evt.id === vKey.DOWN.id){
                if(this._lastKeyNavigation === UP_NAVIGATION){
                    this._level += 1;
                    this._breadcrumb.show();
                    this._menu.hide();
                } else if (this._submenuLoaded) {
                    this._lastKeyMainNavigation = false;
                    this._lastKeySubmenNavigationSideways = false;
                    return this.__menuClickHandler(evt);

                } else if (this._lastKeyNavigation === LEFT_NAVIGATION || this._lastKeyNavigation === RIGHT_NAVIGATION) {
                    this._menu.saveFirstState();
                }
            }
            else if(evt.id === vKey.LEFT.id || evt.id === vKey.RIGHT.id){
                if (this._submenuLoaded && !this._submenu._hidden)
                {
                    this._submenu.hide();
                    this._lastKeyMainNavigationSideways = true;
                    this._lastKeyNavigation = LEFT_NAVIGATION;
                    //this._lastKeySubmenNavigationSideways = true;
                    sNavigationManager.returnUpperLevelMenu(true);
                }
            }
            return true;
        },
        __menuBlur: function(evt){

        },
        __menuFocus: function(evt){
            this._menu.saveFirstState();
        },
        __submenuBlur: function(evt){

        },
        __submenuFocus: function(evt){

        },
        __onMenuNavigated: function(cmd) {
            // check if we just navigated to a level 1 submenu item; if yes we focus the view
            if ((cmd.path.match(/\//g)||[]).length === 1) {
                focusManager.focus(this.getView().find("subCtlrContainer"));
            }
        },
        __onHistoryNavigated: function() {
            // defer is used to wait until subController's DOM ready to be focused when history back
            this._menu.clearState();
            util.defer().then(util.bind(function() {
                this.__focusHandler();
            }, this));
        },
        __focusHandler: function() {
            // When a dialog is open it is impossible to set focus on any component that is not part of that dialog or any another dialog.
            // Setting focus when a dialog is open will only update the dialogs component-to-focus-upon-closing.
            // In this case it will make the dialog focus on this._menu upon closing.
            // In the case that such dialog is open on a detail page this._menu will not be focusable thus rendering a loss of focus when that dialog is closed, see SKYSTORM-692.
            if (!dialogHelper.isAnyDialogOpen()) {
                var currentFocus = focusManager.getCurFocus(),
                    isCompInDOM = function (comp) {
                        return comp && comp.getRoot() && comp.getRoot().isInDOMTree();
                    };
                if (isCompInDOM(currentFocus) && this._subController.isAncestorOf(currentFocus)) {
                    // current focus is really inside subController
                    return;
                }
                if (!focusManager.focus(this._subController)) {
                    if (!focusManager.focus(this._submenu)) {
                        focusManager.focus(this._menu);
                    }
                }
            }
        },
        __breadcrumbClickHandler: function() {
            this._lastKeyNavigation = NULL_NAVIGATION;  // Disable submenuSelectableChecker() on submenu initiation
            sNavigationManager.returnUpperLevelMenu();
            this._level -= 2;
            return true;
        },
        __submenuClickHandler: function () {
            var menuItem = this._submenu.getSelectedData();

            // Track the page hit
            this.trackLevel(this._level, menuItem.text);

            // Save the state of the menu before proceeding (for future snap-back)
            this._submenu.saveState();

            sNavigationManager.handleMenu(menuItem).fail(util.bind(function (err) {
                console.error("Navigation failed due to: " + err);

                if (err instanceof TVEError && err.getFacility() === FACILITY.NAVIGATION_MANAGER && err.getErrorCode() === ERROR.NOT_FOUND) {
                    this.__menuErrorNoResult();
                }

                throw err;
            }, this));

            return false;
        },
        __returnPage: function(){
            var page = document.getElementById("news");
            if(!page){page = document.getElementById("homeView");}
            if(!page){page = document.getElementById("moviesAssetGrid");}
            if(!page){page = document.getElementById("tvShowAssetGrid");}
            if(!page){page = document.getElementById("program-guide-view");}
            if(!page){page = document.getElementById("sport");}
            if(!page){page = document.getElementById("movie");}
            if(!page){page = document.getElementById("tvshow");}
            return page;
        },
        __submenuKeyHandler: function (evt) {
            switch(evt.id) {
                case vKey.OK.id:
                    this._lastKeyNavigation = NULL_NAVIGATION;  // Disable submenuSelectableChecker() on submenu initiation
                    var menuItem = this._submenu.getSelectedData();
                    // Track the page hit
                    this.trackLevel(this._level, menuItem.text);
                    // Save the state of the menu before proceeding (for future snap-back)
                    this._submenu.saveState();

                    sNavigationManager.handleMenu(menuItem).fail(util.bind(function (err) {
                        console.error("Navigation failed due to: " + err);

                        if (err instanceof TVEError && err.getFacility() === FACILITY.NAVIGATION_MANAGER && err.getErrorCode() === ERROR.NOT_FOUND) {
                            this.__menuErrorNoResult();
                        }

                        throw err;
                    }, this));

                    return false;
                    break;
                case vKey.DOWN.id:
                    this._lastKeySubmenuNavigationSideways = false;
                    break;
                case vKey.UP.id:
                    if (this._level > 2)
                    {
                        this._subMenuLevel -= 1;
                        this._shouldSelectSubMenu = false;
                        sNavigationManager.returnUpperLevelMenu();
                    }
                    else
                    {
                        this._submenu.restoreState(false).then(util.bind(function(){
                            focusManager.focus(this._menu);
                        },this));
                        this._lastKeyNavigation = UP_NAVIGATION;  // Disable submenuSelectableChecker() on submenu initiation
                        this._level -= 1;
                        this._breadcrumb.hide();
                        this._menu.show();
                    }
                    return false;
                    // JSHint dislikes this unreachable break, but it's useful safety against future code changes.
                    break; // jshint ignore:line
                case vKey.LEFT.id:
                    this._lastKeySubmenuNavigationSideways = true;
                    this._lastKeyNavigation = LEFT_NAVIGATION;
                    break;
                case vKey.RIGHT.id:
                    this._lastKeySubmenNavigationSideways = true;
                    this._lastKeyNavigation = RIGHT_NAVIGATION;
                    break;
            }
            return true;
        },

        onKey: function (keyEvt) {
            if (keyEvt.id === vKey.EXIT.id) {
                return false;
            }
        },

        __submenuSelectableChecker: function() {
            if (this._lastKeyNavigation === NULL_NAVIGATION) {
                return;
            }
            var menuItem = this._submenu.getSelectedData(),
                index = this._submenu.getSelectedDsIndex();
            if (menuItem.selectable === false) {
                console.info("This item is not selectable, selecting:"+(index+this._lastKeyNavigation));
                this._submenu.select(index+this._lastKeyNavigation, this._submenu.FOCUS_POSITION);
            }
        },

        __menuSelectionFocus: function(evt) {
            if (evt.gridComponents.length > 0) {
                this._menu.setOption("forwardFocus", evt.gridComponents[evt.selectedGridRow][evt.selectedGridCol]);
            }
        },

        __menuErrorNoResult: function() {
            dialogHelper.error({
                reason: sLanguageManager.getString("Global.Global_NoResults"),
                buttonText: sLanguageManager.getString("Global.Global_buttonClose")
            });
        },

        reset: function () {
            mediator.unsubscribe(sNavigationManager.MENU_UPDATE, this.__onMenuUpdateRef);
            mediator.unsubscribe("navigated", this.__onMenuNavigatedRef);
            mediator.unsubscribe(sNavigationManager.MENU_RECONSTRUCT_COMPLETE, this.__onHistoryNavigatedRef);
            mediator.unsubscribe(UserEvent.UserHasBeenLoggedOut, this.__userHasBeenLoggedOutHandler);
            this.getView().removeEventListener(evtType.KEY, this.__onKeyRef);
            this._menu.removeEventListener(evtType.CLICK, this.__menuClickHandlerRef);
            this._menu.removeEventListener(evtType.KEY, this.__menuKeyHandlerRef);
            this._menu.removeEventListener(evtType.SELECTION_CHANGED, this.__menuSelectionFocus);
            this._menu.removeEventListener(evtType.FOCUS, this.__headerFocusRef);
            this._subController.removeEventListener(evtType.FOCUS, this.__subControllerFocusHandlerRef);
            this._submenu.removeEventListener(evtType.KEY, this.__submenuKeyHandlerRef);
            this._submenu.removeEventListener(evtType.SELECTION_CHANGED, this.__submenuSelectableCheckerRef);
            this._submenu.removeEventListener(evtType.FOCUS, this.__headerFocusRef);
            this._breadcrumb.removeEventListener(evtType.CLICK, this.__breadcrumbClickHandlerRef);
        }
    });
});

/**
 * Maintenance view's template
 * @name maintenance
 * @memberof tvedemo/tmpl
 * @class tvedemo/tmpl/maintenance
 * @author Shawn Zeng <shawn.zeng@accedo.tv>
 */
define("tvedemo/tmpl/maintenance", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "xdk-ui-basic/Image"
], function (
    Layout,
    Label,
    Image
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            id: "#maintenanceView",
            width: 1,
            alignment: Layout.HORIZONTAL,
            focusable: true,
            children: [{
                klass: Image,
                css: "backdrop",
                src: "img/skystorm/splash.png"
            }, {
                klass: Label,
                css: "message",
                id: "message",
                text: ""
            }]
        };
    };
});
/**
 * The maintenance view's controller. Setup the maintenance mode and message.
 * @name Maintenance
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Maintenance
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Maintenance", [
    "xdk-base/ax", "tvedemo/ctrl/RoutableController", "xdk-ax/mvc/view",
    "tvedemo/tmpl/maintenance", "storm/mgr/sAppConfigManager", "xdk-base/util",
    "xdk-ax/evt/type", "xdk-ax/focusManager", "xdk-ax/mediator",
    "storm/mgr/sLanguageManager"
], function (ax, RoutableController, view,
    maintenanceTmpl, sAppConfigManager, util,
    evtType, focusManager, mediator,
    sLanguageManager) {

    return ax.klass.create(RoutableController, {
    }, {
        init: function () {
            this.setView(view.render(maintenanceTmpl));
        },

        setup: function (context) {
            var currentView = this.getView();

            this._messageLabel = currentView.find("message");

            sAppConfigManager.getMessage().then(util.bind(function (theMessage) {
                this._messageLabel.setText(theMessage);
            }, this), util.bind(function(outcome) {
                this._messageLabel.setText(sLanguageManager.getString("ui.maintenance.default"));
            }, this));

            focusManager.focus(currentView);
            this._super(context);
        },

        reset: function () {
            this._super();
        }
    });
});
/**
 * mixedListing - contain list of users fav items
 * @name mixedListing
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/mixedListing
 */
define("tvedemo/tmpl/mixedListing", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "xdk-ax/Container",
    "storm/mgr/sLanguageManager"
], function (
    Layout,
    Label,
    LoopedGrid,
    Container,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            forwardFocus: true,
            alignment: Layout.VERTICAL,
            css: "subcontrollerPage mixed-listing",
            children: [{
                klass: Label,
                id: "moviesHeadline",
                css: "movies-headline"
            },{
                klass: LoopedGrid,
                forwardFocus: true,
                alignment: LoopedGrid.VERTICAL,
                id: "moviesAssetGrid",
                css: "movie-asset-grid",
                nextDown: "tvShowAssetGrid",
                rows: 9,
                cols: 1,
                scrollFrontBoundary: 4,
                scrollEndBoundary: 4
            },{
                klass: Container,
                css: "middle-content",
                children: [{
                    klass: Container,
                    id: "descriptionContainer",
                    css: "description-container",
                    children: [{
                        klass: Label,
                        id: "title",
                        css: "title"
                    },{
                        klass: Label,
                        id: "meta",
                        css: "meta"
                    }]
                }]
            },{
                klass: Label,
                id: "seriesHeadline",
                css: "series-headline"
            },{
                klass: LoopedGrid,
                forwardFocus: true,
                alignment: LoopedGrid.VERTICAL,
                id: "tvShowAssetGrid",
                css: "serie-asset-grid",
                nextUp: "moviesAssetGrid",
                rows: 5,
                cols: 1,
                scrollFrontBoundary: 2,
                scrollEndBoundary: 2
            },{
                klass: Label,
                id: "errorMsgNoResults",
                css: "error-msg-center hidden",
                text: sLanguageManager.getString("Global.Global_NoResults")
            }]
        };    
    };
});
/**
 * Listing view of both dvd_cover & 16:9 assets.
 * @name MixedListing
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/MixedListing
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/MixedListing", [
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/data/LocalDatasource",
    "tvedemo/mgr/sAssetManager",
    "tvedemo/tmpl/mixedListing",
    "tvedemo/wgt/ImageButton",
    "tve/mgr/sLinearManager",
    "xdk-ax/focusManager",
    "storm/helper/util",
    "xdk-ax/Container",
    "xdk-ui-basic/Label",
    "xdk-ax/evt/type",
    "xdk-ax/mvc/view",
    "xdk-base/device/vKey",
    "xdk-ax/mediator",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/class",
    "xdk-base/util",
    "storm/mgr/sAppConfigManager"
], function (
    RoutableController,
    LocalDatasource,
    sAssetManager,
    tmpl,
    ImageButton,
    sLinearManager,
    focusManager,
    stormUtil,
    Container,
    Label,
    evtType,
    view,
    vKey,
    mediator,
    console,
    promise,
    klass,
    util,
    sAppConfigManager
) {

    "use strict";

    var SERIES_IMAGE_TYPE = "content_2",
        DISPLAY_TYPE_DVD_COVER = "dvd_cover",
        DISPLAY_TYPE_SIXTEEN_NINE = "16:9",

        GRID_FOCUS_COLUMN_MOVIES = 4,
        GRID_FOCUS_COLUMN_SERIES = 2;

    return klass.create(RoutableController, {
        getDefaultState: function () {
            return {
                navigator: null
            };
        }
    }, {

        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        //override getState to handle latest state from the menu
        getState: function () {
            return {
                navigator: this.context.navigator
            };
        },

        setup: function (context) {
            this.context = context || {};
            this.populateVariables();
            this.addListeners();

            if (context.historyBack === true) {
                return;
            }

            this._data = {};
            this._data[DISPLAY_TYPE_DVD_COVER] = [];
            this._data[DISPLAY_TYPE_SIXTEEN_NINE] = [];
            context.setupPending = this._setupGrid().then(util.bind(function(results) {
                if (Error.prototype.isPrototypeOf(results[0])) {
                    if (Error.prototype.isPrototypeOf(results[1])) {
                        this.getView().find("errorMsgNoResults").removeClass("hidden");
                    } else {
                        focusManager.focus(this._seriesGrid);
                    }
                } else {
                    focusManager.focus(this._moviesGrid);
                }
            }, this));
        },
        populateVariables: function(){
            this._moviesHeadline = this.getView().find("moviesHeadline");
            this._moviesGrid = this.getView().find("moviesAssetGrid");
            this._titleLabel = this.getView().find("title");
            this._metaLabel = this.getView().find("meta");

            this._seriesHeadline = this.getView().find("seriesHeadline");
            this._seriesGrid = this.getView().find("tvShowAssetGrid");
        },
        addListeners: function(){
            this._movieGridClickHandlerRef = util.bind(this._movieGridClickHandler, this);
            this._movieGridFocusHandlerRef = util.bind(this._movieGridFocusHandler, this);

            this._moviesGrid.addEventListener(evtType.CLICK, this._movieGridClickHandlerRef);
            this._moviesGrid.addEventListener(evtType.FOCUS, this._movieGridFocusHandlerRef);

            this._serieGridClickHandlerRef = util.bind(this._serieGridClickHandler, this);
            this._serieGridFocusHandlerRef = util.bind(this._serieGridFocusHandler, this);

            this._seriesGrid.addEventListener(evtType.CLICK, this._serieGridClickHandlerRef);
            this._seriesGrid.addEventListener(evtType.FOCUS, this._serieGridFocusHandlerRef);
        },
        _setupGrid: function() {
            return this.__mergeDataByLexic().then(util.bind(function() {
                return stormUtil.allPromises([
                        this._setupMovieGrid(),
                        this._setupSerieGrid()
                    ]);
            }, this));
        },

        __mergeDataByLexic: function() {
            var listings = this.context.navigator.listings,
                promises = [];
            for (var i=0,len=listings.length;i<len;i++) {
                var listing = listings[i];
                listing.url = listing.path;
                // Only "dvd_cover" & "16:9" is allowed to pass the data parsing stage, as they are used as key value
                if (!listing.displayType || !listing.displayType.length ||
                    !(listing.displayType === DISPLAY_TYPE_DVD_COVER || listing.displayType === DISPLAY_TYPE_SIXTEEN_NINE)) {
                    console.error("[MixedListing __mergeDataByLexic] "+listing.structureType+" displayType "+listing.displayType+" is not recognizable!");
                    continue;
                }
                if (listing.structureType && listing.structureType.indexOf("ByLexic") !== -1) {
                    // Get kinda useless letter header json
                    console.log("[MixedListing __mergeDataByLexic] Start fetching "+listing.structureType+" data...");
                    promises.push(sLinearManager.getLetterHeaderListing(listing.url).then(util.bind(function (listing, letterList) {
                        var rootUrl = listing.url.replace(/[^/]*$/, ""),
                            internalPromises = [];
                        util.each(letterList, function (letterItem) {
                            if (!letterItem.linkable) {     // Skip for unlinkable item
                                return;
                            }
                            var targetUrl = rootUrl + letterItem.content.toString() + ".json";
                            // Retrieve the actual asset listing inside single letter json
                            internalPromises.push(sLinearManager.getAssetListing(targetUrl).then(function (assetList) {
                                console.log("[MixedListing __mergeDataByLexic] "+listing.structureType+" "+letterItem.content+" data fetched");
                                // attaching catalog inside asset
                                util.each(assetList.listing, function (asset) {
                                    asset.catalog = assetList.catalog;
                                });
                                return assetList.listing;
                            }));
                        });
                        // One single internalPromise will screw the whole function :)
                        return promise.all(internalPromises);
                    }, this, listing)).then(util.bind(function (listing, assetListArray) {
                        this._data[listing.displayType] = this._data[listing.displayType].concat.apply(this._data[listing.displayType], assetListArray);
                        console.log("[MixedListing __mergeDataByLexic] Finish merging "+listing.structureType+" data... TotalCount:"+this._data[listing.displayType].length);
                    }, this, listing)));
                } else {
                    // Assume it is a generic AssetListing instead of Lexic Listing
                    promises.push(sLinearManager.getAssetListing(listing.url).then(util.bind(function (listing, assetList) {
                        // attaching catalog inside asset
                        util.each(assetList.listing, function (asset) {
                            asset.catalog = assetList.catalog;
                        });
                        this._data[listing.displayType] = assetList.listing;
                    }, this, listing)));
                }
            }
            return promise.all(promises);
        },

        _setupMovieGrid: function() {
            var ds = new LocalDatasource();
            // This is the implementation of dataloader for LoopedGrid,
            // the dataloader of grid will retrieve a number of "size" of data(variable size) at sometime(who knows) with a starting index "from",
            // we just provide the data it needs to display.
            // But since it is a LoopedGrid,
            // the data is then looped from the original position if "i" is larger than data.length
            ds.setDataLoader(util.bind(function (from, size) {
                var data = this._data[DISPLAY_TYPE_DVD_COVER],
                    deferred = promise.defer(),
                    dataArray = [],
                    i;
                if (!data.length) {
                    console.error(DISPLAY_TYPE_DVD_COVER+" data empty!");
                    deferred.reject(DISPLAY_TYPE_DVD_COVER+" data empty!");
                }
                for (i = 0; i < size; i++) {
                    dataArray.push(data[((from+i) % data.length)]);
                }
                deferred.resolve({
                    data: dataArray,
                    total: data.length
                });
                return deferred.promise;
            }, this));
            this._moviesGrid.setDisplayStgy(function (asset) {
                var view = new Container({
                        forwardFocus: true
                    }),
                    imageButton = new ImageButton({
                        parent: view,
                        placeHolderPromise: sAppConfigManager.getPlaceholderPortrait
                    });
                if (!asset.dvd_cover || !asset.dvd_cover.path || !asset.dvd_cover.file) {
                    console.warn("Asset does not contain dvd_cover images");
                    imageButton.fallback();
                }
                else {
                    sLinearManager.constructCMSUrlPromise(asset.dvd_cover.path+"/"+asset.dvd_cover.file).then(function (url) {
                        imageButton.setSrc(url);
                    });
                }
                return view;
            });
            return this._moviesGrid.setDatasource(ds).then(util.bind(function(){
                this._moviesGrid.select(0, GRID_FOCUS_COLUMN_MOVIES);
            }, this));
        },

        _setupSerieGrid: function() {
            var ds = new LocalDatasource(),
                titleFormatter = function(asset) {
                    var string = "";
                    if (asset.season_nr) {
                        string += "S" + asset.season_nr + " ";
                    }
                    if (asset.episode_nr) {
                        string += "E" + asset.episode_nr;
                    }
                    if (string.length) {
                        string += ": ";
                    }
                    if (asset.serie_title && asset.serie_title.length) {
                        string += asset.serie_title.toUpperCase();
                    } else if (asset.title && asset.title.length) {
                        string += asset.title.toUpperCase();
                    }
                    return string;
                };
            // This is the implementation of dataloader for LoopedGrid,
            // the dataloader of grid will retrieve a number of "size" of data(variable size) at sometime(who knows) with a starting index "from",
            // we just provide the data it needs to display.
            // But since it is a LoopedGrid,
            // the data is then looped from the original position if "i" is larger than data.length
            ds.setDataLoader(util.bind(function (from, size) {
                var data = this._data[DISPLAY_TYPE_SIXTEEN_NINE],
                    deferred = promise.defer(),
                    dataArray = [],
                    i;
                if (!data.length) {
                    console.error(DISPLAY_TYPE_SIXTEEN_NINE+" data empty!");
                    deferred.reject(DISPLAY_TYPE_SIXTEEN_NINE+" data empty!");
                }
                for (i = 0; i < size; i++) {
                    dataArray.push(data[((from+i) % data.length)]);
                }
                deferred.resolve({
                    data: dataArray,
                    total: data.length
                });
                return deferred.promise;
            }, this));
            this._seriesGrid.setDisplayStgy(function (asset) {
                var targetImage,
                    view = new Container({
                        forwardFocus: true
                    }),
                    imageButton = new ImageButton({
                        parent: view,
                        placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                    });
                if (!asset.main_picture || !asset.main_picture.picture || !asset.main_picture.picture.length) {
                    console.warn("Asset does not contain 16:9 images");
                    imageButton.fallback();
                }
                else {
                    util.each(asset.main_picture.picture, function (image) {
                        if (!image.path || !image.file) {
                            return;
                        }
                        targetImage = image;
                        if (image.type === SERIES_IMAGE_TYPE) {   // @TODO: SKYSTORM-233  // @TODO: enumeration/configurable
                            return util.breaker;
                        }
                    });
                    sLinearManager.constructCMSUrlPromise(targetImage.path+"/"+targetImage.file).then(function (url) {
                        imageButton.setSrc(url);
                    });
                }
                var textContainer = new Container({
                        parent: imageButton,
                        css: "textContainer"
                    }),
                    label = new Label({
                        parent: textContainer,
                        text: titleFormatter(asset),
                        css: "text"
                    });

                return view;
            });
            return this._seriesGrid.setDatasource(ds).then(util.bind(function(){
                this._seriesGrid.select(0, GRID_FOCUS_COLUMN_SERIES);
            }, this));
        },

        _movieDescriptionHandler: function() {
            var asset = this._moviesGrid.getSelectedData();

            if (asset.title && asset.title.length) {
                this._titleLabel.setText(asset.title.toUpperCase());
            } else {
                this._titleLabel.setText("");
            }

            this._metaLabel.setText(asset.category.main.content+" | "+asset.year_of_production);
        },

        setMovieGridDescriptionVisible: function(isVisible) {
            // Change visibility without affecting flow...
            if (isVisible) {
                this.getView().find("descriptionContainer").removeClass("hidden");
            } else {
                this.getView().find("descriptionContainer").addClass("hidden");
            }
        },

        _movieGridFocusHandler: function() {
            this.setMovieGridDescriptionVisible(true);
            this._movieDescriptionHandler();
        },

        _serieGridFocusHandler: function() {
            this.setMovieGridDescriptionVisible(false);
        },

        _movieGridClickHandler: function() {
            var asset = this._moviesGrid.getSelectedData();
            mediator.publish("navigate", {
                path: "Main/Movie",
                state: {
                    assetId: asset.id,
                    catalog: asset.catalog
                }
            });
            return false;
        },

        _serieGridClickHandler  : function() {
            var asset = this._seriesGrid.getSelectedData();

            // We need to be handle Episodes, Seasons, and Series; just adding missed Episode handling...

            if (asset.asset_type === "Episode") {
                mediator.publish("navigate", {
                    path: "Main/Episode",
                    state: {
                        selectedEpisodeId: asset.id,
                        catalog: asset.catalog
                    }
                });
            } else {
                mediator.publish("navigate", {
                    path: "Main/TVShow",
                    state: {
                        serieId: asset.id, //CUSTSUPP-3633
                        catalog: asset.catalog
                    }
                });
            }
            return false;
        },

        reset: function () {
            //remove event listeners
            this._moviesGrid.removeEventListener(evtType.CLICK, this._movieGridClickHandlerRef);
            this._moviesGrid.removeEventListener(evtType.FOCUS, this._movieGridFocusHandlerRef);

            this._seriesGrid.removeEventListener(evtType.CLICK, this._serieGridClickHandlerRef);
            this._seriesGrid.removeEventListener(evtType.FOCUS, this._serieGridFocusHandlerRef);

            this._super();
        }
    });
});
/**
 * Movie details view's template
 * @name movie
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/movie
 */
define("tvedemo/tmpl/movie", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "storm/wgt/Image",
    "xdk-ax/Container",
    "xdk-ui-basic/Button",
    "tvedemo/wgt/AssetGrid",
    "tvedemo/wgt/ScrollLabel",
    "tvedemo/wgt/ImageButton",
    "storm/mgr/sAppConfigManager"
], function (
    Layout,
    Label,
    Image,
    Container,
    Button,
    AssetGrid,
    ScrollLabel,
    ImageButton,
    sAppConfigManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#movie",
            children: [{
                klass: Layout,
                alignment: Layout.VERTICAL,
                children: [{
                    klass: Layout,
                    id: "#upContainer",
                    children: [{
                            klass: Image,
                            id: "#thumbnail",
                            placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                        }, {
                            klass: Layout,
                            id: "#blackoutMessageContainer",
                            children: [{
                                klass: Label,
                                id: "#blackoutMessage"
                            }]
                        },{
                            klass: Container,
                            css: "informationContainer",
                            children: [{
                                klass: Label,
                                id: "#title"
                            }, {
                                klass: Layout,
                                id: "#metaDataContainer",
                                alignment: Layout.HORIZONTAL
                            }, {
                                klass: Image,
                                id: "#channelLogo"
                            }, {
                                klass: Container,
                                id: "missingPackage",
                                css: "missingPackage",
                                children: [{
                                    klass: Image,
                                    id: "missingPackageLogo",
                                    css: "missingPackageLogo"
                                }, {
                                    klass: Label,
                                    id: "missingPackageText",
                                    css: "missingPackageText"
                                }]
                            }]
                        }]
                    }, {
                        klass: Layout,
                        alignment: Layout.HORIZONTAL,
                        id: "#videoButtonContainer",
                        children: [
                        {
                            klass: ImageButton,
                            id: "movieStartFromVod",
                            text: "",
                            nextRight: "detailDescription",
                            nextLeft: "movieStartFromVod"
                        }, {
                            klass: ImageButton,
                            id: "movieWatchTrailer",
                            text: "",
                            nextLeft: "movieWatchTrailer",
                            nextRight: "detailDescription"
                        }, {
                            klass: ImageButton,
                            id: "addToWatchlist",
                            text: "",
                            nextRight: "detailDescription",
                            nextLeft: "addToWatchlist"
                        }]
                    }, {
                        klass: ScrollLabel,
                        id: "detailDescription",
                        scrollStep: 72,
                        nextLeft: "videoButtonContainer",
                        nextUp: "header",
                        nextDown: "detailDescription"
                    }]
                }]
        };
    };
});
/**
 * The movie details view's controller. Setup the movie details info, a related movie listing and related actions such as rent, favorite...
 * @name Movie
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Movie
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Movie", [
    "xdk-base/ax",
    "xdk-base/class",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/movie",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/mediator",
    "tvedemo/wgt/TextSelectionListDialog",
    "xdk-base/promise",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/AlertDialog",
    "storm/mgr/sAppConfigManager",
    "xdk-base/console",
    "storm/mgr/sLanguageManager",
    "tvedemo/mgr/sAssetManager",
    "tvedemo/ctrl/DetailsBase",
    "storm/event/UserEvent"
], function (
    ax,
    klass,
    view,
    movieTmpl,
    evtType,
    focusManager,
    vKey,
    util,
    mediator,
    TextSelectionListDialog,
    promise,
    Label,
    moment,
    sEndUserManager,
    sHistoryManager,
    dialogHelper,
    AlertDialog,
    sAppConfigManager,
    console,
    sLanguageManager,
    sAssetManager,
    DetailsBase,
    UserEvent
    ) {

    "use strict";

    return klass.create(DetailsBase, {
        getDefaultState: function () {
            return {};
        }
    }, {
        __asset: null,

        init: function () {
            this._super();
            this.setView(view.render(movieTmpl));
        },

        setup: function (context) {
            this._super(context);

            this.__handleUserDataUpdate = util.bind(function () {

                // Update buttons and entitlement indication according to the users new data.
                if (this.__asset) {
                    this.updateDetailInformation(this.__asset);
                }

            }, this);

            mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            this.setupButtons();

            if (context.historyBack) {
                this.updateDetailInformation(this.__asset);
                return;
            }

            this._autoPlayRef = util.bind(function() {
                this.__watchVod(this.__asset);
            }, this);

            if (context.autoPlay === true) {
                mediator.subscribe("navigated", this._autoPlayRef, true);
            }

            // TODO: Assuming that assetId will be passed in the context object.
            context.setupPending = this.setupDetailsInformation(context.assetId, context.catalog);

        },

        /**
         * Setup buttons on the page, add click event handlers.
         * @return {void}
         */
        setupButtons: function () {
            var currentView = this.getView(),
                watchMovie = currentView.find("movieStartFromVod"),
                watchTrailer = currentView.find("movieWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist");

            this.__watchTrailerRef = util.bind(function () {
                this.__watchTrailer(this.__asset);
            }, this);

            this.__watchMovieRef = util.bind(function () {
                this.__watchVod(this.__asset);
            }, this);


            this.__addToWatchlistRef = util.bind(function () {

                this.__updateWatchList({
                    remove: this.__detailInformation.isInWatchlist ? true : false,
                    add: this.__detailInformation.isInWatchlist ? false : true,
                    catalog: this.__asset.get("catalog"),
                    assetId: this.__asset.get("id"),
                    assetType: this.__asset.get("type")
                })
                .then(util.bind(function (successFully) {

                    if (successFully.added) {
                        this.__detailInformation.isInWatchlist = true;

                    } else if (successFully.removed) {
                            this.__detailInformation.isInWatchlist = false;
                    }

                    this.updateButtons({
                        asset: this.__asset,
                        userHasPrivileges: this.__detailInformation.userHasPrivileges,
                        isBlackedOut: this.__detailInformation.isBlackedOut,
                        isPlayable: this.__assetIsPlayable(this.__asset),
                        isInWatchlist: this.__detailInformation.isInWatchlist,
                        userIsLoggedIn: this.checkIfUserIsLoggedIn()
                    });

                }, this));

            }, this);

            watchTrailer.addEventListener(evtType.CLICK, this.__watchTrailerRef);
            watchMovie.addEventListener(evtType.CLICK, this.__watchMovieRef);
            addToWatchlist.addEventListener(evtType.CLICK, this.__addToWatchlistRef);

        },

        /**
         * Setup all asset specific data of the page.
         * @param  {Number} assetId Id of the asset that is currently displayed on the page.
         * @param  {String} catalog Catalog that contains the asset.
         * @return {void}
         */
        setupDetailsInformation: function (assetId, catalog) {
            var setupPromise;
            if (!assetId || !catalog) {
                setupPromise = ax.promise.reject().fail(function () {
                    util.defer().then(function() {
                        dialogHelper.error({
                            reason: sLanguageManager.getString("Global.Global_NoResults"),
                            closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                            buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                        });
                    });
                });

                return setupPromise;
            }

            setupPromise = sAssetManager.getAssetById(assetId, catalog);

            return setupPromise.then(util.bind(function (asset) {

                return this.updateDetailInformation(asset);

            }, this)).fail(function(reason) {

                console.warn("Movie detail page setup failed: " + reason);

                util.defer().then(function() {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Global.Global_NoResults"),
                        closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                });
            });
        },

        updateDetailInformation: function (asset) {
            return promise.all([
                this.__checkUserPrivileges(asset),
                this.__checkIfAssetIsPresentInWatchlist(asset),
                this.__getBookmarkForAsset(asset.get('id'))
            ])
            .then(util.bind(function (result) {
                var userHasPrivileges = result[0],
                    assetIsInWatchlist = result[1],
                    bookmark = result[2];

                this.__asset = asset;

                this.__detailInformation.title = asset.get("title");
                this.__detailInformation.synopsis = asset.get("synopsis");
                this.__detailInformation.cast = asset.get("cast");
                this.__detailInformation.parentalRating = asset.get("parentalRating");
                this.__detailInformation.length = asset.get("length");
                this.__detailInformation.year = asset.get("year");
                this.__detailInformation.genres = asset.get("genreList");
                this.__detailInformation.onAirDate = asset.get("date");
                this.__detailInformation.packageCode = asset.get("packageCode");
                this.__detailInformation.packageColorCode = asset.get("packageColorCode");
                this.__detailInformation.isBlackedOut = asset.get("blackedOut");
                this.__detailInformation.userHasPrivileges = userHasPrivileges;
                this.__detailInformation.isInWatchlist = assetIsInWatchlist;
                this.__detailInformation.isHD = asset.get("isHD");
                
                this.trackPage(asset.get("title"));   
                
                this.updateCommonDetailInformation(this.__asset, this.__detailInformation);

                this.updateButtons({
                    asset: this.__asset,
                    userHasPrivileges: this.__detailInformation.userHasPrivileges,
                    isBlackedOut: this.__detailInformation.isBlackedOut,
                    isPlayable: this.__assetIsPlayable(this.__asset),
                    isInWatchlist: this.__detailInformation.isInWatchlist,
                    userIsLoggedIn: this.checkIfUserIsLoggedIn(),
                    bookmark: bookmark
                });

            }, this));
        },

        /**
         * Display correct set of buttons.
         * @param  {Object} asset                         Asset that is currently displayed.
         * @param  {boolean} userHasPrivilegeToViewContent True if user is allowed to watch the content, otherwise false.
         * @return {void}
         */
        updateButtons: function (options) {

            if (!options) {
                return;
            }

            // Buttons
            var currentView = this.getView(),
                watchMovie = currentView.find("movieStartFromVod"),
                watchTrailer = currentView.find("movieWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist"),
                videoButtonContainer = currentView.find("videoButtonContainer"),
                detailDescription = currentView.find("detailDescription"),

                // Display options.
                asset = options.asset,
                userHasPrivileges = options.userHasPrivileges,
                userIsLoggedIn = options.userIsLoggedIn,
                isBlackedOut = options.isBlackedOut,
                isPlayable = options.isPlayable,
                isInWatchlist = options.isInWatchlist,
                hasTrailer = this.__hasTrailer(asset);



            watchMovie.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_now_label"));
            watchTrailer.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_trailer_label"));
            addToWatchlist.setText(isInWatchlist ?
                                    sLanguageManager.getString("DetailPage.DetailPage_removeWatchlist") :
                                    sLanguageManager.getString("DetailPage.DetailPage_labeladd_to_watchlist"));

            // Make sure navigation between buttons work as expected.
            this.setButtonNavigation([
                {
                    button: watchMovie,
                    hidden: (isBlackedOut || !isPlayable) ? true : false,
                    greyedOut: userHasPrivileges ? false : (userIsLoggedIn ? true : false)
                },
                {
                    button: watchTrailer,
                    hidden: hasTrailer ? false : true,
                    greyedOut: false
                },
                {
                    button: addToWatchlist,
                    hidden: isBlackedOut ? true : false,
                    greyedOut: false
                }

            ], videoButtonContainer);

            if (!isBlackedOut || hasTrailer) {
                detailDescription.setFocusable(false);
            }

            // Make sure that a visible button is focused.
            this.focusFirstVisibleComponent([
                watchMovie,
                watchTrailer,
                addToWatchlist
            ]);
        },

        reset: function () {
            var currentView = this.getView(),
                watchMovie = currentView.find("movieStartFromVod"),
                watchTrailer = currentView.find("movieWatchTrailer"),
                addToWatchlist = currentView.find("addToWatchlist");

            this._super();

            watchMovie.removeEventListener(evtType.CLICK, this.__watchMovieRef);
            watchTrailer.removeEventListener(evtType.CLICK, this.__watchTrailerRef);
            addToWatchlist.removeEventListener(evtType.CLICK, this.__addToWatchlistRef);

            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            mediator.unsubscribe("navigated", this._autoPlayRef);
        }


    });
});
/**
 * Movie listing view's template
 * @name moviesListing
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/moviesListing
 */
define("tvedemo/tmpl/moviesListing", [
    "storm/mgr/sLanguageManager",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "xdk-ax/Container"
], function (
    sLanguageManager,
    Layout,
    Label,
    LoopedGrid,
    Container
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            forwardFocus: true,
            alignment: Layout.VERTICAL,
            css: "subcontrollerPage movie-listing",
            children: [{
                klass: LoopedGrid,
                forwardFocus: true,
                alignment: LoopedGrid.VERTICAL,
                id: "#moviesAssetGrid",
                rows: 9,
                cols: 2,
                scrollFrontBoundary: 4,
                scrollEndBoundary: 4
            }, {
                klass: Container,
                css: "middle-content",
                children: [{
                    klass: Container,
                    id: "descriptionContainer",
                    css: "description-container",
                    children: [{
                        klass: Label,
                        id: "title",
                        css: "title"
                    },{
                        klass: Label,
                        id: "meta",
                        css: "meta"
                    }]
                }]
            }, {
                klass: Label,
                id: "errorMsg",
                css: "error-msg",
                text: sLanguageManager.getString("Global.Global_NoResults")
            }]
        };
    };
});
/**
 * The movie listing view's controller. Setup the movie listing, category and the sorting.
 * @name MoviesListing
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/MoviesListing
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/MoviesListing", [
    "tvedemo/ctrl/RoutableController",
    "tvedemo/tmpl/moviesListing", 
    "xdk-ax/data/LocalDatasource",
    "tvedemo/mgr/sAssetManager", 
    "tvedemo/wgt/ImageButton",
    "tve/mgr/sLinearManager", 
    "xdk-ax/focusManager",
    "storm/helper/util",
    "xdk-ax/Container",
    "xdk-ax/mvc/view", 
    "xdk-ax/evt/type", 
    "xdk-base/device/vKey", 
    "xdk-ax/mediator",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/class",
    "xdk-base/util",
    "storm/mgr/sAppConfigManager",
    "tvedemo/wgt/BasicGrid"
], function (
    RoutableController,
    tmpl, 
    LocalDatasource,
    sAssetManager, 
    ImageButton,
    sLinearManager, 
    focusManager,
    stormUtil,
    Container,
    view, 
    evtType, 
    vKey, 
    mediator,
    console,
    promise,
    klass, 
    util,
    sAppConfigManager,
    BoundedGrid
    ) {

    "use strict";

    var GRID_FOCUS_COLUMN = 4;

    return klass.create(RoutableController, {
        // approuter: getDefaultState
        getDefaultState: function () {
            return {
                navigator: null
            };
        }
    }, {
        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        setup: function (context) {
            this.context = context || {};
            this._assetGrid = this.getView().find("moviesAssetGrid");
            this._assetGridParent = this._assetGrid._parent;
            this._titleLabel = this.getView().find("title");
            this._metaLabel = this.getView().find("meta");

            this._assetGridHandlerRef = util.bind(this._assetGridHandler, this);
            this._assetDescriptionHandlerRef = util.bind(this._assetDescriptionHandler, this);

            this._assetGrid.addEventListener(evtType.CLICK, this._assetGridHandlerRef);
            this._assetGrid.addEventListener(evtType.FOCUS, this._assetDescriptionHandlerRef);

            if (context.historyBack === true) {
                return;
            }
            this._data = [];
            this.getView().find("errorMsg").hide();

            context.setupPending = this._setupData().then(util.bind(this._setupGrid, this)).then(util.bind(function() {
                focusManager.focus(this._assetGrid);
            }, this), util.bind(function() {
                this.getView().find("errorMsg").show();
            }, this));

            this.trackLevel(2, undefined, true);
        },

        swapAssetGrid: function(len){
            var oldAssetGrid = this._assetGrid;
            this._assetGrid = new BoundedGrid({
                forwardFocus: true,
                alignment: BoundedGrid.VERTICAL,
                id: "#moviesAssetGrid",
                rows: 2,
                cols: Math.ceil(len / 2)
            });
            
            this._assetGridParent.replace(oldAssetGrid, this._assetGrid);
            this._assetGrid.addEventListener(evtType.CLICK, this._assetGridHandlerRef);
            this._assetGrid.addEventListener(evtType.FOCUS, this._assetDescriptionHandlerRef);
        },
        _setupData: function() {
            var _retrieveData = util.bind(function (path) {
                if (!path || !path.length) {
                    console.error("path is empty");
                    return promise.reject("path is empty");
                }
                if (this.context.navigator.id && (this.context.navigator.id.indexOf("ByLexic") !== -1)) {
                    return sLinearManager.getLetterHeaderListing(path).then(function (letterList) {
                        var rootUrl = path.replace(/[^/]*$/, ""),
                            internalPromises = [];
                        util.each(letterList, function (letterItem) {
                            if (!letterItem.linkable) {     // Skip for unlinkable item
                                return;
                            }
                            var targetUrl = rootUrl + letterItem.content.toString() + ".json";
                            internalPromises.push(sLinearManager.getAssetListing(targetUrl).then(function (assetList) {
                                console.log("[MoviesListing _retrieveData] "+letterItem.content+" data fetched");
                                // attaching catalog inside asset
                                util.each(assetList.listing, function (asset) {
                                    asset.catalog = assetList.catalog;
                                });
                                return assetList.listing;
                            }));
                        });
                        // One single internalPromise will screw the whole function :)
                        return promise.all(internalPromises);
                    }).then(util.bind(function (assetListArray) {
                        this._data = this._data.concat.apply(this._data, assetListArray);
                        console.log("[MoviesListing _retrieveData] Finish merging data... TotalCount:"+this._data.length);
                        return;     // resolve
                    }, this));
                } else {
                    return sLinearManager.getAssetListing(path).then(util.bind(function (assetList) {
                        // attaching catalog inside asset
                        util.each(assetList.listing, function (asset) {
                            asset.catalog = assetList.catalog;
                        });

                        this._data = assetList.listing;
                        return;     // resolve
                    }, this));
                }
            }, this);
            return _retrieveData(this.context.navigator.url);
        },

        _setupGrid: function() {
            var ds = stormUtil.arrayToDs(this._data);
            var len = this._data.length;
            if(len < 15){
                this.swapAssetGrid(len);
            }
            this._assetGrid.setDisplayStgy(function (asset) {
                var view = new Container({
                        forwardFocus: true
                    }),
                    imageButton = new ImageButton({
                        parent: view,
                        placeHolderPromise: sAppConfigManager.getPlaceholderPortrait
                    });
                if (!asset.dvd_cover || !asset.dvd_cover.path || !asset.dvd_cover.file) {
                    console.warn("Asset does not contain dvd_cover images");
                    imageButton.fallback();
                }
                else {
                    sLinearManager.constructCMSUrlPromise(asset.dvd_cover.path+"/"+asset.dvd_cover.file).then(function (url) {
                        imageButton.setSrc(url);
                    });  
                }

                return view;
            });

            return this._assetGrid.setDatasource(ds).then(util.bind(function(){
                if(len < 15){
                    this._assetGridParent.addClass("movie-listing-limited");
                    this._assetGrid.addClass("limited-movies");
                }
            }, this));
        },

        _assetDescriptionHandler: function() {
            var asset = this._assetGrid.getSelectedData(),
                category = "";

            if (asset.title && asset.title.length) {
                this._titleLabel.setText(asset.title.toUpperCase());
            } else {
                this._titleLabel.setText("");
            }
            if (asset.category.main.content) {
                category = asset.category.main.content;
            }
            else if (asset.category.other.length > 0) {
                category = asset.category.other[0].content;
            }
            this._metaLabel.setText(category + (asset.year_of_production ? " | " + asset.year_of_production : ""));
        },

        _assetGridHandler: function() {
            var asset = this._assetGrid.getSelectedData();
            switch (asset.type) {
                case "Series":
                    mediator.publish("navigate", {
                        path: "Main/TVShow",
                        state: {
                            serieId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
                default:
                    mediator.publish("navigate", {
                        path: "Main/Movie",
                        state: {
                            assetId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
            }
            return false;
        },

        reset: function () {
            //remove eventlistener and unsubscribe
            this._assetGrid.removeEventListener(evtType.CLICK, this._assetGridHandlerRef);
            this._assetGrid.removeEventListener(evtType.SELECTION_CHANGED, this._assetDescriptionHandlerRef);

            this._super();
        }
    });
});
/**
 * 'My Account' view's template
 * @name myAccount
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/myAccount
 */
define("tvedemo/tmpl/myAccount", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/AssetGrid",
    "xdk-ui-basic/Image",
    "xdk-ax/Container",
    "tvedemo/wgt/ImageButton",
    "xdk-base/config",
    "storm/mgr/sLanguageManager"
], function(
    Layout,
    Label,
    AssetGrid,
    Img,
    Container,
    ImageButton,
    config,
    sLanguageManager
) {

    "use strict";

    return function() {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            forwardFocus: true,
            css: "subcontrollerPage settings-myaccount",
            children: [{
                klass: Container,
                id: "#myaccount-maincontainer",
                children: [{//Account Details Container
                    klass: Container,
                    css: "myaccount-details",
                    alignment: Layout.HORIZONTAL,
                    children: [{
                        klass: Label,
                        id: "#myaccount-title",
                        css: "myaccount-title",
                        text: sLanguageManager.getString("Settings.Settings_labelAccount_SmartTV").toUpperCase()
                    }, {
                        klass: Layout,
                        alignment: Layout.VERTICAL,
                        id: "#user-details",
                        children: [{
                            klass:Label,
                            id: "#title",
                            css: "itemHeader",
                            text: sLanguageManager.getString("Settings.Settings_labelTitle")
                        },{
                            klass:Label,
                            id: "#userTitleValue",
                            css: "itemValue",
                            text: ""
                        },{
                            klass:Label,
                            id: "#name",
                            css: "itemHeader",
                            text: sLanguageManager.getString("Settings.Settings_labelFullName")
                        },{
                            klass:Label,
                            id: "#userNameValue",
                            css: "itemValue",
                            text: ""
                        },{
                            klass:Label,
                            id: "#email",
                            css: "itemHeader",
                            text: sLanguageManager.getString("Settings.Settings_labelEmail")
                        },{
                            klass:Label,
                            id: "#userEmailValue",
                            css: "itemValue",
                            text: ""
                        },{
                            klass:Label,
                            id: "#customerId",
                            css: "itemHeader",
                            text: sLanguageManager.getString("Settings.Settings_AccountlabelId")
                        },{
                            klass:Label,
                            id: "#userCustomerId",
                            css: "itemValue",
                            text: ""
                        },{
                            klass:Label,
                            id: "#CustomerBookmarkFlag",
                            css: "itemHeader",
                            text: "Bookmarking"//sLanguageManager.getString("Settings.Settings_Bookmarking_action") TODO to be replaced MISSING
                        },{
                            klass:ImageButton,
                            id: "#userCustomerBookmarkFlag",
                            css: "itemValue bookmarkToggle",
                            text: "",
                            nextDown: "logoutButton"
                        }]
                    }, {
                        klass: ImageButton,
                        id: "#logoutButton",
                        text: sLanguageManager.getString("Global.Global_buttonLogout_btn").toUpperCase(),
                        nextUp: "userCustomerBookmarkFlag"
                    }]
                }, // SubScription Container
                    {
                        klass: Container,
                        alignment: Layout.HORIZONTAL,
                        children: [{
                            klass: Label,
                            id: "#addonsubscription-title",
                            css: "addonsubscription-title",
                            text: sLanguageManager.getString("Settings.Settings_entitlementSubscription_sky").toUpperCase()
                        }, {
                            klass:Layout,
                            id: "#subscriptiondetail-layout",
                            alignment: Layout.VERTICAL,
                            children: []
                        },{
                            klass:Label,
                            id: "#activedaypass-title",
                            css: "activedaypass-title",
                            text: sLanguageManager.getString("Settings.Settings_entitlementDayPass_active").toUpperCase()
                        },{
                            klass:Layout,
                            id: "#activedaypass-layout",
                            children: []
                        }]

                    }]
            }]
        };
    };
});
/**
 * Daypass Model
 * @class storm/model/Daypass
 */
define("storm/model/Daypass", [
    "xdk-base/class",
    "tve/model/ImmutableModel"
], function (
    klass,
    ImmutableModel
    ) {

    "use strict";

    return klass.create(ImmutableModel, {

        defaults: {

            /**
             * @member key - The key into the daypass description list from the back end
             * @memberof storm/model/Daypass#
             * @public
             * @type {String}
             */
            "key": null,

            /**
             * @member title
             * @memberof storm/model/Daypass#
             * @public
             * @type {string}
             */
            "title": "",

            /**
             * @member startDate - the earliest validity (note, constructed from German local time)
             * @memberof storm/model/Daypass#
             * @public
             * @type {Date}
             */
            "startDate": null,

            /**
             * @member endDate - the latest validity (note, constructed from German local time)
             * @memberof storm/model/Daypass#
             * @public
             * @type {Date}
             */
            "endDate": null,

            /**
             * @member entitlements - like "OFBS|OFBP" but ONLY FOR (POSSIBLE / OPTIONAL) DECORATION, never for actual entitlement checks
             * @memberof storm/model/Daypass#
             * @public
             * @type {String}
             */
            "entitlements": "",

            /**
             * @member category - K, G, or O (currently known) for possible consolidation of passes as presented to the user
             * @memberof storm/model/Daypass#
             * @public
             * @type {String}
             */
            "category": ""
        }
    }, {});
});
/**
 * Daypass Builder, for building the Daypass model
 * @class storm/model/DaypassBuilder
 */
define("storm/model/DaypassBuilder", [
    "xdk-base/class",
    "storm/model/Daypass"
], function (
    klass,
    Daypass
    ) {

    "use strict";

    var DaypassBuilder = klass.create({}, {

        /**
         * Internal attributes marker
         * @member _attrs
         * @memberof storm/model/DaypassBuilder#
         * @protected
         */
        _attrs: {},

        /**
         * Set the key for building the model.
         * @param {String} key
         * @returns {storm/model/DaypassBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        setKey: function (key) {
            this._attrs.key = key;
            return this;
        },

        /**
         * Set the title for building the model.
         * @param {String} title
         * @returns {storm/model/DaypassBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        setTitle: function (title) {
            this._attrs.title = title;
            return this;
        },

        /**
         * Set the startDate for building this model.
         * @param {Date} startDate
         * @returns {storm/model/DaypassBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        setStartDate: function (startDate) {
            this._attrs.startDate = startDate;
            return this;
        },

        /**
         * Set the endDate for building this model.
         * @param {Date} endDate
         * @returns {storm/model/DaypassBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        setEndDate: function (endDate) {
            this._attrs.endDate = endDate;
            return this;
        },

        /**
         * Set the entitlements for building this model.
         * @param {string} entitlements
         * @returns {storm/model/DaypassBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        setEntitlements: function (entitlements) {
            this._attrs.entitlements = entitlements;
            return this;
        },

        /**
         * Set the category for building this model.
         * @param {string} category
         * @returns {storm/model/DaypassBuilder} the current builder for chaining
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        setCategory: function (category) {
            this._attrs.category = category;
            return this;
        },

        /**
         * Build the Daypass model.
         * @returns {storm/model/Daypass} the Daypass model
         * @public
         * @method
         * @memberof storm/model/DaypassBuilder#
         */
        build: function () {
            return new Daypass(this._attrs);
        }
    });

    return DaypassBuilder;
});
/**
 * Returns a singleton responsible to get structures describing (in human-friendly format) products like subscriptions, packages, day passes.
 * @name sProductDetailsManager
 * @memberof storm/mgr
 * @class storm/mgr/sProductDetailsManager
 */
define("storm/mgr/sProductDetailsManager", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/promise",
    "tvedemo/helper/sMoment",
    "tve/TVEError",
    "storm/helper/util",
    "storm/mgr/sEditorialManager",
    "storm/mgr/sLanguageManager",
    "storm/model/DaypassBuilder"
], function (
    klass,
    util,
    promise,
    moment,
    TVEError,
    stormUtil,
    sEditorialManager,
    sLanguageManager,
    DaypassBuilder
    ) {

    "use strict";

    var ProductDetailsManager = klass.create({
    }, {

        //
        // A single editorial source provides information about two distinct types of product:
        //     Day passes
        //     Subscriptions (giving access to one or more packages)
        //
        // Note that a user can have at most ONE subscription at any given time.
        //

        getSubscriptionsDetails: function() {
            return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.PRODUCT_DETAILS).then(function(response){
                var outcome = response.responseJSON.subscriptions;

                if (!outcome) {
                    return promise.reject("getSubscriptionsDetails: Malformed product-describing editorial content");
                } else {
                    return outcome;
                }
            });
        },

        //
        // Here we can get information mapping K G O daypass groups to human-readable information.
        //

        getDaypassGroupDetails: function() {
            return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.PRODUCT_DETAILS).then(function(response){
                var outcome = response.responseJSON.daypasses;

                if (!outcome) {
                    return promise.reject("getDaypassGroupDetails: Malformed product-describing editorial content");
                } else {
                    return outcome;
                }
            });
        },

        //
        // Map a single letter (typically K, G, or O) to a human-readble name, via the sLanguageManager.
        //

        getDaypassGroupNameFromLetter: function(groupLetter) {
            return this.getDaypassGroupDetails().then(function(daypassGroupDetails) {
                var oDaypassGroupDetail = daypassGroupDetails[groupLetter];
                return sLanguageManager.getInitPromise().then(function(){
                    return promise.resolve(sLanguageManager.getString("Settings." + oDaypassGroupDetail.labelKey));
                });
            });
        },

        //
        // There's another source of day pass information; at times we will need to bring the two sources together...
        //

        getDaypassDetails: function() {
            return sEditorialManager.getEditorialContent(sEditorialManager.CONTENT.DAYPASS_DETAILS).then(function(response){

                //
                // Good outcome is an array of detailed descriptions of individual day passes.
                //
                // See eg http://storm-tst3.sky.de/st/multiplatform/ipad/json/daypass/daypass.json
                //

                var outcome = response.responseJSON.daypass;

                if (!outcome) {
                    return promise.reject("getDaypassDetails: Malformed product-describing editorial content");
                } else {
                    return outcome;
                }
            });
        },

        //
        // This will get the core information needed to display a daypass in the 'my account' section...
        //

        getDaypassFromKey: function(keySought) {
            return this.getDaypassDetails().then(function(daypassArray){
                var outcomeModel;
                var format = sLanguageManager.getString("ui.parsing.daypassValidityDate") + sLanguageManager.getString("ui.parsing.daypassValidityTime");

                util.each(daypassArray, function(oneDaypass) {
                    if (oneDaypass.key === keySought) {
                        var daypassBuilder = new DaypassBuilder()
                            .setKey(keySought)
                            .setTitle(oneDaypass.title) // Note that this may not be the text to show; UI designs still TBC.
                            .setStartDate(moment(oneDaypass.validity.start_date + oneDaypass.validity.start_time, format).toDate())
                            .setEndDate(moment(oneDaypass.validity.end_date + oneDaypass.validity.end_time, format).toDate())
                            .setEntitlements(oneDaypass.entitlements)
                            .setCategory(oneDaypass.category);

                        outcomeModel = daypassBuilder.build();
                        return util.each.breaker;
                    }
                });

                if (outcomeModel) {
                    return outcomeModel;
                } else {
                    return promise.reject("getDaypassFromKey: No daypass found with key " + keySought);
                }
            });
        }

    });

    return new ProductDetailsManager();
});
/**
 * The setting view's controller. Setup the setting information and related buttons.
 * @name MyAccount
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/MyAccount
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/MyAccount", [
    "xdk-base/ax",
    "tvedemo/ctrl/RoutableController",
    "tvedemo/tmpl/myAccount",
    "xdk-ax/mvc/view",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-ax/mediator",
    "xdk-base/promise",
    "tvedemo/mgr/sEndUserManager",
    "xdk-base/console",
    "xdk-base/config",
    "xdk-base/device",
    "storm/mgr/sAppConfigManager",
    "tvedemo/helper/dialogHelper",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "storm/mgr/sLanguageManager",
    "xdk-ui-basic/Layout",
    "storm/mgr/sProductDetailsManager",
    "tvedemo/mgr/sNavigationManager",
    "tve/sServiceHolder",
    "storm/event/UserEvent",
    "tvedemo/mgr/sHistoryManager",
    "lib/moment",
    "tvedemo/wgt/Loading"
], function (
    ax,
    RoutableController,
    tmpl,
    view,
    util,
    evtType,
    focusManager,
    mediator,
    promise,
    sEndUserManager,
    console,
    config,
    device,
    sAppConfigManager,
    dialogHelper,
    Label,
    moment,
    sLanguageManager,
    Layout,
    sProductDetailsManager,
    sNavigationManager,
    sServiceHolder,
    UserEvent,
    sHistoryManager,
    momentMIT,
    sLoading
    ) {

    "use strict";

    var MILLISECONDS_IN_A_SECOND = 1000;

    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {};
        }
    }, {

        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        setup: function (context) {
            this._super(context);

            this._logoutButton = this.getView().find("logoutButton");
            this._toggleBookmarkFlag = this.getView().find("userCustomerBookmarkFlag");
            if (sEndUserManager.getLoginStatus()) {
                this._boundLogoutClick = util.bind(this._logoutClick, this);
                this._logoutButton.addEventListener(evtType.CLICK, this._boundLogoutClick);
                this._boundToggleBookmarkClick = util.bind(this._toggleBookmarkFlagClick, this);
                this._toggleBookmarkFlag.addEventListener(evtType.CLICK, this._boundToggleBookmarkClick);

                this.__handleUserDataUpdate = util.bind(function () {
                    this.populateUserData();

                }, this);

                mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

                context.setupPending = this.populateUserData(); //@TODO: Repopulate (or blank) when mediator publishes an updated user state.
            } else if (context.historyBack === true) {
                sHistoryManager.back();
            }
        },

        populateUserData: function() {

            return sEndUserManager.getLoggedInUser().then(util.bind(function (userData) {
                if (userData) {

                    var currentView = this.getView(),
                        title = currentView.find("userTitleValue"),
                        userName = currentView.find("userNameValue"),
                        email = currentView.find("userEmailValue"),
                        customerId = currentView.find("userCustomerId"),
                        bookmarkFlag = currentView.find("userCustomerBookmarkFlag"),
                        subscriptionLayout = currentView.find("subscriptiondetail-layout"),
                        activeDayPassLayout = currentView.find("activedaypass-layout"),
                        subscriptions = userData.get("subscriptions"),
                        dayPasses = userData.get("dayPasses");

                    subscriptionLayout.detachAll();
                    activeDayPassLayout.detachAll();

                    title.setText(userData.get("presentation"));
                    userName.setText(userData.get("firstName") + " " + userData.get("lastName"));
                    email.setText(userData.get("email"));
                    customerId.setText(userData.get("customerCode"));
                    bookmarkFlag.setText(userData.get("isBookmarkOn") === true ? "Y" : "N");

                    if (util.isArray(subscriptions) && (subscriptions.length > 0)) {

                        sProductDetailsManager.getSubscriptionsDetails().then(function(subscriptionsDetails) {
                            util.each(subscriptions, function(subscription) {

                                var subscriptionText = subscriptionsDetails[subscription.get("id")];

                                if (subscriptionText) {

                                    util.each(subscriptionText, function(subText) {

                                        new Label({
                                            parent: subscriptionLayout,
                                            text: subText.label,
                                            css: "itemHeader row-begin row-end"
                                        });
                                    });

                                    return util.breaker();
                                }

                            });

                        }, function(error){
                            console.log("Error while showing subscription catalog ", error);
                        });

                    } else {
                        // This is so rare an edge case that we couldn't obtain a test account demonstrating this.

                        new Label({
                            parent: subscriptionLayout,
                            text: sLanguageManager.getString("Settings.Settings_noSubscriptionsMessage"),
                            css: "itemHeaderFlowing"
                        });
                    }

                    if (util.isArray(dayPasses) && (dayPasses.length > 0)) {

                        util.each(dayPasses, function(dayPass) {
                            var dayPassDetailsLayout = new Layout({
                                parent: activeDayPassLayout
                            });

                            sServiceHolder.getDateTimeService().getServerDateTime().then(function(serverDateTime) {
                                sProductDetailsManager.getDaypassFromKey(dayPass).then(function (daypassModel) {
                                    sProductDetailsManager.getDaypassGroupNameFromLetter(daypassModel.get("category")).then(function (groupName) {

                                        var humanisedValidityPeriod = daypassModel.get("endDate") ? momentMIT.duration((daypassModel.get("endDate").valueOf() - serverDateTime.valueOf()) / MILLISECONDS_IN_A_SECOND, "seconds").humanize(true) : "";

                                        // SKYSTORM-686 means that for periods in _hours_ or _minutes_ we say 'noch' rather than 'in' (so '17 hours more', not 'in 17 hours').

                                        if (
                                            (humanisedValidityPeriod.indexOf("Stunde") !== -1) ||
                                            (humanisedValidityPeriod.indexOf("Minute") !== -1)
                                            ) {
                                            humanisedValidityPeriod = humanisedValidityPeriod.replace("in ", "noch ");
                                        }

                                        new Label({
                                            parent: dayPassDetailsLayout,
                                            text: groupName,
                                            css: "itemHeaderDayPass"
                                        });

                                        new Label({
                                            parent: dayPassDetailsLayout,
                                            text: humanisedValidityPeriod,
                                            css: "itemValueDayPass row-begin row-end"
                                        });

                                    }, function (e) {
                                        ax.console.error(e);
                                    });

                                }, function (e) {
                                    ax.console.error(e);
                                });
                            });
                        });

                    } else {

                        new Label({
                                parent: activeDayPassLayout,
                                text: sLanguageManager.getString("Settings.Settings_noDaypassesMessage"),
                                id: "#nodayPassMessage",
                                css: "itemHeaderFlowing"
                            });

                        new Label({
                                parent: activeDayPassLayout,
                                text: sLanguageManager.getString("Settings.Settings_daypassesUpsellingMessage"),
                                id: "#bookdayPassWebsite",
                                css: "itemHeaderFlowing"
                            });
                    }
                }
            }, this));
        },


        _toggleBookmarkFlagClick: function(){
            var currentView = this.getView();
            var bookmarkFlag = currentView.find("userCustomerBookmarkFlag");

            if (bookmarkFlag.getText() === "Y") {
                dialogHelper.confirm({
                    title: sLanguageManager.getString("Bookmarking.Bookmarking_Deactivation_Popup_hl"),
                    message: sLanguageManager.getString("Bookmarking.Bookmarking_Deactivation_Popup_text"),
                    positiveText: sLanguageManager.getString("Bookmarking.Bookmarking_Deactivation_Popup_Confirm_text"),
                    negativeText: sLanguageManager.getString("Bookmarking.Bookmarking_Deactivation_Popup_Cancel_text"),
                    positiveAction: util.bind(function() {
                        this._updateBookmarkFlag(bookmarkFlag);
                    }, this),
                    negativeAction: util.bind(function(){
                    },this)
                });
            } else {
                this._updateBookmarkFlag(bookmarkFlag);
            }


        },

        _updateBookmarkFlag: function(bookmarkFlag){
            sLoading.open();
            sEndUserManager.updateCustomerBookmarkFlag().then(function (response) {
                if (response.resultMessage === "OK") {
                    sEndUserManager.getLoggedInUser().then(util.bind(function (userData) {
                        sLoading.close();
                        var isBookmarkOn = userData.get("isBookmarkOn"),
                            textMessage = isBookmarkOn ? "Bookmarking_Activation_Successful_Popup_text" : "Bookmarking_Deactivation_Successful_Popup_text",
                            bookmarkingTitle = isBookmarkOn ? "Bookmarking_Activation_Successful_Popup_hl" : "Bookmarking_Deactivation_Successful_Popup_hl";
                        if (userData) {
                            dialogHelper.success({
                                title: sLanguageManager.getString("Bookmarking." + bookmarkingTitle),
                                message: sLanguageManager.getString("Bookmarking." + textMessage)
                            });
                            bookmarkFlag.setText(isBookmarkOn === true ? "Y" : "N");
                        }
                    }));
                }
                else
                {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Errormessages.Errormessages_GenericErrorMessageHeadline"),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                }
            });

        },

        _logoutClick: function () {
            sEndUserManager.logout(sEndUserManager.LOGOUT.DISCARD_USERNAME).then(function () {

                // Success, go to home page.
                mediator.publish("navigate" , {
                    path: "Main/Home"
                });

            }).fail(function (reason) {

                if (promise.isPromise(reason)) {

                    reason.then(function (reasonMessage) {
                        var message = reasonMessage && reasonMessage.get("description");

                        console.info("Logout failed: ", message);
                        dialogHelper.error({
                            reason: message
                        });
                    });

                } else {

                    // This will be due to session expired while user on the page (session expiry detected after view opened)...

                    console.info("Logout on MyAccount failed: ", reason);

                    dialogHelper.error({
                        reason: sLanguageManager.getString("Errormessages.Errormessages_labelSessionExpired")
                    });
                }

            });

        },

        reset: function (context) {
            this._logoutButton.removeEventListener(evtType.CLICK, this._boundLogoutClick);
            this.getView().removeAllListeners();

            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            this._super(context);
        }
    });
});
/**
 * Submenu is a widget that controls the submenu appears on screen.
 * The submenu accepts array of JSON and render a list of buttons. Each object is a JSON object, where a _text_ property is mandatory.
 * This widget also handles the selection state of the items.
 * The other component can listen to the CLICK event of this widget and get the selected state inside the handler for subsequent actions.
 * @name Submenu
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/Submenu
 * @extends ax/ext/ui/Layout
 */
define("tvedemo/wgt/Submenu", ["xdk-base/class", "xdk-base/core", "xdk-ui-basic/Layout", "xdk-ax/evt/type", "xdk-ui-basic/Button", "xdk-base/util"], function (klass, core, Layout, evtType, Button, util) {

    return klass.create(Layout, {}, {

        //Array of submenu items
        _items: [],

        //Index of the selected item
        _selectedIndex: -1,

        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} opts Options
         * @param {Array} items The menu items' object array
         * @memberof tvedemo/wgt/Submenu#
         */
        init: function (opts) {
            opts.alignment = Layout.HORIZONTAL;
            opts.forwardFocus = true;

            this._super(opts);
            this.addClass("wgt-submenu");

            if (opts.items) {
                this.setItems(opts.items);
            }

            // listen in the capturing phase to preceed others
            this.addEventListener(evtType.CLICK, this._onClick, true);
        },

        setItems: function (items) {
            this._items = items;
            this._initUI();
        },

        /**
         * Initiate the widget UI.
         * @method
         * @protected
         * @memberof tvedemo/wgt/Submenu#
         */
        _initUI: function () {
            // remove all existing menu items
            this.detachAll();

            // attach new items according to the pre-defined sequence
            for (var i = 0, len = this._items.length; i < len; i++) {
                new Button({
                    css: "wgt-submenu-item",
                    text: this._items[i].text,
                    parent: this
                }).removeClass("wgt-button").addClass("menu-button");
            }
        },

        /**
         * Get the selected item.
         * @method
         * @public
         * @memberof tvedemo/wgt/Submenu#
         */
        getSelection: function () {
            return this._items[this._selectedIndex];
        },

        /**
         * Get the selected index.
         * @method
         * @public
         * @memberof tvedemo/wgt/Submenu#
         */
        getSelectedIndex: function () {
            return this._selectedIndex;
        },

        /**
         * Select an item using the index.
         * @method
         * @public
         * @param {int} index The target selected index
         * @memberof tvedemo/wgt/Submenu#
         */
        select: function (index) {
            if (index < 0 || index >= this._items.length) {
                throw core.createException("Invalid param", "Array index out of bound");
            }

            this._select(index);
        },

        /**
         * Select the submenu item by updating the selectedIndex and CSS of the DOM elements.
         * @method
         * @protected
         * @param {int} index The target selected index
         * @memberof tvedemo/wgt/Submenu#
         */
        _select: function (index) {
            var children = this.getChildren();

            if (this._selectedIndex >= 0 && children[this._selectedIndex]) {
                children[this._selectedIndex].removeClass("selected");
            }

            this._selectedIndex = index;
            children[this._selectedIndex].addClass("selected");
        },

        /**
         * Handle the CLICK event.
         * This function modify the selected index and the css of the children.
         * @method
         * @protected
         * @param {Event} evt The key event sent from XDK
         * @memberof tvedemo/wgt/Submenu#
         */
        _onClick: function (evt) {
            var childIndex = util.indexOf(this.getChildren(), evt.target);
            this._select(childIndex);
        }
    });
});
/**
 * News details view's template
 * @name tvShow
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/news
 */
define("tvedemo/tmpl/news", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/Submenu",
    "tvedemo/wgt/AssetGrid",
    "storm/wgt/Image",
    "xdk-ax/Container",
    "tvedemo/wgt/ScrollLabel",
    "storm/mgr/sAppConfigManager"
], function (
    Layout,
    Label,
    Submenu,
    AssetGrid,
    Image,
    Container,
    ScrollLabel,
    sAppConfigManager
    ) {

    return function () {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#news",
            children: [{
                klass: Container,
                id: "#upContainer",
                children: [{
                    klass: Image,
                    id: "#thumbnail",
                    placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                }, {
                    klass: Label,
                    id: "#title"
                }, {
                    klass: Layout,
                    id: "#metaDataContainer",
                    alignment: Layout.HORIZONTAL
                }, {
                    klass: Image,
                    id: "#channelLogo"
                }]
            }, {
                klass: ScrollLabel,
                id: "detailDescription",
                css: "serie-description",
                scrollStep: 108,
                nextDown: "relatedNewsGrid",
                nextUp: "header"
            },{
                klass: AssetGrid,
                id: "#relatedNewsGrid",
                focusable: true,
                rows: 1,
                cols: 4,
                button: {
                    showEpisodeNumber: true,
                    icon: true
                },
                nextUp: "detailDescription",
                nextDown: "relatedNewsGrid"
            }]
        };
    };
});
/**
 * EpisodeButton is a widget that represent an episode by showing its thumbnail. A typical usage of this class would be showing an array of assets in the TV show detail view.
 * The episode button consists of a container, which is corresponding to show the metadata of the episode.
 *
 * @name EpisodeButton
 * @class tvedemo/wgt/EpisodeButton
 * @extends tvedemo/wgt/AssetButton
 */
define("tvedemo/wgt/EpisodeButton", [
    "xdk-base/ax",
    "xdk-base/promise",
    "xdk-base/class",
    "tvedemo/wgt/AssetButton",
    "xdk-ui-basic/Label",
    "xdk-ax/Component",
    "storm/mgr/sAppConfigManager"
], function (
    ax,
    promise,
    klass,
    AssetButton,
    Label,
    Component,
    sAppConfigManager
    ) {

    "use strict";

    var PLACE_HOLDER_IMAGE = "img/placeholders/show_placeholder.png",
        __thumbnailPromise,
        __packageColorPromise,
        __episodeLabel;

    return klass.create(AssetButton, {}, {

        /**
         * Overrides parent init() function.
         * @method
         * @override
         * @protected
         * @param {Object} opts Options
         * @param {tvedemo/model/Episode} opts.asset The media asset
         * @memberof tvedemo/wgt/EpisodeButton#
         */
        init: function (opts) {
            __thumbnailPromise = opts.thumbnailPromise;
            __packageColorPromise = opts.packageColorPromise;

            this._super(opts);
        },

        /**
         * Get the placeholder image, overriding the super class.
         * @method
         * @protected
         * @returns {String} the source of the image.
         * @memberof tvedemo/wgt/EpisodeButton#
         */
        _getPlaceholder: function () {
            return PLACE_HOLDER_IMAGE;
        },

        /**
         * Get thumbnail image, overriding the super class.
         * @return {Promise} Set thumbnail image when fulfilled.
         */
        _getThumbnail: function () {

            if (!__thumbnailPromise) {
                // TODO: Implement proper error handling.
                return promise.reject("No thumbnail available");
            }

            return __thumbnailPromise.then(ax.util.bind(function (image) {
                this._thumbnail = image.get("url");
                this._thumbnailImage.setSrc(this._thumbnail);
            }, this));
        },

        /**
         * Set up the container.
         * @method
         * @protected
         * @memberof tvedemo/wgt/EpisodeButton#
         */
        _setupContainer: function () {
            var shade = new Component({
                    css: "wgt-assetbtn-episode-shade"
                }),
                episodeNumber = this._asset.get("episodeNumber"),
                seasonNumber = this._asset.get("seasonNumber"),
                title = this._asset.get("title");

            this._labelContainer.attach(shade);

            __episodeLabel = new Label({
                css: "wgt-assetbtn-episode",
                text: (episodeNumber && seasonNumber) ? "S" + seasonNumber + " E" + episodeNumber + ": " + title : title,
                parent: this._labelContainer
            });
        }
    });
});
/**
 * The news details view's controller.
 * @name News
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/News
 * @extends tvedemo/ctrl/DetailsBase
 */
define("tvedemo/ctrl/News", [
    "xdk-base/ax",
    "xdk-base/class",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/news",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/mediator",
    "tvedemo/wgt/TextSelectionListDialog",
    "xdk-base/promise",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/AlertDialog",
    "storm/mgr/sAppConfigManager",
    "xdk-base/console",
    "storm/mgr/sLanguageManager",
    "tve/mgr/sLinearManager",
    "tvedemo/ctrl/DetailsBase",
    "storm/helper/util",
    "tvedemo/mgr/sAssetManager",
    "tvedemo/wgt/EpisodeButton",
    "xdk-ax/evt/eventManager"
], function (
    ax,
    klass,
    view,
    newsTmpl,
    evtType,
    focusManager,
    vKey,
    util,
    mediator,
    TextSelectionListDialog,
    promise,
    Label,
    moment,
    sEndUserManager,
    sHistoryManager,
    dialogHelper,
    AlertDialog,
    sAppConfigManager,
    console,
    sLanguageManager,
    sLinearManager,
    DetailsBase,
    tvedemoUtil,
    sAssetManager,
    EpisodeButton,
    eventManager
    ) {

    "use strict";

    var GRID_FOCUS_COLUMN = 2;

    return klass.create(DetailsBase, {
        getDefaultState: function () {
            return {};
        }
    }, {
        __news: null,
        __detailInformation: {},

        init: function () {
            this._super();
            this.setView(view.render(newsTmpl));
        },

        setup: function (context) {
            this._super(context);

            this.setupGrid();

            if (context.historyBack) {
                return;
            }

            // TODO: Assuming that assetId will be passed in the context object.
            context.setupPending = this.setupDetailsInformation(context.selectedNewsId, context.selectedNewsCategory);

        },

        /**
         * Setup handling of grid events.
         * @return {void}
         */
        setupGrid: function () {
            var currentView = this.getView(),
                grid = currentView.find("relatedNewsGrid");

            this.__gridClickHandler = util.bind(this._gridClickHandler, this);
            grid.addEventListener(evtType.CLICK, this.__gridClickHandler);
        },

        /**
         * Setup all news specific data of the page.
         * @param  {Number} newsId     Id of the news that is currently displayed on the page.
         * @param  {Number} categoryId Id of the current news category.
         * @return {Promise}
         */
        setupDetailsInformation: function (newsId, categoryId) {

            sLinearManager.getSportNewsAssetsByCategory(categoryId).then(util.bind(function (sportNews) {

                var selectedNews;

                util.each(sportNews, function (news) {

                    if (news.get("id") === newsId) {
                        selectedNews = news;
                        return util.breaker;
                    }
                });

                promise.all([
                        this.displayDetailInformation(selectedNews),
                        this.displayRelatedNews(sportNews)
                    ])
                    .then(util.bind(function () {

                        var currentView = this.getView(),
                            relatedNewsGrid = currentView.find("relatedNewsGrid"),
                            detailDescription = currentView.find("detailDescription");

                        this.focusFirstVisibleComponent([relatedNewsGrid, detailDescription]);

                }, this));

            }, this)).fail(function () {
                // TODO: Implement proper error handling.
            });
        },

        /**
         * Display detail information for a certain news.
         * @param  {tvedemo/model/SportNews} news News to be displayed.
         * @return {Promise<Boolean>} True if no problem occured, otherwise false.
         */
        displayDetailInformation: function (news) {

            if (!news) {
                return promise.resolve(false);
            }

            this.__news = news;

            this.__detailInformation.title = this.__news.get("title");
            this.__detailInformation.synopsis = this.__news.get("synopsis");
            this.__detailInformation.newsDate = moment(this.__news.get("date"), sLanguageManager.getString("ui.parsing.newsDate"));

            // All users will be allowed to read all news.
            this.__detailInformation.userHasPrivileges = true;

            this.updateCommonDetailInformation(this.__news, this.__detailInformation);

            return promise.resolve(true);
        },

        /**
         * Display news in a grid.
         * @param  {tvedemo/model/SportNews[]} relatedNews A list of news to be displayed within the grid.
         * @return {void}
         */
        displayRelatedNews: function (relatedNews) {
            var rootView = this.getView(),
                grid = rootView.find("relatedNewsGrid"),
                newsDs = tvedemoUtil.arrayToDs(relatedNews);

            grid.setDisplayStgy(util.bind(function (news) {
                // We've documented our assumption to Sky, that we use packageCode for preference; packageColourCode is second choice.
                var colourCode = news.get("packageCode");

                if (!colourCode) {
                    colourCode = news.get("packageColourCode");
                }

                var opts = {
                    css: "wgt-assetbutton",
                    asset: news,
                    thumbnailPromise: sAssetManager.getStormAssetImageBySize(news, this.IMAGE_MIN_WIDTH, this.IMAGE_MIN_HEIGHT),
                    packageColorPromise: sAppConfigManager.getPackageColourForCode(colourCode)
                };

                return new EpisodeButton(opts);
            }, this));

            return grid.setDatasource(newsDs);
        },

        /**
         * Handling click on grid items.
         * @return {void}
         */
        _gridClickHandler: function (evt) {
            // Taken from TVShow.js _gridClickHandler
            var notArrow = evt.target._opts.css != "wgt-grid-arrow";
            var grid = this.getView().find("relatedNewsGrid");
            var news = grid.getSelectedData();


            if (notArrow) {
                this.displayDetailInformation(news);
                return false;
            } else{
                var target = evt.target;
                focusManager.focus(grid);

                if (target._root._dom.className.indexOf("right") > -1) {
                    //move grid right
                    eventManager.trigger(evtType.KEY, grid, {id:vKey.RIGHT.id});
                } else {
                    //move grid left
                    eventManager.trigger(evtType.KEY, grid, {id:vKey.LEFT.id});
                }
                return false;
            }
        },

        reset: function () {
            this._super();

            var currentView = this.getView(),
                grid = currentView.find("relatedNewsGrid");

            grid.removeEventListener(evtType.CLICK, this.__gridClickHandler);
        }
    });
});
/**
 * On now view's template
 * @name onNow
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/onNow
 */
define("tvedemo/tmpl/onNow", [
    "xdk-ax/Container",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Image",
    "xdk-ui-basic/Label",
    "xdk-ui-basic/Layout",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "xdk-ui-basic/Checkbox",
    "tvedemo/wgt/Footer",
    "tvedemo/wgt/FooterIconMap"
], function(
    Container,
    Button,
    Image,
    Label,
    Layout,
    ScrollingGrid,
    Checkbox,
    Footer,
    FooterIconMap
    ) {

    "use strict";

    return {
        klass: Container,
        id: "#onNowView",
        width: 2,
        alignment: Layout.HORIZONTAL,
        forwardFocus: true,
        focusable: true,

        children: [{
            klass: Layout,
            id: "onNowChannelListContainer",
            css: "on-now-channel-list-container",
            width: 1,
            alignment: Layout.HORIZONTAL,
            forwardFocus: true,
            children: [{
                klass: Image,
                id: "arrowUp",
                css: "on-now-arrow-up",
                src: "img/arrow_up.png"
            }, {
                klass: Image,
                id: "arrowDown",
                css: "on-now-arrow-down",
                src: "img/arrow_down.png"
            }]
        }, {
            klass: Container,
            id: "detailsPanel",
            css: "details-panel",
            forwardFocus: true,
            children: [{
                klass: Label,
                css: "on-now-label",
                text: "ON NOW" // @TODO LANGUAGE STRING (phase 2, if we reuse this onNow template)
            }, {
                klass: Checkbox,
                css: "favorite-button",
                id: "favoriteButton",
                nextLeft: "onNowChannelList"
            }, {
                klass: Label,
                css: "on-now-title",
                id: "onNowTitle"
            }, {
                klass: Label,
                css: "on-now-time",
                id: "onNowTime"
            }, {
                klass: Label,
                css: "on-now-details",
                id: "onNowDetails"
            }]
        }, {
            klass: Container,
            css: "footer-container on-now",
            id: "footerContainer",
            children: [{
                klass: Footer,
                id: "footer",
                css: "footer",
                iconSet: FooterIconMap.DEFAULT
            }]
        }]
    };
});

/**
 * The on now view's controller. Setup the fullscreen video player, channel listing, current program info, sorting selection and favorite
 * @name OnNow
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/OnNow
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/OnNow", [
    "xdk-base/ax", "xdk-ax/mvc/AppRoot", "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view", "tvedemo/tmpl/onNow", "xdk-ax/evt/type",
    "xdk-ax/focusManager", "tvedemo/wgt/AlertDialog", "xdk-ax/mediator",
    "xdk-base/promise", "xdk-base/util", "tvedemo/wgt/ImageButton",
    "tve/mgr/sLinearManager", "tvedemo/mgr/sEndUserManager", "tvedemo/helper/sMoment",
    "xdk-base/device/vKey", "tvedemo/wgt/TextSelectionListDialog", "xdk-ui-grid/LoopedGrid",
    "tvedemo/wgt/ConfirmDialog",
    "storm/helper/util", "xdk-base/console", "tve/videoPlaybackService/model/Playlist",
    "tve/videoPlaybackService/model/PlaylistItem", "storm/mgr/sVideoManager",
    "tve/videoPlaybackService/evt/VideoPlaybackControlsEvent", "tve/videoPlaybackService/evt/VideoControlsStatusEvent",
    "storm/mgr/sLanguageManager",
    "tvedemo/wgt/vLoading"
], function(ax, AppRoot, RoutableController,
    view, tmpl, evtType,
    focusManager, AlertDialog, mediator,
    promise, util, ImageButton,
    sLinearManager, sEndUserManager, moment,
    vKey, TextSelectionListDialog, LoopedGrid,
    ConfirmDialog,
    tveUtil, console, Playlist,
    PlaylistItem, VideoManager,
    VideoPlaybackControlsEvent, VideoControlsStatusEvent,
    sLanguageManager,
    vLoading
    ) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        CATEGORY_ALL = "all",
        CATEGORY_FAVORITES = "favorites",
        CATEGORT_ARRAY = [{
            id: CATEGORY_ALL,
            text: "All"
        }],
        CATEGORT_ARRAY_FAV = [{
            id: CATEGORY_ALL,
            text: "All"
        }, {
            id: CATEGORY_FAVORITES,
            text: "Favorite"
        }],
        PROGRAM_TIME_FORMAT = sLanguageManager.getString("ui.format.onAirTime"),
        LOGO_PLACE_HOLDER = "img/placeholders/channel_placeholder.png";

    return ax.klass.create(RoutableController, {
        getDefaultState: function() {
            return {};
        }
    }, {
        init: function() {
            this.setView(view.render(tmpl));
        },

        setup: function(context) {
            sAppRoot.getView().addClass("fullscreen-video-mode");
            this.context = context;

            var currentView = this.getView();
            this.onNowView = currentView.find("onNowView");
            this.onNowChannelListContainer = currentView.find("onNowChannelListContainer");
            this.arrowUp = currentView.find("arrowUp");
            this.arrowDown = currentView.find("arrowDown");
            this.detailsPanel = currentView.find("detailsPanel");
            this.favoriteButton = currentView.find("favoriteButton");
            this.onNowTitle = currentView.find("onNowTitle");
            this.onNowTime = currentView.find("onNowTime");
            this.onNowDetails = currentView.find("onNowDetails");
            this.footer = currentView.find("footer");
            this.footerContainer = currentView.find("footerContainer");

            if (sEndUserManager.getLoginStatus()) {
                this.footer.update({
                    colorYellow: "Category",
                    arrowAll: "Move",
                    enter: "Select",
                    back: "Back"
                });
            } else {
                this.footer.update({
                    arrowAll: "Move",
                    enter: "Select",
                    back: "Back"
                });
                this.favoriteButton.hide();
            }

            this.showUI();

            sLinearManager.getChannels().then(util.bind(function(transport) {
                this.totalChannelsNumber = transport.length;
                this.setupGrid(this.totalChannelsNumber, sLinearManager.getChannelsDs());
            }, this));

            this.setupPlayback();

            // no need to fetch again if history back
            if (context.historyBack) {
                return;
            }

            this.favoriteButton.addEventListener(evtType.CLICK, util.bind(function() {
                if (this.favoriteButtonValue) {
                    sEndUserManager.addFavoriteChannelById(this.currentChannel.get("id")).done();
                } else {
                    sEndUserManager.removeFavoriteChannelById(this.currentChannel.get("id")).done();
                }
            }, this));

            this.favoriteButton.addEventListener(evtType.VALUE_CHANGED, util.bind(function(value) {
                this.favoriteButtonValue = value;
            }, this));

            this.__onKeyRef = util.bind(this.onKey, this);
            currentView.addEventListener(evtType.KEY, this.__onKeyRef);

            this.__exitPopupUpdateRef = util.bind(this.__exitPopupUpdate, this);
            mediator.subscribe("exitPopup", this.__exitPopupUpdateRef);
        },

        setupGrid: function(totalCount, gridDatasource) {
            var rows = totalCount > 4 ? 5 : totalCount;

            if (this.onNowChannelList) {
                this.onNowChannelList.detach();
                this.onNowChannelList.removeAllListeners();
            }

            this.onNowChannelList = new LoopedGrid({
                css: "on-now-channel-list",
                id: "onNowChannelList",
                rows: rows,
                cols: 1,
                alignment: LoopedGrid.HORIZONTAL,
                scrollFrontBoundary: 0,
                scrollEndBoundary: rows - 1,
                nextRight: "favoriteButton",
                parent: this.onNowChannelListContainer
            });
            this.setupArrowKeys(totalCount);

            var grid = this.onNowChannelList;
            grid.setDisplayStgy(util.bind(function(channel) {

                var button = new ImageButton({
                    src: "",
                    placeHolder: LOGO_PLACE_HOLDER
                });

                // get the logo url from the manager then substitute the source
                sLinearManager.getChannelLogoUrl(channel).then(function(url) {
                    button.setSrc(url);
                }).fail(function(reason) {
                    console.warn("[OnNow] failed to get channel logo for channel " + channel.get("title") + ": " + reason);
                }).done();

                button.addEventListener(evtType.FOCUS, util.bind(function() {
                    this.currentChannel = channel;
                    if (sEndUserManager.getLoginStatus()) {
                        sEndUserManager.checkFavoriteForChannelById(channel.get("id")).then(util.bind(function(isFavorite) {
                            if (channel.get("id") === this.currentChannel.get("id")) {
                                if (isFavorite) {
                                    this.favoriteButton.check();
                                    return;
                                }
                                this.favoriteButton.uncheck();
                            }
                        }, this)).done();
                    }

                    sLinearManager.getCurrentProgramByChannelId(channel.get("id")).then(util.bind(function(program) {
                        var startTimeText = "NA",
                            endTimeText = "NA";

                        if (channel === this.currentChannel) {
                            try {
                                startTimeText = moment(Math.floor(program.get("startTime"))).format(PROGRAM_TIME_FORMAT);
                                endTimeText = moment(Math.floor(program.get("endTime"))).format(PROGRAM_TIME_FORMAT);
                            } catch (ex) {
                                // most likely the time cannot be parsed
                                console.warn("[OnNow] " + ex);
                            }

                            this.onNowTitle.setText(program.get("title"));
                            this.onNowTime.setText(startTimeText + " - " + endTimeText);
                            this.onNowDetails.setText(program.get("description"));
                        }
                    }, this)).done();
                }, this));

                if (this.currentPlayingChannel && this.currentPlayingChannel.get("id") === channel.get("id")) {
                    button.addClass("playing");
                    this.currentPlayingButton = button;
                }

                button.addEventListener(evtType.CLICK, util.bind(function(evt) {
                    this.playChannel(channel);

                    if (this.currentPlayingButton) {
                        this.currentPlayingButton.removeClass("playing");
                    }
                    button.addClass("playing");
                    this.currentPlayingButton = button;
                }, this));

                return button;
            }, this));

            grid.setDatasource(gridDatasource).then(util.bind(function() {
                var pickChannel = util.bind(function(id) {
                    var ds = grid.getDatasource();

                    //to pick the desired one from the fetched Data
                    ds.getRange(0, ds.getFetchedCount()).then(util.bind(function(channels) {
                        for (var i = 0, l = channels.length; i < l; i++) {
                            if (id === channels[i].get("id")) {
                                grid.select(i, 0);
                                this.playChannel(channels[i]);
                                break;
                            }
                        }
                    }, this));
                }, this);

                if (this.context && this.context.channelId && !this.loadedDataSource) {
                    pickChannel(this.context.channelId);
                } else if (sEndUserManager.getLoginStatus() && !this.loadedDataSource) {
                    sEndUserManager.getLastWatchedChannel().then(util.bind(function(transport) {
                        if (transport && transport.assetId) {
                            pickChannel(transport.assetId);
                        } else {
                            //to pick the first one for default
                            this.onNowChannelList.getDatasource().getRange(0, 1).then(util.bind(function(channels) {
                                this.playChannel(channels[0]);
                            }, this));
                        }
                    }, this));
                } else {
                    var ds = grid.getDatasource();
                    ds.getRange(0, ds.getFetchedCount()).then(util.bind(function(channels) {
                        if (this.currentPlayingChannel) {
                            var currentId = this.currentPlayingChannel.get("id");
                            for (var i = 0, l = channels.length; i < l; i++) {
                                if (currentId === channels[i].get("id")) {
                                    grid.select(i, 0);
                                    this.playChannel(channels[i]);
                                    return;
                                }
                            }
                        }
                        this.playChannel(channels[0]);
                    }, this));
                }
                this.loadedDataSource = true;
                focusManager.focus(grid);
                this.__showUIRef = util.bind(this.showUI, this);
                grid.addEventListener(evtType.SELECTION_CHANGED, this.__showUIRef);
            }, this)).done();
        },

        setupArrowKeys: function(totalCount) {
            if (!totalCount) {
                return;
            }

            if (totalCount === 1) {
                this.arrowUp.hide();
                this.arrowDown.hide();
                return;
            }

            this.arrowUp.show();
            this.arrowDown.show();

            var position = totalCount < 5 ? totalCount : 5;
            this.arrowDown.getRoot().getHTMLElement().style.top = 640 - (5 - position) * 115 + "px";
        },

        setupPlayback: function() {
            this.__dismissControlsRef = util.bind(this._dismissControls, this);
            mediator.subscribe(VideoPlaybackControlsEvent.DismissControls, this.__dismissControlsRef);
            vLoading.open();
        },

        closeLoadingCallback: function(){
            vLoading.close();
        },

        _dismissControls: function(data) {
            //to fake a live streaming video, only for demo
            /*
            if (this.__currentVideoUrl) {
                this.__playByUrl(this.__currentVideoUrl);
            }
            */
        },

        __playByUrl: function(url) {
            var items = [new PlaylistItem({
                url: url
            })],
                playlist = new Playlist({
                    items: items
                });
            this.__videoManager = new VideoManager();
            this.__videoManager.setVideoLoadedCallback(util.bind(this.closeLoadingCallback, this));
            this.__videoManager.setPlaylist(playlist);
            this.__videoManager.playPlaylistItem(items[0]);
        },

        playChannel: function(channel) {
            vLoading.close();
            if (sEndUserManager.getLoginStatus()) {
                sEndUserManager.addLastWatchedChannelById(channel.get("id"));
            }

            sLinearManager.getChannelStream(channel).then(util.bind(function(stream) {
                mediator.publish(VideoControlsStatusEvent.DismissSelected);
                this.__currentVideoUrl = stream.get("url");
                this.__playByUrl(this.__currentVideoUrl);

                this.currentPlayingChannel = channel;
                setTimeout(util.bind(function() {
                    this.onNowChannelList.getChildren()[0].getChildren()[0].getChildren()[0].addClass("playing");
                }, this), 100);
            }, this)).fail(function(reason) {
                console.warn("[OnNow] failed to get the stream for " + channel.get("title") + ": " + reason);
            }).done();
        },

        __exitPopupUpdate: function(flag) {
            this.hasExitPopup = flag;
            if (!flag && this.status === "show") {
                //restart the timer
                this.showUI();
            }
        },

        __hasPopup: function() {
            if (this.hasExitPopup || this.hasCategoryPopup) {
                return true;
            }
            return false;
        },

        showUI: function() {
            clearTimeout(this.hideUITimer);
            this.hideUITimer = setTimeout(util.bind(function() {
                this.hideUI();
            }, this), 5000);

            if (this.status && this.status === "hidden") {
                this.onNowChannelListContainer.show();
                this.detailsPanel.show();
                this.footerContainer.show();
                this.status = "show";

                focusManager.focus(this.onNowChannelList);
                return true;
            }
        },

        hideUI: function() {
            if ((!this.status || this.status === "show") && !this.__hasPopup()) {
                this.onNowChannelListContainer.hide();
                this.detailsPanel.hide();
                this.footerContainer.hide();
                this.status = "hidden";

                focusManager.focus(this.onNowView);
            }
        },

        selectCategoryById: function(id) {
            if (this.currentCategoryId && this.currentCategoryId === id) {
                return;
            }

            var gridDatasource;

            if (id === CATEGORY_ALL) {
                this.currentCategoryId = id;
                this.setupGrid(this.totalChannelsNumber, sLinearManager.getChannelsDs());
            } else if (id === CATEGORY_FAVORITES) {
                this.currentCategoryId = id;
                sEndUserManager.getFavoriteChannels().then(util.bind(function(transport) {
                    if (transport) {
                        var channelIds = [];
                        for (var i = 0, l = transport.length; i < l; i++) {
                            if (transport[i].assetId) {
                                channelIds.push(transport[i].assetId);
                            }
                        }
                        gridDatasource = sLinearManager.getChannelsDsByIds(channelIds);
                    } else {
                        gridDatasource = sLinearManager.getChannelsDs();
                    }

                    this.setupGrid(transport.length, gridDatasource);
                }, this));
            }
        },

        onKey: function(evt) {
            if (this.showUI()) {
                return;
            }
            switch (evt.id) {
                case vKey.YELLOW.id:
                    if (this.__hasPopup()) {
                        return;
                    }
                    sEndUserManager.getFavoriteChannels().then(util.bind(function(transport) {
                        var sortArray, dialog;
                        if (transport.length) {
                            sortArray = CATEGORT_ARRAY_FAV;
                        } else {
                            sortArray = CATEGORT_ARRAY;
                        }

                        dialog = new TextSelectionListDialog({
                            items: sortArray,
                            parent: this.getView()
                        });

                        this.hasCategoryPopup = true;

                        dialog.addEventListener(TextSelectionListDialog.EVT_SELECTED, util.bind(function(index) {
                            dialog.close();
                            this.showUI();
                            this.selectCategoryById(sortArray[index].id);
                        }, this));

                        dialog.addEventListener(evtType.CLOSE, util.bind(function(evt) {
                            this.hasCategoryPopup = false;
                        }, this));
                    }, this));
                    break;
                default:
                    return true;
            }
            return false;
        },

        reset: function() {
            vLoading.close();
            clearTimeout(this.hideUITimer);
            sAppRoot.getView().removeClass("fullscreen-video-mode");
            this.getView().removeEventListener(evtType.KEY, this.__onKeyRef);
            this.onNowChannelList.removeEventListener(evtType.SELECTION_CHANGED, this.__showUIRef);
            this.status = "hidden";

            mediator.publish(VideoControlsStatusEvent.DismissSelected);
            mediator.unsubscribe(VideoPlaybackControlsEvent.DismissControls, this.__dismissControlsRef);
            mediator.unsubscribe("exitPopup", this.__exitPopupUpdateRef);
            this.__videoManager.deinit();
        }
    });
});

/**
 * Program detail popup view's template
 * @name programDetailPopup
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/programDetailPopup
 */
define("tvedemo/tmpl/programDetailPopup", [
    "xdk-ax/Container",
    "xdk-ui-basic/Button",
    "xdk-ui-basic/Label",
    "xdk-ui-basic/Layout"
], function (
    Container,
    Button,
    Label,
    Layout
    ) {

    "use strict";

    // @TODO: If this is reintroduced we need to sort out the language strings.

    return function () {
        return {
            klass: Container,
            css: "popup-controller",
            nextLeft: null,
            nextRight: null,
            nextUp: null,
            nextDown: null,
            children: [{
                klass: Container,
                id: "popupRootView",
                css: "program-detail-popup",
                children: [{
                    klass: Container,
                    id: "popupBody",
                    css: "popup-body",
                    children: [{
                        klass: Label,
                        id: "description",
                        css: "description"
                    }, {
                    klass: Layout,
                    id: "buttonLayout",
                    css: "button-container",
                    forwardFocus: true,
                    children: [{
                            klass: Button,
                            id: "tuneInButton",
                            css: "button",
                            text: "Tune in"
                        }, {
                            klass: Button,
                            id: "restartFromVodButton",
                            css: "button",
                            text: "Restart from VOD"
                        },
                        {
                            klass: Button,
                            id: "addToWatchlistButton",
                            css: "button",
                            text: "Add to watchlist"
                        },
                        {
                            klass: Button,
                            id: "goToDetailsButton",
                            css: "button",
                            text: "Go to details"
                        }]
                    }]
                }]
            }]
        };
    };
});
/**
 * The program detail popup view's controller. Setup the program details info.
 * @name ProgramDetailPopup
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/ProgramDetailPopup
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/ProgramDetailPopup", [
    "xdk-base/ax", "tvedemo/ctrl/RoutableController", "xdk-ax/mvc/view",
    "tvedemo/tmpl/programDetailPopup", "xdk-base/device/vKey", "xdk-ax/evt/type",
    "xdk-ax/focusManager", "xdk-base/promise", "xdk-base/util",
    "tvedemo/mgr/sHistoryManager", "tve/model/Asset", "tvedemo/wgt/AlertDialog",
    "tvedemo/wgt/Loading", "tve/mgr/sLinearManager", "tvedemo/helper/dialogHelper",
    "xdk-ax/mediator",
    "storm/mgr/sLanguageManager"
], function (ax, Controller, view,
    tmpl, vKey, evtType,
    focusManager, promise, util,
    historyManager, Asset, AlertDialog,
    loading, sLinearManager, dialogHelper,
    mediator,
    sLanguageManager
    ) {

    "use strict";

    var DATE_FORMAT = sLanguageManager.getString("ui.format.onAirTime"),
        THUMBNAIL_PLACE_HOLDER = "img/popup_program_guide_show/show_placeholder.png",
        LOGO_PLACE_HOLDER = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAA1JREFUCNdjYGBgMAYAADgANNF/knAAAAAASUVORK5CYII=";

    return ax.klass.create(Controller, {
        getDefaultState: function () {
            return {
                channelId: null,
                programId: null
            };
        }
    }, {

        //The Program model.
        _asset: null,

        //The Channel model.
        _channel: null,

        _thumbnail: null,
        _title: null,
        _onAirTime: null,
        _logo: null,
        _pgIndicator: null,
        _onNowIndicator: null,
        _description: null,

        _tuneInButton: null,
        _restartFromVodButton: null,
        _addToWatchlistButton: null,
        _goToDetailsButton: null,


        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },
        setup: function (context) {
            var self = this,
                currentView = this.getView(),
                buttonLayout = currentView.find("buttonLayout"),
                channelId = context.channelId,
                programId = context.programId,
                channelPromise,
                programPromise;


            this._thumbnail = currentView.find("thumbnail");
            this._title = currentView.find("title");
            this._onNowIndicator = currentView.find("onNowIndicator");
            this._onAirTime = currentView.find("onAirTime");
            this._pgIndicator = currentView.find("pgIndicator");
            this._logo = currentView.find("logo");
            this._description = currentView.find("description");
            this._tuneInButton = currentView.find("tuneInButton");
            this._restartFromVodButton = currentView.find("restartFromVodButton");
            this._addToWatchlistButton = currentView.find("addToWatchlistButton");
            this._goToDetailsButton = currentView.find("goToDetailsButton");

            this.__onClick = util.bind(this._onClick, this);
            buttonLayout.addEventListener(evtType.CLICK, this.__onClick);

            this.__onKeyRef = util.bind(this._onKey, this);
            currentView.addEventListener(evtType.KEY, this.__onKeyRef);

            //skip on history back, no need to re get the data
            if (!context.historyBack) {
                if (!channelId || !programId) {
                    currentView.find("popupRootView").hide();

                    var dialog = dialogHelper.error({
                        title: "Sorry",
                        reason: "Cannot get the program information.<br />\nPlease try again later.",
                        buttonText: "Back",
                        parent: this.getView()
                    });

                    dialog.addEventListener(evtType.CLOSE, function (evt) {
                        historyManager.back();
                    });

                    return;
                }

                this.updateState({
                    channelId: channelId,
                    programId: programId
                });

                channelPromise = sLinearManager.getChannelById(channelId);
                programPromise = sLinearManager.getProgramById(programId);

                buttonLayout.hide();

                // get complete channel and program object
                context.setupPending = promise.all([channelPromise, programPromise]).then(function (result) {
                    self._channel = result[0];
                    self._asset = result[1];

                    buttonLayout.show();
                    focusManager.focus(buttonLayout);
                }).fail(function (reason) {
                    self.getView().hide();

                    var dialog = dialogHelper.error({
                        title: "Sorry",
                        reason: "Cannot get the program information.<br />\nPlease try again later.",
                        buttonText: "Back",
                        parent: self.getView()
                    });

                    dialog.addEventListener(evtType.CLOSE, function (evt) {
                        // let the dialog close first
                        ax.util.delay(0.2).then(function () {
                            historyManager.back();
                        });
                    });
                    return;
                });
            } else {
                focusManager.focus(buttonLayout);
            }

        },

        goToOnNow: function () {
            mediator.publish("navigate", {
                path: "OnNow",
                state: {
                    channelId: this._channel.get("id")
                }
            });
        },

        _onClick: function (evt) {
            var target = evt.target;

            if (target === this._tuneInButton) {

            } else if (target === this._restartFromVodButton) {

            } else if (target === this._addToWatchlistButton) {

            } else if (target === this._goToDetailsButton) {

            }
        },


        _onKey: function (evt) {
            switch (evt.id) {
            case vKey.BACK.id:
            case vKey.OK.id:
            case vKey.EXIT.id:
                // preserve default action
                return true;
            default:
                // prevent default action
                // as this is a popup controller, the event shouldn't be handled by the parent controller
                return false;
            }
        },

        reset: function () {
            this.getView().find("buttonLayout").removeEventListener(evtType.CLICK, this.__onClick, this);
        }

    });
});

define('css!tve/ext/ui/programguide/css/row',[],function(){});
/**
 * ProgramGuideRow is a widget that shows a list of programs of a channel.
 * If CSS transition is desired for the slider, developer may add transition rule to the *wgt-programguide-row-listing-slider* class.
 * e.g.
 * <code>
 *      transition: left 0.5s;
 *      -webkit-transition: left 0.5s;
 * </code>
 *
 * @name Row
 * @memberof tve/ext/ui
 * @class tve/ext/ui/programguide/Row
 */
define("tve/ext/ui/programguide/Row", ["xdk-base/class", "xdk-ax/Container", "xdk-ax/focusManager",
    "xdk-ax/evt/type", "xdk-base/device/vKey", "xdk-ui-basic/Button", "xdk-ui-basic/Image",
    "xdk-ui-basic/Layout", "xdk-base/util", "css!./css/row"
], function (klass, Container, focusMgr,
    eventType, vKey, Button, Image,
    Layout, util) {

    var MS_IN_ONE_SECOND = 1000,
        MS_IN_ONE_MINUTE = 60000,
        DEFAULT_WINDOW_SIZE = 120,
        DEFAULT_VISIBLE_WIDTH = 600,
        DEFAULT_BORDER_WIDTH = 0,
        DEFAULT_MARGIN = 2,
        DEFAULT_SLIDER_WIDTH = 99,
        INVISIBLE_COMPONENTS_DELAY = 0.5;

    var calculateCellWidth = function (startTime, endTime, pixelPerMinute) {
        return (endTime - startTime) / MS_IN_ONE_MINUTE * pixelPerMinute; // 60000 = 1 minute (60000 ms)
    };

    return klass.create(Container, {}, {
        _logo: null,
        _listing: null,
        _slider: null,
        _sliderWidth: 0,
        _visibleWidth: 0,
        _minLeft: 0,
        _currentLeft: 0,

        //Pixel per minute.
        _ppm: 0,
        _programs: [],
        _startTime: 0,
        _endTime: 0,
        _selectionTime: 0, // timestamp of the current selected program
        _programClickedCallback: null,
        _programFocusedCallback: null,

        //The number of programs that have been trimmed while setting up the slider.
        //A program will only be trimmed if it has no overlay with the timeframe.
        _programOffset: 0,


        /**
         * Overrides parent init() function.
         * @method
         * @protected
         * @memberof tve/ext/ui/programguide/Row#
         */
        init: function (opts) {
            this._super(opts);
            opts.borderWidth = DEFAULT_BORDER_WIDTH;
            opts.horizontalMargin = DEFAULT_MARGIN;
            this._visibleWidth = opts.scrollPaneWidth || DEFAULT_VISIBLE_WIDTH;
            this._startTime = opts.startTime;
            this._endTime = opts.endTime;
            this._windowStart = opts.windowStart;
            this._selectionTime = opts.selectionTime;
            var borderWidth = opts.borderWidth,
                horizontalMargin = opts.horizontalMargin,
                cellWidthDiff = borderWidth * 2 + horizontalMargin;

            this.windowSize = opts.windowSize || DEFAULT_WINDOW_SIZE;
            this._ppm = this._visibleWidth / this.windowSize;
            this._channel = opts.channel;
            this._programs = opts.programs;

            this.addClass("wgt-programguide-row");

            var headerContainer = new Container({
                css: "wgt-programguide-row-header-container",
                parent: this
            }),
                listingContainer = new Container({
                    css: "wgt-programguide-row-listing-container",
                    parent: this
                }),
                header;

            if (opts.displayProgramGuideRowHeaderStgy) {
                header = opts.displayProgramGuideRowHeaderStgy(this._channel);
            }

            if (opts.displayProgramItemStgy) {
                this._displayProgramItemStgy = opts.displayProgramItemStgy;
            }

            listingContainer.getRoot().css("width", this._visibleWidth + "px");
            headerContainer.attach(header);

            this.setupSlider(listingContainer, cellWidthDiff);
        },

        /**
         * Set up the slider based on the programs. The slider should be ready before calling this function.
         * @method setupSlider
         * @param {Object} sliderParent the DOM container of widget.
         * @param {Integer} cellWidthDiff the difference basic cell and cell with border and margin.
         * @memberof tve/ext/ui/programguide/Row#
         * @public
         */
        setupSlider: function (sliderParent, cellWidthDiff) {
            this._slider = new Layout({
                css: "wgt-programguide-row-listing-slider",
                parent: sliderParent,
                width: DEFAULT_SLIDER_WIDTH,
                autoNavigation: true,
                forwardFocus: true
            });
            this.setOption("forwardFocus", this._slider);

            var cellWidth,
                sliderWidth = 0,
                self = this;

            // create program layout for each program that starts before the absolute end time

            var cell = [],
                insertBefore = [],
                insertAfter = [],

                windowEnd = this._windowStart + MS_IN_ONE_MINUTE * this.windowSize,

                displayProgramItem = function (i, left, width, placePrepend) {
                    if (self._displayProgramItemStgy) {
                        cell[i] = self._displayProgramItemStgy(self._programs[i].data);
                    }

                    var root = cell[i].getRoot();
                    root.css("left", left + "px");
                    root.css("width", width + "px");

                    if (placePrepend) {
                        slider.attach(cell[i], Container.PLACE_PREPEND);
                    } else {
                        slider.attach(cell[i]);
                    }
                };

            for (var i = 0, length = this._programs.length, endTime = this._startTime; i < length && endTime < this._endTime; i++) {
                var pStartTime = this._programs[i].startTime,
                    pEndTime = this._programs[i].endTime,
                    slider = this._slider;

                if (pStartTime < this._startTime) {
                    if (pEndTime <= this._startTime) {
                        // the entire program does not overlap the timeframe, ignore it
                        this._programOffset++;
                        continue;
                    }

                    // trim the partition that is before this._startTime
                    pStartTime = this._startTime;
                }

                // set the right boundary
                if (pEndTime > this._endTime) {
                    pEndTime = this._endTime;
                }
                endTime = pEndTime;
                cellWidth = calculateCellWidth(pStartTime, pEndTime, this._ppm);

                //when the program items are between the window start and window end, we create immediately,
                //when the program items are not between the window start and window end, we save them and create them later.
                if (pEndTime <= this._windowStart) {
                    insertBefore.push(util.bind(displayProgramItem, null, i, sliderWidth, cellWidth - cellWidthDiff, true));
                } else if (pStartTime >= windowEnd) {
                    insertAfter.push(util.bind(displayProgramItem, null, i, sliderWidth, cellWidth - cellWidthDiff));
                } else {
                    displayProgramItem(i, sliderWidth, cellWidth - cellWidthDiff);
                }

                sliderWidth += cellWidth;
            }

            this.onReady = util.delay(INVISIBLE_COMPONENTS_DELAY).then(util.bind(function () {
                var i, len;

                for (i = insertBefore.length - 1; i > -1; i--) {
                    insertBefore[i](true);
                }
                for (i = 0, len = insertAfter.length; i < len; i++) {
                    insertAfter[i]();
                }

                if (this._selectionTime) {
                    this.setSelectionTime(this._selectionTime);
                    return;
                }

                this.setSelectionTime(this._windowStart);
            }, this));

            this._sliderWidth = sliderWidth;
            this._minLeft = -(this._sliderWidth - this._visibleWidth);
            this._slider.getRoot().css("width", sliderWidth + "px");
        },

        /**
         * Update the window position to the target time.
         * @method updateTime
         * @public
         * @param {Integer} targetTime The target time of the window.
         * @memberof tve/ext/ui/programguide/Row#
         */
        updateTime: function (targetTime) {
            var targetLeft = -this.__timeToLeft(targetTime),
                domRoot = this._slider.getRoot();

            if (domRoot) {
                if (targetLeft > 0) {
                    this._currentLeft = 0;
                } else {
                    this._currentLeft = Math.max(targetLeft, this._minLeft);
                }
                domRoot.css("left", this._currentLeft + "px");
            }
        },

        /**
         * Get the current selected(focused) program.
         * @method getSelection
         * @public
         * @memberof tve/ext/ui/programguide/Row#
         */
        getSelection: function () {
            return this.__getSelectedProgram();
        },

        /**
         * Get the current selection time.
         * The selection time equals Math.max(selected program start time, window start time).
         * @method getSelectionTime
         * @public
         * @memberof tve/ext/ui/programguide/Row#
         */
        getSelectionTime: function () {
            var selectionTime,
                currentStartTime;

            currentStartTime = this.__leftToTime(-this._currentLeft); // convert the window position to timestamp

            selectionTime = this.__getSelectedProgram().startTime;

            return Math.max(selectionTime, currentStartTime);
        },

        /**
         * Set the selection time.
         * @method setSelectionTime
         * @public
         * @param {Integer} time The target timestamp
         * @memberof tve/ext/ui/programguide/Row#
         */
        setSelectionTime: function (time) {
            this._selectionTime = time;
            this._slider.setOption("forwardFocus", this._searchChildByTime(time));
        },

        /**
         * Get the channel id that this row associates to.
         * @method getChannel
         * @public
         * @returns {Object} the channel object
         * @memberof tve/ext/ui/programguide/Row#
         */
        getChannel: function () {
            return this._channel;
        },

        /**
         * Search for the button which the corresponding program interval contains the time specified.
         * @method _searchChildByTime
         * @protected
         * @param {Integer} time The target timestamp
         * @returns {Object} the child button
         * @memberof tve/ext/ui/programguide/Row#
         */
        _searchChildByTime: function (time) {
            for (var i = this._programOffset, len = this._programs.length; i < len; i++) {
                var program = this._programs[i];
                if (program.startTime <= time && time < program.endTime) {
                    return this._slider.getChildren()[i - this._programOffset]; // match found, return the corresponding button
                }
            }
        },

        /**
         * Select a button which the corresponding program interval contains the time specified.
         * @method selectByTime
         * @public
         * @param {Integer} time The target timestamp
         * @memberof tve/ext/ui/programguide/Row#
         */
        selectByTime: function (time) {
            this._selectionTime = time;

            for (var i = this._programOffset, len = this._programs.length; i < len; i++) {
                var program = this._programs[i];
                if (program.startTime <= time && time < program.endTime) {
                    focusMgr.focus(this._slider.getChildren()[i - this._programOffset]);
                    return; // only one valid focus exist, avoid unnecessary iteration
                }
            }
        },

        /**
         * Get the program that corresponds to the selected(focused) button.
         * @method __getSelectedProgram
         * @private
         * @memberof tve/ext/ui/programguide/Row#
         */
        __getSelectedProgram: function () {
            var children = this._slider.getChildren();
            for (var i = 0, len = this._programs.length; i < len; i++) {
                if (focusMgr.isCompFocused(children[i])) {
                    return this._programs[i + this._programOffset];
                }
            }
            return null;
        },

        /**
         * Convert the time to a css left value, which can be used to determine the window position.
         * @method __timeToLeft
         * @private
         * @param {Integer} time The target timestamp
         * @memberof tve/ext/ui/programguide/Row#
         */
        __timeToLeft: function (time) {
            return (time - this._startTime) / MS_IN_ONE_MINUTE * this._ppm;
        },

        /**
         * Convert the css left value to timestamp, which can be used to determine the time representation of the window position.
         * @method __leftToTime
         * @private
         * @param {Integer} left The left position
         * @memberof tve/ext/ui/programguide/Row#
         */
        __leftToTime: function (left) {
            return Math.round(left / this._ppm * MS_IN_ONE_MINUTE) + this._startTime;
        }
    });
});

define('css!tve/ext/ui/programguide/css/timeline',[],function(){});
/**
 * ProgramGuideTimeline is a widget that shows a list of time labels to indicate the viewing time.
 * If CSS transition is desired for the slider, developer may add transition rule to the *wgt-timeline-slider* class.
 * e.g.
 * <code>
 *      transition: left 0.5s;
 *      -webkit-transition: left 0.5s;
 * </code>
 * @name Timeline
 * @memberof tve/ext/ui/programguide
 * @class tve/ext/ui/programguide/Timeline
 * @param {Object} opts The options object
 */
define("tve/ext/ui/programguide/Timeline", ["xdk-base/class", "xdk-ax/Container", "xdk-ui-basic/Button",
        "xdk-ui-basic/Label", "xdk-ui-basic/Layout", "xdk-base/util", "tvedemo/helper/sMoment", "css!./css/timeline"
    ],
    function (klass, Container, Button,
        Label, Layout, util, moment) {

        var MS_IN_ONE_MINUTE = 60000,
            DEFAULT_TIMESCALE = 30,
            DEFAULT_WINDOW_SIZE = 120,
            DEFAULT_VISIBLE_WIDTH = 600,
            DEFAULT_UPDATE_INTERVAL = 60000,
            DEFAULT_DATE_FORMAT = "D-MMM",
            DEFAULT_TIME_FORMAT = "hh:mm a";

        return klass.create(Container, {}, {
            _slider: null,
            _sliderWidth: 0,
            _visibleWidth: 0,
            _minLeft: 0,
            _currentLeft: 0,

            //Pixel per minute.
            _ppm: 0,
            _dateFormat: "",
            _timeFormat: "",
            _dateLabel: null,
            _labels: [],
            _marker: null,
            _markerTimer: null,
            _startTime: 0,
            _endTime: 0,


            /**
             * Overrides parent init() function.
             * @method
             * @protected
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            init: function (opts) {
                opts.focusable = false;
                opts.forwardFocus = false;
                this._super(opts);

                this._visibleWidth = opts.scrollPaneWidth || DEFAULT_VISIBLE_WIDTH;
                this._startTime = opts.startTime;
                this._endTime = opts.endTime;
                this._dateFormat = opts.dateFormat || DEFAULT_DATE_FORMAT;
                this._timeFormat = opts.timeFormat || DEFAULT_TIME_FORMAT;

                var windowSize = opts.windowSize || DEFAULT_WINDOW_SIZE,
                    sliderContainer;

                this._ppm = this._visibleWidth / windowSize;
                this._timescale = opts.timescale || DEFAULT_TIMESCALE;
                this.addClass("wgt-programguide-timeline");

                this._dateLabel = new Label({
                    css: "wgt-programguide-timeline-date",
                    parent: this
                });

                sliderContainer = new Container({
                    css: "wgt-programguide-timeline-slider-container",
                    parent: this
                });
                sliderContainer.getRoot().css("width", this._visibleWidth + "px");
                this._setupSlider(sliderContainer, opts.programs);

                this._marker = new Label({
                    css: "wgt-programguide-timeline-marker",
                    parent: this._slider,
                    focusable: false
                });

                this._marker.hide();
            },

            /**
             * Update the window position to the target time.
             * @method updateTime
             * @public
             * @param {Integer} targetTime The target time of the window.
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            updateTime: function (targetTime) {
                var targetLeft = -this.__timeToLeft(targetTime),
                    domRoot = this._slider.getRoot();

                if (domRoot) {
                    if (targetLeft > 0) {
                        this._currentLeft = 0;
                    } else {
                        this._currentLeft = Math.max(targetLeft, this._minLeft);
                    }
                    domRoot.css("left", this._currentLeft + "px");
                }

                this._dateLabel.setText(moment(targetTime).format(this._dateFormat));
            },

            /**
             * Show the NOW indicator and start the auto update of it.
             * @method startMarker
             * @public
             * @param {Integer} interval The update interval in ms
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            startMarker: function (interval) {
                this._marker.show();

                if (!interval) {
                    interval = DEFAULT_UPDATE_INTERVAL;
                }

                var timerFunction = util.bind(function () {
                    this._marker.getRoot().css("left", this.__timeToLeft(new Date().getTime()) + "px");
                }, this);

                timerFunction(); // call once first

                if (!this._markerTimer) {
                    this._markerTimer = setInterval(timerFunction, interval);
                }
            },

            /**
             * Hide the NOW indicator and stop the auto update of it.
             * @method stopMarker
             * @public
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            stopMarker: function () {
                this._marker.hide();
                clearInterval(this._markerTimer);
                this._markerTimer = null;
            },

            /**
             * Set up the slider based on the programs. The slider should be ready before calling this function.
             * @method _setupSlider
             * @protected
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            _setupSlider: function (sliderParent, programs) {
                this._slider = new Layout({
                    css: "wgt-programguide-timeline-slider",
                    parent: sliderParent,
                    autoNavigation: true,
                    forwardFocus: true
                });
                this.setOption("forwardFocus", this._slider);

                var sliderWidth = 0,
                    cellWidth = this._timescale * this._ppm,
                    time = this._startTime,
                    momentTime = moment(time),
                    htmlString = "",
                    text,
                    attribute = {},
                    timescaleInMinute = this._timescale * MS_IN_ONE_MINUTE;

                attribute.width = "width: " + cellWidth + "px;";

                for (var i = 0; time < this._endTime; i++) {
                    if (i === 0) {
                        attribute.position = "";
                    } else {
                        attribute.position = "position: absolute;";
                    }

                    attribute.left = "left: " + sliderWidth + "px;";
                    text = momentTime.format(this._timeFormat);

                    htmlString += '<div class="wgt-label wgt-programguide-timeline-time" style="clear: left; float: left;' + attribute.width + attribute.left + attribute.position + '">' + text + "</div>";

                    sliderWidth += cellWidth;
                    time += timescaleInMinute;
                    momentTime.add("m", this._timescale);
                }

                this._slider.getRoot().setInnerHTML(htmlString);

                this._sliderWidth = (this._endTime - this._startTime) / MS_IN_ONE_MINUTE * this._ppm; // not using cellWidth as we may have 12.5 cells
                this._minLeft = -(this._sliderWidth - this._visibleWidth);
                this._slider.getRoot().css("width", sliderWidth + "px");
            },

            /**
             * Convert the time to a css left value, which can be used to determine the window position.
             * @method __timeToLeft
             * @private
             * @param {Integer} time The target timestamp
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            __timeToLeft: function (time) {
                return (time - this._startTime) / MS_IN_ONE_MINUTE * this._ppm;
            },

            /**
             * Convert the css left value to timestamp, which can be used to determine the time representation of the window position.
             * @method __leftToTime
             * @private
             * @param {Integer} left The left position
             * @memberof tve/ext/ui/programguide/Timeline#
             */
            __leftToTime: function (left) {
                return Math.round(left / this._ppm * MS_IN_ONE_MINUTE) + this._startTime;
            }
        });
    });


define('css!storm/programguide/css/structure',[],function(){});
/**
 * ProgramGuide is a channel-by-time widget dedicated for EPG presentation.
 * This widget consists of one _programGuideTimeline_ and one of more _EpgRow_. The programGuideTimeline is responsible for displaying the time labels and the NOW marker, and each ProgramGuideRow is responsible for showing the programs of a particular channel.
 * A viewing window isintroduced so that only a portion of the programs are visible at any time. The viewing window can move horizontally based on the time given, from _epgStart_ to _epgEnd_.
 *
 * ProgramGuide is designed to be customizable in a few ways:
 *  - data set by time
 *  - starting position (in terms of time)
 *  - scrollPaneWidth: the width of the displayed tv listing part in px.
 *  - windowSize:      the number of minutes to display in the widget.
 *  - timescale:       the timescale to display
 *  - rows:            number of channels shown at a time, same as the configuration in grid.
 * Regarding the way to customize, please see the _init_ and _show_ function.
 *
 * If you find difficulties on getting the ProgramGuide visible on screen, try to set the height to the elements (eg. _.wgt-epgrow-listing-container_, .wgt-programguide-timeline-slider-container).
 *
 * @memberof tve/ext/ui
 * @class tve/ext/ui/ProgramGuide
 * @extends ax/ext/ui/Grid
 */
define("storm/ProgramGuide", ["xdk-base/class", "xdk-base/core", "xdk-ui-grid/Grid", "xdk-ax/Component", "xdk-ax/Container",
        "xdk-ax/data/LocalDatasource", "xdk-ax/focusManager", "xdk-ax/evt/type", "xdk-base/device/vKey", "xdk-ui-grid/gridStgy", "xdk-ui-grid/boundedGridStgy",
        "xdk-ui-basic/Layout", "xdk-ui-basic/Button", "xdk-ui-basic/Label", "xdk-base/promise", "xdk-base/util", "tve/ext/ui/programguide/Row",
        "tve/ext/ui/programguide/Timeline", "tvedemo/helper/sMoment", 
        "xdk-ax/focusManager",
        "css!./programguide/css/structure"

    ],
    function (klass, core, Grid, Component, Container, Ds, focusManager, evtType, vKey, gridStgy, boundedGridStgy, Layout, Button, Label,
        promise, util, ProgramGuideRow, ProgramGuideTimeline, moment,
        focusManager) {

        var DEFAULT_ROWS = 5,
            FIXED_COLS = 1,
            DEFAULT_TIMESCALE = 30,
            DEFAULT_WINDOW_SIZE = 120,
            DEAFULT_SCROLL_PANE_WIDTH = 600,
            MS_IN_ONE_SECOND = 1000,
            MS_IN_ONE_MINUTE = 60000,
            DIR_FORWARD = true,
            DIR_BACKWARD = false,
            TOP = 0,
            RIGHT = 1,
            BOTTOM = 2,
            LEFT = 3;

        return klass.create(Grid, {}, {

            /**
             * An array holding all the visible EpgRows.
             * @member _epgRows
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _epgRows: [],

            /**
             * A ProgramGuideTimeline that responsible to display the time labels.
             * @member _programGuideTimeline
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _programGuideTimeline: null,

            /**
             * An array for the extended TVListing objects, that contains the channel object.
             * @member _tvListings
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _tvListings: [],

            /**
             * The timestamp of where the time window starts.
             * @member _windowStart
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _windowStart: 0,

            /**
             * The timestamp of where the time window ends.
             * @member _windowEnd
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _windowEnd: 0,

            /**
             * The number of minutes that should be visible to the user.
             * @member _windowSize
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _windowSize: 0,

            /**
             * The width of the window in px.
             * @member _scrollPaneWidth
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _scrollPaneWidth: 0,

            /**
             * Maximum timestamp of the window position (epgEnd - windowSize).
             * @member _upperBound
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _upperBound: 0,

            /**
             * Minimum timestamp of the window position (epgStart).
             * @member _lowerBound
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _lowerBound: 0,

            /**
             * Current selected cell in the selected ProgramGuideRow.
             * @member _selectionInRow
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _selectionInRow: null,

            /**
             * Current selection time in the selected ProgramGuideRow.
             * This is the time of when  max(the selected cell's start time, the viewing window start time)
             * @member _selectionTime
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _selectionTime: 0,

            /**
             * Last selection time in the selected ProgramGuideRow.
             * @member _lastFocusedProgramStart
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _lastFocusedProgramStart: 0,

            /**
             * The date format.
             * @member _dateFormat
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _dateFormat: null,

            /**
             * The time format.
             * @member _timeFormat
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _timeFormat: null,

            /**
             * The real grid container.
             * @member _container
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _container: null,

            /**
             * The arrows.
             * @member _arrows
             * @memberof tve/ext/ui/ProgramGuide#
             * @protected
             */
            _arrows: [],

            /**
             * Overrides parent init() function.
             * @method init
             * @protected
             * @param {Object} [opts] Options
             * @param {Number} [opts.windowSize] The number of minutes that the viewing window can display (Default 120)
             * @param {Number} [opts.scrollPaneWidth] The number of pixels the viewing window actually occupy (Default 600)
             * @memberof tve/ext/ui/ProgramGuide#
             */
            init: function (opts) {
                opts = opts || {};
                opts.rows = opts.rows || DEFAULT_ROWS;
                opts.cols = FIXED_COLS;
                opts.forwardFocus = true;

                this._super(opts);

                this._windowSize = opts.windowSize || DEFAULT_WINDOW_SIZE;
                this._scrollPaneWidth = opts.scrollPaneWidth || DEAFULT_SCROLL_PANE_WIDTH;
                this._timescale = opts.timescale || DEFAULT_TIMESCALE;
                this._container = this.getChildren()[0];
                this._initArrows();

                var isVerticalAlign = false,
                    frontBoundary = 0,
                    endBoundary = 0;

                this.setPrereadyStgy(gridStgy.BASIC_PREREADY_STGY);
                this.setCheckScrollableStgy(gridStgy.BASIC_CHECK_SCROLLABLE_STGY);
                this.setCheckSelectableStgy(util.bind(boundedGridStgy.SCROLL_BOUNDARY_CHECK_SELECTABLE_STGY, this, frontBoundary, endBoundary));
                this.setDataMappingStgy(gridStgy.BASIC_DATA_MAPPING_STGY);

                this.setScrollEntranceStgy(util.bind(this._scrollEntranceStgy, this, isVerticalAlign));

                this.setScrollShiftStgy(gridStgy.BASIC_SCROLL_SHIFT_STGY);
                this.setScrollExitStgy(gridStgy.BASIC_SCROLL_EXIT_STGY);

                this.setOnUpdateStgy(gridStgy.BASIC_ONUPDATE_STGY);

                this.setKeyNavigationStgy(util.bind(boundedGridStgy.SCROLL_BOUNDARY_KEY_NAVIGATION_STGY, this, isVerticalAlign, frontBoundary, endBoundary));

                // handle the window scroll/program focus while moving left/right
                this.addEventListener(evtType.KEY, util.bind(this._onKey, this), true);
                // handle the focus event of the program buttons from the EpgRows
                this.addEventListener(evtType.FOCUS, util.bind(this._onRowProgramFocused, this));

                this.addClass("wgt-programguide");
                this.getRoot().addEventListener("mousewheel", this.scrollFunc);
            },
            scrollFunc: function(e) {
                var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));

                var event = document.createEvent("Event");
                event.initEvent('keydown', true, true);
                event.target = document;
                event.currentTarget = document;
                event.isSimulated = true;
                if (delta == 1) {
                    // UP
                    event.keyCode = 38;
                    event.keyCodeVal = 38;
                } else {
                    // DOWN
                    event.keyCode = 40;
                    event.keyCodeVal = 40;
                }
                document.dispatchEvent(event);
            },

            /**
             * Set the datasource of the program guide widget
             * @method setProgramGuideDatasource
             * @public
             * @param {Object} programGuideDatasource the data source
             * @memberof tve/ext/ui/ProgramGuide#
             */
            setProgramGuideDatasource: function (programGuideDatasource) {
                this.__programGuideDatasource = programGuideDatasource;
            },

            /**
             * Update the content of the widget.
             * @method updateEpg
             * @public
             * @param {Object} opts.date The date to update.
             * @param {Number} opts.windowPosition Set the window position after the content is loaded.
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _updateEpgRowsLeft: function (opts) {
                var self = this,
                    pgDs = this.__programGuideDatasource,
                    date = opts.date,
                    momentDate = moment(date.getTime()),
                    epgStart = momentDate.hour(0).minute(0).second(0).millisecond(0).unix() * 1000,
                    epgEnd = momentDate.add("d", 1).unix() * 1000;

                this._epgRows = [];

                this._upperBound = epgEnd - this._windowSize * MS_IN_ONE_MINUTE;
                this._lowerBound = epgStart;
                this._selectionTime = this._lowerBound;
                this._lastFocusedProgramStart = 0;
                this._setupTimeLabels();

                this.setWindowPosition(opts.windowPosition ? opts.windowPosition : this._lowerBound);

                return pgDs.getTotalRowNumber().then(function (total) {
                    var data = [],
                        promises = [],
                        ds = new Ds(),
                        injectChannel = function (index) {
                            return pgDs.getRowHeaderData(index).then(function (channel) {
                                data[index] = data[index] || {};
                                data[index].channel = channel;
                            });
                        },
                        injectListing = function (index) {
                            return pgDs.getProgramGuideCellData(index, date).then(function (tvListing) {
                                data[index] = data[index] || {};
                                data[index].tvListing = tvListing;
                            });
                        },
                        tvListingPromise, channelPromise, dataLoader;

                    for (var i = 0; i < total; i++) {
                        channelPromise = injectChannel(i);

                        tvListingPromise = injectListing(i);

                        promises.push(channelPromise);
                        promises.push(tvListingPromise);
                    }

                    return promise.all(promises).then(function () {
                        dataLoader = function (from, size) {
                            var defer = promise.defer();

                            defer.resolve({
                                data: data,
                                total: data.length
                            });

                            return defer.promise;
                        };

                        self._tvListings = data;

                        self.setDisplayStgy(function (dataObj) {
                            var tvListing = dataObj.tvListing,
                                ret = new ProgramGuideRow({
                                    forwardFocus: true,
                                    channel: dataObj.channel,
                                    programs: tvListing,
                                    scrollPaneWidth: self._scrollPaneWidth,
                                    windowSize: self._windowSize,
                                    startTime: epgStart,
                                    endTime: epgEnd,
                                    windowStart: self._windowStart,
                                    selectionTime: self._selectionTime,
                                    displayProgramGuideRowHeaderStgy: self._rowHeaderDisplayStgy || null,
                                    displayProgramItemStgy: self._cellDisplayStgy || null
                                });
                            return ret;
                        });

                        ds.setDataLoader(dataLoader);

                        return self.setDatasource(ds);
                    });
                });
            },

            /**
             * Set the new starting position of the viewing window.
             * The viewing window will be repositioned, and the selection time will be updated.
             * @method setWindowPosition
             * @public
             * @param {Timestamp} windowStart The target UNIX timestamp in ms for the window as a starting position
             * @memberof tve/ext/ui/ProgramGuide#
             */
            setWindowPosition: function (windowStart) {
                var isMoveForward = this._windowStart < windowStart;

                if (windowStart < this._lowerBound) {
                    this._windowStart = this._lowerBound;
                } else if (windowStart > this._upperBound) {
                    this._windowStart = this._upperBound;
                } else {
                    this._windowStart = windowStart;
                }

                this._windowEnd = this._windowStart + (this._windowSize * MS_IN_ONE_MINUTE);

                if (isMoveForward && this._windowStart > this._selectionTime) {
                    this._selectionTime = this._windowStart;
                } else if (!isMoveForward) {
                    this._selectionTime = Math.max(this._lastFocusedProgramStart, this._windowStart);
                }

                this._programGuideTimeline.updateTime(this._windowStart);
                this._updateEpgRowTimeAndLeft();
            },

            /**
             * Show the NOW indicator and start the auto update of it.
             * @method startMarker
             * @public
             * @param {Number} interval The update interval in ms
             * @memberof tve/ext/ui/ProgramGuide#
             */
            startMarker: function (interval) {
                this._programGuideTimeline.startMarker(interval);
            },

            /**
             * Hide the NOW indicator and stop the auto update of it.
             * @method stopMarker
             * @public
             * @memberof tve/ext/ui/ProgramGuide#
             */
            stopMarker: function () {
                this._programGuideTimeline.stopMarker();
            },

            /**
             * Get the selected(focused) program of the selected(focused) ProgramGuideRow.
             * @method getSelectedProgram
             * @public
             * @memberof tve/ext/ui/ProgramGuide#
             */
            getSelectedProgram: function () {
                return this._getSelectedRow().getSelection();
            },

            /**
             * Get the selection states of the grid.
             * Information includes:
             *  - channelId: the id of the current selected(focused) channel
             *  - program: the model object of the current selected(focused) program
             *  - isFirstChannel: equals true if the current selected(focused) program is in the first row
             *  - isLastChannel: equals true if the current selected(focused) program is in the last row
             *  - isFirstProrgam: equals true if the current selected(focused) program is the first program in its row
             *  - isLastProrgam: equals true if the current selected(focused) program is the last program in its row
             *
             * @method getSelectionStates
             * @public
             * @memberof tve/ext/ui/ProgramGuide#
             */
            getSelectionStates: function () {
                var selectedRow = this._getSelectedRow(),
                    selectedProgram = selectedRow.getSelection(),
                    channel = this._tvListings[this._selectedDsIndex].channel,
                    programsInRow = this._tvListings[this._selectedDsIndex].tvListing;

                return {
                    channel: channel,
                    program: selectedProgram,
                    isFirstChannel: channel === this._tvListings[0].channel,
                    isLastChannel: channel === this._tvListings[this._tvListings.length - 1].channel,
                    isFirstProgram: selectedProgram === programsInRow[0],
                    isLastProgram: selectedProgram === programsInRow[programsInRow.length - 1]
                };
            },

            /**
             * Set the display strategy(a function to create the header component by given Channel model object)
             * for the header of each program guide row.
             * @method setRowHeaderDisplayStgy
             * @public
             * @param {Function} the function to create the header component
             * @memberof tve/ext/ui/ProgramGuide#
             */
            setRowHeaderDisplayStgy: function (stgy) {
                this._rowHeaderDisplayStgy = stgy;
            },

            /**
             * Set the display strategy (a function to create the program cell component by given Asset model object)
             * for the program cell of each program guide row.
             * @method setCellDisplayStgy
             * @public
             * @param {Function} the function to create the program guide cell
             * @memberof tve/ext/ui/ProgramGuide#
             */
            setCellDisplayStgy: function (stgy) {
                this._cellDisplayStgy = stgy;
            },

            /**
             * Create the program guide timeline by using ProgramGuideTimeline component
             * @method _setupTimeLabels
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _setupTimeLabels: function () {
                if (this._programGuideTimeline) {
                    this.detach(this._programGuideTimeline);
                }

                this._programGuideTimeline = new ProgramGuideTimeline({
                    scrollPaneWidth: this._scrollPaneWidth,
                    windowSize: this._windowSize,
                    timescale: this._timescale,
                    startTime: this._lowerBound,
                    endTime: this._upperBound + this._windowSize * MS_IN_ONE_MINUTE,
                    dateFormat: this._dateFormat,
                    timeFormat: this._timeFormat
                });

                this.attach(this._programGuideTimeline, Container.PLACE_BEFORE, this._container);
            },

            /**
             * Get the selected row.
             * @method _getSelectedRow
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _getSelectedRow: function () {
                return this._epgRows[this._selectedDsIndex];
            },

            /**
             * Move the window forward or back.
             * @method _moveWindow
             * @protected
             * @param {Boolean} forward move forward or back
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _moveWindow: function (forward) {
                if (forward) {
                    this.setWindowPosition(this._windowStart + this._windowSize * MS_IN_ONE_MINUTE);
                } else {
                    this.setWindowPosition(this._windowStart - this._windowSize * MS_IN_ONE_MINUTE);
                }
            },

            /**
             * Update the window position of each row.
             * @method _updateEpgRowsLeft
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _updateEpgRowsLeft: function () {
                for (var i in this._epgRows) {
                    this._epgRows[i].updateTime(this._windowStart);
                }
            },

            /**
             * Update the default selection of each row.
             * @method _updateEpgRowSelectionTime
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _updateEpgRowSelectionTime: function () {
                for (var i in this._epgRows) {
                    this._epgRows[i].setSelectionTime(this._selectionTime);
                }
            },

            /**
             * Update both the window position and the default selection of each row.
             * @method _updateEpgRowTimeAndLeft
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _updateEpgRowTimeAndLeft: function () {
                for (var i in this._epgRows) {
                    this._epgRows[i].updateTime(this._windowStart);
                    this._epgRows[i].setSelectionTime(this._selectionTime);
                }
            },

            /**
             * The scrolling strategy of this grid.
             * It essentially remove the exiting ProgramGuideRow from _epgRows, and add the entering ProgramGuideRow to _epgRows.
             * @method _scrollEntranceStgy
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _scrollEntranceStgy: function (verticalAlign, container, scrollStep, curState, toState) {
                var newRowsComponents = toState.gridComponents.slice(toState.newRowsStart, toState.newRowsStart + toState.newRowsCount),
                    newRowsCount = toState.newRowsCount,
                    i, j, rowComponent, rowChildren, placement, marker,

                    // REMOVE   
                    children = container.getChildren(),
                    len;

                //only deinit when there are children
                if (children.length > 0) {
                    // scrolling downwards, top rows need to be removed
                    if (scrollStep > 0) {
                        for (i = 0; i < scrollStep; i++) {
                            // throw away child
                            children[i].deinit();
                        }
                    } else {
                        // scrolling upwards, bottoom rows need to be removed
                        len = children.length;
                        for (i = len + scrollStep; i < len && children[i]; i++) {
                            // throw away child
                            children[i].deinit();
                        }
                    }
                }

                // ADD
                var newEpgRow, pendingRowsReady = [];

                for (i = 0; i < newRowsCount; i++) {
                    rowChildren = [];
                    for (j = 0; j < curState.cols; j++) {
                        if (!newRowsComponents[i] || !newRowsComponents[i][j]) {
                            break;
                        }
                        rowChildren.push(newRowsComponents[i][j]);
                    }

                    // add the ProgramGuideRow reference
                    if (newRowsComponents[i]) {
                        newEpgRow = newRowsComponents[i][0]; // always pick col 0 as ProgramGuide is a nx1 grid
                        var isRowExist = false,
                            channelStr = JSON.stringify(newEpgRow.getChannel());

                        for (var rowIndex = 0, rowCount = this._epgRows.length; rowIndex < rowCount; rowIndex++) {
                            if (channelStr === JSON.stringify(this._epgRows[rowIndex].getChannel())) {
                                this._epgRows[rowIndex] = newEpgRow;
                                isRowExist = true;
                                break;
                            }
                        }


                        if (!isRowExist) {
                            if (scrollStep >= 0) {
                                this._epgRows.push(newEpgRow);
                            } else {
                                this._epgRows.unshift(newEpgRow);
                            }
                        }

                        newEpgRow.updateTime(this._windowStart); // update the entering row's time
                    }
                    // finished the reference add

                    rowComponent = new Container({
                        css: verticalAlign ? "wgt-grid-row-v" : "wgt-grid-row-h",
                        children: rowChildren
                    });

                    if (scrollStep < 0 && curState.gridComponents && curState.gridComponents[0]) {
                        placement = Component.PLACE_BEFORE;
                        marker = curState.gridComponents[0][0].getParent();
                    } else {
                        placement = Component.PLACE_APPEND;
                        marker = null;
                    }

                    container.attach(rowComponent, placement, marker);

                    pendingRowsReady.push(newEpgRow.onReady);
                }

                return promise.all(pendingRowsReady);
            },


            /**
             * Attach the arrows to the grid structure, and add the event listener for the visibility control.
             * @method _initArrows
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _initArrows: function () {
                for (var i = 0; i < 4; i++) {
                    this._arrows[i] = new Button({
                        css: "wgt-programguide-arrow"
                    });
                }

                this._arrows[TOP].addClass("top");
                this._arrows[RIGHT].addClass("right");
                this._arrows[BOTTOM].addClass("bottom");
                this._arrows[LEFT].addClass("left");
                this.attach(this._arrows[TOP], Container.PLACE_BEFORE, this._container);
                this.attach(this._arrows[LEFT], Container.PLACE_BEFORE, this._container);
                this.attach(this._arrows[RIGHT], Container.PLACE_APPEND);
                this.attach(this._arrows[BOTTOM], Container.PLACE_APPEND);

                this._arrows[RIGHT].addEventListener(evtType.CLICK, util.bind(function() {
                    this._moveWindow(DIR_FORWARD);
                }, this), true);

                this._arrows[LEFT].addEventListener(evtType.CLICK, util.bind(function() {
                    this._moveWindow(DIR_BACKWARD);
                }, this), true);
                this._arrows[TOP].addEventListener(evtType.CLICK, util.bind(function() {
                    focusManager.focus(this._epgRows[this._firstSlotDsIndex]);
                    var event = document.createEvent("Event");
                    event.initEvent('keydown', true, true);
                    event.target = document;
                    event.currentTarget = document;
                    event.isSimulated = true;
                    event.keyCode = 38;
                    event.keyCodeVal = 38;
                    //Get focus back to epg
                    document.dispatchEvent(event);
                }, this), true);

                this._arrows[BOTTOM].addEventListener(evtType.CLICK, util.bind(function() {
                    focusManager.focus(this._epgRows[this._firstSlotDsIndex+4]);
                    var event = document.createEvent("Event");
                    event.initEvent('keydown', true, true);
                    event.target = document;
                    event.currentTarget = document;
                    event.isSimulated = true;
                    event.keyCode = 40;
                    event.keyCodeVal = 40;
                    //Get focus back to epg
                    document.dispatchEvent(event);
                }, this), true);

                this.addEventListener(evtType.FOCUS, this._updateArrows);
            },

            /**
             * Show/hide the arrows based on the selection states.
             * @method _updateArrows
             * @protected
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _updateArrows: function () {
                var states = this.getSelectionStates();

                if (states.isFirstChannel) {
                    this._arrows[TOP].hide();
                } else {
                    this._arrows[TOP].show();
                }

                if (states.isLastChannel) {
                    this._arrows[BOTTOM].hide();
                } else {
                    this._arrows[BOTTOM].show();
                }

                if (states.isFirstProgram) {
                    this._arrows[LEFT].hide();
                } else {
                    this._arrows[LEFT].show();
                }

                if (states.isLastProgram) {
                    this._arrows[RIGHT].hide();
                } else {
                    this._arrows[RIGHT].show();
                }
            },

            /**
             * A handler that handles the key event of the EpgGrid, to override the default behaviors for LEFT/RIGHT key.
             * The viewing window will be reposition if needed.
             * @method _onKey
             * @protected
             * @param {Object} evt The event object sent from XDK
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _onKey: function (evt) {
                var selectedRow;

                switch (evt.id) {
                case vKey.LEFT.id:
                    selectedRow = this._epgRows[this._selectedDsIndex];
                    this._selectionInRow = selectedRow.getSelection();
                    this._selectionTime = selectedRow.getSelectionTime();

                    if (this._windowStart > this._lowerBound) {
                        var programStartTime = this._selectionInRow.startTime;

                        if (programStartTime < this._windowStart) {
                            // the current program span through the left boundary, move window backward
                            this._moveWindow(DIR_BACKWARD);

                            // consume the key event to keep the current program focused
                            return false;
                        } else if (programStartTime === this._windowStart) {
                            // the current program's start time touches the left boundary, move window backward
                            this._moveWindow(DIR_BACKWARD);

                            // do not consume the key, the focus will change to the program before
                            return true;
                        }
                    }
                    break;
                case vKey.RIGHT.id:
                    selectedRow = this._epgRows[this._selectedDsIndex];
                    this._selectionInRow = selectedRow.getSelection();
                    this._selectionTime = selectedRow.getSelectionTime();

                    if (this._windowStart < this._upperBound) {
                        var programEndTime = this._selectionInRow.endTime;

                        if (programEndTime > this._windowEnd) {
                            // the current program span through the right boundary, move window forward
                            this._moveWindow(DIR_FORWARD);

                            // consume the key event to keep the current program focused
                            return false;
                        } else if (programEndTime === this._windowEnd) {
                            // the current program's end time touches the right boundary, move window backward
                            this._moveWindow(DIR_FORWARD);

                            // do not consume the key, the focus will change to the program after
                            return true;
                        }
                    }
                    break;
                default:
                    // ignore it as we are only interested in LEFT/RIGHT key
                    break;
                }
            },

            /**
             * A handler that handles the program focus event of the EpgRows.
             * This handler will try to set the selection time for each row to make sure they have the correct forward focus.
             * @method _onRowProgramFocused
             * @protected
             * @param {Object} evt The event object sent from XDK
             * @memberof tve/ext/ui/ProgramGuide#
             */
            _onRowProgramFocused: function (evt) {
                if(evt.target._opts.css !== "wgt-programguide-arrow"){
                    var selectedRow = this._getSelectedRow(),
                        selectedProgram = selectedRow.getSelection();

                    this._updateArrows();
                    this._selectionTime = Math.max(selectedRow.getSelectionTime(), this._windowStart);
                    this._lastFocusedProgramStart = selectedProgram.startTime;

                    this._updateEpgRowSelectionTime();
                }
            }
        });
    });
define("tvedemo/wgt/ProgramGuideTimeline",
    [
        "xdk-base/class",
        "xdk-base/util",
        "xdk-base/console",
        "tve/ext/ui/programguide/Timeline",
        "tve/sServiceHolder"
    ],
    function (
        klass,
        util,
        console,
        ProgramGuideTimeline,
        sServiceHolder
        ) {

        "use strict";

        var DEFAULT_UPDATE_INTERVAL = 60000;

        return klass.create(ProgramGuideTimeline, {}, {

            init: function (opts) {
                // Not strictly necessary to do anything with init, but this is a useful place to diagnose; check that the sub-classed version is in use.
                console.log("EPG timeline sub-classed to use server date/time");

                this._super(opts);
            },

            /**
             * Show the NOW indicator and start the auto update of it.
             * @method startMarker
             * @public
             * @param {Integer} interval The update interval in ms
             * @memberof tvedemo/wgt/ProgramGuideTimeline#
             */
            startMarker: function (interval) {

                //
                // In order to attach our custom ProgramGuideTimeline class, we have replicated
                // the whole of the base class _setupTimeLabels. If we update the underlying program
                // guide implementation we need to be careful to keep in sync!
                //

                this._marker.show();

                if (!interval) {
                    interval = DEFAULT_UPDATE_INTERVAL;
                }

                var timerFunction = util.bind(function () {
                    sServiceHolder.getDateTimeService().getServerDateTime().then(util.bind(function(serverDateTime) {
                        this._marker.getRoot().css("left", this.__timeToLeft(serverDateTime.getTime()) + "px");
                    }, this));
                }, this);

                timerFunction(); // call once first

                if (!this._markerTimer) {
                    this._markerTimer = setInterval(timerFunction, interval);
                }
            }

        });
    });

define('css!tve/ext/ui/programguide/css/style',[],function(){});
define("tvedemo/wgt/ProgramGuide",
    [
        "xdk-base/class",
        "storm/ProgramGuide",
        "xdk-ax/evt/type",
        "xdk-base/util",
        "xdk-base/console",
        "xdk-ui-basic/Label",
        "xdk-ax/Container",
        "xdk-ui-grid/boundedGridStgy",
        "tvedemo/wgt/ProgramGuideTimeline",
        "tvedemo/wgt/Loading",
        "lib/moment",
        "xdk-ax/data/LocalDatasource",
        "xdk-base/promise",
        "tve/ext/ui/programguide/Row",
        "css!tve/ext/ui/programguide/css/style"
    ],
    function (
        klass,
        ProgramGuide,
        evtType,
        util,
        console,
        Label,
        Container,
        boundedGridStgy,
        ProgramGuideTimeline,
        loading,
        moment,
        Ds,
        promise,
        ProgramGuideRow
        ) {

        "use strict";

        var MS_IN_ONE_MINUTE = 60000;

        return klass.create(ProgramGuide, {}, {

            init: function (opts) {
                opts = opts || {};
                opts.frontBoundary = opts.frontBoundary || 0;
                opts.endBoundary = opts.endBoundary || 0;
                this._dateFormat = opts.dateFormat || "";
                this._timeFormat = opts.timeFormat || "";

                this._super(opts);

                // "re-set" the boundedGrid stgies to use the frontBoundary/endBoundary parameters
                this.setCheckSelectableStgy(util.bind(boundedGridStgy.SCROLL_BOUNDARY_CHECK_SELECTABLE_STGY, this, opts.frontBoundary, opts.endBoundary));
                this.setKeyNavigationStgy(util.bind(boundedGridStgy.SCROLL_BOUNDARY_KEY_NAVIGATION_STGY, this, false, opts.frontBoundary, opts.endBoundary));

                // TODO: REEAVLUATE THIS!
                this.addClass("transparent pg-custom");
                this.__attachedToDom = util.defer().then(util.bind(function () {
                    this.removeClass("transparent");
                    this.removeEventListener(evtType.ATTACHED_TO_DOM, this.__attachedToDom);
                }, this));

                this.addEventListener(evtType.ATTACHED_TO_DOM, this.__attachedToDom);

                // add our bottom gradient component
                this._epgBotGradient = new Container({
                    css: "epg-bottom-gradient",
                    parent: this
                });
                // and override scroll entrance strategy to show/hide it when necessary
                var stg = this._scrollEntranceStgy;
                this.setScrollEntranceStgy(util.bind(function(container, scrollStep, curState, toState) {
                    return stg.apply(this, arguments).then(util.bind(function() {
                        if (toState.lastSlotDsIndex < this._tvListings.length - 1) {
                            this._epgBotGradient.show();
                        } else {
                            this._epgBotGradient.hide();
                        }
                    }, this));
                }, this));

            },

            /**
             * This method comes directly from the "tve/ext/ui/ProgramGuide" class
             * The only modification (look for // FIX comment) allows to specify a selectionTime value
             * Nothing else has been touched
             */
            updateEpg: function(opts) {
                var self = this,
                    pgDs = this.__programGuideDatasource,
                    date = opts.date,
                    momentDate = moment(date.getTime()),
                    epgStart = momentDate.hour(0).minute(0).second(0).millisecond(0).unix() * 1000,
                    epgEnd = momentDate.add("d", 1).unix() * 1000;

                this._epgRows = [];

                this._upperBound = epgEnd - this._windowSize * MS_IN_ONE_MINUTE;
                this._lowerBound = epgStart;
                // FIX: allows user to specify a selectionTime
                this._selectionTime = opts.selectionTime || this._lowerBound;
                this._lastFocusedProgramStart = 0;
                this._setupTimeLabels();

                this.setWindowPosition(opts.windowPosition ? opts.windowPosition : this._lowerBound);

                return pgDs.getTotalRowNumber().then(function (total) {
                    var data = [],
                        promises = [],
                        ds = new Ds(),
                        injectChannel = function (index) {
                            return pgDs.getRowHeaderData(index).then(function (channel) {

                                data[index] = data[index] || {};
                                data[index].channel = channel;
                            });
                        },
                        injectListing = function (index) {
                            return pgDs.getProgramGuideCellData(index, date).then(function (tvListing) {
                                data[index] = data[index] || {};
                                data[index].tvListing = tvListing;
                            });
                        },
                        tvListingPromise, channelPromise, dataLoader;

                    for (var i = 0; i < total; i++) {
                        channelPromise = injectChannel(i);
                        tvListingPromise = injectListing(i);

                        promises.push(channelPromise);
                        promises.push(tvListingPromise);
                    }

                    return promise.all(promises).then(function () {
                        dataLoader = function (from, size) {
                            var defer = promise.defer();

                            defer.resolve({
                                data: data,
                                total: data.length
                            });

                            return defer.promise;
                        };

                        self._tvListings = data;

                        self.setDisplayStgy(function (dataObj) {
                            var tvListing = dataObj.tvListing,
                                ret = new ProgramGuideRow({
                                    forwardFocus: true,
                                    channel: dataObj.channel,
                                    programs: tvListing,
                                    scrollPaneWidth: self._scrollPaneWidth,
                                    windowSize: self._windowSize,
                                    startTime: epgStart,
                                    endTime: epgEnd,
                                    windowStart: self._windowStart,
                                    selectionTime: self._selectionTime,
                                    displayProgramGuideRowHeaderStgy: self._rowHeaderDisplayStgy || null,
                                    displayProgramItemStgy: self._cellDisplayStgy || null
                                });
                            
                            /*
                            console.warn("Listing data:");
                            for (var abc in dataObj.tvListing[0].data)
                                console.log(abc+': '+dataObj.tvListing[0].data[abc]);
                            */
                                
                            return ret;
                        });

                        ds.setDataLoader(dataLoader);

                        return self.setDatasource(ds);
                    });
                });
            },

            /**
             * This method comes directly from the "tve/ext/ui/ProgramGuide" class
             * The only modification (look for // FIX comment) prevent the selectionTime value
             * from being modified when still within the EPG time window
             * Nothing else has been touched
             */
            setWindowPosition: function (windowStart) {
                var isMoveForward = this._windowStart < windowStart;

                if (windowStart < this._lowerBound) {
                    this._windowStart = this._lowerBound;
                } else if (windowStart > this._upperBound) {
                    this._windowStart = this._upperBound;
                } else {
                    this._windowStart = windowStart;
                }

                this._windowEnd = this._windowStart + (this._windowSize * MS_IN_ONE_MINUTE);

                // FIX: modify selectionTime only if not within the EPG bounds
                if (this._selectionTime < this._windowStart || this._selectionTime > this._windowEnd) {
                    if (isMoveForward && this._windowStart > this._selectionTime) {
                        this._selectionTime = this._windowStart;
                    } else if (!isMoveForward) {
                        this._selectionTime = Math.max(this._lastFocusedProgramStart, this._windowStart);
                    }
                }

                this._programGuideTimeline.updateTime(this._windowStart);
                this._updateEpgRowTimeAndLeft();
            },

            /**
             * Create the program guide timeline by using ProgramGuideTimeline component
             * @method _setupTimeLabels
             * @protected
             * @memberof tvedemo/wgt/ProgramGuide#
             */
            _setupTimeLabels: function () {

                //
                // The loading animation gets closed at the end of the navigation (in the appRouter),
                // but the page takes a while to fully render, so we have to restart the animation.
                //

                loading.open();

                //
                // In order to attach our custom ProgramGuideTimeline class, we have replicated
                // the whole of the base class _setupTimeLabels. If we update the underlying program
                // guide implementation we need to be careful to keep in sync!
                //

                if (this._programGuideTimeline) {
                    this.detach(this._programGuideTimeline);
                }
                this._programGuideTimeline = new ProgramGuideTimeline({
                    scrollPaneWidth: this._scrollPaneWidth,
                    windowSize: this._windowSize,
                    timescale: this._timescale,
                    startTime: this._lowerBound,
                    endTime: this._upperBound + this._windowSize * MS_IN_ONE_MINUTE,
                    dateFormat: this._dateFormat,
                    timeFormat: this._timeFormat
                });

                this.attach(this._programGuideTimeline, Container.PLACE_BEFORE, this._container);
            },

            /**
             * This method comes directly from the "tve/ext/ui/ProgramGuide" class
             * We just add checks for undefined values
             */
            getSelectionStates: function () {
                var selectedRow = this._getSelectedRow(),
                    selectedProgram = selectedRow && selectedRow.getSelection(),
                    channel = this._tvListings[this._selectedDsIndex] && this._tvListings[this._selectedDsIndex].channel,
                    programsInRow = this._tvListings[this._selectedDsIndex] && this._tvListings[this._selectedDsIndex].tvListing;

                return {
                    channel: channel,
                    program: selectedProgram,
                    isFirstChannel: this._tvListings[0] && (channel === this._tvListings[0].channel),
                    isLastChannel: this._tvListings[this._tvListings.length - 1] && (channel === this._tvListings[this._tvListings.length - 1].channel),
                    isFirstProgram: programsInRow && (selectedProgram === programsInRow[0]),
                    isLastProgram: programsInRow && (selectedProgram === programsInRow[programsInRow.length - 1])
                };
            },

            _updateArrows: function () {
                this._super();
                var states = this.getSelectionStates();
                // hide gradient if last row of the grid is selected
                if (states.isLastChannel) {
                    this._epgBotGradient.hide();
                }
            }

        });
    });
/**
 * Program guide view's template
 * @name programGuide
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/programGuide
 */
define("tvedemo/tmpl/programGuide", [
    "xdk-ax/Container",
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/ProgramGuide",
    "tvedemo/wgt/Submenu",
    "storm/wgt/Image",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sAppConfigManager",
    "xdk-base/device"
], function (
    Container,
    Layout,
    Label,
    EpgGrid,
    Submenu,
    Image,
    sLanguageManager,
    sAppConfigManager,
    device
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            css: "program-guide-view",
            alignment: Layout.VERTICAL,
            autoNavigation: false,
            children: [{
                klass: Container,
                css: "program-detail-container",
                children: [{
                    klass: Container,
                    css: "thumbnail-wrapper",
                    children: [{
                        klass: Image,
                        id: "thumbnail",
                        css: "thumbnail",
                        placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                    }, {
                        klass: Container,
                        css: "thumbnail-overlay hidden",
                        id: "thumbnail-overlay",
                        children: [{
                            klass: Label,
                            text: sLanguageManager.getString("Epg.blackoutShort"),
                            css: "thumbnail-unavailable"
                        }]
                    }]
                }, {
                    klass: Label,
                    id: "title",
                    css: "title"
                }, {
                    klass: Container,
                    css: "packageNeeded hidden",
                    id: "packageNeeded",
                    children: [
                        {
                            klass: Image,
                            id: "packageNeededLogo",
                            css: "packageNeededLogo"
                        },
                        {
                            klass: Label,
                            id: "packageNeededLabel",
                            text: "",
                            css: "packageNeededLabel"
                        }
                    ]
                }, {
                    klass: Label,
                    id: "metadata",
                    css: "metadata"
                }, {
                    klass: Label,
                    id: "description",
                    css: "description"
                }]
            }, {
                klass: Label,
                text: sLanguageManager.getString("Global.Global_buttonBack_button"),
                css: "program-guide-back"
            }, {
                klass: EpgGrid,
                id: "epgGrid",
                scrollPaneWidth: 936, //the width of the displayed tv listing part in px.
                windowSize: 120, //the number of minutes to display in the widget.
                timescale: 30, //the timescale to display
                rows: 6, //the rows to display, same as the configuration in grid.
                nextUp: "submenu",
                endBoundary: 1,
                timeFormat: sLanguageManager.getString("ui.format.epgEventTime"),
                dateFormat: sLanguageManager.getString("ui.format.epgShortDate")
            }]
        };
    };
});

define("tvedemo/helper/CentralEuropeanTime", 
    [], function () {

    var CentralEuropeanTime = {
        getTimestampMillis: function() {
            var dateNow = new Date();
            var nowUnixTimestampMillis = dateNow.getTime();
            var currentYear = dateNow.getUTCFullYear();
            
            // Return false, if DST rules have been different than nowadays:
            if (currentYear <= 1998 && currentYear > 2099) return false;
        
            // Calculate DST start day, it is the last sunday of March - valid until 2099
            var CENTRAL_EUROPEAN_DST_START_DAY = (31 - ((((5 * currentYear) / 4) + 4) % 7));
            var CENTRAL_EUROPEAN_DST_START = new Date(Date.UTC(currentYear, 2, CENTRAL_EUROPEAN_DST_START_DAY, 1, 0, 0));
        
            // Calculate DST end day, it is the last sunday of October
            var CENTRAL_EUROPEAN_DST_END_DAY = (31 - ((((5 * currentYear) / 4) + 1) % 7))
            var CENTRAL_EUROPEAN_DST_END = new Date(Date.UTC(currentYear, 9, CENTRAL_EUROPEAN_DST_END_DAY, 1, 0, 0));
        
            // Check if the time is between CENTRAL_EUROPEAN_DST_START and CENTRAL_EUROPEAN_DST_END
            // If the time is in summer, the offset is 0 hour
            // else offset is 1 hours
            var timezoneOffsetMillis = 0;
            if (dateNow > CENTRAL_EUROPEAN_DST_START && dateNow < CENTRAL_EUROPEAN_DST_END) {
                timezoneOffsetMillis = 1 * 60 * 60 * 1000;
            }
        
            // Add server timestamp to midnight January 1, 1970
            // Add timezone offset to that
            return nowUnixTimestampMillis + timezoneOffsetMillis;
        },
        getDate: function() {
            return new Date().setTime(this.getTimestampMillis());
        }
    }
    return CentralEuropeanTime;    
});
/**
 * The program guide view's controller. Setup the TV listing, program info, date selection, sorting selection.
 * @name ProgramGuide
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/ProgramGuide
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/ProgramGuide", [
    "xdk-base/ax",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/programGuide",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-ui-basic/Image",
    "xdk-base/promise",
    "xdk-ax/mediator",
    "tve/mgr/sLinearManager",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/wgt/TextSelectionListDialog",
    "tvedemo/helper/dialogHelper",
    "tvedemo/helper/sMoment",
    "tvedemo/helper/CentralEuropeanTime",
    "storm/mgr/sAppConfigManager",
    "tvedemo/wgt/Loading",
    "xdk-ui-basic/Button",
    "tvedemo/wgt/ChannelLogo",
    "xdk-base/console",
    "xdk-ax/Container",
    "tvedemo/mgr/sNavigationManager",
    "storm/mgr/sLanguageManager",
    "tve/sServiceHolder",
    "tvedemo/model/ContextBuilder",
    "xdk-ax/mvc/AppRoot"
], function (
    ax,
    RoutableController,
    view,
    tmpl,
    evtType,
    focusManager,
    vKey,
    Image,
    promise,
    mediator,
    sLinearManager,
    endUserManager,
    SelectionDialog,
    dialogHelper,
    moment,
    CentralEuropeanTime,
    sAppConfigManager,
    loading,
    Button,
    ChannelLogo,
    console,
    Container,
    sNavigationManager,
    sLanguageManager,
    sServiceHolder,
    ContextBuilder,
    AppRoot) {

    "use strict";

    var sAppRoot = AppRoot.singleton(),
        EPG_FOCUS_DELAY_VALUE = 0.5, // Seconds
        EPG_FOCUS_DELAY_NAME = "epgFocusDelay",
        ONE_MINUTE_IN_MS = 60000,
        ONE_DAY = 86400 * 1000,
        TIME_FRAME = 2 * 3600 * 1000, // 2 hours
        TODAY, // Has to be acquired asynchronously / on a promise, because we need server time.

        getClosestBlockTime = function (timestamp) {
            var blockTime = moment(timestamp).startOf("day").unix() * 1000; // start of day

            while (blockTime + TIME_FRAME < timestamp) {
                blockTime += TIME_FRAME;
            }

            return blockTime;
        };

    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {
                __forceReload: true
            };
        }
    }, {
        _title: null,
        _metadata: null,
        _thumbnail: null,
        _description: null,

        _submenuItems: [],

        _epgGrid: null,
        _currentDate: undefined, // Has to be acquired asynchronously / on a promise, because we need server time.

        _currentCategoryId: null,
        _availableDays: 1, // Default to today, tomorrow only.

        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        setup: function (context) {
            var currentView = this.getView();

            this._title = currentView.find("title");
            this._metadata = currentView.find("metadata");
            this._thumbnail = currentView.find("thumbnail");
            this._thumbnailOverlay = currentView.find("thumbnail-overlay");
            this._description = currentView.find("description");
            this._epgGrid = currentView.find("epgGrid");
            this._packageNeeded = currentView.find("packageNeeded");
            this._packageNeededLabel = currentView.find("packageNeededLabel");
            this._packageNeededLogo = currentView.find("packageNeededLogo");

            // bind the event listeners
            this.__boundKeyHandler = ax.util.bind(this._keyHandler,this);
            this.__epgFocus = ax.util.bind(this._epgFocus, this);
            this.__epgClick = ax.util.bind(this._epgClick, this);
            this.__epgBlur = ax.util.bind(this._epgBlur, this);

            currentView.addEventListener(evtType.KEY, this.__boundKeyHandler);
            this._epgGrid.addEventListener(evtType.FOCUS, this.__epgFocus);
            this._epgGrid.addEventListener(evtType.CLICK, this.__epgClick);
            this._epgGrid.addEventListener(evtType.BLUR, this.__epgBlur);

            this._epgGrid.setRowHeaderDisplayStgy(function (channel) {
                var ctn = new Container({
                    css: "channel-logo-wrapper",
                    children: [new ChannelLogo({css: "channel-logo", src: channel.logo})]
                }),
                    ctnHTMLRoot = ctn.getRoot().getHTMLElement();

                return ctn;
            });

            this._epgGrid.setCellDisplayStgy(function (program) {
                return new Button({
                    css: "wgt-programguide-row-program " + (program.get("epgBlackout") ? "program-blackout" : ""),
                    text: program.get("title"),
                    focusable: true,
                    clickable: true
                });
            });

            //terminate here if historyBack
            if (context.historyBack) {
                return;
            }

            this._submenuItems = [];
            // Since the view is focusable when not initialized,
            // the focus will falls into a dead-end component.
            // The view is considered to be fully initialized once selectCategoryById() is called.
            currentView.hide();

            var hookFct = ax.util.bind(function(id) {
                return ax.util.bind(function() {
                    // if the epg controller is not being displayed anymore (prob cause we've been navigating away from it), we navigate back to it
                    if (!this.getView()._parent) {
                        mediator.publish("navigate", {
                            path: "Main/ProgramGuide",
                            state: {
                                outerNavigation: {
                                    id: id,
                                    submenu: this._submenuItems
                                }
                            }
                        });
                        return;
                    }
                    // SKYSTORM-705: 
                    // Since the menu state was cloned on Controller's arrival (RoutableController._navigationBacktrace()),
                    // when there is no Controller movement, the menu state will not be recorded (to avoid wrong menu recorded).
                    // However some Controllers using insertSubmenu need to record the menu state
                    // even when they are sticking in the same Controller
                    // 
                    // The solution is to record the state of menu while handling the menu on menuitem.action()
                    this.saveMenuState();
                    // otherwise we just load the selected epg date
                    return this.selectCategoryById(id);
                }, this);
            }, this);

            var menuPromise;
            if (context.outerNavigation) {
                this._submenuItems = context.outerNavigation.submenu;
                // refresh functions ctx
                for (var i=this._submenuItems.length-1; i>=0; i--) {
                    this._submenuItems[i].action = hookFct(this._submenuItems[i].id);
                }
                menuPromise = this.selectCategoryById(context.outerNavigation.id);
            }
            menuPromise = menuPromise || sServiceHolder.getDateTimeService().getServerDateTime().then(ax.util.bind(function(serverTime) {
                var nowMoment = moment(serverTime);

                this._submenuItems.push({
                    id: "today",
                    text: sLanguageManager.getString("Epg.LabelToday_SmartTV"),
                    time: nowMoment.unix() * 1000,
                    action: hookFct("today")
                });
                nowMoment.add("d", 1);
                this._submenuItems.push({
                    id: "tomorrow",
                    text: sLanguageManager.getString("Epg.LabelTomorrow_SmartTV"),
                    time: nowMoment.unix() * 1000,
                    action: hookFct("tomorrow")
                });

                return sAppConfigManager.getEpgDaysForwards().then(ax.util.bind(function(result){
                    this._availableDays = result;
                    for (var i = 1; i < this._availableDays; i++) {
                        nowMoment.add("d", 1);
                        this._submenuItems.push({
                            id: this._availableDays + 2 + i,
                            text: nowMoment.format(sLanguageManager.getString("ui.format.epgMenuDate")),
                            time: nowMoment.unix() * 1000,
                            action: hookFct(this._availableDays + 2 + i)
                        });
                    }

                    return sNavigationManager.insertSubmenu(this._submenuItems);

                }, this));

            }, this));

            var dateTimePromise = sServiceHolder.getDateTimeService().getServerDateTime().then(ax.util.bind(function(serverTime) {
                this._currentDate = serverTime.getTime();
                TODAY = moment(serverTime).startOf("day");
            }, this));

            context.setupPending = promise.all([menuPromise, dateTimePromise]);
            
            this.trackLevel(2, undefined, true);
        },

        selectDate: function (timestamp, windowPosition) {
            var targetTime = moment(timestamp).startOf("day").unix() * 1000;

            if (targetTime === this._currentDate) {
                return;
            }

            this._currentDate = targetTime;
            var epgDataObj = {};

            if (windowPosition) {
                epgDataObj.windowPosition = windowPosition;
            }

            return this.updateEpg(epgDataObj);
        },

        nextDay: function () {
            if (this._canNext()) {
                return this.selectDate(this._currentDate + ONE_DAY);
            }
        },

        prevDay: function () {
            if (this._canPrev()) {
                return this.selectDate(this._currentDate - ONE_DAY);
            }
        },

        selectCategoryById: function (id) {
            this.getView().show();
            for (var i = this._submenuItems.length - 1; i >= 0; i--) {
                if (this._submenuItems[i].id === id) {
                    return this.selectSubmenuByIndex(i);
                }
            }

            throw ax.core.createException("Invalid Param", "Cannot find item *" + id + "* in the submenu.");
        },

        selectSubmenuByIndex: function (index) {
            this._currentCategoryId = this._submenuItems[index].id;
            this._currentDate = this._submenuItems[index].time;
            
            return this.selectDate(this._currentDate, getClosestBlockTime(this._currentDate));
        },

        updateEpg: function (dataObj) {
            loading.open();
            return promise.all([this.__setPromisesBasedOnCategory(), sServiceHolder.getDateTimeService().getServerDateTime()]).then(ax.util.bind(function(results) {
                var epgTimeObj = {
                        date: new Date(this._currentDate),
                        selectionTime: results[1].getTime()
                    },
                    updateDs = ax.util.bind(function (ds) {
                        this._epgGrid.setProgramGuideDatasource(ds);
                        return this._epgGrid.updateEpg(epgTimeObj).then(ax.util.bind(function () {
                            this._epgGrid.startMarker(ONE_MINUTE_IN_MS);
                            focusManager.focus(this._epgGrid);
                        }, this));
                    }, this);

                if (ax.util.isObject(dataObj)) {
                    ax.util.extend(epgTimeObj, dataObj);
                }

                return sLinearManager.getProgramGuideDatasource().then(updateDs);

            }, this)).complete(function() {
                loading.close();
            });
        },

        _highlightSubmenuByCategoryId: function (id) {
            for (var i = this._submenuItems.length - 1; i >= 0; i--) {
                if (this._submenuItems[i].id === id) {
                    return this.getView().find("submenu").select(i);
                }
            }
        },

        _canPrev: function () {
            return moment(this._currentDate).startOf("day").isAfter(TODAY);
        },

        _canNext: function () {
            return moment(this._currentDate).startOf("day").subtract("d", this._availableDays - 1).isBefore(TODAY);
        },

        _focusToTopMenu: function () {
            var theSubMenu = sAppRoot.getView().find("list-sub-menu");
            focusManager.focus(theSubMenu);
        },

        /**
         * Set the promises that can be used to fetch the channels and tv listings, according to the selected category.
         * @method
         * @private
         */
        __setPromisesBasedOnCategory: function () {
            var defer = promise.defer();

            defer.resolve();

            return defer.promise;
        },

        _keyHandler: function (evt) {
            switch (evt.id) {
                case vKey.BACK.id:
                    this._focusToTopMenu();
                    return false;
            }
            return true;
        },

        _epgClick: function () {
            var state = this._epgGrid.getSelectionStates();

            if (state.program.id === 0) {
                // If there's a zero program id then this is a PLACEHOLDER, for which we'll never be able to get EpgEvent detail.
                return;
            }

            var contextBuilder = new ContextBuilder(),
                context;

            context = contextBuilder.setData({
                        channelId: state.channel.id,
                        eventId: state.program.id
                    })
                    .build();

            mediator.publish("navigate", {
                path: "Main/EpgEvent",
                state: {
                    context: context
                }
            });
        },

        _epgFocus: function () {
            var state = this._epgGrid.getSelectionStates(),
                program = state.program && state.program.data,
                program_id = program && program.get("id"),
                channel = state.channel && state.channel.mobilepc;

            if (!program || ax.util.isUndefined(program_id) || !channel) {
                return;
            }

            if (program_id === this._program_id_last_shown) {
                return; // If focus re-applied to the grid, don't keep refreshing the detail area: SKYSTORM-691.
            }

            this._program_id_last_shown = program_id; // Retain id of the last one we sought details for.

            this._title.setText(program.get("title"));
            this._metadata.setText(program.get("inlineMetadata"));
            this._description.setText(program.get("description"));
            this._thumbnailOverlay[program.get("epgBlackout") ? "removeClass" : "addClass"]("hidden");
            program.set("packageCode", channel); // So that checkUserPrivileges() below is done with the linear channel entitlements in mind.

            // Hide this, or it lingers during the pause before full data is shown.

            this._packageNeeded.addClass("hidden");

            // Debounce / delay before we make the expensive call to populate fuller information; see SKYSTORM-678.

            ax.util.clearDelay(EPG_FOCUS_DELAY_NAME);
            ax.util.delay(EPG_FOCUS_DELAY_VALUE, EPG_FOCUS_DELAY_NAME).then(ax.util.bind(function() {

                var epgFocusPromises = [
                    sAppConfigManager.getPlaceholderLandscape(),
                    sLinearManager.getProgramById(program_id, state.channel.id),
                    endUserManager.checkUserPrivileges(program)
                ];

                promise.all(epgFocusPromises).then(ax.util.bind(function (program_id_loopback, outcomes) {
                    var program = outcomes[1],
                        thumbnailUrl = outcomes[0],
                        userAccess = outcomes[2];

                    // Safety against overwriting out of sequence due to asynchronous detail round-trip.
                    if (this._program_id_last_shown === program_id_loopback) {
                        var finalTitle = program.get("title"),
                            finalMetadata = program.get("inlineMetadata"),
                            finalDescription = program.get("description"),
                            imagesArray = program.get("images"),
                            relativeImageUrl = ax.util.isArray(imagesArray) && imagesArray.length && imagesArray[0].file;

                        if (finalTitle) {
                            this._title.setText(finalTitle);
                        }
                        if (finalMetadata) {
                            this._metadata.setText(finalMetadata);
                        }
                        if (finalDescription) {
                            this._description.setText(finalDescription);
                        }
                        if (relativeImageUrl) {
                            sLinearManager.constructCMSUrlPromise(relativeImageUrl).then(ax.util.bind(function (url) {
                                this._thumbnail.setSrc(url);
                            }, this));
                        } else {
                            this._thumbnail.setSrc(thumbnailUrl);
                        }

                        if (!userAccess) {
                            // Get the appropriate image logo.
                            sAppConfigManager.getPackageImageForCode(channel).then(ax.util.bind(function(logo) {
                                this._packageNeededLogo.setSrc(logo);
                                this._packageNeededLogo.removeClass("hidden");
                            },this), ax.util.bind(function() {
                                // We failed to get a corresponding logo so hide it.
                                this._packageNeededLogo.addClass("hidden");
                            },this));

                            var missingLookup = "DetailPage.DetailPage_MissingEntitlement_" + channel,
                                missingMsg = sLanguageManager.getString(missingLookup);
                            // If we received the same text we sent that means there was no specific message available, default to the OTHER message.
                            if (missingMsg === missingLookup) {
                                missingMsg = sLanguageManager.getString("DetailPage.DetailPage_MissingEntitlement_OTHER");
                            }
                            this._packageNeededLabel.setText(missingMsg);
                            this._packageNeeded.removeClass("hidden");
                        }
                        else {
                            this._packageNeeded.addClass("hidden");
                        }
                    }
                }, this, program_id));

            }, this));

        },

        _epgBlur: function () {
            // @TODO: No behaviour defined here. TBC, maybe blank the metadata area.
        },

        reset: function () {
            this.getView().removeEventListener(evtType.KEY, this.__boundKeyHandler);
            this._epgGrid.removeEventListener(evtType.FOCUS, this.__epgFocus);
            this._epgGrid.removeEventListener(evtType.CLICK, this.__epgClick);
            this._epgGrid.removeEventListener(evtType.BLUR, this.__epgBlur);
        }

    });
});
/**
 * recentlyWatched - contain list of assets seen by user
 * @name recentlyWatched
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/recentlyWatched
 */
define("tvedemo/tmpl/recentlyWatched", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/Submenu",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "storm/mgr/sLanguageManager"
], function (
    Layout,
    Label,
    Submenu,
    LoopedGrid,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            forwardFocus: true,
            alignment: Layout.VERTICAL,
            css: "subcontrollerPage recentlyWatched",
            children: [{
                klass: LoopedGrid,
                forwardFocus: true,
                alignment: LoopedGrid.VERTICAL,
                id: "#recentlyWatchedGrid",
                rows: 3,
                cols: 2,
                scrollFrontBoundary: 1,
                scrollEndBoundary: 1
            },{
                klass: Label,
                id: "empty-list-label",
                text: sLanguageManager.getString("Global.Global_NoResults"),
                css: "empty-list-label hidden"
            }]
        };    
    };
});
/**
 * The RecentlyWatched view's controller.
 * @name RecentlyWatched
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/RecentlyWatched
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/RecentlyWatched", [
    "xdk-base/ax",
    "xdk-base/promise",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/recentlyWatched",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "tvedemo/helper/dialogHelper",
    "xdk-base/util",
    "tvedemo/mgr/sEndUserManager",
    "xdk-base/console",
    "tvedemo/wgt/ImageButton",
    "xdk-ax/Container",
    "xdk-ui-basic/Label",
    "storm/helper/util",
    "storm/mgr/sAppConfigManager",
    "tvedemo/mgr/sHistoryManager",
    "storm/mgr/sLanguageManager",
    "xdk-ax/mediator"
], function (
    ax,
    promise,
    RoutableController,
    view,
    tmpl,
    focusManager,
    evtType,
    dialogHelper,
    util,
    sEndUserManager,
    console,
    ImageButton,
    Container,
    Label,
    stormUtil,
    sAppConfigManager,
    sHistoryManager,
    sLanguageManager,
    mediator) {

    "use strict";

    var GRID_FOCUS_COLUMN = 1,
        HIGHLIGHTS = {
            MOVIE : "Film",
            EPISODE : "Episode",
            SERIES : "Series",
            SPORT_EVENT : "Sport",
            SPORT_NEWS : "sportsNews" // Deprecated; we don't expect to see these based on the hardcoded data URLs Sky supply now / wireframes.
        };

    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {};
        }
    }, {

        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        // Override getState to handle latest state from the menu.
        getState: function () {
            return this._super();
        },

        setup: function (context) {
            this._super(context);

            if (context.historyBack === true) {
                if (!sEndUserManager.getLoginStatus()) {
                    sHistoryManager.back();
                    return;
                }
            }
            
            this.currentView = this.getView();
            this.recentlyWatchedGrid = this.currentView.find("recentlyWatchedGrid");

            // Recently watched is only a listing to display items that have been watched by the account.
            // For example a way for parents to see what their children have been watching.
            // It is not a quick way to watch content once again, thus a click on an item in the grid
            // should not yield any action, and we have no evtType.CLICK listener on it.

            context.setupPending = this.getRecentlyWatchList();
            
            this.trackLevel(2, undefined, true);
        },

        getRecentlyWatchList: function() {
            return sEndUserManager.getRecentlyWatched().then(util.bind(function (recentlyWatchedList) {
                if (recentlyWatchedList && util.isArray(recentlyWatchedList) && recentlyWatchedList.length) {
                    this.setupGrid(this.recentlyWatchedGrid, recentlyWatchedList).then(util.bind(function() {
                        this.recentlyWatchedGrid.select(0, GRID_FOCUS_COLUMN); // Zeroth data to appear in a specific column.
                        focusManager.focus(this.recentlyWatchedGrid);
                    }, this));
                } else {
                    this.currentView.find("empty-list-label").removeClass("hidden");
                }

            },this)).fail(function (reason) {
                console.info("Error while fetching recently watched ", reason);

                dialogHelper.error({
                    reason: sLanguageManager.getString("Errormessages.Errormessages_labelErrorMessage"),
                    buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                });
            });
        },

        // set a datasource to a grid, and if any error occurs, set the grid as invalid
        setupGrid: function(grid, itemArray) {
            var episodesDataSource = stormUtil.arrayToDs(itemArray);
            var curDate = new Date();
            var self = this;

            grid.setDisplayStgy(function (asset) {
                var view = new Container({
                    forwardFocus: true
                }),
                imageButton = new ImageButton({
                    parent: view,
                    src: asset.get("imageUrl"),
                    placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                }),
                textContainer = new Container({
                    parent: imageButton,
                    css: "textContainer"
                }),
                label = new Label({
                    parent: textContainer,
                    text: asset.get("title"),
                    css: "text"
                });

                var startDate = new Date(asset.get("startDate")),
                endDate = new Date(asset.get("endDate"));
                if ((!(startDate < curDate  && curDate < endDate)) || ((asset._attrs.catalog === false) && (asset._attrs.contentTargeting === false)) ){
                    imageButton.addClass("notAvailable");
                    new Label({
                        parent: imageButton,
                        text:"this content is currently expired",//sLanguageManager.getString("noDataFoundMessage")
                        css: "contentNoAvailable"
                    })
                }

                imageButton.addEventListener(evtType.CLICK, util.bind(self._gridClickHandler, self, asset));
                
                return view;
            });

            return grid.setDatasource(episodesDataSource);
        },

        _gridClickHandler: function(asset) {

            var id = asset.get('assetId');
            var catalog = asset.get('skyCatalog');
            var type = asset.get('assetType');

            if (type === HIGHLIGHTS.MOVIE) {
                mediator.publish("navigate", {
                    path: "Main/Movie",
                    state: {
                        assetId: id,
                        catalog: catalog
                    }
                });
            } else if (type === HIGHLIGHTS.EPISODE) {
                mediator.publish("navigate", {
                    path: "Main/Episode",
                    state: {
                        selectedEpisodeId: id,
                        catalog: catalog
                    }
                });
            } else if (type === HIGHLIGHTS.SERIES) {
                mediator.publish("navigate", {
                    path: "Main/TVShow",
                    state: {
                        serieId: id,
                        catalog: catalog
                    }
                });
            } else if (type === HIGHLIGHTS.SPORT_EVENT) {
                mediator.publish("navigate", {
                    path: "Main/Sport",
                    state: {
                        assetId: id,
                        catalog: catalog
                    }
                });
            }
            else {
                console.warn("Clicked on unexpected type " + type);
            }
            return false;
        },

        reset: function () {
            // No listeners to remove (see earlier comment about grid not being clickable).
            this._super();
        }

    });
});
/**
 * 2 separate 16:9 LoopedGrid Carousels
 * @name searchListing
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/searchListing
 */
define("tvedemo/tmpl/searchListing", [
    "storm/mgr/sLanguageManager",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "xdk-ui-basic/Layout",
    "xdk-ax/Container",
    "xdk-ui-basic/Label"
], function (
    sLanguageManager,
    LoopedGrid, 
    Layout,
    Container,
    Label
) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            forwardFocus: true,
            alignment: Layout.VERTICAL,
            css: "subcontrollerPage search-listing",
            children: [{
                klass: Label,
                id: "skyGoLabel",
                css: "sky-go-label"
            },{
                klass: Container,
                id: 'searchGridContainer',
                css: 'search-grid-container',
                children: []
            },{
                klass: Label,
                id: "errorMsgGo",
                css: "error-msg",
                text: sLanguageManager.getString("Global.Global_NoResults")
            }]
        };
    };
});
/**
 * 2 separate 16:9 LoopedGrid Carousels
 * @name SearchListing
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/SearchListing
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/SearchListing", [
    "tvedemo/ctrl/RoutableController",
    "storm/mgr/sAppConfigManager",
    "xdk-ax/data/LocalDatasource",
    "tvedemo/tmpl/searchListing",
    "storm/mgr/sLanguageManager",
    "tvedemo/wgt/ImageButton",
    "tve/mgr/sLinearManager",
    "xdk-ax/focusManager",
    "storm/helper/util",
    "xdk-ax/Container",
    "xdk-ui-basic/Label",
    "xdk-ax/mediator",
    "xdk-ax/evt/type",
    "xdk-ax/mvc/view",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/class",
    "xdk-base/util",
    "tvedemo/wgt/BasicGrid",
    "tvedemo/ext/ui/grid/LoopedGrid"
], function (
    RoutableController,
    sAppConfigManager,
    LocalDatasource,
    tmpl,
    sLanguageManager,
    ImageButton,
    sLinearManager,
    focusManager,
    stormUtil,
    Container,
    Label,
    mediator,
    evtType,
    view,
    console,
    promise,
    klass,
    util,
    BasicGrid,
    LoopedGrid
) {
    "use strict";

    var SKY_GO_CATALOG = "sg",
        GRID_FOCUS_COLUMN = 1;

    return klass.create(RoutableController, {
        getDefaultState: function() {
            return {
                keyword: null
            };
        }
    }, {
        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },
        getState: function() {

            // Do not overwrite a state variable in case it already has been created.
            if (util.isObject(this.__state)) {
                this.__state.keyword = this.context.keyword;
                return this.__state;
            }

            return {
                keyword: this.context.keyword
            };

        },
        setup: function (context) {
            this.context = context || {};
            
            this._skyGoLabel = this.getView().find("skyGoLabel");
            this._gridContainer = this.getView().find("searchGridContainer");

            this._assetGridHandlerRef = util.bind(this._assetGridHandler, this);

            if (context.historyBack === true) {

                // skyGoGrid is already created if we are going back in history.
                // This means we will have to readd the eventhandler.
                this._skyGoGrid.addEventListener(evtType.CLICK, this._assetGridHandlerRef);

                // Forward focus to correct page item.
                focusManager.focus(this.getView());
                return;
            }

            this.getView().find("errorMsgGo").hide();

            context.setupPending = this._setupGrid().then(util.bind(function(results) {
                if (Error.prototype.isPrototypeOf(results[0])) {
                    this.getView().find("errorMsgGo").show();
                } else {
                    focusManager.focus(this._skyGoGrid);
                }
            }, this)); // @TODO: Handle failure here, or user is left on an empty screen.
            
            this.trackLevel(1, "SUCHE");
        },
        _setupGrid: function() {
            var keyword = this.context.keyword;
            if (!keyword || !keyword.length) {
                console.error("Keyword is empty");
                return promise.reject();
            }

            return stormUtil.allPromises([
                this._setupAssetGrid(keyword)
            ]);
        },

        _createAssetGrid: function(assetLength) {

            // Create a bounded grid to avoid repeated content.
            if (assetLength < 7) {
                this._skyGoGrid = new BasicGrid({
                    forwardFocus: true,
                    alignment: BasicGrid.VERTICAL,
                    id: "skyGoGrid",
                    css: "asset-grid",
                    rows: 2,
                    cols: Math.ceil(assetLength / 2)
                });
            } else {
                // Create a looped grid

                this._skyGoGrid = new LoopedGrid({
                    forwardFocus: true,
                    alignment: LoopedGrid.VERTICAL,
                    id: "skyGoGrid",
                    css: "asset-grid",
                    rows: 3,
                    cols: 2,
                    scrollFrontBoundary: 1,
                    scrollEndBoundary: 1   
                });
            }

            this._gridContainer.attach(this._skyGoGrid);

            this._skyGoGrid.addEventListener(evtType.CLICK, this._assetGridHandlerRef);

            return this._skyGoGrid;
        },

        _setupAssetGrid: function(keyword) {

            return sLinearManager.getSearchResults(keyword, SKY_GO_CATALOG).then(util.bind(function (assetList) {
                    this._skyGoLabel.setText(sLanguageManager.getString("Search.Search_GoHL", {
                        "search term": keyword,
                        "amounts results": assetList.length
                    }));

                    var grid = this._createAssetGrid(assetList.length);
                        
                    grid.setDisplayStgy(function (asset) {
                        var view = new Container({
                            forwardFocus: true
                        }),
                        imageButton = new ImageButton({
                            parent: view,
                            placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                        }),
                        textContainer = new Container({
                            parent: imageButton,
                            css: "textContainer"
                        }),
                        label = new Label({
                            parent: textContainer,
                            text: asset.title,
                            css: "text"
                        });

                        sLinearManager.constructCMSUrlPromise(asset.picture).then(function (url) {
                            imageButton.setSrc(url);
                        });

                        return view;
                    });

                    var ds = this._setupSkyGoDatasource(assetList);

                    return grid.setDatasource(ds).then(util.bind(function(){
                        grid.select(0);
                    }, this));
            }, this));
        },

        _setupSkyGoDatasource: function(assetList) {
            var ds = new LocalDatasource();
            ds.setDataLoader(util.bind(function() {
                if (!assetList.length) {
                    return promise.reject("skyGoGrid has empty data");
                }
                return promise.resolve({
                    data: assetList,
                    total: assetList.length
                });
            }, this));
            return ds;
        },
        _assetGridHandler: function(evt) {
            var asset;
            if (evt.target.isDescendantOf(this._skyGoGrid)) {
                asset = this._skyGoGrid.getSelectedData();
            }

            switch (asset.contentType) {
                case "Sport":
                    mediator.publish("navigate", {
                        path: "Main/Sport",
                        state: {
                            assetId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                    break;
                case "Film":
                    mediator.publish("navigate", {
                        path: "Main/Movie",
                        state: {
                            assetId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                    break;
                case "Episode":
                    mediator.publish("navigate", {
                        path: "Main/Episode",
                        state: {
                            selectedEpisodeId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                    break;
            }
            return false;
        },
        reset: function() {
            this._skyGoGrid.removeEventListener(evtType.CLICK, this._assetGridHandlerRef);
            this._super();
        }
    });
});

/**
 * Sport details view's template
 * @name movie
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/movie
 */
define("tvedemo/tmpl/sport", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/AssetGrid",
    "storm/wgt/Image",
    "xdk-ax/Container",
    "tvedemo/wgt/ScrollLabel",
    "xdk-ui-basic/Button",
    "tvedemo/wgt/ImageButton",
    "storm/mgr/sAppConfigManager"
], function (
    Layout,
    Label,
    AssetGrid,
    Image,
    Container,
    ScrollLabel,
    Button,
    ImageButton,
    sAppConfigManager
    ) {

    return function () {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#sport",
            children: [{
                klass: Layout,
                alignment: Layout.VERTICAL,
                children: [{
                    klass: Layout,
                    id: "#upContainer",
                    children: [{
                            klass: Image,
                            id: "#thumbnail",
                            placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                        }, {
                            klass: Layout,
                            id: "#blackoutMessageContainer",
                            children: [{
                                klass: Label,
                                id: "#blackoutMessage"
                            }]
                        },{
                            klass: Container,
                            css: "informationContainer",
                            children: [{
                                klass: Label,
                                id: "#title"
                            }, {
                                klass: Layout,
                                id: "#metaDataContainer",
                                alignment: Layout.HORIZONTAL
                            }, {
                                klass: Image,
                                id: "#channelLogo"
                            }, {
                                klass: Container,
                                id: "missingPackage",
                                css: "missingPackage",
                                children: [{
                                    klass: Image,
                                    id: "missingPackageLogo",
                                    css: "missingPackageLogo"
                                }, {
                                    klass: Label,
                                    id: "missingPackageText",
                                    css: "missingPackageText"
                                }]
                            }]
                        }]
                    }, {
                        klass: Layout,
                        alignment: Layout.HORIZONTAL,
                        id: "#videoButtonContainer",
                        children: [{
                            klass: ImageButton,
                            id: "sportTuneIn",
                            text: "",
                            nextRight: "detailDescription"
                        }, {
                            klass: ImageButton,
                            id: "sportStartFromVod",
                            text: "",
                            nextRight: "detailDescription",
                            nextLeft: "sportStartFromVod"
                        }, {
                            klass: ImageButton,
                            id: "addToWatchlist",
                            text: "",
                            nextRight: "detailDescription",
                            nextLeft: "addToWatchlist"
                        }]
                    }, {
                        klass: ScrollLabel,
                        id: "detailDescription",
                        scrollStep: 72,
                        nextLeft: "videoButtonContainer",
                        nextUp: "header",
                        nextDown: "detailDescription"
                    }]
                }]
        };
    };
});
/**
 * The Sport item's detail controller
 * @name Sport
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Sport
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Sport", [
    "xdk-base/ax",
    "xdk-base/class",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/sport",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/mediator",
    "tvedemo/wgt/TextSelectionListDialog",
    "xdk-base/promise",
    "xdk-ui-basic/Label",
    "tvedemo/helper/sMoment",
    "tvedemo/mgr/sEndUserManager",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "tvedemo/wgt/AlertDialog",
    "storm/mgr/sAppConfigManager",
    "xdk-base/console",
    "storm/mgr/sLanguageManager",
    "tvedemo/mgr/sAssetManager",
    "tvedemo/ctrl/DetailsBase",
    "storm/helper/util"
], function (
    ax,
    klass,
    view,
    sportTmpl,
    evtType,
    focusManager,
    vKey,
    util,
    mediator,
    TextSelectionListDialog,
    promise,
    Label,
    moment,
    sEndUserManager,
    sHistoryManager,
    dialogHelper,
    AlertDialog,
    sAppConfigManager,
    console,
    sLanguageManager,
    sAssetManager,
    DetailsBase,
    stormHelper
    ) {
    "use strict";

    return klass.create(DetailsBase, {
        getDefaultState: function () {
            return {};
        }
    }, {
        __asset: null,

        init: function () {
            this._super();
            this.setView(view.render(sportTmpl));
        },

        setup: function (context) {
            this._super(context);

            this.setupButtons();

            if (context.historyBack) {
                this.updateDetailInformation(this.__asset);
                return;
            }

            context.setupPending = this.setupDetailsInformation(context.assetId, context.catalog);

        },

        /**
         * Setup buttons on the page, add click event handlers.
         * @return {void}
         */
        setupButtons: function () {
            var currentView = this.getView(),
                tuneInSport = currentView.find("sportTuneIn"),
                watchSport = currentView.find("sportStartFromVod"),
                addToWatchlist = currentView.find("addToWatchlist");

           this.__tuneInRef = util.bind(function () {
                if (tuneInSport.isDisabled()) {
                    return;
                }

                this.__tuneIn(this.__asset);
            }, this);

            this.__watchSportRef = util.bind(function () {

                if (watchSport.isDisabled()) {
                    return;
                }

                var isLiveEvent = this.__asset.get("live");

                // In case it is a live event, check that it is currently airing.
                // In Case of a VOD event, just start playback.
                if (isLiveEvent) {

                    stormHelper.isOnAir(this.__asset.get("onAir")).then(util.bind(function (currentlyOnAir) {

                        if (currentlyOnAir) {

                            // Even though sport events can be broadcasted live,
                            // they still contain their video streams in the same way as a VOD asset.
                            this.__watchVod(this.__asset);

                        } else {
                            dialogHelper.error({
                                title: sLanguageManager.getString("Sport.Sport_Error_TecEvent_not_ongoingTitle"),
                                reason: sLanguageManager.getString("Sport.Sport_Error_TecEvent_not_ongoingMessage"),
                                buttonText: sLanguageManager.getString("Global.Global_Continue")
                            });
                        }

                    }, this));

                } else {
                    this.__watchVod(this.__asset);
                }

            }, this);

            this.__addToWatchlistRef = util.bind(function () {

                this.__updateWatchList({
                    remove: this.__detailInformation.isInWatchlist ? true : false,
                    add: this.__detailInformation.isInWatchlist ? false : true,
                    catalog: this.__asset.get("catalog"),
                    assetId: this.__asset.get("id"),
                    assetType: this.__asset.get("type")
                })
                .then(util.bind(function (successFully) {

                    if (successFully.added) {
                        this.__detailInformation.isInWatchlist = true;

                    } else if (successFully.removed) {
                          this.__detailInformation.isInWatchlist = false;
                    }

                    this.updateButtons({
                        isBlackedOut: this.__detailInformation.isBlackedOut,
                        channelIsPermitted: this.__detailInformation.channelIsPermitted,
                        channelIsPlayable: this.__detailInformation.channelIsPlayable,
                        userHasPrivilegeToWatchChannel: this.__detailInformation.userHasPrivilegeToWatchChannel,
                        userHasPrivilegeToWatchVod: this.__detailInformation.userHasPrivilegeToWatchVod,
                        isInWatchlist: this.__detailInformation.isInWatchlist,
                        userIsLoggedIn: this.checkIfUserIsLoggedIn(),
                        vodIsPlayable: this.__assetIsPlayable(this.__asset)
                    });

                }, this));

            }, this);

            tuneInSport.addEventListener(evtType.CLICK, this.__tuneInRef);
            watchSport.addEventListener(evtType.CLICK, this.__watchSportRef);
            addToWatchlist.addEventListener(evtType.CLICK, this.__addToWatchlistRef);

        },

        /**
         * Setup all asset specific data of the page.
         * @param  {Number} assetId Id of the asset that is currently displayed on the page.
         * @param  {String} catalog Catalog that contains the asset.
         * @return {void}
         */
        setupDetailsInformation: function (assetId, catalog) {
            var setupPromise;

            if (!assetId || !catalog) {

                setupPromise = ax.promise.reject().fail(function () {
                    util.defer().then(function() {
                        dialogHelper.error({
                            reason: sLanguageManager.getString("Global.Global_NoResults"),
                            closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                            buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                        });
                    });
                });

                return setupPromise;
            }

            setupPromise = sAssetManager.getSportAssetById(assetId, catalog);

            return setupPromise.then(util.bind(function (asset) {

                this.updateDetailInformation(asset);

            }, this)).fail(function() {
                util.defer().then(function() {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Global.Global_NoResults"),
                        closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                });
            });
        },

        updateDetailInformation: function (asset) {
            var associatedChannel = asset.get("channel");

            if (associatedChannel) {
                // Since SKYSTORM-687 we do not allow users to access the linear channel from Sport detail pages (only from TV event pages that happen to have sport on them).
                console.warn("Sport detail page doesn't expect an associated channel (" + associatedChannel + ")");
                associatedChannel = null;
            }

            promise.all([
                // Check if associated channel is permitted.
                // This will return false at the moment, since no sport event has an associated channel.
                associatedChannel ? this.__checkIfChannelIsPermitted(associatedChannel) : promise.resolve(false),

                // Check if associated channel is playable.
                // This will return false at the moment, since no sport event has an associated channel.
                associatedChannel ? this.__checkIfChannelIsPlayable(associatedChannel) : promise.resolve(false),

                // Check if user is entitled to watch channel.
                // This will return false at the moment, since no sport event has an associated channel.
                associatedChannel ? this.__checkUserPrivileges(associatedChannel) : promise.resolve(false),

                // Check if user is entitled to watch associated asset.
                this.__checkUserPrivileges(asset),

                // Check if associated asset is in watchlist
                this.__checkIfAssetIsPresentInWatchlist(asset)
            ])
            .then(util.bind(function (result) {
                var channelIsPermitted = result[0],
                    channelIsPlayable = result[1],
                    userHasPrivilegeToWatchChannel = result[2],
                    userHasPrivilegeToWatchVod = result[3],
                    assetIsInWatchlist = result[4],
                    liveSupported = result[5];


                this.__asset = asset;

                this.__detailInformation.title = asset.get("title");
                this.__detailInformation.synopsis = asset.get("subtitle");
                this.__detailInformation.cast = asset.get("cast");
                this.__detailInformation.parentalRating = asset.get("parentalRating");
                this.__detailInformation.length = asset.get("length");
                this.__detailInformation.year = asset.get("year");
                this.__detailInformation.genres = asset.get("genreList");
                this.__detailInformation.startTime = asset.get("startTime");
                this.__detailInformation.endTime = asset.get("endTime");
                this.__detailInformation.packageCode = asset.get("packageCode");
                this.__detailInformation.packageColorCode = asset.get("packageColorCode");
                this.__detailInformation.isBlackedOut = asset.get("blackedOut");
                this.__detailInformation.channelIsPermitted = channelIsPermitted;
                this.__detailInformation.channelIsPlayable = channelIsPlayable;
                this.__detailInformation.userHasPrivilegeToWatchChannel = userHasPrivilegeToWatchChannel;
                this.__detailInformation.userHasPrivilegeToWatchVod = userHasPrivilegeToWatchVod;
                this.__detailInformation.isInWatchlist = assetIsInWatchlist;
                 
                this.trackPage(asset.get("title"));   
                
                this.updateCommonDetailInformation(this.__asset, this.__detailInformation);

                this.updateButtons({
                    isBlackedOut: this.__detailInformation.isBlackedOut,
                    channelIsPermitted: this.__detailInformation.channelIsPermitted,
                    channelIsPlayable: this.__detailInformation.channelIsPlayable,
                    userHasPrivilegeToWatchChannel: this.__detailInformation.userHasPrivilegeToWatchChannel,
                    userHasPrivilegeToWatchVod: this.__detailInformation.userHasPrivilegeToWatchVod,
                    isInWatchlist: this.__detailInformation.isInWatchlist,
                    userIsLoggedIn: this.checkIfUserIsLoggedIn(),
                    vodIsPlayable: this.__assetIsPlayable(this.__asset),
                    liveSupported: true // Just set it to true since the disabled feature was cancelled at the last minute.
                });

            }, this));
        },

        /**
         * Display correct set of buttons.
         * @param  {Object} asset                         Asset that is currently displayed.
         * @param  {boolean} userHasPrivilegeToViewContent True if user is allowed to watch the content, otherwise false.
         * @return {void}
         */
        updateButtons: function (options) {
            if (!options) {
                return;
            }

            // Buttons.
            var currentView = this.getView(),
                tuneInSport = currentView.find("sportTuneIn"),
                watchSport = currentView.find("sportStartFromVod"),
                addToWatchlist = currentView.find("addToWatchlist"),
                videoButtonContainer = currentView.find("videoButtonContainer"),
                detailDescription = currentView.find("detailDescription"),

                // Display options.
                isBlackedOut = options.isBlackedOut,
                channelIsPermitted = options.channelIsPermitted,
                channelIsPlayable = options.channelIsPlayable,
                userHasPrivilegeToWatchChannel = options.userHasPrivilegeToWatchChannel,
                userHasPrivilegeToWatchVod = options.userHasPrivilegeToWatchVod,
                isInWatchlist = options.isInWatchlist,
                userIsLoggedIn = options.userIsLoggedIn,
                vodIsPlayable = options.vodIsPlayable,
                liveSupported = options.liveSupported || true,
                isVodLive = this.__asset.get("currentType") === sAssetManager.SPORT_ASSET_CURRENT_TYPES.LIVE;

            tuneInSport.setText(sLanguageManager.getString("DetailPage.DetailPage_labelTuneIn"));
            watchSport.setText(sLanguageManager.getString("DetailPage.DetailPage_labelwatch_now_label"));
            addToWatchlist.setText(isInWatchlist ?
                                    sLanguageManager.getString("DetailPage.DetailPage_removeWatchlist") :
                                    sLanguageManager.getString("DetailPage.DetailPage_labeladd_to_watchlist"));

            // Make sure navigation between buttons work as expected.
            this.setButtonNavigation([
                {
                    button: tuneInSport,
                    hidden: (isBlackedOut || !channelIsPermitted ||!channelIsPlayable) ? true : false,
                    greyedOut: userHasPrivilegeToWatchChannel && liveSupported ? false : (userIsLoggedIn || !liveSupported ? true : false)
                },
                {
                    button: watchSport,
                    hidden: vodIsPlayable ? false : true,
                    greyedOut: (!liveSupported && isVodLive) ? true : (userHasPrivilegeToWatchVod ? false : (userIsLoggedIn  ? true : false))
                },
                {
                    button: addToWatchlist,
                    hidden: isBlackedOut ? true : false,
                    greyedOut: false
                }

            ], videoButtonContainer);

            if (!isBlackedOut || vodIsPlayable) {
                detailDescription.setFocusable(false);
            }
            
            // Make sure that a visible button is focused.
            this.focusFirstVisibleComponent([
                tuneInSport,
                watchSport,
                addToWatchlist
            ]);
        },

        __keyHandler: function (evt) {
            switch (evt.id) {
                default:
                return true;
            }
            return false;
        },
        reset: function () {
            var currentView = this.getView(),
                   tuneInSport = currentView.find("sportTuneIn"),
                watchSport = currentView.find("sportStartFromVod"),
                addToWatchlist = currentView.find("addToWatchlist");

            this._super();

            tuneInSport.removeEventListener(evtType.CLICK, this.__tuneInRef);
            watchSport.removeEventListener(evtType.CLICK, this.__watchSportRef);
            addToWatchlist.removeEventListener(evtType.CLICK, this.__addToWatchlistRef);
        }


    });
});
/**
 * Sport home view's template
 * @name sportHome
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/sportHome
 */

define("tvedemo/tmpl/sportHome", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/BasicGrid",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "tvedemo/wgt/AssetGrid",
    "tvedemo/wgt/HighlightsMenu",
    "xdk-ax/Container",
    "storm/mgr/sLanguageManager"
], function (
    Layout,
    Label,
    BasicGrid,
    LoopedGrid,
    AssetGrid,
    HighlightsMenu,
    Container,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            id: "#homeView",
            width: 1,
            alignment: Layout.HORIZONTAL,
            css: "subcontrollerPage sportHome",
            children: [{
                klass: Label,
                id: "homePanelLabel",
                css: "home-panel-label",
                text: sLanguageManager.getString("Sport.Sport_LabelLive").toUpperCase()
            },{
                klass: LoopedGrid,
                alignment: LoopedGrid.VERTICAL,
                scrollFrontBoundary: 1,
                scrollEndBoundary: 3,
                id: "livePlanner",
                css: "home-panel-grid",
                rows: 5,
                cols: 1
            },{
                klass: Container,
                id: "#sportOverlay",
                css: "overlay"
            }/*,{
                klass: Layout,
                alignment: Layout.HORIZONTAL,
                css: "highlightsBar",
                id: "highlightsBar",
                children:[{
                    klass: Label,
                    id: "homePanelHighlightsLabel",
                    css: "home-panel-label",
                    text: sLanguageManager.getString("Sport.Sport_Highlights_Title").toUpperCase()
                },{
                    klass: Container,
                    css: "highlightsMenu",
                    children: [{
                        klass: HighlightsMenu,
                        id: "highlightsMenu"
                    }]
                }]
            }*/,{
                klass: Container,
                id: "#highlightsContainer",
                css: "highlightsContainer",
                children:[{
                    klass: LoopedGrid,
                    id: "highlightGrid",
                    css: "movie-grid",
                    scrollFrontBoundary: 2,
                    scrollEndBoundary: 3,
                    rows: 5,
                    cols: 1,
                    alignment: LoopedGrid.VERTICAL
                }]
            }]
        };
    };
});

/**
 * TV Show Listing view's template
 * @name tvShowsListing
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/tvShowsListing
 */
define("tvedemo/tmpl/tvShowsListing", [
    "xdk-ui-basic/Label",
    "xdk-ui-basic/Layout",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "storm/mgr/sLanguageManager"
], function (
    Label,
    Layout,
    LoopedGrid,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            forwardFocus: true,
            alignment: Layout.VERTICAL,
            css: "subcontrollerPage serie-listing",
            children: [{
                klass: LoopedGrid,
                forwardFocus: true,
                alignment: LoopedGrid.VERTICAL,
                id: "#tvShowAssetGrid",
                rows: 3,
                cols: 2,
                scrollFrontBoundary: 1,
                scrollEndBoundary: 1
            },{
                klass: Label,
                id: "errorMsg",
                css: "error-msg",
                text: sLanguageManager.getString("Global.Global_NoResults")
            }]
        };
    };
});
/**
 * The TV show listing view's controller. Setup the movie listing, category and the sorting.
 * @name TVShowsListing
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/TVShowsListing
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/TVShowsListing", [
    "xdk-base/class",
    "xdk-ax/mvc/view",
    "tvedemo/ctrl/RoutableController",
    "tvedemo/tmpl/tvShowsListing",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ax/data/LocalDatasource",
    "tve/mgr/sLinearManager",
    "tvedemo/wgt/ImageButton",
    "tvedemo/mgr/sAssetManager",
    "xdk-ax/Container",
    "xdk-ax/mediator",
    "xdk-ui-basic/Label",
    "xdk-base/promise",
    "xdk-base/console",
    "storm/helper/util",
    "tvedemo/mgr/sNavigationManager",
    "storm/mgr/sAppConfigManager",
    "storm/mgr/sLanguageManager",
    "tvedemo/wgt/BasicGrid"
], function (
    klass,
    view,
    RoutableController,
    tmpl,
    evtType,
    focusManager,
    vKey,
    util,
    LocalDatasource,
    sLinearManager,
    ImageButton,
    sAssetManager,
    Container,
    mediator,
    Label,
    promise,
    console,
    stormUtil,
    sNavigationManager,
    sAppConfigManager,
    sLanguageManager,
    BoundedGrid
    ) {

    "use strict";

    var GRID_FOCUS_COLUMN = 1;

    return klass.create(RoutableController, {
        // approuter: getDefaultState
        getDefaultState: function () {
            return {
                navigator: null
            };
        }
    }, {
        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        setup: function (context) {
            var prevNavigator = this.context && this.context.navigator;
            this.context = context || {};
            this._assetGrid = this.getView().find("tvShowAssetGrid");
            this._assetGridParent = this._assetGrid._parent;

            this._assetGridHandlerRef = util.bind(this._assetGridHandler, this);
            this._assetGrid.addEventListener(evtType.CLICK, this._assetGridHandlerRef);

            if (context.historyBack === true) {
                if (!this.context.navigator) {
                    this.context.navigator = prevNavigator;
                }
                return;
            }
            this._data = [];
            this.getView().find("errorMsg").hide();
            
            var initPromise;
            if (context.navigator.highlights) {
                initPromise = this._buildMenu(context);
            } else {
                initPromise = this._setupData().then(util.bind(this._setupGrid, this));
            }

            context.setupPending = initPromise.then(util.bind(function() {
                focusManager.focus(this._assetGrid);
            }, this), util.bind(function() {
                this.getView().find("errorMsg").show();
            }, this));
            
            this.trackLevel(2, undefined, true);
        },

        _buildMenu: function(context) {
            var i, hookFct = util.bind(function(index) {
                    return util.bind(function() {
                        if (!this.getView()._parent) {
                            mediator.publish("navigate", {
                                path: "Main/TVShowsListing",
                                state: {
                                    navigator: {
                                        title: context.navigator.title,
                                        highlights: context.navigator.highlights,
                                        index: index,
                                        submenu: this._submenuItems
                                    }
                                }
                            });
                            return;
                        }
                        // SKYSTORM-705: 
                        // Since the menu state was cloned on Controller's arrival (RoutableController._navigationBacktrace()),
                        // when there is no Controller movement, the menu state will not be recorded (to avoid wrong menu recorded).
                        // However some Controllers using insertSubmenu need to record the menu state
                        // even when they are sticking in the same Controller
                        // 
                        // The solution is to record the state of menu while handling the menu on menuitem.action()
                        this.saveMenuState();
                        context.navigator.index = index;
                        return this._setupData().then(util.bind(this._setupGrid, this));
                    }, this);
                }, this);

            this._submenuItems = stormUtil.getSanitizedValue(context, "navigator.submenu");
            if (this._submenuItems) {
                for (i=this._submenuItems.length-1; i>=0; i--) {
                    this._submenuItems[i].action = hookFct(i);
                }
                context.navigator.index = context.navigator.index;
                return this._setupData().then(util.bind(this._setupGrid, this));
            }
            else {
                this._submenuItems = [];
                for (i=0; i<context.navigator.highlights.data.length; i++) {
                    this._submenuItems.push({
                        id: context.navigator.highlights.data[i].category.id,
                        text: i ? context.navigator.highlights.data[i].category.label : sLanguageManager.getString("Sport.Sport_LabelAll").toUpperCase(),
                        action: hookFct(i)
                    });
                }
                return sNavigationManager.insertSubmenu(this._submenuItems, context.navigator.title.toUpperCase(), null, context.navigator.index, true);
            }
        },

        _setupData: function() {
            var _retrieveData = util.bind(function (path) {
                if (this.context.navigator.highlights) {
                    this._data = this.context.navigator.highlights.data[this.context.navigator.index].items;
                    return promise.resolve();   // resolve
                }
                if (!path || !path.length) {
                    console.error("path is empty");
                    return promise.reject("path is empty");
                }
                if (this.context.navigator.id && (this.context.navigator.id.indexOf("ByLexic") !== -1)) {
                    return sLinearManager.getLetterHeaderListing(path).then(function (letterList) {
                        var rootUrl = path.replace(/[^/]*$/, ""),
                            internalPromises = [];
                        util.each(letterList, function (letterItem) {
                            if (!letterItem.linkable) {     // Skip for unlinkable item
                                return;
                            }
                            var targetUrl = rootUrl + letterItem.content.toString() + ".json";
                            internalPromises.push(sLinearManager.getAssetListing(targetUrl).then(function (assetList) {
                                console.log("[TVShowsListing _retrieveData] " + letterItem.content + " data fetched");
                                // attaching catalog inside asset
                                util.each(assetList.listing, function (asset) {
                                    asset.catalog = assetList.catalog;
                                });
                                return assetList.listing;
                            }));
                        });
                        // One single internalPromise will screw the whole function :)
                        return promise.all(internalPromises);
                    }).then(util.bind(function (assetListArray) {
                        this._data = this._data.concat.apply(this._data, assetListArray);
                        console.log("[TVShowsListing _retrieveData] Finish merging data... TotalCount:" + this._data.length);
                        return;     // resolve
                    }, this));
                } else {
                    return sLinearManager.getAssetListing(path).then(util.bind(function (assetList) {
                        // attaching catalog inside asset
                        util.each(assetList.listing, function (asset) {
                            asset.catalog = assetList.catalog;
                        });

                        this._data = assetList.listing;
                        return;     // resolve
                    }, this));
                }
            }, this);
            return _retrieveData(this.context.navigator.url);
        },
        swapAssetGrid: function(len){
            var oldAssetGrid = this._assetGrid;
            this._assetGrid = new BoundedGrid({
                forwardFocus: true,
                alignment: BoundedGrid.VERTICAL,
                id: "#tvShowAssetGrid",
                rows: 2,
                cols: Math.ceil(len / 2)
            });
            
            this._assetGridParent.replace(oldAssetGrid, this._assetGrid);
            this._assetGrid.addEventListener(evtType.CLICK, this._assetGridHandlerRef);
        },
        _setupGrid: function() {
            var ds = stormUtil.arrayToDs(this._data),
                len = this._data.length,
                titleFormatter = function(asset) {
                    var string = "";
                    if (asset.season_nr) {
                        string += "S" + asset.season_nr;
                    }
                    if (asset.episode_nr) {
                        if (string.length) {
                            string += " ";
                        }
                        string += "E" + asset.episode_nr;
                    }
                    if (string.length) {
                        string += ": ";
                    }
                    if (asset.serie_title && asset.serie_title.length) {
                        string += asset.serie_title.toUpperCase();
                    } else if (asset.title && asset.title.length) {
                        string += asset.title.toUpperCase();
                    }
                    if (asset.item_title && asset.item_title.length) {
                        string += asset.item_title.toUpperCase();
                    }
                    return string;
                };

            if(len < 7){
                this.swapAssetGrid(len);
            }
            // we come from the sport page, we already have all the data we need
            if (this.context.navigator.highlights) {
                this._assetGrid[this.context.navigator.index ? "addClass" : "removeClass"]("no-category-tag");
            }

            this._assetGrid.setDisplayStgy(function (asset) {
                var targetImage,
                    view = new Container({
                        forwardFocus: true
                    }),
                    imageButton = new ImageButton({
                        parent: view,
                        placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                    });

                if (!asset.item_preview_image && (!asset.main_picture || !asset.main_picture.picture || !asset.main_picture.picture.length)) {
                    console.warn("Asset does not contain 16:9 images");
                    imageButton.fallback();
                }
                else {
                    if (asset.item_preview_image) {
                        targetImage = asset.item_preview_image;
                    } else {
                        util.each(asset.main_picture.picture, function (image) {
                            if (!image.path || !image.file) {
                                return;
                            }
                            targetImage = image.path+"/"+image.file;
                            if (image.type === "content_2") {   // @TODO: SKYSTORM-233  // @TODO: enumeration/configurable
                                return util.breaker;
                            }
                        });
                    }
                    sLinearManager.constructCMSUrlPromise(targetImage).then(function (url) {
                        imageButton.setSrc(url);
                    });
                }

                var textContainer = new Container({
                    parent: imageButton,
                    css: "textContainer"
                });
                if (asset.item_category_name) {
                    new Label({
                        parent: textContainer,
                        text: asset.item_category_name,
                        css: "category"
                    });
                }
                var label = new Label({
                    parent: textContainer,
                    text: titleFormatter(asset),
                    css: "text"
                });

                return view;
            });
            return this._assetGrid.setDatasource(ds).then(util.bind(function() {
                if(len < 7){
                    this._assetGridParent.addClass("serie-listing-limited");
                    this._assetGrid.addClass("limited-serie");
                } 
            }, this));
        },

        _assetGridHandler: function() {
            var asset = this._assetGrid.getSelectedData();

            switch (asset.type) {
                // @TODO: to be completed
                case "News":
                    mediator.publish("navigate", {
                        path: "Main/News",
                        state: {
                            selectedNewsId: asset.id,
                            selectedNewsCategory: asset.item_category_id
                        }
                    });
                break;
                case "Clip":
                break;
                case "Sport":
                    mediator.publish("navigate", {
                        path: "Main/Sport",
                        state: {
                            assetId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
                case "Film":
                    mediator.publish("navigate", {
                        path: "Main/Movie",
                        state: {
                            assetId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
                case "Series":
                    mediator.publish("navigate", {
                        path: "Main/TVShow",
                        state: {
                            serieId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
                case "Season":
                    mediator.publish("navigate", {
                        path: "Main/TVShow",
                        state: {
                            seasonId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
                default:
                    mediator.publish("navigate", {
                        path: "Main/Episode",
                        state: {
                            selectedEpisodeId: asset.id,
                            catalog: asset.catalog
                        }
                    });
                break;
            }
            return false;
        },
        reset: function () {
            //remove eventlistener and unsubscribe
            this._assetGrid.removeEventListener(evtType.CLICK, this._assetGridHandlerRef);

            this._super();
        }
    });
});
/**
 * The Sport home pages's controller.
 * @name Home
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Home
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/SportHome", [
    "xdk-base/ax",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "xdk-ax/data/LocalDatasource",
    "tvedemo/tmpl/sportHome",
    "storm/mgr/sAppConfigManager",
    "tve/mgr/sVODManager",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/mediator",
    "xdk-ax/mvc/AppRoot",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/promise",
    "tvedemo/ctrl/TVShowsListing",
    "tvedemo/helper/dialogHelper",
    "storm/helper/util",
    "tvedemo/wgt/ConfirmDialog",
    "tvedemo/wgt/HomeGridButton",
    "xdk-base/console",
    "tvedemo/wgt/BasicGrid",
    "tve/sServiceHolder",
    "require",
    "tve/mgr/sLinearManager",
    "tvedemo/mgr/sNavigationManager",
    "tvedemo/helper/sMoment",
    "tvedemo/model/ContextBuilder",
    "storm/mgr/sLinearChannelManager",
    "storm/mgr/sLanguageManager"
], function (
    ax,
    RoutableController,
    view,
    LocalDatasource,
    homeTmpl,
    sAppConfigManager,
    sVODManager,
    util,
    evtType,
    mediator,
    AppRoot,
    focusManager,
    vKey,
    promise,
    TVShowsListing,
    dialogHelper,
    stormUtil,
    ConfirmDialog,
    HomeGridButton,
    console,
    BasicGrid,
    sServiceHolder,
    require,
    sLinearManager,
    sNavigationManager,
    moment,
    ContextBuilder,
    sLinearChannelManager,
    sLanguageManager
    ) {

    "use strict";
    var SPORT_IMAGE_TYPE = "content_2"; // 402 x 226 16:9 image

    var sAppRoot = AppRoot.singleton(),
        LIVE_PLANNER_FOCUS_COLUMN = 1,
        HIGHLIGHTS_FOCUS_COLUMN = 2; // See SKYSTORM-719.

    return ax.klass.create(RoutableController, {}, {

        LIVE_EVENT_DAYS: 7,
        DATE_FORMAT: sLanguageManager.getString("ui.parsing.onAirStartDate"),

        init: function () {
            this.setView(view.render(homeTmpl));
        },

        setup: function (context) {
            var currentView = this.getView();
            this.imageContainer = currentView.find("imageContainer");
            this.livePlanner = currentView.find("livePlanner");
            this.subContainer = currentView.find("highlightsContainer");
            // this.subBar = currentView.find("highlightsBar");
            // this.submenu = currentView.find("highlightsMenu");
            this.highlightGrid = currentView.find("highlightGrid");
            this.overlay = currentView.find("sportOverlay");

            this._keyHandlerRef = util.bind(this.keyHandler, this);
            currentView.addEventListener(evtType.KEY, this._keyHandlerRef);

            this._subContainerHandlerRef =  util.bind(this.subContainerHandler, this);
            // this.submenu.addEventListener(evtType.FOCUS, this._subContainerHandlerRef);
            // this._subMenuBlurRef =  util.bind(this.subMenuBlur, this);
            // this.submenu.addEventListener(evtType.BLUR, this._subMenuBlurRef);

            // this._submenuClickRef = util.bind(this.submenuClick, this);
            // this.submenu.addEventListener(evtType.CLICK, this._submenuClickRef);

            this._livePlannerClickHandlerRef = util.bind(this._livePlannerClickHandler, this);
            this.livePlanner.addEventListener(evtType.CLICK, this._livePlannerClickHandlerRef);

            this._highlightGridClickHandlerRef = util.bind(this._highlightGridClickHandler, this);
            this.highlightGrid.addEventListener(evtType.CLICK, this._highlightGridClickHandlerRef);

            /* if (context.historyBack) {
                if (this.subBar && this.subBar.__expanded) {
                    //sAppRoot.getView().addClass("show-overlay");
                    this.showOverlay();
                }
                return;
            } */

            this._curIndexGrid = 0;
            // save our sport node menu
            this._sportNode = context.navigator.node;

            // let's retrieve all the categories and filter out those we don't want
            this._categories = sServiceHolder.getLinearContentService().getSportHighlightSections(this._sportNode);

            //
            // ReplaysSection is in the excluded list, in case the 'hide' flag is changed server side.
            // We're not confident of our implementation there: SKYSTORM-327, SKYSTORM-294.
            //
            var excludedCategories = ["LiveplannerSection", "ClipSection", "ReplaysSection"];
            this._categories = util.filter(this._categories, util.bind(function(item) {
                return (util.indexOf(excludedCategories, item.structureType) === -1);
            }, this));

            // this.submenu.setItems(this._categories);
            // this.submenu.select(this._curIndexGrid);

            this.livePlanner.setDisplayStgy(function (data) {

                var targetImageURL = null;
                if (!data || !data.main_picture || !data.main_picture.picture || !data.main_picture.picture.length) {
                    console.warn("Asset does not contain 16:9 images");
                }
                else {
                    targetImageURL = data.main_picture.picture[0].path + "/" + data.main_picture.picture[0].file;

                    util.each(data.main_picture.picture, function (imageJSON) {
                        if (!imageJSON.path || !imageJSON.file) {
                            return;
                        }
                        if (imageJSON.type === SPORT_IMAGE_TYPE) {   // @TODO: SKYSTORM-233  // @TODO: enumeration/configurable
                            targetImageURL = imageJSON.path + "/" + imageJSON.file;
                            return util.breaker;
                        }
                    });
                }

                return new HomeGridButton({
                    id: data.id,
                    title: data.title,
                    category: data.category && data.category.main ? data.category.main.content : null,
                    period: data.on_air.start_time + "-" + data.on_air.end_time,
                    image: targetImageURL,
                    channelImage: data.logo,
                    channelColour: data.package_code
                });
            });

            this.highlightGrid.setDisplayStgy(util.bind(function (data) {
                var curItem = data.items[0];
                return new HomeGridButton({
                    id: curItem.id,
                    title: curItem.item_title,
                    category: curItem.item_category_name,
                    period: this._formatSportDate(curItem.item_Create_Date),
                    image: curItem.item_preview_image,
                    channelColour: curItem.package_code
                    //channelImage: curItem.item_category_icon
                });
            }, this));

            context.setupPending = stormUtil.allPromises([this.setupLivePlanner(context), this.updateHighlightGrid(0)]);
        },

        _formatSportDate: function(dateStr) {
            if (!util.isString(dateStr) || !dateStr.length) {
                return "";
            }
            var date = moment(dateStr, sLanguageManager.getString("ui.parsing.newsDate"));
            return date.format(sLanguageManager.getString("ui.format.highlightNewsTime"));
        },

        setupLivePlanner: function (context) {
            return promise.all([
                sServiceHolder.getDateTimeService().getServerDateTime(),
                sServiceHolder.getLinearContentService().getSportLivePlannerPromise(context.navigator.node)
            ]).spread(util.bind(function(date, jsonObj) {
                var assets = stormUtil.getSanitizedValue(jsonObj, "listing.listing.asset") || [];
                if (assets.length) {
                    // filter live planner events to the next LIVE_EVENT_DAYS days only
                    var endDate = moment(date).add(this.LIVE_EVENT_DAYS, "day"),
                        k=0;
                    while (k<assets.length && moment(assets[k].on_air.start_date, this.DATE_FORMAT).diff(endDate, "days") < 0) {
                        if (!assets[k].catalog) {
                            // Transcribe the list's catalog onto each asset, if required...
                            assets[k].catalog = jsonObj.product;
                        }
                        k++;
                    }
                    assets = assets.slice(0, k);
                }
                if (!assets.length) {
                    this.livePlanner.setOption("focusable", false);
                    this.subBar.setOption("nextUp", "header");
                }
                return this.livePlanner.setDatasource(stormUtil.arrayToDs(assets)).then(util.bind(function(){
                    this.livePlanner.select(0, LIVE_PLANNER_FOCUS_COLUMN); // Zeroth data to appear in a specific column.
                }, this));
            }, this));
        },

        updateHighlightGrid: function (index) {
            if (!this._categories || this._categories.length <= index) {
                return promise.resolve();
            }

            this._curIndexGrid = index;

            return sServiceHolder.getLinearContentService().getSportHighlightPromise(this._sportNode, this._categories[index].structureType).then(util.bind(function(data) {
                var ds, dataSource;

                this._highlights = data;

                //clear the current content in the grid
                this.highlightGrid._data = null;
                this.highlightGrid._ds = null;

                // SKYSTORMPLAYSTN-37: remove redudant memory usage on long data, since they are not displayed on grid.
                dataSource = data.displayFirstChild ? data.data : data.data.slice(1);
                for (var i = 0, len = dataSource.length; i < len; i++) {
                    dataSource[i].items = [dataSource[i].items[0]];
                }

                //set the data source in the grid
                ds = stormUtil.arrayToDs(dataSource);

                return this.highlightGrid.setDatasource(ds).then(util.bind(function(){
                    this.highlightGrid.select(0, HIGHLIGHTS_FOCUS_COLUMN); // Zeroth data to appear in a specific column.
                }, this));
            }, this));
        },

        _livePlannerClickHandler: function() {
            var asset = this.livePlanner.getSelectedData();
            if (asset && asset.event_id) {
                mediator.publish("navigate", {
                    path: "Main/Sport", // @TODO: Check if this is the right one. Do we really need a multiplicity of details page types?
                    state: {
                        assetId: asset.id,
                        catalog: asset.catalog
                    }
                });
            }
        },

        _highlightGridClickHandler: function() {
            mediator.publish("navigate", {
                path: "Main/TVShowsListing",
                state: {
                    navigator: {
                        title: this._categories[this._curIndexGrid].text,
                        highlights: this._highlights,
                        index: this.highlightGrid.getSelectedDsIndex() + (this._highlights.displayFirstChild ? 0 : 1)
                    }
                }
            });
        },

        subContainerHandler: function (e) {
            /*
            if (e.relatedTarget._parent.getId() !== "highlightsMenu" //the previous focused element is not an item from the highlights menu
                && e.target._parent.getId() === "highlightsMenu" //the target is an item from the highlights menu
                && e.target._label._root._dom.innerHTML != this._categories[2] //the target is not the "Movies" item
                && e.target._parent._children[2]._label._root._dom.innerHTML === this._categories[2] //the item 2 in the highlights menu is the "Movies" item
            ){
                focusManager.focus(e.target._parent._children[2]); //focus the "Movies" item
            }
            */

            if (e.target._parent.getId() === "highlightsMenu"){ //the target is an item from the highlights menu
                this.setHighlightsMenuExpanded(true);
            }

        },

        submenuClick: function(e){
            if (this._curIndexGrid !== this.submenu.getSelectedIndex()) {
                this.updateHighlightGrid(this.submenu.getSelectedIndex());
            }
        },

        subMenuBlur: function (e) {
            console.log(e.relatedTarget);
            if (!e.relatedTarget.isDescendantOf(this.subContainer)) {
                //Contracts the highlights menu when focusing away from it
                this.setHighlightsMenuExpanded(false);
            }
        },

        setHighlightsMenuExpanded: function(state) {
            if (state) {
                if (!this.subBar.__expanded) {
                    this.subBar.addClass("focused");
                    this.subContainer.addClass("focused");
                    //sAppRoot.getView().addClass("show-overlay");
                    this.showOverlay();
                    this.subBar.__expanded = true;
                }
            } else {
                if (this.subBar.__expanded) {
                    this.subBar.removeClass("focused");
                    this.subContainer.removeClass("focused");
                    //sAppRoot.getView().removeClass("show-overlay");
                    this.hideOverlay();
                    this.subBar.__expanded = false;
                }
            }
        },

        showOverlay: function() {
            this.overlay.addClass("visible");
        },

        hideOverlay: function() {
            this.overlay.removeClass("visible");
        },

        keyHandler: function (evt) {
            /*switch (evt.id) {
            case vKey.UP.id:
                //Automatically select the first item in the movie grid when pressing up from the movie grid
                //Automatically focus the selected item in the Highlights menu
                if (focusManager.getCurFocus().getParent() === this.submenu) {
                    //this.highlightGrid.select(0);
                    focusManager.focus(this.submenu.getChildren()[this.submenu.getSelectedIndex()]);
                }
                else {
                    this.setHighlightsMenuExpanded(false);
                    return true;
                }
                break;
            default:
                return true;
            }*/
            return true;
        },

        reset: function () {
            if (this.subBar && this.subBar.__expanded) {
                //sAppRoot.getView().removeClass("show-overlay");
                this.hideOverlay();
            }

            this.getView().removeEventListener(evtType.KEY, this._keyHandlerRef);
            /* this.submenu.removeEventListener(evtType.FOCUS, this._subContainerHandlerRef);
            this.submenu.removeEventListener(evtType.BLUR, this.__boundSubMenuBlur);
            this.submenu.removeEventListener(evtType.CLICK, this._submenuClickRef); */
            this.livePlanner.removeEventListener(evtType.CLICK, this._livePlannerClickHandlerRef);
            this.highlightGrid.removeEventListener(evtType.CLICK, this._highlightGridClickHandlerRef);

            this._super();
        }
    });
});

/**
 * Text view's template
 * @name text
 * @memberof tvedemo/tmpl
 * @class tvedemo/tmpl/textpage
 */
define("tvedemo/tmpl/textpage", [
    "xdk-ui-basic/Layout", 
    "xdk-ui-basic/Label",
    "tvedemo/wgt/ScrollLabel"
], function (
    Layout,
    Label, 
    ScrollLabel
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            id: "#textpageView",
            css: "subcontrollerPage",
            width: 1,
            alignment: Layout.VERTICAL,
            children: [{
                klass: Layout,
                children: [{
                    klass: Label,
                    css: "title",
                    id: "title",
                    text: "&nbsp;"
                },{
                    klass: ScrollLabel,
                    id: "scrollableField",
                    css: "scrollable-field",
                    scrollStep: 108             
                }]
            }]
        };
    };
});
/**
 * The Text Page view's controller.
 * @name TextPage
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/TextPage
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/TextPage", [
    "xdk-base/ax",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/textpage",
    "storm/mgr/sAppConfigManager",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-ax/mediator",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sEulaManager",
    "storm/mgr/sLegalTextManager",
    "tvedemo/mgr/sEndUserManager",
    "storm/event/UserEvent"
], function (
    ax,
    RoutableController,
    view,
    textPageTmpl,
    sAppConfigManager,
    util,
    evtType,
    focusManager,
    mediator,
    sLanguageManager,
    sEulaManager,
    sLegalTextManager,
    sEndUserManager,
    UserEvent
    ) {

    "use strict";

    // id of the menu item -> corresponding promise returning some legal text
    var TEXT_PAGES = {
        "eula": sEulaManager.getEula,
        "imprint": sLegalTextManager.getImpressum,
        "dataPrivacy": sLegalTextManager.getPrivacy,
        "tnc": sLegalTextManager.getTermsForReview
    };

    return ax.klass.create(RoutableController, {
        getDefaultState: function() {
            return {
                __forceReload: true
            };
        }
    }, {

        init: function () {
            this.setView(view.render(textPageTmpl));
        },

        setup: function (context) {

            this.__handleUserDataUpdate = util.bind(function () {
                this.setupInformation(context);

            }, this);

            mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            this.setupInformation(context);
        },

        setupInformation: function (context) {
            var currentView = this.getView(),
                titleLabel = currentView.find("title"),
                scrollableField = currentView.find("scrollableField"),
                nav = context && context.navigator || {},
                optionalCountryCode;
                    

            sEndUserManager.getLoggedInUser().then(function (currentUser) {

                optionalCountryCode = currentUser && currentUser.get("country");

                TEXT_PAGES[nav.id] && TEXT_PAGES[nav.id](optionalCountryCode).then(function(model) {

                    if (model && model.get) {

                        var body = model.get("body");

                        // If we are showing impressum we want to show UI version and try to style it similar to the rest of impressum text.
                        if (nav.id === "imprint") {
                            var findFontSize = /font-size: (\w+);/,
                                fontSizeMatch = body.match(findFontSize),
                                fontSize = "font-size: medium;",
                                fontSizeReplace,
                                findFontColor = /color: rgb\((\d+), (\d+), (\d+)\);/,
                                fontColorMatch = body.match(findFontColor),
                                fontColor = "color: rgb(153, 153, 153);",
                                fontColorReplace;

                            if (fontSizeMatch && fontSizeMatch.length > 0) {
                                fontSizeReplace = fontSize.replace(fontSize, fontSizeMatch[0])
                                
                                if (fontSizeReplace && fontSizeReplace !== "undefined") {
                                    fontSize = fontSizeReplace;
                                }
                            }

                            if (fontColorMatch && fontColorMatch.length > 0) {
                                fontColorReplace = fontColor.replace(fontColor, fontColorMatch[0])
                                
                                if (fontColorReplace && fontColorReplace !== "undefined") {
                                    fontColor = fontColorReplace;
                                }
                            }                            

                            body = "<p><span style=\"" + fontSize + fontColor + "\">UI version: " + ax.config.get("version") + "</span></p>" + body;
                        }

                        titleLabel.setText(model.get("title"));
                        scrollableField.setText(body);
                        
                        this.trackPage(model.get("title"));
                    }
                });

                focusManager.focus(currentView);
            });
        },

        reset: function () {
            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            this._super();
        }
    });
});
/**
 * TV Show details view's template
 * @name tvShow
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/tvShow
 */
define("tvedemo/tmpl/tvShow", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/wgt/Submenu",
    "tvedemo/wgt/AssetGrid",
    "storm/wgt/Image",
    "xdk-ax/Container",
    "tvedemo/wgt/ImageButton",
    "tvedemo/wgt/ScrollLabel",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sAppConfigManager"
], function (
    Layout,
    Label,
    Submenu,
    AssetGrid,
    Image,
    Container,
    ImageButton,
    ScrollLabel,
    sLanguageManager,
    sAppConfigManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            alignment: Layout.VERTICAL,
            id: "#tvshow",
            children: [{
                klass: Container,
                id: "#tvshowUpperContainer",
                children: [{
                    klass: Image,
                    id: "#thumbnail",
                    placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                }, {
                    klass: Layout,
                    id: "#blackoutMessageContainer",
                    children: [{
                        klass: Label,
                        id: "#blackoutMessage"
                    }]
                }, {
                    klass: Container,
                    css: "informationContainer",
                    children: [{
                        klass: Container,
                        css: "title-positioner",
                        children: [{
                            klass: Label,
                            id: "#title"
                        }, {
                            klass: Label,
                            id: "#seasonLabel"
                        }]
                    }, {
                        klass: Layout,
                        id: "#metaDataContainer",
                        alignment: Layout.HORIZONTAL
                    }, {
                        klass: Image,
                        id: "#channelLogo"
                    }, {
                        klass: Container,
                        id: "missingPackage",
                        css: "missingPackage",
                        children: [{
                            klass: Image,
                            id: "missingPackageLogo",
                            css: "missingPackageLogo"
                        }, {
                            klass: Label,
                            id: "missingPackageText",
                            css: "missingPackageText"
                        }]
                    }]
                }]
            }, {
                klass: Layout,
                alignment: Layout.HORIZONTAL,
                id: "#serieButtonContainer",
                children: [{
                    klass: ImageButton,
                    id: "addToWatchlist",
                    text: "",
                    nextDown: "seasonSelectionButtonContainer",
                    nextRight: "detailDescription"
                }]
            }, {
                klass: Layout,
                alignment: Layout.HORIZONTAL,
                id: "#seasonSelectionButtonContainer",
                children: [{
                    klass: Label,
                    id: "navigate-seasons",
                    css: "navigate-seasons",
                    text: sLanguageManager.getString("DetailPage.DetailPage_labelNavigateSeasons")
                },{
                    klass: ImageButton,
                    id: "previousSeasonButton",
                    css: "previousSeason",
                    text: "",
                    nextLeft: "previousSelectionButton",
                    nextRight: "nextSeasonButton",
                    nextDown: "seasonEpisodesGrid"
                }, {
                    klass: ImageButton,
                    id: "nextSeasonButton",
                    css: "nextSeason",
                    text: "",
                    nextLeft: "previousSelectionButton",
                    nextRight: "detailDescription",
                    nextDown: "seasonEpisodesGrid"
                }]
            }, {
                klass: ScrollLabel,
                id: "detailDescription",
                css: "serie-description",
                scrollStep: 108,
                nextLeft: "addToWatchlist",
                nextRight: "detailDescription",
                nextDown: "seasonEpisodesGrid",
                nextUp: "header"
            }, {
                klass: Label,
                id: "#episodesGridLabel"
            }, {
                klass: AssetGrid,
                id: "#seasonEpisodesGrid",
                focusable: true,
                rows: 1,
                cols: 4,
                button: {
                    showEpisodeNumber: true,
                    icon: true
                },
                nextUp: "seasonSelectionButtonContainer",
                nextDown: "seasonEpisodesGrid"
            }]
        };
    };
});
/**
 * TVSeasonSelectionDialog extends {@link tvedemo/wgt/TextSelectionListDialog} to provide a dialog for the user to select a TV season.
 * Each entry consists of a thumbnail of the TV season and the season number of it.
 *
 * @name TVSeasonSelectionDialog
 * @class tvedemo/wgt/TVSeasonSelectionDialog
 * @extend tvedemo/wgt/TextSelectionListDialog
 */
define("tvedemo/wgt/TVSeasonSelectionDialog", [
    "xdk-base/class", "xdk-base/util", "xdk-ax/Container", "tvedemo/wgt/TextSelectionListDialog",
    "storm/helper/util", "xdk-ui-basic/Label", "tvedemo/wgt/ImageButton",
    "tvedemo/wgt/TextSelectionList", "tve/mgr/sVODManager", "xdk-base/console"
], function (klass, util, Container, TextSelectionListDialog,
    helperUtil, Label, ImageButton,
    TextSelectionList, sVODManager, console) {

    return klass.create(TextSelectionListDialog, {}, {
        init: function (opts) {
            opts = opts || {};
            opts.size = opts.size || 3;
            opts.headerText = opts.headerText || "Select Season";

            this._super(opts);

            this.addClass("wgt-seasons-dialog");
        },
        _createList: function (opts) {
            var list = new TextSelectionList({
                id: "list",
                rows: opts.size
            });

            list.setDisplayStgy(function (season) {
                var button = new ImageButton({
                    css: "season-option",
                    text: "Season " + season.get("seasonNumber")
                });

                sVODManager.getTVSeasonThumbnail(season).then(function (thumbnail) {
                    button.setSrc(thumbnail.get("url"));
                }).fail(function (reason) {
                    console.warn("[TVSeasonSelectionDialog] fail to get thumbnail for season " + season.get("seasonNumber") + ": " + reason);
                }).done();

                return button;
            });

            return list;
        }
    });
});
/**
 * The scrolling Label consist of label and scroll bar. It will automactically scroll when focused and scroll back to the top when blur.
 * @name ScrollingLabel
 * @memberof tvedemo/wgt
 * @class tvedemo/wgt/ScrollingLabel
 * @extends ax/ext/ui/Container
 */
define("tvedemo/wgt/ScrollingLabel", [
    "xdk-base/class", "xdk-ui-basic/AbstractScrollable", "xdk-base/util",
    "xdk-ui-basic/Label", "xdk-ui-basic/Scrollbar", "xdk-base/Element",
    "xdk-ax/evt/type", "xdk-base/cssUtil", "xdk-ui-basic/ScrollingMediator",
    "xdk-base/console"
], function (klass, AbstractScrollable, util,
    Label, Scrollbar, Element,
    evtType, cssUtil, ScrollingMediator,
    console) {

    cssUtil.addCss(".wgt-scrollingLabel .container{\
                        position: absolute;\
                        overflow:hidden;\
                    }\
                    .wgt-scrollingLabel .text{\
                        position:absolute;\
                        top:0px;\
                    }");

    return klass.create(AbstractScrollable, {}, {

        //Store the label
        __label: null,

        //Store the label container which will be measured the height of this container and label height
        __labelContainer: null,

        //Store the scrollbar
        __scrollbar: null,

        //Store the status
        __inited: false,

        // auto scroll flag
        __auto: true,

        //Check if the scrolling label is scrolling
        __processing: false,

        // flag to indicate whether the auto-scroll has been stopped
        __stopped: true,

        //The scrollable container height
        __containerHeight: 0,

        //The label height
        __labelHeight: 0,

        //check the label is able to scroll or not
        __scrollable: false,

        //the maximum step to scroll
        __maxStep: 0,

        // each step size
        __stepSize: 0,

        // time to wait before the subsequent scroll
        __interval: 5,

        // id of the util delay
        __delayId: "",

        // the action to perform when the transition end
        __bindedTransitionEndAction: function () {},

        /**
         * Overrides parent init() function.
         * @method init
         * @override
         * @protected
         * @param {Object} [opts] Options
         * @param {String} [opts.text=""] the text to display inside the label
         * @param {Number} [opts.scrollStep=50] the length to scroll for each step in pixel
         * @param {Number} [opts.scrollSecond=1] the duration of the scroll, in seconds
         * @param {Number} [opts.interval=5] the interval before 2 consecutive scrolls in seconds
         * @param {Boolean} [opts.autoScroll=true] auto-scroll while on focus
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        init: function (opts) {
            var mediator = new ScrollingMediator(),
                scrollSecond,
                text;

            opts = opts || {};
            opts.focusable = true;
            opts.root = new Element("div");

            text = opts.text || "";
            scrollSecond = opts.scrollSecond || 1;
            this.__stepSize = opts.scrollStep || 50;
            this.__interval = opts.interval || 5;
            this.__auto = util.isUndefined(opts.autoScroll) ? true : opts.autoScroll;

            // generate an id for util.delay
            this.__delayId = "scrollDelay" + opts.id + Math.floor(Math.random() * 1000);

            this._super(opts);

            this.getRoot().addClass("wgt-scrollingLabel");

            //add a scroll container for scrolling text
            this.__labelContainer = new Element("div").addClass("container");
            this.getRoot().append(this.__labelContainer);

            this.__label = new Label({
                parent: this
            });

            //set it to be text class only
            this.__label.getRoot().setClass("text");

            this.__scrollbar = new Scrollbar({
                css: "scrollbar",
                parent: this
            });

            this.setText(text);

            //update the position
            this.addEventListener(evtType.ATTACHED_TO_DOM, util.bind(this.__attachToDom, this));
            this.addEventListener(evtType.DETACHED_FROM_DOM, util.bind(this.__detachFromDom, this));

            //set css animation
            this.__label.getRoot().getHTMLElement().style.transition = "top " + scrollSecond + "s ease-in-out";
            this.__scrollbar._nodeTable.getHTMLElement().style.transition = "top " + scrollSecond + "s ease-in-out";

            this.__label.getRoot().getHTMLElement().style.webkitTransition = "top " + scrollSecond + "s ease-in-out";
            this.__scrollbar._nodeTable.getHTMLElement().style.webkitTransition = "top " + scrollSecond + "s ease-in-out";

            // add animation to make it to keep runing
            this.__bindedTransitionEndAction = util.bind(function () {
                if (!this.__stopped) {
                    this.start();
                }
            }, this);

            this.__bindedTransitionEndFlagControl = util.bind(function () {
                this.__processing = false;
            }, this);

            mediator.registerIndicator(this.__scrollbar);
            mediator.setScrollable(this);

            this.__inited = true;
        },
        /**
         * Set the text to be displayed on the label.
         * @method
         * @param {String} text the text to set
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        setText: function (text) {
            this.__label.setText(text);
            //update the size when setText after inited. If it is in inited stage, it will update when attach to dom
            if (this.__inited) {
                //scroll to back immediately.
                this.__updateSize();
                this._scrollTo(0);
            }
        },
        /**
         * Get the text in the label.
         * @method
         * @returns {String} the text
         * @memberOf tvedemo/wgt/ScrollingLabel#
         */
        getText: function () {
            return this.__label.getText();
        },
        /**
         * Start auto scrolling.
         * @method
         * @public
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        start: function () {
            this.__stopped = false;
            util.clearDelay(this.__delayId);
            this.__label.getRoot().getHTMLElement().addEventListener("webkitTransitionEnd", this.__bindedTransitionEndAction);

            util.delay(this.__interval, this.__delayId).then(util.bind(function () {
                this.scroll();
            }, this));
        },
        /**
         * Perform the actual scroll on the label.
         * This function will detect the current position and decide the next target position.
         * @method
         * @param {Boolean} [downward=true] True if scroll downward, false if scroll upward
         * @memberOf tvedemo/wgt/ScrollingLabel#
         */
        scroll: function (downward) {
            if (!this.__scrollable) {
                console.info("Abort the scroll: The content is fit into the label, no scroll is needed.");
                return;
            }

            if (this.__processing) {
                console.info("Abort the scroll: Another scroll is in progress.");
                return;
            }

            // currentPosition would be a non-positive number
            var currentPosition = parseInt(this.__label.getRoot().getHTMLElement().offsetTop, 10),
                size = this.__stepSize,
                targetPosition;

            downward = util.isUndefined(downward) ? true : downward;
            targetPosition = currentPosition + (downward ? -size : size);

            if (targetPosition >= 0) {
                // scroll upward and exceed the boundary
                this._scrollTo(0);
            } else if (targetPosition > this.__maxStep) {
                // normal scrolling case
                this._scrollTo(targetPosition);
            } else {
                if (currentPosition !== this.__maxStep) {
                    // if the target < the bottom boundary, scroll to the boundary
                    this._scrollTo(this.__maxStep);
                } else if (!this.__stopped) {
                    // target == bottom boundary from auto-scroll, bound back to 0
                    this._scrollTo(0);
                }
            }
        },
        /**
         * Stop auto scrolling.
         * @method
         * @public
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        stop: function () {
            this.__stopped = true;
            util.clearDelay(this.__delayId);
            this.__label.getRoot().getHTMLElement().removeEventListener("webkitTransitionEnd", this.__bindedTransitionEndAction);
        },
        /**
         * Reset the position to 0.
         * @method
         * @memberOf tvedemo/wgt/ScrollingLabel#
         */
        reset: function () {
            this._scrollTo(0);

            if (!this.__stopped) {
                this.start();
            }
        },
        /**
         * Get the label position.
         * @method
         * @private
         * @returns {Number} the position
         * @memberOf tvedemo/wgt/ScrollingLabel#
         */
        __getPosition: function () {
            return parseInt(this.__label.getRoot().getHTMLElement().offsetTop, 10);
        },
        /**
         * Scroll to the specific position.
         * @method
         * @protected
         * @param {Number} targetPosition The target position of the label
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        _scrollTo: function (targetPosition) {
            var currentPosition = this.__getPosition();
            if (currentPosition === targetPosition) {
                console.info("Abort the scroll: Label is at target position.");
                return;
            }

            this.__label.getRoot().css("top", targetPosition + "px");
            this.dispatchScrolledInfo(-targetPosition, this.__containerHeight, this.__labelHeight);

            this.__processing = true;
        },
        /**
         * To get the size when attached to dom
         * @method __attachToDom
         * @private
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        __attachToDom: function () {
            this.__updateSize();

            if (this.__auto) {
                this.__focus = util.bind(function () {
                    this.start();
                }, this);

                this.__blur = util.bind(function () {
                    this.stop();
                    this.reset();
                }, this);

                // add event listener to start scroll when focus
                this.addEventListener(evtType.FOCUS, this.__focus);

                // add event listener to stop scroll when blur
                this.addEventListener(evtType.BLUR, this.__blur);
            }


            this.__label.getRoot().getHTMLElement().addEventListener("webkitTransitionEnd", this.__bindedTransitionEndFlagControl);
        },
        /**
         * To remove the event listener and pause further scroll
         * @method __detachFromDom
         * @private
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        __detachFromDom: function () {
            var domObject = this.__label.getRoot().getHTMLElement();

            this.__stopped = true;
            this.__processing = false;
            this.removeEventListener(evtType.FOCUS, this.__focus);
            this.removeEventListener(evtType.BLUR, this.__blur);
            domObject.removeEventListener("webkitTransitionEnd", this.__bindedTransitionEndAction);
            domObject.removeEventListener("webkitTransitionEnd", this.__bindedTransitionEndFlagControl);
        },
        /**
         * To append the label into the container
         * @method  _doAttach
         * @override
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        _doAttach: function (child, placement, marker) {
            //To ensure the structure of the scrolling label.
            if (this.__inited) {
                console.info("Unavailable to append more children after inited.");
                return;
            }
            var parent = this._root;

            //attach the label to the scroll container
            if (child instanceof Label) {
                parent = this.__labelContainer;
            }

            switch (placement) {
            case AbstractScrollable.PLACE_APPEND:
                parent.append(child.getRoot());
                break;
            case AbstractScrollable.PLACE_PREPEND:
                parent.prepend(child.getRoot());
                break;
            case AbstractScrollable.PLACE_BEFORE:
                parent.insertBefore(marker.getRoot(), child.getRoot());
                break;
            case AbstractScrollable.PLACE_AFTER:
                parent.insertAfter(marker.getRoot(), child.getRoot());
                break;
            }
        },
        /**
         * To update the container size
         * @method  __updateSize
         * @private
         * @memberof tvedemo/wgt/ScrollingLabel#
         */
        __updateSize: function () {
            this.__labelHeight = this.__label.getRoot().getHTMLElement().offsetHeight;
            this.__containerHeight = this.__labelContainer.getHTMLElement().offsetHeight;

            //to determine whether can scroll
            if (this.__labelHeight > this.__containerHeight) {
                this.__scrollable = true;
                this.__scrollbar.show();
                this.dispatchScrolledInfo(0, this.__containerHeight, this.__labelHeight);
            } else {
                this.__scrollable = false;
                this.__scrollbar.hide();
            }

            this.__maxStep = -(this.__labelHeight - this.__containerHeight);
        }
    });
});
define("tvedemo/wgt/InfoDialog", [
    "xdk-base/class", "fix/Dialog", "xdk-base/util",
    "xdk-ax/Container", "xdk-ax/evt/type", "xdk-ui-basic/Button",
    "tvedemo/wgt/ScrollingLabel", "tvedemo/wgt/Footer", "tvedemo/wgt/FooterIconMap",
    "xdk-ax/focusManager", "xdk-base/device/vKey", "xdk-ui-basic/Image"
], function (klass, Dialog, util,
    Container, evtType, Button,
    ScrollingLabel, Footer, FooterIconMap,
    focusManager, vKey, Image) {

    return klass.create(Dialog, {}, {
        _footer: null,
        _scrollingLabel: null,
        _arrowUp: null,
        _arrowDown: null,

        init: function (opts) {
            opts = opts || {};

            opts.title = opts.title || "Info.";

            var button = new Button({
                css: "wgt-infodialog-button",
                text: opts.buttonText || "OK"
            });

            this._footer = new Footer({
                css: "footer",
                iconSet: FooterIconMap.DIALOG
            });

            this._scrollingLabel = new ScrollingLabel({
                css: "wgt-dialog-message",
                text: opts.message,
                scrollStep: 450,
                scrollSecond: 0.5,
                autoScroll: false
            });

            this._arrowUp = new Image({
                css: "arrow up"
            });

            this._arrowDown = new Image({
                css: "arrow down"
            });

            opts.content = new Container({
                forwardFocus: button,
                children: [
                    this._arrowUp,
                    this._scrollingLabel,
                    this._arrowDown,
                    button
                ]
            });

            opts.footer = new Container({
                css: "footer-container",
                children: [this._footer]
            });

            opts.forwardFocus = button;

            // set footer
            this._footer.update({
                arrowUpDown: "Move",
                enter: "Select",
                back: "Back"
            });

            this._super(opts);
            this.addClass("wgt-infodialog");

            button.addEventListener(evtType.CLICK, util.bind(this.close, this));
            this.addEventListener(evtType.KEY, util.bind(this._onKey, this));
        },

        open: function () {
            if (this._isOpen) {
                return;
            }

            this._super();

            // remember the last focus, that can be resumed after the dialog is closed
            this._lastFocus = focusManager.getCurFocus();

            // to ensure the focus is button instead of footer (which is overwrite in the dialog widget)
            this.setOption("forwardFocus", this.getOption("content"));

            // to ensure open has focus on the alert dialog
            focusManager.focus(this);
        },

        close: function () {
            this._super();
            this.deinit();
        },

        _onKey: function (evt) {
            switch (evt.id) {
            case vKey.UP.id:
                this._scrollingLabel.scroll(false);
                break;
            case vKey.DOWN.id:
                this._scrollingLabel.scroll();
                break;
            default:
                return true;
            }

            return false;
        }
    });

});
/**
 * The TV shows details view's controller. Setup the show's infomation, its episodes listing and related actions.
 * @name TVShow
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/TVShow
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/TVShow", [
    "xdk-base/ax",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/tvShow",
    "tve/mgr/sVODManager",
    "xdk-base/util",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-ax/mediator",
    "xdk-base/device/vKey",
    "tvedemo/helper/sMoment",
    "xdk-ui-basic/Label",
    "xdk-base/promise",
    "tvedemo/helper/dialogHelper",
    "tvedemo/mgr/sEndUserManager",
    "storm/helper/util",
    "xdk-base/console",
    "tve/TVEError",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/wgt/EpisodeButton",
    "tvedemo/wgt/TVSeasonSelectionDialog",
    "tvedemo/wgt/InfoDialog",
    "tvedemo/mgr/sAssetManager",
    "storm/mgr/sLanguageManager",
    "tvedemo/ctrl/DetailsBase",
    "storm/mgr/sAppConfigManager",
    "storm/event/UserEvent",
    "xdk-ax/evt/eventManager",
    "tvedemo/wgt/Loading"
], function (
    ax,
    view,
    tvShow,
    sVODManager,
    util,
    evtType,
    focusManager,
    mediator,
    vKey,
    moment,
    Label,
    promise,
    dialogHelper,
    sEndUserManager,
    tvedemoUtil,
    console,
    TVEError,
    sHistoryManager,
    EpisodeButton,
    TVSeasonSelectionDialog,
    InfoDialog,
    sAssetManager,
    sLanguageManager,
    DetailsBase,
    sAppConfigManager,
    UserEvent,
    evtMgr,
    sLoading) {

    "use strict";

    return ax.klass.create(DetailsBase, {
        getDefaultState: function () {
            return {};
        }
    }, {
        __tvShow: null,
        _currentlySelectedSeason: 0,

        _grid: null,

        init: function () {
            this._super();
            this.setView(view.render(tvShow));
        },

        setup: function (context) {
            this._super(context);

            var currentView = this.getView();
            this._grid = currentView.find("seasonEpisodesGrid");

            //update the footer
            mediator.publish("footerUpdate", {
                colorGreen: "Search",
                arrowAll: "Move",
                enter: "Select",
                back: "Back"
            });

            //grid handling
            this.__gridClickHandler = util.bind(this._gridClickHandler, this);
            this._grid.addEventListener(evtType.CLICK, this.__gridClickHandler);

            this._setupButtons();

            this.__handleUserDataUpdate = util.bind(function () {

                // Update buttons and entitlement indication according to the users new data.
                if (this.__tvShow) {
                    this._displayAsset(this.__tvShow);
                }

            }, this);

            mediator.subscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);

            if (context.historyBack) {
                this._displayAsset(this.__tvShow);
                return;
            }

            var startupPromise;

            // if we're provided a season Id, we will fetch the season asset and then proceed with it's corresponding serieId
            if (context.seasonId) {
                startupPromise = sAssetManager.getSeasonAssetById(context.seasonId, context.catalog).then(util.bind(function(asset) {
                    // -1 because _currentlySelectedSeason is the index of the currently selected season, from the seasons array
                    this._currentlySelectedSeason = asset.get("seasonNumber") - 1;
                    return this._displayContent(asset.get("serieId"), context.catalog);
                }, this));
            } else {
                startupPromise = this._displayContent((context.serieId)?context.serieId:context.assetId, context.catalog);
            }

            context.setupPending = startupPromise;

        },

        _setupButtons: function () {
            var currentView = this.getView(),
                addToWatchlistButton = currentView.find("addToWatchlist"),
                previousSeasonButton = currentView.find("previousSeasonButton"),
                nextSeasonButton = currentView.find("nextSeasonButton");

            this.__addToWatchlistReference = util.bind(function () {
                var currentSeason = this.__tvShow.get("seasons") && this.__tvShow.get("seasons")[this._currentlySelectedSeason],
                    currentSeasonEpisodes = currentSeason && currentSeason.get("episodes"),
                    episodeIds = "";

                    util.each(currentSeasonEpisodes, function (episode, episodeIndex) {

                        episodeIds += episode.get("id");

                        if (episodeIndex < currentSeasonEpisodes.length - 1) {
                            episodeIds += ",";
                        }

                    });

                this.__updateWatchList({
                    remove: this.__detailInformation.isInWatchlist ? true : false,
                    add: this.__detailInformation.isInWatchlist ? false : true,
                    catalog: this.__tvShow.get("catalog"),
                    assetId: episodeIds,
                    assetType: sAssetManager.ASSET_TYPES.EPISODE
                })
                .then(util.bind(function (successFully) {

                    if (successFully.added) {
                        this.__detailInformation.isInWatchlist = true;

                    } else if (successFully.removed) {
                            this.__detailInformation.isInWatchlist = false;
                    }

                    this.updateButtons({
                        tvShow: this.__tvShow,
                        isBlackedOut: this.__detailInformation.isBlackedOut,
                        isInWatchlist: this.__detailInformation.isInWatchlist
                    });

                }, this));

            }, this);

            this.__selectPreviousSeasonReference = util.bind(this._selectPreviousSeason, this);
            this.__selectNextSeasonReference = util.bind(this._selectNextSeason, this);

            addToWatchlistButton.addEventListener(evtType.CLICK, this.__addToWatchlistReference);
            previousSeasonButton.addEventListener(evtType.CLICK, this.__selectPreviousSeasonReference);
            nextSeasonButton.addEventListener(evtType.CLICK, this.__selectNextSeasonReference);
        },

        _displayContent: function (serieId, catalog) {

            if (!serieId || !catalog) {
                return ax.promise.reject().fail(function () {
                    util.defer().then(function() {
                        dialogHelper.error({
                            reason: sLanguageManager.getString("Global.Global_NoResults"),
                            closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                            buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                        });
                    });
                });

            }

            return sAssetManager.getSerieAssetById(serieId, catalog).then(util.bind(function (serie) {
                // season is null if no season is available under the TV show
                // for those cases, use TV show as the display subject
                if (serie) {
                    this._currentlySelectedSeason = this._currentlySelectedSeason || 0;
                    this._displayAsset(serie);
                }

            }, this)).fail(function (reason) {
                console.log("sAssetManager.getSerieAssetById(" + serieId + ", " + catalog + ") failed: " + reason);
                util.defer().then(function() {
                    dialogHelper.error({
                        reason: sLanguageManager.getString("Global.Global_NoResults"),
                        closeAction: util.bind(sHistoryManager.back, sHistoryManager),
                        buttonText: sLanguageManager.getString("Global.Global_buttonBack_button")
                    });
                });
            });
        },

        _displayAsset: function (tvShow) {
            this.__checkUserPrivileges(tvShow).then(util.bind(function (userHasPrivileges) {
                this.__tvShow = tvShow;

                this.__detailInformation.title = this.__tvShow.get("title");
                this.__detailInformation.synopsis = this.__tvShow.get("synopsis");
                this.__detailInformation.cast = this.__tvShow.get("cast");
                this.__detailInformation.parentalRating = this.__tvShow.get("parentalRating");
                this.__detailInformation.length = this.__tvShow.get("length");
                this.__detailInformation.year = this.__tvShow.get("year");
                this.__detailInformation.genres = this.__tvShow.get("genreList");
                this.__detailInformation.onAirDate = this.__tvShow.get("date");
                this.__detailInformation.packageCode = this.__tvShow.get("packageCode");
                this.__detailInformation.packageColorCode = this.__tvShow.get("packageColorCode");
                this.__detailInformation.isBlackedOut = this.__tvShow.get("blackedOut");
                this.__detailInformation.userHasPrivileges = userHasPrivileges;
                this.__detailInformation.country = this.__tvShow.get("country");
                this.__detailInformation.isHD = this.__tvShow.get("isHD");
                
                this.trackPage(this.__tvShow.get("title"));   
                
                // If the series has no colour information, take it from the first available episode.
                if (!this.__detailInformation.packageCode && !this.__detailInformation.packageColorCode) {
                    try {
                        this.__tvShow.set("packageCode", this.__tvShow.get("seasons")[0].get("episodes")[0].get("packageCode"));
                        this.__tvShow.set("packageColorCode", this.__tvShow.get("seasons")[0].get("episodes")[0].get("packageColorCode"));
                    } catch (e) {
                        console.info("No episode information available for this series.");
                    }
                }
                this.updateCommonDetailInformation(this.__tvShow, this.__detailInformation);

                if (this.isSeasonIndexAvailable(this._currentlySelectedSeason)) {
                    var seasonToDisplay = this.__tvShow.get("seasons") && this.__tvShow.get("seasons")[this._currentlySelectedSeason];
                    this._displaySeason(seasonToDisplay);

                } else {
                    // Serie contains no episodes.
                    this.hideButtons();
                }

            }, this));
        },

        updateButtons: function (options) {
            var tvShow = options && options.tvShow,
                isBlackedOut = options && options.isBlackedOut,
                isInWatchlist = options && options.isInWatchlist,
                currentView = this.getView(),
                addToWatchlist = currentView.find("addToWatchlist"),
                seasonEpisodesGrid = currentView.find("seasonEpisodesGrid"),
                detailDescription = currentView.find("detailDescription"),
                seasonSelection = currentView.find("seasonSelectionButtonContainer");

            if (!tvShow) {
                return;
            }

            if (isBlackedOut) {

                addToWatchlist.hide();

                detailDescription.setOption("nextDown", seasonEpisodesGrid);
                detailDescription.setOption("nextUp", "");
                seasonEpisodesGrid.setOption("nextUp", detailDescription);

                if (seasonEpisodesGrid.getDatasource() && seasonEpisodesGrid.getDatasource().getTotalCount() > 0) {
                    detailDescription.setFocusable(false);
                }
            } else {
                addToWatchlist.setText(isInWatchlist ?
                                    sLanguageManager.getString("DetailPage.DetailPage_removeWatchlist") :
                                    sLanguageManager.getString("DetailPage.DetailPage_labeladd_to_watchlist"));
                
                detailDescription.setFocusable(false);
            }

            this.focusFirstVisibleComponent(options.evtTarget ? [options.evtTarget, seasonSelection, detailDescription] : [addToWatchlist, seasonEpisodesGrid, detailDescription]);
        },

        /**
         * Hide all buttons on this page.
         * @return {void}
         */
        hideButtons: function () {
            var currentView = this.getView(),
                detailDescription = currentView.find("detailDescription"),
                addToWatchlist = currentView.find("addToWatchlist");

            detailDescription.setOption("nextDown", null);
            addToWatchlist.hide();
        },

        /**
         * [_displaySeason description]
         * @param  {Object} season Season to be displayed.
         * @return {void}
         */
        _displaySeason: function(season, evt) {
            this.__checkIfSeasonIsPresentInWatchlist(season).then(util.bind(function (seasonIsInWatchlist) {
                this.__detailInformation.isInWatchlist = seasonIsInWatchlist;

                var whichSeason = season.get("seasonNumber"),
                    seasonLabel = this.getView().find("seasonLabel");

                if (whichSeason) {
                    var seasonString = sLanguageManager.getString("DetailPage.DetailPage_labelseason_label") + " " + whichSeason;
                    seasonLabel.show().setText(seasonString.toUpperCase());
                } else {
                    seasonLabel.hide();
                }

                // Update buttons after episodes grid have been updated.
                // In order to be able to focus first episode in episodes grid if no buttons should be visible.
                this._displayEpisodes(season.get("episodes")).then(util.bind(function () {
                    this.updateButtons({
                        tvShow: this.__tvShow,
                        isBlackedOut: this.__detailInformation.isBlackedOut,
                        isInWatchlist: this.__detailInformation.isInWatchlist,
                        evtTarget: evt && evt.target
                    });
                    sLoading.close();

                }, this)).fail(function(error){
                    sLoading.close();
                    console.warn("_displayEpisodes request failed. Error: "+error);
                });

            }, this)).fail(function(error){
                sLoading.close();
                console.warn("__checkIfSeasonIsPresentInWatchlist request failed. Error: "+error);
            });
        },

        _displayEpisodes: function (episodes) {
            var rootView = this.getView(),
                episodesDs = tvedemoUtil.arrayToDs(episodes),
                episodesGridLabel = this.getView().find("episodesGridLabel");

            if (episodes.length > 0) {
                episodesGridLabel.setText(sLanguageManager.getString("DetailPage.DetailPage_labelseries_overview").toUpperCase());
            }

            this._grid.setDisplayStgy(util.bind(function (episode) {
                // We've documented our assumption to Sky, that we use packageCode for preference; packageColourCode is second choice.
                var colourCode = episode.get("packageCode");

                if (!colourCode) {
                    colourCode = episode.get("packageColourCode");
                }
                var opts = {
                    css: "wgt-assetbutton",
                    asset: episode,
                    thumbnailPromise: sAssetManager.getStormAssetImageBySize(episode, this.IMAGE_MIN_WIDTH, this.IMAGE_MIN_HEIGHT),
                    packageColorPromise: sAppConfigManager.getPackageColourForCode(colourCode)
                };

                return new EpisodeButton(opts);
            }, this));

            return this._grid.setDatasource(episodesDs).fail(util.bind(function () {
                this._grid.hide();
            }, this));
        },

        _gridClickHandler: function (evt) {
            var notArrow = evt.target._opts.css != "wgt-grid-arrow";
            if(notArrow){
                var episode = this._grid.getSelectedData();

                mediator.publish("navigate", {
                    path: "Main/Episode",
                    message: {
                        selectedEpisodeId: episode.get("id"),
                        seasonEpisodes: this.__tvShow.get("seasons")[this._currentlySelectedSeason].get("episodes"),
                        catalog: episode.get("catalog")
                    }
                });

                return false;
            }else{
                var target = evt.target;
                focusManager.focus(this._grid);
                if(target._root._dom.className.indexOf("right") > -1){
                    //move grid right
                    evtMgr.trigger(evtType.KEY, this._grid, {id:vKey.RIGHT.id});
                }else{
                    //move grid left
                    evtMgr.trigger(evtType.KEY, this._grid, {id:vKey.LEFT.id});
                }
                return false;
            }
            return true;
        },

        isSeasonIndexAvailable: function(index) {
            var currentView = this.getView(),
                addToWatchlistButton = currentView.find("addToWatchlist"),
                previousSeasonButton = currentView.find("previousSeasonButton"),
                nextSeasonButton = currentView.find("nextSeasonButton"),
                seasonEpisodesGrid = currentView.find("seasonEpisodesGrid"),
                navigateSeasonsLabel = currentView.find("navigate-seasons"),
                detailDescription = currentView.find("detailDescription"),
                seasonIndexAvailable = true;

            if (index < 0 || index >= (this.__tvShow.get("seasons") && this.__tvShow.get("seasons").length) ) {
                seasonIndexAvailable = false;
            }

            if (index <= 0) {
                previousSeasonButton.hide();
            } else {
                previousSeasonButton.show();
            }

            if (index >= (this.__tvShow.get("seasons") && this.__tvShow.get("seasons").length - 1) ) {
                nextSeasonButton.hide();
                previousSeasonButton.setOption("nextRight", detailDescription);
            } else {
                nextSeasonButton.show();
                previousSeasonButton.setOption("nextRight", nextSeasonButton);
            }

            // Only one season which means we should not swap.
            if (!this.__tvShow.get("seasons") || this.__tvShow.get("seasons").length <= 1) {
                previousSeasonButton.hide();
                nextSeasonButton.hide();
                navigateSeasonsLabel.hide();

                addToWatchlistButton.setOption("nextDown", seasonEpisodesGrid);
                seasonEpisodesGrid.setOption("nextUp", addToWatchlistButton);
            }

            if (nextSeasonButton.isHidden() && !previousSeasonButton.isHidden()) {

                if (focusManager.isCompFocused(nextSeasonButton)) {
                    focusManager.focus(previousSeasonButton);
                }

                addToWatchlistButton.setOption("nextDown", previousSeasonButton);

            }

            if (previousSeasonButton.isHidden() && !nextSeasonButton.isHidden()) {

                if (focusManager.isCompFocused(previousSeasonButton)) {
                    focusManager.focus(nextSeasonButton);
                }

                addToWatchlistButton.setOption("nextDown", nextSeasonButton);

            }

            return seasonIndexAvailable;
        },

        /**
         * Selects the nextcomming season.
         * @return {void}
         */
        _selectNextSeason: function (evt) {
            if (this.isSeasonIndexAvailable(this._currentlySelectedSeason + 1)) {
                sLoading.open();
                
                this._currentlySelectedSeason++;

                var seasonToDisplay = this.__tvShow.get("seasons") && this.__tvShow.get("seasons")[this._currentlySelectedSeason];

                this._displaySeason(seasonToDisplay, evt);
            }
        },

        /**
         * Select previous season.
         * @return {void}
         */
        _selectPreviousSeason: function (evt) {
            if (this.isSeasonIndexAvailable(this._currentlySelectedSeason - 1)) {
                sLoading.open();

                this._currentlySelectedSeason--;

                var seasonToDisplay = this.__tvShow.get("seasons") && this.__tvShow.get("seasons")[this._currentlySelectedSeason];

                this._displaySeason(seasonToDisplay, evt);
            }
        },

        reset: function () {
            this._super();

            var currentView = this.getView(),
                addToWatchlistButton = currentView.find("addToWatchlist"),
                previousSeasonButton = currentView.find("previousSeasonButton"),
                nextSeasonButton = currentView.find("nextSeasonButton");

            this._grid.removeEventListener(evtType.CLICK, this.__gridClickHandler);

            addToWatchlistButton.removeEventListener(evtType.CLICK, this.__addToWatchlistReference);
            previousSeasonButton.removeEventListener(evtType.CLICK, this.__selectPreviousSeasonReference);
            nextSeasonButton.removeEventListener(evtType.CLICK, this.__selectNextSeasonReference);

            mediator.unsubscribe(UserEvent.UserDataUpdated, this.__handleUserDataUpdate);
        }
    });
});
/**
 * A util to create items for the epg.
 * @module tvedemo/wgt/EPG/EpgItemBuilder
 */
define("tvedemo/wgt/EPG/EpgItemBuilder", [
    "xdk-ax/Container", "xdk-ui-basic/Button", "xdk-ui-basic/Label", "xdk-ui-basic/Image", "tvedemo/helper/sMoment", "xdk-base/console",
    "storm/mgr/sAppConfigManager",
    "xdk-base/ax"
], function (Container, Button, Label, Image, moment, console,
    sAppConfigManager,
    ax) {
    "use strict";
    var DEFAULT_DATE_FORMAT = "D.MM",
        DEFAULT_TIME_FORMAT = "HH:mm";
    return {
        _dateFormat: DEFAULT_DATE_FORMAT,
        _timeFormat: DEFAULT_TIME_FORMAT,
        patron: null,

        setDateFormat: function(value){
            this._dateFormat = value;
        },
        setTimeFormat: function(value){
            this._timeFormat = value;
        },
        returnContainer: function(id, css, parent, placement){
            return new Container({
                    id: id,
                    css: css,
                    placement: placement,
                    parent: parent
                });
        },
        returnLabel: function (id, css, parent, text) {
            return new Label({
                id: id,
                css: css,
                text: text,
                parent: parent
            });
        },
        returnImage: function (id, css, parent, src) {
            return new Image({
                id: id,
                css: css,
                src: src,
                parent: parent
            });
        },
        returnHeaderItem: function (id, css, parent, targetTime) {
            return this.returnLabel(id, css, parent, moment(targetTime).format(this._dateFormat));
        },
        returnTimeLineItem: function (id, css, parent, targetTime) {
            return this.returnLabel(id, css, parent, moment(targetTime).format(this._timeFormat));
        },
        returnChannelItem: function (id, css, parent, dataId, smallLogo, title, blackout, subscribed, channelPackColourCode, placement) {
            var channel, image, label, labelCss = 'channelLabel';
            placement = (placement)?placement:Container.PLACE_APPEND;
            channel = this.returnContainer('channel'+dataId, css, parent, placement);
            channel.blackout = blackout;
            channel.subsribed = subscribed;
            image = this.returnImage('channelImage'+dataId, 'channelLogo', channel, smallLogo);
            if(smallLogo) labelCss += ' hidden';
            label = this.returnLabel('channelLabel'+dataId, labelCss, channel, title);
            image.setErrorCallback(this._brokenImageHandler(image, label));

            return channel;
        },
        returnProgrammeItem: function (id, css, text, data, parent, left, width) {
            width -= 1;
            if(width < 30)text ='';
            var programme = new Button({
                id: id,
                css: css,
                text: text,
                programmeData: data,
                parent: parent
            });
            programme.getRoot().getHTMLElement().style.left = left + 'px';
            programme.getRoot().getHTMLElement().style.width = width + 'px';
            programme.getChildren()[0].getRoot().getHTMLElement().style.width = (width-this.patron.programmeTextPadding) + 'px';
            return programme;
        },
        setTimeLineItems: function(slot, array, parent, timeSegment){
            for(var i = 0; i < 4; i++){
                var timeItem;
                var time = slot + (timeSegment * i);
                timeItem = this.returnTimeLineItem('timeLineItem'+time, 'timeLineItem', parent, time);
                array.push(timeItem);
            }
        },
        _brokenImageHandler: function (image, label) {
            return function() {
                image.addClass('hidden');
                label.removeClass('hidden');
            }
        }
    }
});

/**
 * A util to handle time and position for the epg.
 * @module tvedemo/wgt/EPG/EpgTimeAndPosition
 */
define("tvedemo/wgt/EPG/EpgTimeAndPosition", [
       "tvedemo/helper/sMoment", 
       "xdk-base/console",
       "tvedemo/helper/CentralEuropeanTime"
], function (moment, console, centralEuropeanTime) {
    "use strict";
        var topChannelIndex =  0,
            MS_IN_1_DAY = 86400000;

    return {
        patron: null,
        MS_IN_1_MIN : 60000,
        slotPosition: 0,
        dayPosition: 0,
        rowPosition: 0,
        numberOfChannels: null,
        dataStartSlot: 0,
        stopVerticalPaging: false,
        setCurrentTimeSlot: function(patron){
            var currentDay = this._getTimestamp();
            var startDay = this._getStartOfDayTimestamp();
            var msFromStart = currentDay - startDay;
            this.slotPosition = Math.floor(msFromStart / (this.MS_IN_1_MIN * patron.timeSlotSize));
            this.dataStartSlot = this.slotPosition;
            this.patron = patron;
        },
        getTimeSlot: function(timestamp){
            var timestampDay = this._getStartOfDayTimestamp();
            var startCurrentDay = this._getStartOfDayTimestamp();
            var startDay = this._getStartOfDayTimestamp();
            var msFromStart = timestampDay - startDay;
            var retObj = {};
            retObj.slotPosition = Math.floor(msFromStart / (this.MS_IN_1_MIN * this.patron.timeSlotSize));
            retObj.dayPosition = Math.floor((startDay-startCurrentDay)/MS_IN_1_DAY);
            return retObj;
        },
        getCurrentTimeSlotStart: function(){
            var time = this._getStartOfDayTimestamp();
                time += this.dayPosition * MS_IN_1_DAY;
                time += this.slotPosition * (this.MS_IN_1_MIN * this.patron.timeSlotSize);
            return time;
        },
        getCurrentSlotTimesForMarker: function(){
            if(this.dayPosition !=0)return false;
            var currentDay = this._getTimestamp() + (this.MS_IN_1_MIN*60);
            var startOfDay = this._getStartOfDayTimestamp() + (this.MS_IN_1_MIN*60);
            var msFromStart = currentDay - startOfDay;
            var retObj = {};
            var tempSlot = Math.floor(msFromStart / (this.MS_IN_1_MIN * this.patron.timeSlotSize));
            retObj.dataStartSlot = tempSlot;
            if(this.slotPosition != tempSlot) return retObj;
            retObj.startTime = startOfDay +(tempSlot * (this.MS_IN_1_MIN * this.patron.timeSlotSize));
            retObj.endTime = retObj.startTime + (this.MS_IN_1_MIN * this.patron.timeSlotSize);
            return retObj;
        },
        getTopChannelIndex: function(){
            return topChannelIndex;
        },
        setTopChannelIndex: function(value){
            topChannelIndex = value;
                if(this.numberOfChannels !== null)
                if(topChannelIndex<0){
                    topChannelIndex = this.numberOfChannels -1;
                }else if(topChannelIndex>this.numberOfChannels -1){
                    topChannelIndex = 0;
                }
        },
        returnTimeSlot: function(){
            var startDay = this._getStartOfDayTimestamp();
            var requiredDay = startDay + (this.dayPosition * MS_IN_1_DAY);
            return requiredDay + (this.slotPosition * (this.MS_IN_1_MIN * this.patron.timeSlotSize));
        },
        updateDayAndSlotPositions: function(direction, moveChannelHeader){
            if(direction < 0 && this.dayPosition == this.patron.minDay && this.slotPosition < 1) return false;
            var tempDay = (direction > 0) ? Math.floor(direction/12) :  Math.ceil(direction/12);
            this.slotPosition += direction;
            if(direction > 0 && this.slotPosition > 11){
                if(this.invalidDay(tempDay)){
                    this.slotPosition -= direction;
                    return false;
                }
                if(direction!=12){
                    if(direction==1){
                        this.slotPosition = 0;
                    }else{
                        this.slotPosition -= direction;
                    }
                    if(tempDay==0)tempDay = 1;
                }else{
                    this.slotPosition -= direction;
                }
                moveChannelHeader(tempDay);
            }else if(direction < 0 && this.slotPosition < 0){
                if(this.invalidDay(tempDay)){
                    this.slotPosition -= direction;
                    return false;
                }
                if(direction!=-11){
                    if(direction==-1){
                        this.slotPosition = 11;
                    }else{
                        this.slotPosition -= direction;
                    }
                    if(tempDay==0)tempDay = -1;
                }else{
                    this.slotPosition -= direction;
                }
                moveChannelHeader(tempDay);
            }
            return true
        },
        invalidDay: function(tempDay){
            if((this.dayPosition + tempDay) > this.patron.maxDay || (this.dayPosition + tempDay) < this.patron.minDay)
                return true;
        },
        _getTimestamp: function() {
            return moment().unix()*1000;
        },
        _getStartOfDayTimestamp: function() {
            return moment().startOf('d').unix()*1000;
        }
    }
});

/**
 * A util to handle top bar for the epg.
 * @module tvedemo/wgt/EPG/EpgTopBar
 */
define("tvedemo/wgt/EPG/EpgTopBar", [
    "tvedemo/helper/sMoment", "xdk-base/console"
], function (moment, console) {
    "use strict";
    var timeLineAnimationDelay = null,
        channelHeaderAnimationDelay = null,
        timeSegmentMS;

    return {
        epgAndTimeLineMask: null,
        epgTimeLine: null,
        epgTimeLineNext: null,
        epgTimeLineObjects: null, //ARRAY contains each time line objects

        channelHeaderMask: null,
        channelHeader:null,
        channelHeaderNext:null,
        channelHeaderItem:null,

        patron: null,
        timeAndPosition: null,
        itemBuilder: null,

        setVariables: function(patron, TimeAndPosition, ItemBuilder){
            this.patron = patron;
            this.timeAndPosition = TimeAndPosition;
            this.itemBuilder = ItemBuilder;
            timeSegmentMS = (patron.timeSegment * TimeAndPosition.MS_IN_1_MIN);
            this.setupContainers();
        },

        setupContainers: function(){
            this.channelHeaderMask = this.itemBuilder.returnContainer('channelHeaderMask', 'channelHeaderMask', this.patron);
            this.channelHeader = this.itemBuilder.returnContainer('channelHeader'+this.timeAndPosition.dayPosition, 'channelHeader', this.channelHeaderMask);
            this.timeLineMask = this.itemBuilder.returnContainer('timeLineMask', 'timeLineMask', this.patron);
            this.timeLine = this.itemBuilder.returnContainer('timeLine'+this.timeAndPosition.dayPosition+'-'+this.timeAndPosition.slotPosition, 'timeLine', this.timeLineMask);
        },
        setUpHeaderAndTimeLine: function(time){
            this.channelHeaderItem = this.itemBuilder.returnHeaderItem('chHeader'+this.timeAndPosition.dayPosition, 'channelHeaderLabel', this.channelHeader, time);
            this.epgTimeLineObjects = [];
            console.log(this.timeLine)
            this.itemBuilder.setTimeLineItems(time, this.epgTimeLineObjects, this.timeLine, timeSegmentMS);
        },
        moveTimeLineHorizontal: function(direction){
            var directionFrom, directionTo;
            if(direction>0){
                directionFrom = 'epgRight';
                directionTo = 'epgLeft';
            }else{
                directionFrom = 'epgLeft';
                directionTo = 'epgRight';
            }
            if(this.timeAndPosition.updateDayAndSlotPositions(direction, this.moveChannelHeader(this))){
                this.timeLineNext = this.itemBuilder.returnContainer('timeLine'+this.timeAndPosition.dayPosition+'-'+this.timeAndPosition.slotPosition, 'timeLine '+directionFrom, this.timeLineMask);
                this.itemBuilder.setTimeLineItems(this.timeAndPosition.returnTimeSlot(), this.epgTimeLineObjects, this.timeLineNext, timeSegmentMS);
                timeLineAnimationDelay = setInterval(this.animateTimeLine(this, directionTo, directionFrom),30);  //required so css is applied enabling transition
                return true;
            }else{
                return false;
            }
        },
        moveChannelHeader: function(scope){
            return function(direction){
                var timeAndPos = scope.timeAndPosition;
                timeAndPos.dayPosition += direction;
                var directionFrom, directionTo;
                if(direction>0){
                    directionFrom = 'epgChannelRight';
                    directionTo = 'epgChannelLeft';
                }else{
                    directionFrom = 'epgChannelLeft';
                    directionTo = 'epgChannelRight';
                }
                scope.channelHeaderNext = scope.itemBuilder.returnHeaderItem('chHeader'+timeAndPos.dayPosition, 'channelHeaderLabel '+directionFrom, scope.channelHeader, timeAndPos.returnTimeSlot());
                channelHeaderAnimationDelay = setInterval(scope.animateChannelHeader(scope, directionTo, directionFrom),30);  //required so css is applied enabling transition
            }
        },
        animateTimeLine: function(scope, directionTo, directionFrom){
            return function(){
                clearInterval(timeLineAnimationDelay);
                scope.timeLine.addClass(directionTo);
                scope.timeLineNext._root._dom.addEventListener('transitionend', scope.timeLineAniComplete(scope));
                scope.timeLineNext._root._dom.addEventListener('webkitTransitionEnd', scope.timeLineAniComplete(scope));
                scope.timeLineNext.removeClass(directionFrom);
            }
        },
        animateChannelHeader: function(scope, directionTo, directionFrom){
            return function(){
                clearInterval(channelHeaderAnimationDelay);
                scope.channelHeaderItem.addClass(directionTo);
                scope.channelHeaderNext._root._dom.addEventListener('transitionend', scope.channelHeaderAniComplete(scope));
                scope.channelHeaderNext._root._dom.addEventListener('webkitTransitionEnd', scope.channelHeaderAniComplete(scope));
                scope.channelHeaderNext.removeClass(directionFrom);
            }
        },
        timeLineAniComplete: function(scope){
            return function(){
                if(scope.timeLineNext){
                    scope.timeLineNext._root._dom.removeEventListener('transitionend', scope.timeLineAniComplete(scope));
                    scope.timeLineNext._root._dom.removeEventListener('webkitTransitionEnd', scope.timeLineAniComplete(scope));
                    for(var i = 0; i < 4; i++){
                        var obj = scope.epgTimeLineObjects.shift();
                        scope.timeLine.detach(obj);
                    }
                    scope.timeLineMask.detach(scope.timeLine);
                    scope.timeLine = scope.timeLineNext;
                    scope.timeLineNext = null;
                }
            };
        },
        channelHeaderAniComplete: function(scope){
            return function(){
                if(scope.channelHeaderNext){
                    scope.channelHeaderNext._root._dom.removeEventListener('transitionend', scope.channelHeaderAniComplete(scope));
                    scope.channelHeaderNext._root._dom.removeEventListener('webkitTransitionEnd', scope.channelHeaderAniComplete(scope));
                    scope.channelHeader.detach(scope.channelHeaderItem);
                    scope.channelHeaderItem = scope.channelHeaderNext;
                    scope.channelHeaderNext = null;
                }
            };
        }
    }
});

define("tvedemo/wgt/EPG/data/Retrieval", [
    "xdk-base/console"
], function (console) {
    "use strict";

    return {
        retrieveChannelDataElement: function(channelIndex, elementLocation, patron){
            var data = patron.channels;
            var i;
            data = data[channelIndex];
            if(elementLocation.length > 0){
                for (i = 0; i < elementLocation.length; i++){
                    try {
                        data = data[elementLocation[i]];
                    }catch(e){
                        return null;
                    }
                }
            }
            return data
        },
        retrieveChannelProgrammes: function(channelIndex, patron, dayPosition){
            var data = patron.programmes[dayPosition].data;
            var i;
            data = data[channelIndex];
            data = this.retrieveProgrammeElement(data, patron.programmeDataBase);
            return data;
        },
        retrieveProgrammeDataElement: function(channelProgrammes, programmeIndex, elementLocation){
            var data = channelProgrammes[programmeIndex];
            return this.retrieveProgrammeElement(data, elementLocation);
        },
        retrieveProgrammeElement: function(data, elementLocation){
            var i;
            if(elementLocation.length > 0){
                for (i = 0; i < elementLocation.length; i++){
                    data = data[elementLocation[i]];
                }
            }
            return data
        }
    }
});
/**
 * A util to handle Channel bar for the epg.
 * @module tvedemo/wgt/EPG/EpgChannelBar
 */
define("tvedemo/wgt/EPG/EpgChannelBar", [
    "tvedemo/wgt/EPG/data/Retrieval", "xdk-ax/Container", "tvedemo/helper/sMoment", "xdk-base/console"
], function (Retrieval, Container, moment, console) {
    "use strict";
    var channelBarAnimationDelay = null;

    return {
        channelMask:null,
        channelContainer:null,
        channelContainerNext:null,
        channelObjects: null, //ARRAY contains each channel object
        newChannelItem:null,
        channelBarAnimationDelay:null,

        patron: null,
        timeAndPosition: null,
        itemBuilder: null,
        upAni: false,

        animationListener: null,
        animationUpListener: null,

        setVariables: function(patron, TimeAndPosition, ItemBuilder){
            this.patron = patron;
            this.timeAndPosition = TimeAndPosition;
            this.itemBuilder = ItemBuilder;
            this.setupContainers();
        },

        setupContainers: function(){
            this.channelMask = this.itemBuilder.returnContainer('channelMask', 'channelMask', this.patron);
            this.channelContainer = this.itemBuilder.returnContainer('channelContainer', 'channelContainer channelContainerStepAni', this.channelMask);
        },

        setupChannels: function(){
            var start = this.timeAndPosition.getTopChannelIndex();
            var end = start + this.patron.numberOfRows;
            var endChannelListAdjustment;
            this.channelObjects = [];
            for(var i = start; i < end; i++){
                if(i>=this.patron.channels.length){
                    endChannelListAdjustment = this.patron.channels.length
                }else{
                    endChannelListAdjustment = 0;
                }
                var id = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelDataId, this.patron);
                var logo = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelDataLogo, this.patron);
                var title = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelDataTitle, this.patron);
                var blackout = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelDataBlackout, this.patron);
                var status = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelDataStatus, this.patron);
                var subscribed = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelDataSubscribed, this.patron);
                var channelPackColourCode = Retrieval.retrieveChannelDataElement(i - endChannelListAdjustment, this.patron.channelPackColourCode, this.patron);
                var css = (status=='offline')?'channelObject channel-offline':'channelObject';
                    //css = blackout?css+' channel-blackout':css;
                if(this.patron.loggedIn){
                    css = subscribed?css:css+' channel-unsubscribed';
                    if(!subscribed) console.log("Channel "+id+" "+title +"  ----------unsubscribed");
                }
                this.channelObjects.push(this.itemBuilder.returnChannelItem('channelItem'+i,css, this.channelContainer, id, logo, title, blackout, subscribed, channelPackColourCode, Container.PLACE_APPEND));
            }
        },
        moveChannel: function(direction){
            var channelRequired, id, logo, title, cssDirection;
            this.timeAndPosition.setTopChannelIndex(this.timeAndPosition.getTopChannelIndex() + direction);
            channelRequired = (direction>0)?this.timeAndPosition.getTopChannelIndex() + (this.patron.numberOfRows-1):this.timeAndPosition.getTopChannelIndex();
            if(channelRequired >= this.patron.channels.length)channelRequired-=this.patron.channels.length;
            id = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelDataId, this.patron);
            logo = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelDataLogo, this.patron);
            title = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelDataTitle, this.patron);
            var blackout = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelDataBlackout, this.patron);
            var status = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelDataStatus, this.patron);
            var subscribed = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelDataSubscribed, this.patron);
            var channelPackColourCode = Retrieval.retrieveChannelDataElement(channelRequired, this.patron.channelPackColourCode, this.patron);
            var css = (status=='offline')?'channelObject channel-offline':'channelObject';
            //    css = blackout?css+' channel-blackout':css;
            if(this.patron.loggedIn){
               css = subscribed?css:css+' channel-unsubscribed';
            }
            if(direction>0){
                this.upAni = false;
                this.newChannelItem = this.itemBuilder.returnChannelItem('channelItem'+channelRequired,css, this.channelContainer, id, logo, title, blackout, subscribed, channelPackColourCode, Container.PLACE_APPEND);
                this.channelObjects.push(this.newChannelItem);
                cssDirection = 'beforeTop';
                this.animationListener = this.channelAniComplete(this, cssDirection);
                this.channelContainer._root._dom.addEventListener('transitionend', this.animationListener);
                this.channelContainer._root._dom.addEventListener('webkitTransitionEnd', this.animationListener);
                this.channelContainer.addClass(cssDirection);
            }else{
                this.upAni = true;
                this.newChannelItem = this.itemBuilder.returnChannelItem('channelItem'+channelRequired,css, this.channelContainer, id, logo, title, blackout, subscribed, channelPackColourCode, Container.PLACE_PREPEND);
                this.channelObjects.unshift(this.newChannelItem);
                cssDirection = 'beforeTop'
                this.channelContainer.removeClass('channelContainerStepAni');
                this.channelContainer.addClass(cssDirection);
                channelBarAnimationDelay = setInterval(this.channelBarUpStep2Animation(this, cssDirection), 30);
            }
        },
        channelBarUpStep2Animation: function(scope, cssDirection){
            return function(){
                clearInterval(channelBarAnimationDelay);
                scope.animationUpListener = scope.channelUpAniComplete(scope, cssDirection);
                scope.channelContainer._root._dom.addEventListener('transitionend', scope.animationUpListener);
                scope.channelContainer._root._dom.addEventListener('webkitTransitionEnd', scope.animationUpListener);
                scope.channelContainer.addClass('channelContainerStepAni');
                scope.channelContainer.removeClass(cssDirection);

            };
        },
        channelUpAniComplete: function(scope, cssDirection){
            return function(){
                scope.channelContainer._root._dom.removeEventListener('transitionend', scope.animationUpListener);
                scope.channelContainer._root._dom.removeEventListener('webkitTransitionEnd', scope.animationUpListener);
                if(scope.newChannelItem && scope.upAni){
                    scope.channelContainer.detach(scope.channelObjects.pop());
                    scope.newChannelItem.removeClass(cssDirection);
                    scope.newChannelItem = null;
                }
            };
        },
        channelAniComplete: function(scope, cssDirection){
            return function(){
                scope.channelContainer._root._dom.removeEventListener('transitionend', scope.animationListener);
                scope.channelContainer._root._dom.removeEventListener('webkitTransitionEnd', scope.animationListener);
                if(scope.newChannelItem && !scope.upAni){
                    scope.channelContainer.removeClass('channelContainerStepAni');
                    scope.channelContainer.detach(scope.channelObjects.shift());
                    scope.newChannelItem.removeClass(cssDirection);
                    scope.newChannelItem = null;
                    scope.channelContainer.removeClass(cssDirection);
                    channelBarAnimationDelay = setInterval(scope.channelBarStepAnimationFinish(scope), 1);
                }
            };
        },
        channelBarStepAnimationFinish: function(scope){
            return function(){
                clearInterval(channelBarAnimationDelay);
                scope.channelContainer.addClass('channelContainerStepAni');

            }
        },
        detachChannelObjects: function(){
            for(var i=0; i<this.channelObjects.length; i++){
                this.channelObjects[i].detach();
            }
        }

    }
});

define("tvedemo/wgt/EPG/ProgrammeGrid/HorizontalAnimation", [
   "xdk-base/console",
   "tvedemo/wgt/Loading"
], function (console, sLoading) {
    "use strict";

    // Holds the callback function for transionend.
    var animationComplete;

    return {
        patron: null,
        animateProgrammes: function(scope, self, directionTo, directionFrom, callback){
            return function(){
                sLoading.open();
                clearInterval(scope.programmeAnimationDelay);
                scope.epgContainer.addClass(directionTo);

                if (animationComplete) {
                    scope.epgContainerNext._root._dom.removeEventListener('transitionend', animationComplete);
                    scope.epgContainerNext._root._dom.removeEventListener('webkitTransitionEnd', animationComplete);
                }

                animationComplete = self.programmeAniComplete(scope, self, callback);
                scope.epgContainerNext._root._dom.addEventListener('transitionend', animationComplete);
                scope.epgContainerNext._root._dom.addEventListener('webkitTransitionEnd', animationComplete);
                scope.epgContainerNext.removeClass(directionFrom);
            }
        },
        programmeAniComplete: function(scope, self, callback){
            return function(){
                if(scope.epgContainerNext){
                    scope.epgContainerNext._root._dom.removeEventListener('transitionend', animationComplete);
                    scope.epgContainerNext._root._dom.removeEventListener('webkitTransitionEnd', animationComplete);
                    scope.epgMask.detach(scope.epgContainer);
                    sLoading.close();
                    
                    scope.epgContainer = scope.epgContainerNext;
                    scope.epgContainerNext = null;
                    if(callback) callback();
                }
            };
        }
    }
});
define("tvedemo/wgt/EPG/ProgrammeGrid/VerticalStepAnimation", [
    "tvedemo/helper/sMoment", "xdk-base/console"
], function (moment, console) {
    "use strict";

    return {
        upAni: false,

        verticalUpStep2Animation: function(scope, self, cssDirection, callback){
            return function(){
                clearInterval(scope.programmeAnimationDelay);
                scope.animationUpListener = self.verticalUpAniComplete(scope, self, cssDirection, callback)
                scope.epgContainer._root._dom.addEventListener('transitionend', scope.animationUpListener);
                scope.epgContainer._root._dom.addEventListener('webkitTransitionEnd', scope.animationUpListener);
                scope.epgContainer.addClass('channelContainerStepAni');
                scope.epgContainer.removeClass(cssDirection);

            };
        },
        verticalUpAniComplete: function(scope, self, cssDirection, callback){
            return function(){
                scope.epgContainer._root._dom.removeEventListener('transitionend', scope.animationUpListener);
                scope.epgContainer._root._dom.removeEventListener('webkitTransitionEnd', scope.animationUpListener);
                if(scope.newRow && self.upAni){
                    scope.epgContainer.detach(scope.epgProgrammeRows.pop());
                    scope.newRow.removeClass(cssDirection);
                    scope.newRow = null;
                    if(callback)callback();
                }
            };
        },
        verticalAniComplete: function(scope, self, cssDirection, callback){
            return function(){
                scope.epgContainer._root._dom.removeEventListener('transitionend', scope.animationListener);
                scope.epgContainer._root._dom.removeEventListener('webkitTransitionEnd', scope.animationListener);
                if(scope.newRow && !self.upAni){
                    scope.epgContainer.removeClass('channelContainerStepAni');
                    scope.epgContainer.detach(scope.epgProgrammeRows.shift());
                    scope.newRow.removeClass(cssDirection);
                    scope.newRow = null;
                    scope.epgContainer.removeClass(cssDirection);
                    scope.programmeAnimationDelay = setInterval(self.verticalStepAnimationFinish(scope, callback), 30);
                }
            };
        },
        verticalStepAnimationFinish: function(scope, callback){
            return function(){
                clearInterval(scope.programmeAnimationDelay);
                scope.epgContainer.addClass('channelContainerStepAni');
                if(callback)callback();
            }
        }
    }
});
/**
 * A util to handle programmes/rows for the epg.
 * @module tvedemo/wgt/EPG/EpgProgrammeGrid
 */
define("tvedemo/wgt/EPG/EpgProgrammeGrid", [
    "tvedemo/wgt/EPG/ProgrammeGrid/HorizontalAnimation", 
    "tvedemo/wgt/EPG/data/Retrieval",
    "tvedemo/wgt/EPG/ProgrammeGrid/VerticalStepAnimation", 
    "xdk-ax/evt/type",
    "xdk-ax/Container", 
    "tvedemo/helper/sMoment",
    "xdk-base/console", 
    "xdk-base/device"
], function (HorizontalAnimation, 
             Retrieval,
             VerticalStepAnimation, 
             evtType,
             Container, 
             moment,
             console, 
             device) {
    "use strict";
    var pixelsPerMinute = 0,
        checkTimeType = function(time){
            if(typeof time === 'number'){
                return time;
            }
            return new moment(time).valueOf();
        };

    return {
        epgMask: null,
        epgContainer: null,
        epgContainerNext: null,
        epgProgrammeRows: null, //ARRAY contains each row of programme objects
        newRow: null,

        patron: null,
        timeAndPosition: null,
        itemBuilder: null,
        channelBar: null,

        programmeAnimationDelay: null,
        animationListener: null,
        animationUpListener: null,

        setVariables: function(patron, TimeAndPosition, ItemBuilder, ChannelBar){
            this.patron = patron;
            this.timeAndPosition = TimeAndPosition;
            this.itemBuilder = ItemBuilder;
            this.channelBar = ChannelBar;
            pixelsPerMinute = patron.scrollPanelWidth / patron.timeSlotSize;
            this.epgProgrammeRows = [];
            this.setupContainers();
        },

        setupContainers: function(){
            this.epgMask = this.itemBuilder.returnContainer('epgMask', 'epgMask', this.patron);
            this.epgContainer = this.itemBuilder.returnContainer('epgContainer-'+this.timeAndPosition.dayPosition + '-' + this.timeAndPosition.slotPosition, 'epgContainer channelContainerStepAni', this.epgMask);
        },

        setupProgrammes: function(){
            this.defineEndDayAndSlot();
            this.setupProgrammesIn(this.epgContainer);
        },
        defineEndDayAndSlot: function(){
            try{
                var channelProgrammes = Retrieval.retrieveChannelProgrammes(0, this.patron, this.patron.programmes.length-1);
                var programmeStartTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, channelProgrammes.length-1, this.patron.programmeDataStartTime));
                var programmeEndTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, channelProgrammes.length-1, this.patron.programmeDataEndTime));
                var dayAndSlot = this.timeAndPosition.getTimeSlot(programmeStartTime);
                this.patron.endDay = dayAndSlot.dayPosition;
                this.patron.endSlot = (moment(programmeStartTime).startOf('d').unix() != moment(programmeEndTime).startOf('d').unix())?11:dayAndSlot.slotPosition;
            }catch(err){
                console.log("[EpgProgrammeGrid].defineEndDayAndSlot not posible");
            }
        },
        moveOneProgrammesVertical: function(direction, callback){
            var requiredChannel, cssDirection;
            this.timeAndPosition.getTopChannelIndex();
            requiredChannel = (direction>0)?this.timeAndPosition.getTopChannelIndex() + (this.patron.numberOfRows-1):this.timeAndPosition.getTopChannelIndex();
            if(requiredChannel >= this.patron.channels.length)requiredChannel-=this.patron.channels.length;
            this.newRow = this.generateRow(requiredChannel, requiredChannel, this.epgContainer, (direction<0));
            cssDirection = 'beforeTop';
            if(direction>0){
                VerticalStepAnimation.upAni = false;
                this.animationListener = VerticalStepAnimation.verticalAniComplete(this, VerticalStepAnimation, cssDirection, callback);
                this.epgContainer._root._dom.addEventListener('transitionend', this.animationListener);
                this.epgContainer._root._dom.addEventListener('webkitTransitionEnd', this.animationListener);
                this.epgContainer.addClass(cssDirection);
            }else{
                VerticalStepAnimation.upAni = true;
                this.epgContainer.removeClass('channelContainerStepAni');
                this.epgContainer.addClass(cssDirection);
                this.programmeAnimationDelay = setInterval(VerticalStepAnimation.verticalUpStep2Animation(this, VerticalStepAnimation, cssDirection, callback), 30);
            }
            var firstRow = requiredChannel === 0 ? true : false,
                lastRow = requiredChannel === (this.patron.channels.length-1) ? true : false;
            this.patron.verticalScrollFunc(firstRow, lastRow);
        },
        moveProgrammesHorizontal: function(direction, callback){
            var directionFrom, directionTo, firstSlot, lastSlot;
            if(direction>0){
                directionFrom = 'epgRight';
                directionTo = 'epgLeft';
            }else{
                directionFrom = 'epgLeft';
                directionTo = 'epgRight';
            }
            if (this.timeAndPosition.slotPosition === 0) {
                firstSlot = true;
            }
            if (this.timeAndPosition.slotPosition === 11) {
                lastSlot = true;
            }

            this.patron.horizontalScrollFunc(firstSlot, lastSlot);
            this.epgContainerNext = this.itemBuilder.returnContainer('epgContainer-'+this.timeAndPosition.dayPosition + '-' + this.timeAndPosition.slotPosition, 'epgContainer channelContainerStepAni '+directionFrom, this.epgMask);
            this.setupProgrammesIn(this.epgContainerNext);
            this.programmeAnimationDelay = setInterval(HorizontalAnimation.animateProgrammes(this, HorizontalAnimation, directionTo, directionFrom, callback),30);  //required so css is applied enabling transition
        },
        setupProgrammesIn: function(container){
            var start = this.timeAndPosition.getTopChannelIndex();
            var end = start + this.patron.numberOfRows;
            var endChannelListAdjustment;
            this.epgProgrammeRows = [];
            for(var i = start; i < end; i++){
                if(i>=this.patron.channels.length){
                    endChannelListAdjustment = this.patron.channels.length;
                }else{
                    endChannelListAdjustment = 0;
                }
                this.generateRow(i - endChannelListAdjustment, i, container)
            }
        },
        generateRow: function(requiredChannel, index, container, prepend){
            var channelProgrammes = Retrieval.retrieveChannelProgrammes(requiredChannel, this.patron, this.timeAndPosition.dayPosition);
            var status = Retrieval.retrieveChannelDataElement(requiredChannel, this.patron.channelDataStatus, this.patron);
            var channelBlackout = Retrieval.retrieveChannelDataElement(requiredChannel, this.patron.channelDataBlackout, this.patron);
            var channelSubscribed = Retrieval.retrieveChannelDataElement(requiredChannel, this.patron.channelDataSubscribed, this.patron);
            var channelType = Retrieval.retrieveChannelDataElement(requiredChannel, this.patron.channelDataType, this.patron);
            var channelData = this.patron.channels[requiredChannel];
            var rowContainer = this.itemBuilder.returnContainer('row-'+index,'programmeRow', container, (prepend)?Container.PLACE_PREPEND:Container.PLACE_APPEND);
                rowContainer.channelData = channelData;
            if(prepend){
                this.epgProgrammeRows.unshift(rowContainer);
            }else{
                this.epgProgrammeRows.push(rowContainer);
            }
            this.setupProgrammesInRow(channelProgrammes, rowContainer, status, channelBlackout, channelSubscribed, channelType);
            return rowContainer;
        },
        setupProgrammesInRow: function(channelProgrammes, rowContainer, status, channelBlackout, channelSubscribed, channelType){
            var timeSlotStart = this.timeAndPosition.returnTimeSlot();
            var timeSlotEnd = timeSlotStart + (this.patron.timeSlotSize * this.timeAndPosition.MS_IN_1_MIN);
            var programmeIndex = this.getFirstProgrammeIndex(timeSlotStart, timeSlotEnd, channelProgrammes);
            if (programmeIndex === false || channelProgrammes.length === 0) {
                var dummyListing = [];
                dummyListing.push(this.createDummyProgramme(timeSlotStart, timeSlotEnd));
                this.populateRow([0], dummyListing, timeSlotStart, timeSlotEnd, rowContainer, true, status, channelBlackout, channelSubscribed, channelType);
                return;
            }
            try{
                var createIndex = [programmeIndex];
                if (programmeIndex < (channelProgrammes.length - 1)) {
                    programmeIndex += 1;
                    var programmeStartTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, programmeIndex, this.patron.programmeDataStartTime));
                    while (programmeStartTime < timeSlotEnd){
                        createIndex.push(programmeIndex);
                        programmeIndex += 1;
                        if (programmeIndex == channelProgrammes.length)break;
                        programmeStartTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, programmeIndex, this.patron.programmeDataStartTime));
                    }
                }
                //this.patron.endOfData = createIndex[createIndex.length-1]==channelProgrammes.length-1;
                this.populateRow(createIndex, channelProgrammes, timeSlotStart, timeSlotEnd, rowContainer, false, status, channelBlackout, channelSubscribed, channelType);
            }catch(e){
                console.warn('[Epg ProgrammeGrid]setupProgrammesInRow '+e)
            }
        },
        populateRow: function(createIndex, channelProgrammes, timeSlotStart, timeSlotEnd, rowContainer, dummyFill, status, channelBlackout, channelSubscribed, channelType){
            var programmeStartTime, programmeEndTime, leftAndWidth, id, text, data, css, blackout, flags;
            var len = createIndex.length;
            var item;
            for (var i = 0; i < len; i++){
                programmeStartTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programmeDataStartTime));
                programmeEndTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programmeDataEndTime));
                leftAndWidth = this.returnProgrammeLeftAndWidth(programmeStartTime, programmeEndTime, timeSlotStart, timeSlotEnd);

                // Interrupt to fill any blank space the first show might have left before it.
                if ((i === 0) && (leftAndWidth.left !== 0) && (!dummyFill)) {
                    this.populateRow([0], [this.createDummyProgramme(timeSlotStart, programmeStartTime)], timeSlotStart, timeSlotEnd, rowContainer, true, status, channelBlackout, channelSubscribed, channelType);
                }

                id = Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programmeDataId);
                text = Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programmeDataTitle);
                // flags = Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programmeDataFlags);
                blackout = (channelBlackout)?channelBlackout:Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programmeDataBlackout);
                data = channelProgrammes[createIndex[i]];
                css = id ? 'programmeItem' : 'programmeItem dummy';
                if(this.patron.locked){
                    var prName = Retrieval.retrieveProgrammeDataElement(channelProgrammes, createIndex[i], this.patron.programPrName);
                    var prNameIndex = this.patron.getParentalRatingIndex(prName);
                    // if(this.patron.prIndex <= prNameIndex){
                    //     css+=' locked';
                    // }else if((4&flags)===4){
                    //     css+=' ondemand';
                    // }
                // }else if((4&flags)===4){
                //     css+=' ondemand';
                }
                var nowTime = new Date().getTime();
                if(programmeStartTime <= nowTime && programmeEndTime > nowTime){
                    css += ' programme-onnow';
                } else if(programmeEndTime < nowTime){
                    css += ' programme-past';
                }
                if(blackout) {
                    if (device.platform === "playstation") {
                        css+= ' programme-blackout-playstation';
                    } else {
                        css+= ' programme-blackout';
                    }
                }
                //if(status == 'offline')css+= ' programme-offline';
                //@Todo : re-use blackout and subscribed for on demand
                //if(!channelSubscribed)css+= ' programme-unsubscribed';
                if(channelType)css+= ' ' + channelType;
                item = this.itemBuilder.returnProgrammeItem(id, css, text, data, rowContainer, leftAndWidth.left, leftAndWidth.width);
                item.addEventListener(evtType.FOCUS, this.itemFocus(this));
                if(this.patron.programmeClickFunc){
                    item.addEventListener(evtType.CLICK, this.patron.programmeClickFunc);
                }else if (!dummyFill){
                    console.warn('[Epg ProgrammeGrid ] programmeClickFunc not set');
                }
                // Check no blank space has been left after the final programme.
                if ((i === len-1) && (programmeEndTime < timeSlotEnd) && (!dummyFill)) {
                    this.populateRow([0], [this.createDummyProgramme(programmeEndTime, timeSlotEnd)], timeSlotStart, timeSlotEnd, rowContainer, true, status, channelBlackout, channelSubscribed, channelType);
                }
            }
        },

        createDummyProgramme: function(start, end) {
            return {
                blackout: false,
                category: "",
                end: end,
                id: null,
                start: start,
                synopsis: "",
                thumbnail: "",
                title: "No programme available"
            }
        },

        itemFocus: function(scope){
            return function(evt){
                var target = evt.target;
                var parent = target._parent;
                var row = parent._parent._children.indexOf(parent);
                scope.rowPosition(row);
            };
        },
        returnProgrammeLeftAndWidth: function(programmeStartTime, programmeEndTime, timeSlotStart, timeSlotEnd){
            var retObj = {}, widthAdjust = 0;
            retObj.left = 0;
            if(programmeStartTime > timeSlotStart){
                retObj.left = Math.floor((programmeStartTime - timeSlotStart)/this.timeAndPosition.MS_IN_1_MIN * pixelsPerMinute);
            }else{
                widthAdjust = timeSlotStart - programmeStartTime;
            }
            if(programmeEndTime < timeSlotEnd){
                retObj.width = Math.floor((programmeEndTime - (programmeStartTime + widthAdjust))/this.timeAndPosition.MS_IN_1_MIN * pixelsPerMinute);
            }else{
                retObj.width = Math.floor((timeSlotEnd - (programmeStartTime + widthAdjust))/this.timeAndPosition.MS_IN_1_MIN * pixelsPerMinute);
            }
            return retObj;
        },
        getFirstProgrammeIndex: function(timeSlotStart, timeSlotEnd, channelProgrammes){
            var len = channelProgrammes.length, startTime, endTime;
            for (var i = 0; i < len; i++){
                startTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, i, this.patron.programmeDataStartTime));
                endTime = checkTimeType(Retrieval.retrieveProgrammeDataElement(channelProgrammes, i, this.patron.programmeDataEndTime));
                if(startTime < timeSlotEnd && endTime > timeSlotStart){
                    return i;
                }
            }
            return false;
        },
        rowPosition: function(value) {
            if(value > -1) {
                if(this.timeAndPosition.rowPosition < this.patron.numberOfRows){
                    this.removeRowFocus(this.timeAndPosition.rowPosition);
                }
                this.timeAndPosition.rowPosition = value;
                this.addRowFocus(value);
            }
            return this.timeAndPosition.rowPosition;
        },
        removeRowFocus: function(rowPosition){
            var rowChildren = this.epgProgrammeRows[rowPosition]._children;
            for(var i = 0; i< rowChildren.length; i++)
                rowChildren[i].removeClass('rowFocus');
            this.channelBar.channelObjects[rowPosition].removeClass('rowFocus');
        },
        addRowFocus: function(rowPosition){
            // var rowChildren = this.epgProgrammeRows[rowPosition]._children;
            // for(var i = 0; i< rowChildren.length; i++)
            //     rowChildren[i].addClass('rowFocus');
            // this.channelBar.channelObjects[rowPosition].addClass('rowFocus');
        },
        returnNowProgrammeIndex: function(){
            var rowChildren = this.epgProgrammeRows[this.rowPosition()]._children;
            var nowTime = moment().unix() * 1000;
            var startTime, endTime
            for(var i = 0; i< rowChildren.length; i++){
                console.log(rowChildren[i])
                startTime = Retrieval.retrieveProgrammeElement(rowChildren[i]._opts.programmeData , this.patron.programmeDataStartTime);
                endTime = Retrieval.retrieveProgrammeElement(rowChildren[i]._opts.programmeData , this.patron.programmeDataEndTime);
                if((checkTimeType(startTime) < nowTime) && (checkTimeType(endTime) > nowTime))
                    return i;
            }
            return 0;
        },
        detachProgrammeRows: function(){
            for(var i=0; i<this.epgProgrammeRows.length; i++){
                this.epgProgrammeRows[i].detach();
            }
        }

    }
});


define("tvedemo/wgt/EPG/EPGKeyHandler", [
    "tvedemo/wgt/EPG/data/Retrieval", "xdk-base/device/vKey", "xdk-ax/focusManager", "xdk-base/console", "tvedemo/helper/sMoment", "xdk-base/util"
], function (Retrieval, vKey, focusManager, console, moment, util) {
    "use strict";
    var programmeGrid, navigation, timeMarker, animating = false, MIN_IN_DAY =  1440, SCROLL_DELAY = 500;


    return {
        setVariables: function(ProgrammeGrid, Navigation, TimeMarker){
            programmeGrid = ProgrammeGrid;
            navigation = Navigation;
            timeMarker = TimeMarker;
        },
        handleKey: function(scope, self, callback){
            return function(evt){
                var target, parent, children, timeS;
                console.log('[EPGKeyHandler]handleKey - evt '+evt.id);
                console.log(evt);
                if(!animating){
                    switch (evt.id) {
                        case "device:kb-vkey:r":
                        case scope.forwardFocusKey:
                            if(scope.forwardFocusFunc){
                                scope.forwardFocusFunc();
                            }else{
                                console.warn('[EPG KeyHandler] opts.forwardFocusFunc not set');
                            }
                            return false;
                        case "device:kb-vkey:y":
                        case scope.dateDialogKey:
                            if(scope.dateDialogFunc){
                                scope.dateDialogFunc(scope.endDay+1);
                            }else{
                                console.warn('[EPG KeyHandler] opts.dateDialogFunc not set');
                            }
                            return false;
                        case "device:kb-vkey:g":
                        case scope.submenuKey:
                            if(scope.submenuFunc){
                                scope.submenuFunc();
                            }else{
                                console.warn('[EPG KeyHandler] opts.submenuFunc not set');
                            }
                            return false;
                        case 'localUp':
                            programmeGrid.rowPosition(0);
                            timeS = programmeGrid.timeAndPosition.getCurrentTimeSlotStart();
                            self.moveUp(scope, {startTime: timeS, entTime: timeS}, callback);
                            return false;
                        case 'localDown':
                            programmeGrid.rowPosition(scope.numberOfRows-2);
                            timeS = programmeGrid.timeAndPosition.getCurrentTimeSlotStart();
       
                            var navigationCallback = function() {
                                self.goDownOne(scope, {startTime: timeS, entTime: timeS}, callback);
                            };
                            var targetTop = self.downTargetTop(scope);

                            // Check if there is a need to retrieve more data.
                            self.checkForListingsInChannelPage(scope, programmeGrid.timeAndPosition.dayPosition, targetTop, navigationCallback);

                            return false;
                        case vKey.UP.id:
                            self.moveUp(scope, evt);
                            return false;
                        case vKey.OK.id:
                            if(scope.programmeClickFunc){
                                scope.programmeClickFunc(evt);
                            }else{
                                console.warn('[Epg KeyHandler ] programmeClickFunc not set');
                            }
                            return false;
                        case vKey.DOWN.id:
                            self.moveDown(scope, evt);
                            return false;
                        case vKey.RIGHT.id:
                            self.moveRight(scope, evt, self);
                            return false;
                        case vKey.LEFT.id:
                            self.moveLeft(scope, evt, self);
                            return false;
                        case scope.goToStartKey:
                        case "device:kb-vkey:b":
                            self.nowPosition(this);
                            return false;
                        case vKey.NEXT.id:
                        case  "device:kb-vkey:m":
                        case vKey.FF.id:
                            self.dayRight(scope);
                            return false;
                        case vKey.PREV.id:
                        case  "device:kb-vkey:n":
                        case vKey.RW.id:
                            if(programmeGrid.timeAndPosition.dayPosition > 0){
                                if(programmeGrid.timeAndPosition.slotPosition < programmeGrid.timeAndPosition.dataStartSlot && programmeGrid.timeAndPosition.dayPosition == 1){
                                    programmeGrid.timeAndPosition.slotPosition = programmeGrid.timeAndPosition.dataStartSlot;
                                }
                                self.dayLeft(scope);
                            }
                            return false;
                        default:
                            console.log('[EPGKeyHandler]handleKey - evt '+evt.id + ' : TRUE');
                            return true;
                    }
                }else{
                    switch (evt.id) {
                        case 'localUp':
                        case 'localDown':
                        case vKey.UP.id:
                        case vKey.DOWN.id:
                        case vKey.RIGHT.id:
                        case vKey.LEFT.id:
                        case scope.goToStartKey:
                        case "device:kb-vkey:y":
                        case vKey.NEXT.id:
                        case  "device:kb-vkey:m":
                        case vKey.FF.id:
                        case vKey.PREV.id:
                        case  "device:kb-vkey:n":
                        case vKey.RW.id:
                            return false;
                        default:
                            return true;
                    }
                }
                return true;
            }
        },
        goToDay: function(scope, day){
            if(day >= scope.minDay && day <= scope.maxDay && day != programmeGrid.timeAndPosition.dayPosition){
                var slot = programmeGrid.timeAndPosition.slotPosition;
                var direction = -1;
                var numberOfSlots;
                if(programmeGrid.timeAndPosition.slotPosition < programmeGrid.timeAndPosition.dataStartSlot && day == 0){
                    slot = programmeGrid.timeAndPosition.dataStartSlot;
                }
                var navigationCallback = util.bind(function() {
                    animating = true;
                    if(day > programmeGrid.timeAndPosition.dayPosition){
                        direction = 1;
                        numberOfSlots = ((day - programmeGrid.timeAndPosition.dayPosition)*MIN_IN_DAY / scope.timeSlotSize);
                        //numberOfSlots += slot - programmeGrid.timeAndPosition.dataStartSlot;
                        navigation.moveDays(numberOfSlots, direction, this.pageFocus(0, this));
                    }else{
                        numberOfSlots = ((programmeGrid.timeAndPosition.dayPosition - day)*MIN_IN_DAY / scope.timeSlotSize);
                        navigation.moveDays(numberOfSlots, direction, this.pageFocus('last', this));
                    }
                },this);
                this.checkForListings(scope, day, navigationCallback);
            };
        },
        moveUp: function(scope, evt, callback){
            var timeObj;

            if (callback) { // Scrolled using up arrow button.
                timeObj = evt;
            } else {
                timeObj = this.returnStartAndEndTime(scope, evt.target._opts.programmeData);
            }

            var targetTop = programmeGrid.timeAndPosition.getTopChannelIndex() - programmeGrid.patron.numberOfRows;
            if(targetTop < 0){
                targetTop = targetTop + programmeGrid.timeAndPosition.numberOfChannels;
            }
            if((targetTop % programmeGrid.patron.numberOfRows) > 0){
                targetTop += programmeGrid.patron.numberOfRows - (targetTop % programmeGrid.patron.numberOfRows);
            }
            if(targetTop >= programmeGrid.timeAndPosition.numberOfChannels-1){
                targetTop -= (programmeGrid.timeAndPosition.numberOfChannels-1);
            }
            var navigationCallback = util.bind(function() {
                    // animating = true;
                    this.goUpOne(scope, timeObj, callback);
                }, this);
            this.checkForListingsInChannelPage(scope, programmeGrid.timeAndPosition.dayPosition, targetTop, navigationCallback);
        },
        goUpOne: function(scope, timeObj, callback){
            if(programmeGrid.rowPosition() == 0){
                // Create an artificial delay to allow row animation to complete before firing another.
                if (!this.scrollDelayUp) {
                    this.scrollDelayUp = setTimeout(util.bind(function(){ this.scrollDelayUp = false; }, this), SCROLL_DELAY);
                    animating = true;

                    if (callback) {
                        navigation.nextUp(util.bind(function() {
                            this.itemFocus(timeObj, scope, this)();
                            callback();
                        }, this), true);
                    } else {
                        navigation.nextUp(this.itemFocus(timeObj, scope, this));
                    }
                }
            }else{
                programmeGrid.rowPosition(programmeGrid.rowPosition()-1);
                this.itemFocus(timeObj, scope, this)();
            }
        },
        moveDown: function(scope, evt){
            var timeObj = this.returnStartAndEndTime(scope, evt.target._opts.programmeData);
            var targetTop = this.downTargetTop(scope);

            if(targetTop > programmeGrid.timeAndPosition.numberOfChannels){
                return;
            }

            // We want to just move to last row.
            if (targetTop === programmeGrid.timeAndPosition.numberOfChannels) {
                this.goDownOne(scope, timeObj, null, true);
                return;
            }

            var navigationCallback = util.bind(function() {
                    this.goDownOne(scope, timeObj);
                }, this);
            this.checkForListingsInChannelPage(scope, programmeGrid.timeAndPosition.dayPosition, targetTop, navigationCallback);
        },
        downTargetTop: function(scope){
            if (programmeGrid.timeAndPosition.getTopChannelIndex() + scope.numberOfRows === programmeGrid.timeAndPosition.numberOfChannels-2) {
                return programmeGrid.timeAndPosition.getTopChannelIndex() + programmeGrid.timeAndPosition.rowPosition + 1;
            }
            if (programmeGrid.timeAndPosition.rowPosition === scope.numberOfRows-2) {
                return programmeGrid.timeAndPosition.getTopChannelIndex() + scope.numberOfRows;
            }
            return programmeGrid.timeAndPosition.getTopChannelIndex() + programmeGrid.timeAndPosition.rowPosition + 1;
        },

        goDownOne: function(scope, timeObj, callback, moveToLastRow){
            var chAdjust = (programmeGrid.timeAndPosition.getTopChannelIndex() + scope.numberOfRows === programmeGrid.timeAndPosition.numberOfChannels-1) ? 1 : 2;

            // If there is a callback we can assume it's from arrow button click. So we always wants to animate downwards.
            if ((programmeGrid.timeAndPosition.rowPosition === scope.numberOfRows-chAdjust && moveToLastRow !== true) || callback) {
                // Create an artificial delay to allow row animation to complete before firing another.
                if (!this.scrollDelayDown) {
                    this.scrollDelayDown = setTimeout(util.bind(function(){ this.scrollDelayDown = false; }, this), SCROLL_DELAY);
                    animating = true;

                    if (callback) {
                        navigation.nextDown(util.bind(function() {
                            this.itemFocus(timeObj, scope, this)();
                            callback && callback();
                        }, this));
                    } else {
                        navigation.nextDown(this.itemFocus(timeObj, scope, this));
                    }
                }
            } else if (programmeGrid.timeAndPosition.rowPosition <= scope.numberOfRows-chAdjust) {
                programmeGrid.rowPosition(programmeGrid.timeAndPosition.rowPosition+1);
                this.itemFocus(timeObj, scope, this)();
            }
        },

        checkForListings: function(scope, offset, navigationCallback) {
            if (offset >= scope.minDay && offset <= scope.maxDay) {
                // Test if listings exist for the offset day.
                var requirement = this.checkForListingsInDayPage(scope, offset);
                if (requirement[0].required || requirement[1].required) {
                    var dozen = 2;
                    var targetTop;
                    if(requirement[0].required === requirement[1].required){
                        targetTop = requirement[1].targetTop;
                        if(requirement[0].targetTop !== requirement[1].targetTop){
                            dozen = 3;
                        }
                    }else{
                        if(requirement[0].required){
                            targetTop = requirement[0].targetTop;
                        }else if(requirement[1].required){
                            targetTop = requirement[1].targetTop;
                        }
                    }
                    scope.requestListings(offset, navigationCallback, targetTop, false, dozen);
                } else {
                    navigationCallback();
                }
            }
            else {
                return false;
            }
        },
        checkForListingsInDayPage: function(scope, offset){
            var targetTopA = programmeGrid.timeAndPosition.getTopChannelIndex();
            var aToB = programmeGrid.patron.numberOfRows;
            if(targetTopA < 0){
                targetTopA = targetTopA + programmeGrid.timeAndPosition.numberOfChannels;
            }
            if((targetTopA % programmeGrid.patron.numberOfRows) > 0){
                targetTopA += programmeGrid.patron.numberOfRows - (targetTopA % programmeGrid.patron.numberOfRows);
            }else{
                aToB = 0;
            }
            if(targetTopA >= programmeGrid.timeAndPosition.numberOfChannels){
                targetTopA -= programmeGrid.timeAndPosition.numberOfChannels;
            }
            var targetTopB = targetTopA - aToB;
            if(targetTopB < 0){
                targetTopB = targetTopB + programmeGrid.timeAndPosition.numberOfChannels;
            }
            var aRequired = false;
            var bRequired = false;
            if (!scope.programmes[offset] || (scope.programmes[offset].timestamp + scope.listingsCache < new Date().getTime())) {
                aRequired = true;
                bRequired = true;
             }else{
                if(!scope.programmes[offset].data[targetTopA]){
                    aRequired = true;
                }
                if(!scope.programmes[offset].data[targetTopB]){
                    bRequired = true;
                }
             }
             return [{
                    required : aRequired,
                    targetTop : targetTopA
                },{
                    required : bRequired,
                    targetTop : targetTopB
                }];
        },
        checkForListingsInChannelPage: function(scope, offset, topIndex, navigationCallback, hidden) {
            if (offset >= scope.minDay && offset <= scope.maxDay) {
                // Test if listings exist for the offset day.
                if (!scope.programmes[offset] || !scope.programmes[offset].data[topIndex] || (scope.programmes[offset].timestamp + scope.listingsCache < new Date().getTime())) {
                    scope.requestListings(offset, navigationCallback, topIndex, hidden);
                } else {
                    navigationCallback();
                }
            }
            else {
                return false;
            }
        },

        getNewDayPosition: function(direction) {
            var dayPosition = programmeGrid.timeAndPosition.dayPosition;
            var slotPosition = programmeGrid.timeAndPosition.slotPosition;
            slotPosition += direction;
            if (slotPosition > 11) {
                slotPosition -= 12;
                dayPosition += 1;
            }
            else if (slotPosition < 0) {
                slotPosition += 12;
                dayPosition -= 1;
            }
            return dayPosition;
        },
        checkForEnd: function(scope, direction, self) {
            var dayPosition = self.getNewDayPosition(direction);
            return (dayPosition <= scope.maxDay && dayPosition >= scope.minDay);
        },
        returnValidEnd: function(dayPosition, slotPosition, scope, navigationCallback){
            if(dayPosition > scope.endDay){
                this.checkForListings(scope, dayPosition).then(function() {
                    navigationCallback();
                    return;
                });
            } else if(dayPosition == scope.endDay && slotPosition > scope.endSlot){
                return false;
            }
            else {
                navigationCallback();
            }
        },
        dayLeft: function(scope){
            this.checkForListings(scope, programmeGrid.timeAndPosition.dayPosition-1, util.bind(function() {
                timeMarker.hide();
                animating = true;
                navigation.prevDay(this.pageFocus('last', this));
            },this));
        },
        dayRight: function(scope){
            this.checkForListings(scope, programmeGrid.timeAndPosition.dayPosition+1, util.bind(function() {
                timeMarker.hide();
                animating = true;
                navigation.nextDay(this.pageFocus(0, this));
            },this));
        },
        nowPosition: function(scope){
            var navigationFunction = this.nowNavigationFunction();
            if(navigationFunction){
                animating = true;
                programmeGrid.timeAndPosition.slotPosition = programmeGrid.timeAndPosition.dataStartSlot;
                programmeGrid.timeAndPosition.dayPosition = 1;
                var navigationCallback = this.nowNavigationCallback(this, navigationFunction);
                this.checkForListings(scope, 0, util.bind(navigationCallback, navigation));
            }
        },
        nowNavigationCallback: function(self, navigationFunction){
            return function(){
                navigationFunction(self.pageFocus('current', self));
            }
        },
        nowNavigationFunction: function(){
            if(programmeGrid.timeAndPosition.dayPosition === 0){
                if(programmeGrid.timeAndPosition.slotPosition > programmeGrid.timeAndPosition.dataStartSlot){
                    return util.bind(navigation.prevDay, navigation);
                }else if(programmeGrid.timeAndPosition.slotPosition < programmeGrid.timeAndPosition.dataStartSlot){
                    return util.bind(navigation.prevDay, navigation);
                }else{
                    return;
                }
            }else if(programmeGrid.timeAndPosition.dayPosition > 0){
                return util.bind(navigation.prevDay, navigation);
            }else{
                return util.bind(navigation.prevDay, navigation);
            }
        },
        moveLeft: function(scope, evt, self){
            var target = evt.target;
            if(!animating) {
                self.goLeft(target, scope, self);
            }
        },
        goToPrevPage: function(scope, self, callback){
            if(!animating && self.checkForEnd(scope, 1, self)){
                if(!(programmeGrid.timeAndPosition.dayPosition == 0 && programmeGrid.timeAndPosition.slotPosition == programmeGrid.timeAndPosition.dataStartSlot)){
                    timeMarker.hide();
                    animating = true;

                    if (callback) {
                        navigation.nextLeft(function() {
                            self.pageFocus('last', self)();
                            callback();
                        });
                    } else {
                        navigation.nextLeft(self.pageFocus('last', self));
                    }
                }
            }
        },
        goLeft: function(target, scope, self){
            var parent = target._parent;
            var children = parent._children;
            var index = children.indexOf(target) - 1;
            if(index == -1 && this.checkForEnd(scope, -1, this)){
                if(!(scope.bookendHorizontal && programmeGrid.timeAndPosition.slotPosition === 0)){
                    this.checkForListings(scope, self.getNewDayPosition(-1), util.bind(function() {
                        timeMarker.hide();
                        animating = true;
                        navigation.nextLeft(this.pageFocus('last', this));
                    },this));
                }
            }else{
                focusManager.focus(children[index]);
            }
        },
        moveRight: function(scope, evt, self){
            var target = evt.target;
            self.goRight(target, scope, self);
        },
        goToNextPage: function(scope, self, callback) {
            if(!animating && self.checkForEnd(scope, 1, self)){
                if(!scope.endOfData){
                    timeMarker.hide();
                    animating = true;

                    if (callback) {
                        navigation.nextRight(function() {
                            self.pageFocus(0, self)();
                            callback();
                        });
                    } else {
                        navigation.nextRight(self.pageFocus(0, self));
                    }
                }
            }
        },
        goRight: function(target, scope, self){
            var parent = target._parent;
            var children = parent._children;
            var index = children.indexOf(target) + 1;
            if(index == children.length){
                if(!(scope.bookendHorizontal && programmeGrid.timeAndPosition.slotPosition === 11)){
                    var navigationCallback = function() {
                        timeMarker.hide();
                        animating = true;
                        navigation.nextRight(self.pageFocus(0, self));
                    };
                    if(self.checkForEnd(scope, 1, self)){
                        self.checkForListings(scope, self.getNewDayPosition(1), navigationCallback);
                    }
                }
            }else{
                focusManager.focus(children[index]);
            }
        },
        pageFocus: function(index, self){
            return function(notComplete){
                timeMarker.updateMarkerPosition(timeMarker)();
                if(index == 'last'){
                    index = programmeGrid.epgProgrammeRows[programmeGrid.rowPosition()]._children.length -1;
                }else if(index == 'current'){
                    index = programmeGrid.returnNowProgrammeIndex();
                }
                if(!notComplete){
                    index = self.validateFocus(index);
                    focusManager.focus(programmeGrid.epgProgrammeRows[programmeGrid.rowPosition()]._children[index]);
                }
                animating = false;
            };
        },
        validateFocus: function(index){
            if(index < 0) index = this.findFocus();
            if(programmeGrid.epgProgrammeRows[programmeGrid.rowPosition()]._children.length == 0) index = this.findFocus();
            if(programmeGrid.epgProgrammeRows[programmeGrid.rowPosition()]._children.length-1 < index) index = programmeGrid.epgProgrammeRows[programmeGrid.rowPosition()]._children.length -1;
            return index;
        },
        findFocus: function(){
            var index = 0;
            for(var i = 0; i < programmeGrid.epgProgrammeRows.length; i++){
                if(programmeGrid.epgProgrammeRows[i]._children.length > 0){
                    programmeGrid.rowPosition(i);
                    return index;
                }
            }
            return index;
        },
        returnStartAndEndTime: function(scope, data){
            var retObj = {};
            retObj.startTime = moment(Retrieval.retrieveProgrammeElement(data, scope.programmeDataStartTime)).unix();
            retObj.endTime = moment(Retrieval.retrieveProgrammeElement(data, scope.programmeDataEndTime)).unix();
            return retObj;
        },
        itemFocus: function(oldFocusObj, scope, self){
            return function(){
                var items = programmeGrid.epgProgrammeRows[programmeGrid.rowPosition()]._children;
                var len = items.length;
                var itemsWeight = [];
                var newFocusObj;
                var focusItem = self.returnOnNowFocusItem(scope, self, items, oldFocusObj);
                if(focusItem === null){
                    for(var i = 0; i<len; i++){
                        newFocusObj = self.returnStartAndEndTime(scope, items[i]._opts.programmeData);
                        itemsWeight.push(self.weightItem(newFocusObj, oldFocusObj));
                    }
                    focusItem = self.returnItemToFocusFromWeight(items, itemsWeight);
                }

                focusManager.focus(focusItem);

                animating = false;
            }
        },
        returnOnNowFocusItem: function(scope, self, items, oldFocusObj){
            var nowTime = moment().unix();
            var newFocusObj, len;
            if(oldFocusObj.startTime < nowTime && oldFocusObj.endTime > nowTime){
                len = items.length;
                for(var i = 0; i<len; i++){
                    newFocusObj = self.returnStartAndEndTime(scope, items[i]._opts.programmeData);
                    if(newFocusObj.startTime < nowTime && newFocusObj.endTime > nowTime){
                        return items[i];
                    }
                }
            }
            return null;
        },
        returnItemToFocusFromWeight: function(items, itemsWeight){
            var focusItem = items[0];
            var focusItemWeight = itemsWeight[0];
            var len = items.length;
            for(var i = 1; i<len; i++){
                if(focusItemWeight<itemsWeight[i]){
                    focusItem = items[i];
                    focusItemWeight = itemsWeight[i];
                }
            }
            return focusItem;
        },
        weightItem: function(newFocusObj, oldFocusObj){
            var coverTime = 0;
            if(newFocusObj.startTime > oldFocusObj.endTime)return 0;
            if(newFocusObj.endTime < oldFocusObj.startTime)return 0;
            if(newFocusObj.startTime == oldFocusObj.startTime)return 100;
            if(newFocusObj.startTime < oldFocusObj.startTime && newFocusObj.endTime >= oldFocusObj.endTime )return 100;
            if(newFocusObj.startTime < oldFocusObj.startTime && newFocusObj.endTime < oldFocusObj.endTime){
                coverTime = newFocusObj.endTime - oldFocusObj.startTime;
            }else if(newFocusObj.startTime > oldFocusObj.startTime && newFocusObj.endTime < oldFocusObj.endTime){
                coverTime = newFocusObj.endTime - newFocusObj.startTime;
            }else if(newFocusObj.startTime > oldFocusObj.startTime && newFocusObj.endTime > oldFocusObj.endTime){
                coverTime = oldFocusObj.endTime - newFocusObj.startTime;
            }

            return (100/(oldFocusObj.endTime - oldFocusObj.startTime))*coverTime;
        }
    }
});

define("tvedemo/wgt/EPG/EpgNavigation", [
    "tvedemo/helper/sMoment", "xdk-base/console"
], function (moment, console) {
    "use strict";
    var MIN_IN_DAY =  1440;

    return {
        patron: null,
        channelBar: null,
        programmeGrid: null,
        topBar: null,

        setVariables: function(patron, ChannelBar, ProgrammeGrid, TopBar){
            this.patron = patron;
            this.channelBar = ChannelBar;
            this.programmeGrid = ProgrammeGrid;
            this.topBar = TopBar;
        },

        nextUp: function(callback, arrowClicked){
            var intendedChannel = this.programmeGrid.timeAndPosition.getTopChannelIndex() - 1;
            if ((intendedChannel < 0 || intendedChannel >= this.patron.channels.length) && this.patron.verticalPagingDisabled()) {
                callback();
                if (!arrowClicked) {
                    this.patron.submenuFunc();
                }
                return;
            }
            this.programmeGrid.removeRowFocus(this.programmeGrid.timeAndPosition.rowPosition);
            this.channelBar.moveChannel(-1);
            this.programmeGrid.moveOneProgrammesVertical(-1, callback);
        },
        nextDown: function(callback){
            var intendedChannel = this.programmeGrid.timeAndPosition.getTopChannelIndex() + this.patron.maxRows;
            if ((intendedChannel < 0 || intendedChannel >= this.patron.channels.length) && this.patron.verticalPagingDisabled()) {
                return callback();
            }
            this.programmeGrid.removeRowFocus(this.programmeGrid.timeAndPosition.rowPosition);
            this.channelBar.moveChannel(1);
            this.programmeGrid.moveOneProgrammesVertical(1, callback);
        },
        nextRight: function(callback){
            var validMove = this.topBar.moveTimeLineHorizontal(1);
            if(validMove) {
                this.programmeGrid.moveProgrammesHorizontal(1, callback);
            }else{
                callback(true);
            }
        },
        nextLeft: function(callback){
            var validMove = this.topBar.moveTimeLineHorizontal(-1);
            if(validMove) {
                this.programmeGrid.moveProgrammesHorizontal(-1, callback);
            }else{
                callback(true);
            }
        },
        nextDay: function(callback){
            var slots = MIN_IN_DAY / this.patron.timeSlotSize;
            var validMove = this.topBar.moveTimeLineHorizontal(slots);
            if(validMove) {
                this.programmeGrid.moveProgrammesHorizontal(slots, callback);
            }else{
                callback(true);
            }
        },
        prevDay: function(callback){
            var slots = MIN_IN_DAY / this.patron.timeSlotSize;
            var validMove = this.topBar.moveTimeLineHorizontal(-slots);
            if(validMove) {
                this.programmeGrid.moveProgrammesHorizontal(-slots, callback);
            }else{
                callback(true);
            }
        },
        moveDays: function(numberOfSlots, direction, callback){
            var validMove = this.topBar.moveTimeLineHorizontal(direction * numberOfSlots);
            if(validMove) {
                this.programmeGrid.moveProgrammesHorizontal(direction * numberOfSlots, callback);
            }else{
                callback(true);
            }
        }
    }
});

define("tvedemo/wgt/EPG/EpgTimeMarker", [
    "tvedemo/helper/sMoment", 
    "xdk-base/console",
    "tvedemo/helper/CentralEuropeanTime"
], function (moment, console, centralEuropeanTime) {
    "use strict";
        var pixelsPerMinute;
    return {
        patron: null,
        timeAndPosition: null,
        programmeGrid: null,
        itemBuilder:null,

        timeMarker: null,
        timeMarkerHTML: null,

        startingLeft:0,
        markerWidthInTime:0,

        interval:null,

        setVariables: function(patron, TimeAndPosition, ProgrammeGrid, ItemBuilder){
            this.patron = patron;
            this.timeAndPosition = TimeAndPosition;
            this.programmeGrid = ProgrammeGrid;
            this.itemBuilder = ItemBuilder;
            this.setupContainers();
            this.startingLeft = patron.channelBarWidth - (patron.timeMarkerImageWidth/2);
            pixelsPerMinute = patron.scrollPanelWidth / patron.timeSlotSize;
            this.show();
        },
        setupContainers: function(){
            this.timeMarker = this.itemBuilder.returnContainer('timeMarker', 'timeMarker hidden', this.patron);
            this.timeMarkerHTML = this.timeMarker.getRoot().getHTMLElement();
        },
        updateMarkerPosition: function(scope){
            return function(){
                var timeObj = scope.timeAndPosition.getCurrentSlotTimesForMarker();
                if(timeObj.dataStartSlot)scope.timeAndPosition.dataStartSlot = timeObj.dataStartSlot
                if(timeObj.startTime) {
                    var currentTime = centralEuropeanTime.getTimestampMillis() - timeObj.startTime;
                    var end = timeObj.endTime - timeObj.startTime;
                    if(currentTime > end){
                        scope.hide();
                    } else {
                        scope.timeMarker.removeClass('hidden');
                        scope.timeMarkerHTML.style.left = (scope.startingLeft + (currentTime * (pixelsPerMinute / scope.timeAndPosition.MS_IN_1_MIN))) + 'px';
                    }
                }else{
                    scope.hide();
                }

            }
        },
        hide: function(){
            this.timeMarker.addClass('hidden');
        },
        show: function(){
            if(this.interval == null) this.interval = setInterval(this.updateMarkerPosition(this), 500);
            this.updateMarkerPosition(this)();
        }
    }
});
/**
 * sets all options from opts for the epg.
 * @module tvedemo/wgt/EPG/EpgCSS
 */
define("tvedemo/wgt/EPG/EpgOptions", ["xdk-base/device/vKey"], function (vKey) {
    "use strict";
    var patron = null,
        TimeAndPosition = null,
        defaultCache = (60*60*1000);

    return {

        setOptions: function(opts, _patron, timeAndPosition){
            TimeAndPosition = timeAndPosition;
            TimeAndPosition.dayPosition = opts.offset ? opts.offset : 0;
            patron = _patron;
            this.resetOptions(opts);
        },
        resetOptions: function(opts){
            this.populateVariables(opts);
            this.populateDataLocations(opts);
            this.populateEpgDimensions(opts);
            this.populateTimeMarker(opts);
            this.populateKeyHandling(opts);
            this.populateColours(opts);
        },
        populateVariables: function(opts){
            patron.locateTop=(opts.locateTop)?opts.locateTop:170;
            patron.locateLeft=(opts.locateLeft)?opts.locateLeft:80;
            patron.numberOfRows=(opts.numberOfRows)?opts.numberOfRows:6;
            patron.maxRows = patron.numberOfRows;
            patron.maxDay=(opts.maxDay)?opts.maxDay:7; // 0 based
            patron.minDay=(opts.minDay)?opts.minDay:0;
            patron.setFocusOnLaunch=(opts.setFocusOnLaunch)?opts.setFocusOnLaunch:true;
            patron.setFocusOnLaunchDelay=(opts.setFocusOnLaunchDelay)?opts.setFocusOnLaunchDelay:200;
            if(opts.topChannelIndex || opts.topChannelIndex === 0)TimeAndPosition.setTopChannelIndex(opts.topChannelIndex);
            patron.requestListings=(opts.requestListingsFunc)?opts.requestListingsFunc:null;
            patron.requestListingsErrorHandler=(opts.requestListingsErrorHandler)?opts.requestListingsErrorHandler:null;
            patron.horizontalScrollFunc=(opts.horizontalScrollFunc)?opts.horizontalScrollFunc:null;
            patron.verticalScrollFunc=(opts.verticalScrollFunc)?opts.verticalScrollFunc:null;
            TimeAndPosition.stopVerticalPaging = (opts.stopVerticalPaging)? opts.stopVerticalPaging : false;
            patron.forcedStopVerticalPaging = (opts.stopVerticalPaging)? opts.stopVerticalPaging : false;
            patron.listingsCache=(opts.listingsCache) ? opts.listingsCache : defaultCache;
            patron.prIndex =(opts.parentalRatingIndex)?opts.parentalRatingIndex:null;
            if(opts.parentalRatingIndex > -1){
                patron.locked = true;
            }else{
                patron.locked = false;
            }
            patron.getParentalRatingIndex = opts.getParentalRatingIndex;
            patron.programmeDataFlags=(opts.programmeDataFlags)?opts.programmeDataFlags:'flags';
            patron.loggedIn = opts.loggedIn ? opts.loggedIn : false;
            patron.bookendHorizontal = opts.bookendHorizontal ? opts.bookendHorizontal : false;
        },
        populateColours: function(opts){
            patron.channelHeaderLabelBackgroundColour=(opts.channelHeaderLabelBackgroundColour)?opts.channelHeaderLabelBackgroundColour: [23, 34, 82,1];
            patron.channelHeaderLabelTextColour=(opts.channelHeaderLabelTextColour)?opts.channelHeaderLabelTextColour: [115, 120, 153,1];
            patron.timeLineItemBackgroundColour=(opts.timeLineItemBackgroundColour)?opts.timeLineItemBackgroundColour: [23, 34, 82,1];
            patron.timeLineItemTextColour=(opts.timeLineItemTextColour)?opts.timeLineItemTextColour: [115, 120, 153,1];
            patron.channelObjectBackgroundColour=(opts.channelObjectBackgroundColour)?opts.channelObjectBackgroundColour: [23, 34, 82,1];
            patron.channelObjectOfflineColour=(opts.channelObjectOfflineColour)?opts.channelObjectOfflineColour: [36,39,44,1];
            patron.channelObjectBlackoutColour=(opts.channelObjectBlackoutColour)?opts.channelObjectBlackoutColour: [36,39,44,1];
            patron.channelObjectUnsubscribedColour=(opts.channelObjectUnsubscribedColour)?opts.channelObjectUnsubscribedColour: [36,39,44,1];
            patron.channelObjectTextColour=(opts.channelObjectTextColour)?opts.channelObjectTextColour: [115, 120, 153,1];
            patron.channelMaskBackgroundColour=(opts.channelMaskBackgroundColour)?opts.channelMaskBackgroundColour: [0,0,0,0];
            patron.epgBackgroundColour=(opts.epgBackgroundColour)?opts.epgBackgroundColour: [0,0,0,1];
            patron.programmeItemBackgroundColour=(opts.programmeItemBackgroundColour)?opts.programmeItemBackgroundColour: [83,90,98,0.4];
            patron.programmeItemTextColour=(opts.programmeItemTextColour)?opts.programmeItemTextColour: [255,255,255,1];
            patron.programmeItemPastBackgroundColour=(opts.programmeItemPastBackgroundColour)?opts.programmeItemPastBackgroundColour: [129,130,134,1];
            patron.programmeItemPastTextColour=(opts.programmeItemPastTextColour)?opts.programmeItemPastTextColour: [255,255,255,1];
            patron.programmeItemOnNowBackgroundColour=(opts.programmeItemOnNowBackgroundColour)?opts.programmeItemOnNowBackgroundColour:  [83,90,93,1];
            patron.programmeItemOnNowTextColour=(opts.programmeItemOnNowtextColour)?opts.programmeItemOnNowTextColour:  [255,255,255,1];
            patron.programmeItemOnDemandBackgroundColour=(opts.programmeItemOnDemandBackgroundColour)?opts.programmeItemOnDemandBackgroundColour:  [83,90,93,1];
            patron.programmeItemOnDemandTextColour=(opts.programmeItemOnDemandtextColour)?opts.programmeItemOnDemandTextColour:  [255,255,255,1];
            patron.programmeItemBlackoutColour=(opts.programmeItemBlackoutColour)?opts.programmeItemBlackoutColour: [83,90,98,0.4];
            patron.programmeItemBlackoutTextColour=(opts.programmeItemBlackoutTextColour)?opts.programmeItemBlackoutTextColour: [255,255,255,0.4];
            patron.programmeItemOfflineColour=(opts.programmeItemOfflineColour)?opts.programmeItemOfflineColour: [36,39,44,1];
            patron.programmeItemOfflineTextColour=(opts.programmeItemOfflineTextColour)?opts.programmeItemOfflineTextColour: [130,131,135,1];
            patron.programmeItemUnsubscribedColour=(opts.programmeItemUnsubscribedColour)?opts.programmeItemUnsubscribedColour: [36,39,44,1];
            patron.programmeItemUnsubscribedTextColour=(opts.programmeItemUnsubscribedTextColour)?opts.programmeItemUnsubscribedTextColour: [130,131,135,1];
            patron.rowFocusBackgroundColour=(opts.rowFocusBackgroundColour)?opts.rowFocusBackgroundColour: [110,111,112,1];
            patron.rowFocusTextColour=(opts.rowFocusTextColour)?opts.rowFocusTextColour: [255,255,255,1];
            patron.programmeItemFocusedBackgroundColour=(opts.programmeItemFocusedBackgroundColour)?opts.programmeItemFocusedBackgroundColour: [0,127,212,1];
            patron.programmeItemPaidFocusedBackgroundColour=(opts.programmeItemPaidFocusedBackgroundColour)?opts.programmeItemPaidFocusedBackgroundColour: [219,58,148,1];
            patron.programmeItemFocusedTextColour=(opts.programmeItemFocusedTextColour)?opts.programmeItemFocusedTextColour: [255,255,255,1];
        },
        populateEpgDimensions: function(opts){
            patron.timeSegment=(opts.timeSegmentMinutes)?opts.timeSegmentMinutes:30;
            patron.timeSlotSize=(opts.timeSlotSizeMinutes)?opts.timeSlotSizeMinutes:120;
            patron.scrollPanelWidth=(opts.scrollPanelWidthPx)?opts.scrollPanelWidthPx:936;
            patron.scrollPanelHeight=(opts.scrollPanelHeightPx)?opts.scrollPanelHeightPx:282;
            patron.channelRowHeight=(opts.channelRowHeightPx)?opts.channelRowHeightPx:46
            patron.channelBarWidth=(opts.channelBarWidthPx)?opts.channelBarWidthPx:185;
            patron.topBarHeight=(opts.topBarHeightPx)?opts.topBarHeightPx:38;
            patron.programmeTextPadding=(opts.programmeTextPadding)?opts.programmeTextPadding:10;
        },
        populateTimeMarker:function(opts){
            patron.timeMarkerImage=(opts.timeMarkerImage)?opts.timeMarkerImage:'img/program_guide/on_now_pointer.png';
            patron.timeMarkerImageTop=(opts.timeMarkerImageTop)?opts.timeMarkerImageTop:6;
            patron.timeMarkerImageWidth=(opts.timeMarkerImageWidth)?opts.timeMarkerImageWidth:26;
            patron.timeMarkerImageHeight=(opts.timeMarkerImageHeight)?opts.timeMarkerImageHeight:33;
        },
        populateKeyHandling: function(opts){
            patron.goToStartKey=(opts.goToStartKey)?opts.goToStartKey:vKey.YELLOW.id;
            patron.dateDialogFunc=(opts.dateDialogFunc)?opts.dateDialogFunc:null;
            patron.dateDialogKey=(opts.dateDialogKey)?opts.dateDialogKey:'Not-In-Use';
            patron.forwardFocusFunc=(opts.forwardFocusFunc)?opts.forwardFocusFunc:null;
            patron.forwardFocusKey=(opts.forwardFocusKey)?opts.forwardFocusKey:'Not-In-Use';
            patron.submenuFunc=(opts.submenuFunc)?opts.submenuFunc:null;
            patron.submenuKey=(opts.submenuKey)?opts.submenuKey:'Not-In-Use';
            patron.programmeClickFunc=(opts.programmeClickFunc)?opts.programmeClickFunc:null;
        },
        populateDataLocations: function(opts){
            patron.channelDataId = opts.channelDataId;
            patron.channelDataTitle = opts.channelDataTitle;
            patron.channelDataLogo = opts.channelDataLogo;
            patron.channelDataStatus = opts.channelDataStatus?opts.channelDataStatus:[];
            patron.channelDataBlackout = opts.channelDataBlackout?opts.channelDataBlackout:[];
            patron.channelDataSubscribed = opts.channelDataSubscribed?opts.channelDataSubscribed:['subscribed'];
            patron.channelDataType = opts.channelDataType?opts.channelDataType:[];
            patron.channelPackColourCode = opts.channelPackColourCode?opts.channelPackColourCode:[];

            patron.programmeSetDataBase = opts.programmeSetDataBase;
            patron.programmeDataBase = opts.programmeDataBase;
            patron.programmeDataId = opts.programmeDataId;
            patron.programmeDataTitle = opts.programmeDataTitle;
            patron.programmeDataStartTime = opts.programmeDataStartTime;
            patron.programmeDataEndTime = opts.programmeDataEndTime;
            patron.programmeDataBlackout = opts.programmeDataBlackout?opts.programmeDataBlackout:[];
            patron.programPrName = opts.programPrName?opts.programPrName:"";
        }
    }
});
define("tvedemo/wgt/EPG", ["xdk-base/class", "xdk-ax/Container", "xdk-ax/focusManager",
    "tvedemo/wgt/EPG/EpgItemBuilder", "tvedemo/wgt/EPG/EpgTimeAndPosition",
    "tvedemo/wgt/EPG/EpgTopBar", "tvedemo/wgt/EPG/EpgChannelBar", "tvedemo/wgt/EPG/EpgProgrammeGrid",
    "tvedemo/wgt/EPG/EPGKeyHandler", "tvedemo/wgt/EPG/EpgNavigation", "tvedemo/wgt/EPG/EpgTimeMarker",
    "tvedemo/wgt/EPG/EpgOptions",
    "xdk-base/device/vKey",
    "tve/mgr/sLinearManager",
    "xdk-base/util",
    "tvedemo/wgt/Loading"],
    function (klass, Container, focusManager,
              ItemBuilder, TimeAndPosition,
              TopBar, ChannelBar, ProgrammeGrid,
              KeyHandler, Navigation, TimeMarker,
              Options,
              vKey,
              sLinearManager,
              util,
              loading) {
        var delayedFocusInterval=null,
            sLinearManager,
            dataFetchTopChannel = 0,
            dataFetchInterval = null;

    return klass.create(Container, {}, {

        topBarHeight: null,
        channelRowHeight: null,
        channelBarWidth: null,
        scrollPanelWidth: null, //the width of the displayed tv listing part in px.
        timeSlotSize: null, //the number of minutes to display in the widget.
        timeSegment: null, //the timeSegment to display
        numberOfRows: null, //the rows to display, same as the configuration in grid.
        maxDay: null,
        minDay: null,
        setFocusOnLaunch: null,
        programmeTextPadding:null,
        goToStartKey: null,
        timeMarkerImage: null,
        timeMarkerImageTop: null,
        timeMarkerImageWidth: null,
        timeMarkerImageHeight: null,

        channelDataId: null,         //Array containing location to each channel data id (base + id)
        channelDataTitle: null,      //Array containing location to each channel data title (base + title)
        channelDataLogo: null,       //Array containing location to each channel data logo (base + logo)

        programmeSetDataBase: null,  //Array containing location of the programme array
        programmeDataBase: null,     //Array containing the base to each programme data
        programmeDataId: null,       //Array containing location to each programme data id (base + id)
        programmeDataTitle: null,    //Array containing location to each programme data title (base + title)
        programmeDataStartTime: null,//Array containing location to each programme data StartTime (base + StartTime)
        programmeDataEndTime: null,  //Array containing location to each programme data EndTime (base + EndTime)

        dateDialogFunc:null,
        dateDialogKey:null,
        forwardFocusFunc:null,
        forwardFocusKey:null,
        programmeClickFunc:null,
        submenuKey:null,
        submenuFunc:null,

        requestListings:null,
        requestListingsErrorHandler:null,

        horizontalScrollFunc:null,
        verticalScrollFunc:null,

        channels: null,
        programmes: [],
        endOfData: false,
        endDay: null,
        endSlot: null,
        maxRows: 6,

        loggedIn: false,

        sideload: true,

        init: function (opts) {
            Options.setOptions(opts, this, TimeAndPosition);
            this._super(opts);
            TimeAndPosition.setCurrentTimeSlot(this);
            this.setChildVariables();
            TopBar.setUpHeaderAndTimeLine(TimeAndPosition.returnTimeSlot(TimeAndPosition.dayPosition, this.slotPosition));
        },
        resetOpts: function(opts){
            Options.resetOptions(opts);
        },
        setRowsAndPaging: function(rows, stopVerticalPaging){
            this.numberOfRows=rows;
            TimeAndPosition.stopVerticalPaging = stopVerticalPaging;
        },
        verticalPagingDisabled: function() {
            return TimeAndPosition.stopVerticalPaging;
        },
        setChildVariables: function(){
            ItemBuilder.patron = this;
            TopBar.setVariables(this, TimeAndPosition, ItemBuilder);
            ChannelBar.setVariables(this, TimeAndPosition, ItemBuilder);
            ProgrammeGrid.setVariables(this, TimeAndPosition, ItemBuilder, ChannelBar);
            TimeMarker.setVariables(this, TimeAndPosition, ProgrammeGrid, ItemBuilder);
            Navigation.setVariables(this, ChannelBar, ProgrammeGrid, TopBar);
            KeyHandler.setVariables(ProgrammeGrid, Navigation, TimeMarker);
        },
        setChannels: function(scope){
            return function(channels){
                if(channels){
                    TimeAndPosition.numberOfChannels = channels.length;
                    if(TimeAndPosition.numberOfChannels <= scope.numberOfRows){
                        scope.setRowsAndPaging(TimeAndPosition.numberOfChannels, true);
                    }else{
                        scope.setRowsAndPaging(scope.maxRows, scope.forcedStopVerticalPaging);
                    }
                    scope.channels = channels;
                }
            }
        },
        setProgrammeData: function(scope){
            return function(programmeData, day, topChannelIndex){
                if(programmeData){
                    var programmeDataDay = scope.programmes[day];
                    if(!programmeDataDay){
                        programmeDataDay = scope.createProgrammeDataDay();
                    }else{
                        programmeDataDay = programmeDataDay.data;
                    }
                    programmeDataDay = scope.populateProgrammeDataPage(programmeData, topChannelIndex, programmeDataDay);
                    scope.programmes[day] = { timestamp: new Date().getTime(), data: programmeDataDay };

                    if (scope.programmes[day]) { return true; }
                }
                return false;
            };
        },
        populateProgrammeDataPage: function(data, topChannelIndex, programmeDataDay){
            for(var i = 0; i < data.length; i++){
                var channelIndex = i + topChannelIndex;
                if(channelIndex >= TimeAndPosition.numberOfChannels){
                    channelIndex -= TimeAndPosition.numberOfChannels;
                }
                programmeDataDay[channelIndex] = data[i];
            }
            return programmeDataDay;
        },
        createProgrammeDataDay: function(){
            var retArray = [];
            for(var i = 0; i < TimeAndPosition.numberOfChannels; i++){
                retArray.push(null);
            }
            return retArray;
        },
        refreshProgrammeData: function() {
            ProgrammeGrid.defineEndDayAndSlot();
        },
        setupEpg: function(scope){
            return function(){
                    ChannelBar.setupChannels();
                    ProgrammeGrid.setupProgrammes();
                    if(scope.setFocusOnLaunch){
                        if(scope.setFocusOnLaunchDelay>0){
                            delayedFocusInterval = setInterval(scope.focusFirstItem(scope), scope.setFocusOnLaunchDelay);
                        }else{
                            scope.focusFirstItem(scope)();
                        }
                    }
            };
        },
        focusFirstItem: function(scope){
            return function(){
                var oldFocus;
                clearInterval(delayedFocusInterval);
                if (document.getElementsByClassName('wgt-dialog').length > 0) {
                    oldFocus = focusManager.getCurFocus();
                }
                if (document.getElementsByClassName('program-detail-popup').length > 0){
                    oldFocus = focusManager.getCurFocus();
                }
                focusManager.focus(ProgrammeGrid.epgProgrammeRows[0]._children[ProgrammeGrid.returnNowProgrammeIndex()]);
                if (oldFocus) { focusManager.focus(oldFocus); }
            }
        },
        handleKey: function(self){
            return KeyHandler.handleKey(self, KeyHandler);
        },

        /**
         * @method goToStartPosition
         */
        goToNowPosition: function(){
            console.log('[EPG]goToStartPosition');
            KeyHandler.nowPosition(this);
        },
        /**
         * @method goToNextDay
         */
        goToNextPage: function(){
            console.log('[EPG]goToNextDay');
            KeyHandler.goToNextPage(this, KeyHandler);
        },
        /**
         * @method goToNextPageScoped
         */
        goToNextPageScoped: function(scope, callback){
            return function(){
                console.log('[EPG]goToNextDay');
                KeyHandler.goToNextPage(scope, KeyHandler, callback);
            };
        },
        /**
         * @method goToPrevDay
         */
        goToPrevPage: function(){
            console.log('[EPG]goToPrevDay');
            KeyHandler.goToPrevPage(this, KeyHandler);
        },
        /**
         * @method goToPrevDay
         */
        goToPrevPageScoped: function(scope, callback){
            return  function(){
                console.log('[EPG]goToPrevDay');
                KeyHandler.goToPrevPage(scope, KeyHandler, callback);
            }
        },
        /**
         * @method goToNextDay
         */
        goToNextDay: function(){
            console.log('[EPG]goToNextDay');
            KeyHandler.handleKey(this, KeyHandler)({id:vKey.RW.id});
        },
        /**
         * @method goToNextDayScoped
         */
        goToNextDayScoped: function(scope){
            return function(){
                console.log('[EPG]goToNextDay');
                KeyHandler.handleKey(scope, KeyHandler)({id:vKey.RW.id});
            };
        },
        /**
         * @method goToPrevDay
         */
        goToPrevDay: function(){
            console.log('[EPG]goToPrevDay');
            KeyHandler.handleKey(this, KeyHandler)({id:vKey.FF.id});
        },
        /**
         * @method goToPrevDay
         */
        goToPrevDayScoped: function(scope){
            return function(){
                console.log('[EPG]goToPrevDay');
                KeyHandler.handleKey(scope, KeyHandler)({id:vKey.FF.id});
            };
        },
        /**
         * @method goUpOneScoped
         * @param scope needs to be this class
         */
        goUpOneScoped: function(scope, callback){
            return function(){
                console.log('[EPG]goUpOneScoped');
                KeyHandler.handleKey(scope, KeyHandler, callback)({id:'localUp'});
            };
        },
        /**
         * @method goUpOne
         */
        goUpOne: function(){
            console.log('[EPG]goUpOne');
            KeyHandler.handleKey(this, KeyHandler)({id:'localUp'});
        },
        /**
         * @method goDownOneScooped
         * @param scope needs to be this class
         */
        goDownOneScoped: function(scope, callback){
            return function(){
                console.log('[EPG]goDownOneScoped');
                KeyHandler.handleKey(scope, KeyHandler, callback)({id:'localDown'});
            };
        },
        /**
         * @method goDownOne
         */
        goDownOne: function(){
            console.log('[EPG]goDownOne');
            KeyHandler.handleKey(this, KeyHandler)({id:'localDown'});
        },
        /**
         * @method goDownOne
         */
        goToDay: function(day){
            console.log('[EPG]goToDay '+ day);
            KeyHandler.goToDay(this, day);
        },

        resetEpgData: function(){
            this.channels = null;
            this.programmes = [];
            this.endOfData = false;
            this.endDay = null;
            this.endSlot = null;
            TimeAndPosition.timeslotPosition = 0;
            TimeAndPosition.dayPosition = 0;
            TimeAndPosition.rowPosition = 0;
            TimeAndPosition.numberOfChannels = null;
            TimeAndPosition.dataStartSlot = 0;
            TimeAndPosition.setTopChannelIndex(0);
            ChannelBar.detachChannelObjects();
            ProgrammeGrid.detachProgrammeRows();
        }
    });
});
/**
 * Program guide popup view's template
 * @name programGuide
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/programGuide
 */
define("tvedemo/tmpl/programListing", [
    "xdk-ax/Container", 
    "xdk-ui-basic/Layout", 
    "xdk-ui-basic/Label",
    "tvedemo/wgt/EPG", 
    "xdk-ui-basic/Image",
    "storm/mgr/sLanguageManager",
    "storm/mgr/sAppConfigManager",
    "xdk-base/device"
], function (Container, 
    Layout, 
    Label,
    EpgGrid, 
    Image,
    sLanguageManager,
    sAppConfigManager,
    device) {

    return function () {
        return {
            klass: Layout,
            css: "program-guide-view",
            alignment: Layout.VERTICAL,
            autoNavigation: false,
            children: [{
                klass: Container,
                css: "program-detail-container",
                children: [{
                    klass: Container,
                    css: "thumbnail-wrapper",
                    children: [{
                        klass: Image,
                        id: "thumbnail",
                        css: "thumbnail",
                        placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                    }, {
                        klass: Container,
                        css: "thumbnail-overlay hidden",
                        id: "thumbnail-overlay",
                        children: [{
                            id: 'thumbnail-overlay-message',
                            klass: Label,
                            text: sLanguageManager.getString("Epg.blackoutShort"),
                            css: "thumbnail-unavailable"
                        }]
                    }]
                }, {
                    klass: Label,
                    id: "title",
                    css: "title"
                }, {
                    klass: Container,
                    css: "packageNeeded hidden",
                    id: "packageNeeded",
                    children: [
                        {
                            klass: Image,
                            id: "packageNeededLogo",
                            css: "packageNeededLogo"
                        },
                        {
                            klass: Label,
                            id: "packageNeededLabel",
                            text: "",
                            css: "packageNeededLabel"
                        }
                    ]
                }, {
                    klass: Label,
                    id: "metadata",
                    css: "metadata"
                }, {
                    klass: Label,
                    id: "description",
                    css: "description"
                }]
            }, {
                klass: Label,
                text: sLanguageManager.getString("Global.Global_buttonBack_button"),
                css: "program-guide-back"
            }, {
                klass: Container,
                id: "epgGrid",
                css: "epgGrid"
            },{
                klass: Container,
                css: "epg-bottom-gradient"
            }
            ]
        };
    };
});

/**
 * The program guide view's controller. Setup the TV listing, program info, date selection, sorting selection.
 * @name ProgramListing
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/ProgramListing
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/ProgramListing", [
    "xdk-base/ax",
    "xdk-ax/evt/type",
    "xdk-ax/focusManager",
    "xdk-base/device/vKey",
    "xdk-base/promise",
    "xdk-base/config",
    "xdk-base/util",
    "xdk-ax/mediator",
    "xdk-ax/mvc/view",
    "xdk-base/device",
    "xdk-base/console",
    "xdk-ax/Container",
    "xdk-ui-basic/Image",
    "xdk-ui-basic/Button",
    "tvedemo/helper/sMoment",
    "tvedemo/tmpl/programListing",
    "tvedemo/ctrl/RoutableController",
    "tvedemo/helper/dialogHelper",
    "storm/mgr/sAppConfigManager",
    "tve/mgr/sLinearManager",
    "tve/videoPlaybackService/evt/VideoPlaybackControlsEvent",
    "tve/videoPlaybackService/VideoManager",
    "tve/videoPlaybackService/model/Playlist",
    "tve/videoPlaybackService/model/PlaylistItem",
    "tvedemo/wgt/TextSelectionListDialog",
    "tvedemo/wgt/Loading",
    "tvedemo/wgt/AlertDialog",
    "tvedemo/wgt/EPG",
    "tvedemo/wgt/EPG/data/Retrieval",
    "tvedemo/mgr/sEndUserManager",
    // "tvedemo/wgt/PinInputDialog",
    "xdk-base/Env",
    "tvedemo/mgr/sNavigationManager",
    "storm/mgr/sLanguageManager",
    "tvedemo/model/ContextBuilder",
    "tve/sServiceHolder",
    "storm/mgr/sLiveFeatureManager"


], function (ax,
             evtType,
             focusManager,
             vKey,
             promise,
             config,
             util,
             mediator,
             view,
             Device,
             console,
             Container,
             Image,
             Button,
             moment,
             tmpl,
             RoutableController,
             dialogHelper,
             sAppConfigManager,
             sLinearManager,
             VideoPlaybackControlsEvent,
             VideoManager,
             Playlist,
             PlaylistItem,
             SelectionDialog,
             loading,
             AlertDialog,
             EPG,
             Retrieval,
             EndUserManager,
             // PinInputDialog,
             Env,
             sNavigationManager,
             sLanguageManager,
             ContextBuilder,
             sServiceHolder,
             sLiveFeatureManager) {

    var DATE_FORMAT = "ddd Do MMM, hh:mma",
        TOP = 0,
        RIGHT = 1,
        BOTTOM = 2,
        LEFT = 3,
        FORWARD_DAYS_AVAILABLE = 6,
        BACKWARD_DAYS_AVAILABLE = 6,

        CATEGORY_ALL = "all",
        EPG_CACHE_TIME = 60 * 60 * 1000,
        MS_DAY = 1000 * 60 * 60 * 24,
        EPG_FOCUS_DELAY_VALUE = 0.5, // Seconds
        EPG_FOCUS_DELAY_VALUE_PS = 1, // Seconds
        EPG_FOCUS_DELAY_NAME = "epgFocusDelay",

        _eventListenerActive = false;
        _KeyCallback = null;


    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {
                date: new Date().getTime(),
                categoryId: "all"
            };
        }
    }, {
        _title: null,
        // _programStart: null,
        // _parentalRating: null,
        _description: null,

        _initialising: true,

        _arrows:null,


        _filtered: null,

        _epgGrid: null,
        _currentDate: new Date().getTime(),
        _currentCategoryId: null,
        _numberOfChannelsToDisplay: 6,
        _channelSet: null,

        programmeDataDescription:['_attrs','description'],
        programmeDataThumbnail: ['_attrs','images'],

        setupComplete: false,

        programmeWaitInterval: null,
        parentalRatingIndex: null,
        programPrName:['_attrs','parentalRating'],

        mainController:null,
        context: null,
        __epgFocus: null,

        init: function () {
            this._super();
            this.setView(view.render(tmpl));

            if(Device && Device.id){
//                ga('set', 'UUID', Device.id.getUniqueID());
            }
//            ga('send', 'pageview', {'title': 'ChannelsPage'});
        },

        setup: function (context) {
            this.context = context;
            this._closed = false;
            if (!context.historyBack){
                if (this.__epgFocus === null) {
                    this.__epgFocus = util.bind(this._epgFocus, this);
                }

                var currentView = this.populateVariables();
                this.__setFooter(false, false);
                this.parentalRatingIndex = -1;
                this.finishSetup(currentView, context.submenuClick? context.submenuClick-8 :0);
                currentView.hide();
                this._submenuItems = [];
                this.initSubmenu();
            }
            this.addListeners();
        },
        initSubmenu : function(){
            var hookFct = ax.util.bind(function(id) {
                return ax.util.bind(function() {
                    // if the epg controller is not being displayed anymore (prob cause we've been navigating away from it), we navigate back to it
                    if (!this.getView()._parent) {
                        mediator.publish("navigate", {
                            path: "Main/ProgramListing",
                            state: {
                                submenuClick: id,
                                outerNavigation: {
                                    id: id,
                                    submenu: this._submenuItems
                                }
                            }
                        });
                        return;
                    }
                    // SKYSTORM-705:
                    // Since the menu state was cloned on Controller's arrival (RoutableController._navigationBacktrace()),
                    // when there is no Controller movement, the menu state will not be recorded (to avoid wrong menu recorded).
                    // However some Controllers using insertSubmenu need to record the menu state
                    // even when they are sticking in the same Controller
                    //
                    // The solution is to record the state of menu while handling the menu on menuitem.action()
                    this.saveMenuState();
                    // otherwise we just load the selected epg date
                    return this.selectCategoryById(id);
                }, this);
            }, this);

            var menuPromise;
            if (this.context.outerNavigation) {
                //there is an existing submenu
                this._submenuItems = this.context.outerNavigation.submenu;
                // refresh functions ctx
                for (var i=this._submenuItems.length-1; i>=0; i--) {
                    this._submenuItems[i].action = hookFct(i);
                }
                menuPromise = this.selectCategoryById(this.context.outerNavigation.id);
            }
            menuPromise = menuPromise || sServiceHolder.getDateTimeService().getServerDateTime().then(ax.util.bind(function(serverTime) {
                    var nowMoment = moment(serverTime);

                    this._submenuItems.push({
                        id: "today",
                        text: sLanguageManager.getString("Epg.LabelToday_SmartTV"),
                        time: nowMoment.unix() * 1000,
                        action: hookFct(8)
                    });
                    nowMoment.add("d", 1);
                    this._submenuItems.push({
                        id: "tomorrow",
                        text: sLanguageManager.getString("Epg.LabelTomorrow_SmartTV"),
                        time: nowMoment.unix() * 1000,
                        action: hookFct(9)
                    });

                    return sAppConfigManager.getEpgDaysForwards().then(ax.util.bind(function(result){
                        this._availableDays = result;
                        for (var i = 1; i < this._availableDays; i++) {
                            nowMoment.add("d", 1);
                            this._submenuItems.push({
                                id: this._availableDays + 2 + i,
                                text: nowMoment.format(sLanguageManager.getString("ui.format.epgMenuDate")),
                                time: nowMoment.unix() * 1000,
                                action: hookFct(this._availableDays + 2 + i)
                            });
                        }

                        return sNavigationManager.insertSubmenu(this._submenuItems);
                    }, this));
                }, this));

            var dateTimePromise = sServiceHolder.getDateTimeService().getServerDateTime().then(ax.util.bind(function(serverTime) {
                this._currentDate = serverTime.getTime();
                TODAY = moment(serverTime).startOf("day");
            }, this));

            this.context.setupPending = promise.all([menuPromise, dateTimePromise]);

            this.trackLevel(2, undefined, true);
        },
        selectCategoryById: function(id){
            console.log('selectCategoryById : '+id);
            try{
                focusManager.focus(this._epgGrid);
                var day = id > 7 ? id - 8 : id;
                this.getView().show();
                this._epgGrid.goToDay(day);
                focusManager.focus(this._epgGrid);
            }catch(err){
                console.info("EPG not ready");
            }
            return true;
        },
        finishSetup: function(currentView, offset){
            this.makeEPG(currentView, null, null, offset);
            this.setupComplete = true;
        },
        makeEPG: function(currentView, channelIds, epgColours, offset){
            Env.singleton().blockKeys()
            var retPromise, scope = this;

            this.setUpEPG(epgColours, offset);

            if(!this.setupComplete)this.initArrows(currentView);

            currentView.find('epgGrid').attach(this._epgGrid, Container.PLACE_PREPEND);

            sLinearManager.getChannels({}).then(util.bind(function(channelData) {
                this._channelSet = channelData;
                this._epgGrid.setChannels(this._epgGrid)(channelData);

            },this)).then(util.bind(function() {
                var channelIds = scope.getPageOfChannelIds(0);

                retPromise = sLinearManager.getChannelListingsByDate(new Date((new Date().getTime() + (offset * MS_DAY))), channelIds);
                scope.waitForProgrammes(scope, retPromise, offset, true, null, 0)();
            }), scope);
        },
        getPageOfChannelIds: function(startChannelIndex, increment){
            var channelIds = [];
            increment = (increment) ? increment : 2;
            for(var i = 0; i < this._numberOfChannelsToDisplay * increment; i++){
                var index = startChannelIndex + i;
                if(index >= this._channelSet.length){
                    index = index - this._channelSet.length;
                }
                if(index >= this._channelSet.length) return channelIds;
                channelIds.push(this._channelSet[index]._attrs.id);
            }
            return channelIds;
        },

        waitForProgrammes: function(scope, retPromise, offset, firstCall, callback, topChannelIndex){
            return function(){
                if(scope.programmeWaitInterval) clearInterval(scope.programmeWaitInterval);
                if(retPromise.inspect().state == 'pending'){
                    scope.programmeWaitInterval = setInterval(scope.waitForProgrammes(scope, retPromise, offset, firstCall, callback, topChannelIndex), 100);
                    return;
                }else if(retPromise.inspect().state == 'rejected'){
                    //TODO fail case
                    return;
                }
                var programmeData = retPromise.inspect().value;
                var setData = scope._epgGrid.setProgrammeData(scope._epgGrid)(programmeData, offset, topChannelIndex);

                if(firstCall) {
                    scope._epgGrid.setupEpg(scope._epgGrid)();
                } else {
                    if (setData) {
                        scope._epgGrid.refreshProgrammeData();
                    }
                }

                // close the extended loading when EPG is prepared.
                loading.close();

                scope.requestingListings = false;
                Env.singleton().unblockKeys();
                if(callback){
                    callback();
                }
            };
        },
        returnToEPGnow: function(){
            this._epgGrid.goToNowPosition();
        },
        setUpEPG: function(epgColours, offset){
            // var sEndUserManager = EndUserManager.singleton();
            // var channelNonFocused = this.retrieveType(epgColours.egp_channel_listing.epg_channel_colour_set, "Non focused", "epg_channel_listing_type"),
            //     channelFocused = this.retrieveType(epgColours.egp_channel_listing.epg_channel_colour_set, "Focused", "epg_channel_listing_type"),
            //     programPast = this.retrieveType(epgColours.epg_program_item, "Past", "epg_item_type"),
            //     programOnNow = this.retrieveType(epgColours.epg_program_item, "On Now", "epg_item_type"),
            //     programOnDemand = this.retrieveType(epgColours.epg_program_item, "On Demand", "epg_item_type"),
            //     programFuture = this.retrieveType(epgColours.epg_program_item, "Future", "epg_item_type"),
            //     programFocused = this.retrieveType(epgColours.epg_program_item, "Focused", "epg_item_type");

            var submenuFocusButton = Device.platform === 'playstation' ? 'playstation:vkey:triangle' : vKey.GREEN.id;

            this._epgGrid = new EPG({id:'EPG',
                    //Data
                    offset:offset,
                    channelDataId:['_attrs','id'],
                    channelDataTitle:['_attrs','title'],
                    channelDataLogo:['_attrs','images', 0, '_attrs', 'url'],
                    channelDataBlackout:['blackout'],
                    channelDataStatus:['status'],
                    channelDataSubscribed:['subscribed'],
                    channelDataType:['type'],
                    channelPackColourCode:['_attrs','mobilepc'],
                    programmeDataBase:['_attrs','programs'],
                    programmeDataId:['_attrs','id'],
                    programmeDataTitle:['_attrs','title'],
                    programmeDataStartTime:['_attrs','startTime'],
                    programmeDataEndTime:['_attrs','endTime'],
                    programmeDataBlackout:['_attrs','epgBlackout'],
                    programmeDataFlags:['_attrs','flags'],
                    programPrName:this.programPrName,
                    //Buttons
                    goToStartKey:vKey.BLUE.id,
                    submenuKey:submenuFocusButton,
                    submenuFunc:ax.util.bind(this._jumpToSubmenu, this),
                    programmeClickFunc: ax.util.bind(this._epgClick, this),
                    //Colours
                    //TODO: sLinearManager.getLastChannel()
                    topChannelIndex: 0,//sLinearManager.getLastChannel(),
                    requestListingsFunc: ax.util.bind(this._epgRequestListings, this),
                    requestListingsErrorHandler: ax.util.bind(this._epgRequestListingsErrorHandler, this),
                    horizontalScrollFunc: ax.util.bind(this._epgHorizonalScrollHandler, this),
                    verticalScrollFunc: ax.util.bind(this._epgVerticalScrollHandler, this),
                    stopVerticalPaging: true,
                    locateTop: 180,
                    listingsCache: EPG_CACHE_TIME,
                    parentalRatingIndex: this.parentalRatingIndex,
                    getParentalRatingIndex : ax.util.bind(this.returnNoParentalGuidance, this),
                    loggedIn: false, //sEndUserManager.getLoginStatus()
                    bookendHorizontal: true
                }
            );
        },
        returnNoParentalGuidance: function(){
            return 100;
        },
        retrieveType: function(data, type, typeRef){
            if(!typeRef){typeRef="type";}
            for(var i=0; i < data.length; i++){
                if(data[i][typeRef] === type){
                    return data[i]
                }
            }
        },
        populateVariables: function(){
            this.mainController = this.getParentController();
            var currentView = this.getView();
            this._title = currentView.find("title");
            this._metadata = currentView.find("metadata");

            // this._programStart = currentView.find("programStartTime");
            // this._parentalRating = currentView.find("parentalRating");
            // this._parentalRating.addClass('hidden');

            this._description = currentView.find("description");
            this._thumbnail = currentView.find("thumbnail");
            this._thumbnailOverlay = currentView.find("thumbnail-overlay");
            this._thumbnailOverlayMessage = currentView.find("thumbnail-overlay-message");
            // this._submenu = currentView.find("submenu");
            this._packageNeeded = currentView.find("packageNeeded");
            this._packageNeededLabel = currentView.find("packageNeededLabel");
            this._packageNeededLogo = currentView.find("packageNeededLogo");
            return currentView;
        },
        addListeners: function(){
            if (_eventListenerActive === false) {
                if (!_KeyCallback) {
                    _KeyCallback = this._epgGrid.handleKey(this._epgGrid);
                }

                this._epgGrid.addEventListener(evtType.FOCUS, this.__epgFocus);
                //REQUIRED?
                this._epgGrid.addEventListener(evtType.KEY, _KeyCallback);
                _eventListenerActive = true;
            }
        },

    removeListeners: function(){
        this._epgGrid.removeEventListener(evtType.FOCUS);
        this._epgGrid.removeEventListener(evtType.KEY, _KeyCallback);

        _KeyCallback = null;
        _eventListenerActive = false;
    },
    initArrows: function (currentView) {
        this._arrows = [];
        for (var i = 0; i < 4; i++) {
            this._arrows[i] = new Button({
                id:'arrowBtn-'+i,
                css: "wgt-programguide-arrow",
                nextUp: 'EPG',
                nextLeft: 'EPG',
                nextRight: 'EPG',
                nextDown: 'EPG'
            });
        }

        this._arrows[TOP].addClass("top");
        this._arrows[RIGHT].addClass("right");
        this._arrows[BOTTOM].addClass("bottom");
        this._arrows[LEFT].addClass("left");
        currentView.attach(this._arrows[TOP]);
        currentView.attach(this._arrows[LEFT]);
        currentView.attach(this._arrows[RIGHT]);
        currentView.attach(this._arrows[BOTTOM]);
        this.subscribeToArrowClick();
        this._epgGrid.getRoot().addEventListener("mousewheel", this.scrollFunc);
    },
    scrollFunc: function(e) {
        var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));

        var event = document.createEvent("Event");
        event.initEvent('keydown', true, true);
        event.target = document;
        event.currentTarget = document;
        event.isSimulated = true;
        if (delta == 1) {
            // UP
            event.keyCode = 38;
            event.keyCodeVal = 38;
        } else {
            // DOWN
            event.keyCode = 40;
            event.keyCodeVal = 40;
        }
        document.dispatchEvent(event);
    },
    subscribeToArrowClick: function(){

        var reFocusCallback = function(arrow) {
            focusManager.focus(arrow);
        };

        this._arrows[TOP].addEventListener(evtType.CLICK, this._epgGrid.goUpOneScoped(this._epgGrid, util.bind(reFocusCallback, this, this._arrows[TOP])));
        this._arrows[BOTTOM].addEventListener(evtType.CLICK, this._epgGrid.goDownOneScoped(this._epgGrid,  util.bind(reFocusCallback, this, this._arrows[BOTTOM])));
        this._arrows[RIGHT].addEventListener(evtType.CLICK, this._epgGrid.goToNextPageScoped(this._epgGrid,  util.bind(reFocusCallback, this, this._arrows[RIGHT])));
        this._arrows[LEFT].addEventListener(evtType.CLICK, this._epgGrid.goToPrevPageScoped(this._epgGrid,  util.bind(reFocusCallback, this, this._arrows[LEFT])));
    },

    unsubscribeToArrowClick: function(){
        this._arrows[TOP].removeEventListener(evtType.CLICK, this._epgGrid.goUpOneScoped(this._epgGrid));
        this._arrows[BOTTOM].removeEventListener(evtType.CLICK, this._epgGrid.goDownOneScoped(this._epgGrid));
        this._arrows[RIGHT].removeEventListener(evtType.CLICK, this._epgGrid.goToNextPageScoped(this._epgGrid));
        this._arrows[LEFT].removeEventListener(evtType.CLICK, this._epgGrid.goToPrevPageScoped(this._epgGrid));
    },

    _jumpToSubmenu: function () {
        this.focusedProgramme = focusManager.getCurFocus();
        this.focus(this.mainController.getView().find('list-sub-menu'));
        this.__setFooter(false, false);
    },

    _epgClick: function (evt) {
        if (evt.target._opts.programmeData._attrs.id) {
            var channelId = evt.target._parent.channelData._attrs.id;
            var programmeId = evt.target._opts.programmeData._attrs.id;

            var contextBuilder = new ContextBuilder(),
                context;

            context = contextBuilder.setData({
                channelId: channelId,
                eventId: programmeId
            }).build();

            sNavigationManager.returnUpperLevelMenu().then(function() {
                mediator.publish("navigate", {
                    path: "Main/EpgEvent",
                    state: {
                        context: context
                    }
                });
            });
        }
    },

    _epgFocus: function (evt) {
        if(this._initialising){
            this._initialising = false;
        }
        this.__setFooter(true, true);

        var programData = evt.target._opts.programmeData;
        var channelData = evt.target._opts.parent.channelData;

        var program = programData;
        var program_id = program && program.get("id");
        var channel = channelData && channelData._attrs.mobilepc;

        if (!program || ax.util.isUndefined(program_id) || !channel) {
            return;
        }

        if (program_id === this._program_id_last_shown) {
            return; // If focus re-applied to the grid, don't keep refreshing the detail area: SKYSTORM-691.
        }

        this._program_id_last_shown = program_id; // Retain id of the last one we sought details for.

        this._title.setText(program.get("title"));
        this._metadata.setText(program.get("inlineMetadata"));
        this._description.setText(program.get("description"));

        this._thumbnailOverlayMessage.setText(sLanguageManager.getString("Epg.blackoutShort"));
        this._thumbnailOverlay[program.get("epgBlackout") ? "removeClass" : "addClass"]("hidden");
        
        program.set("packageCode", channel); // So that checkUserPrivileges() below is done with the linear channel entitlements in mind.

        // Hide this, or it lingers during the pause before full data is shown.

        this._packageNeeded.addClass("hidden");

        // Debounce / delay before we make the expensive call to populate fuller information; see SKYSTORM-678.
        var focusRequestDelayTime = (Device.platform === "playstation") ? EPG_FOCUS_DELAY_VALUE_PS : EPG_FOCUS_DELAY_VALUE;

        ax.util.clearDelay(EPG_FOCUS_DELAY_NAME);
        ax.util.delay(focusRequestDelayTime, EPG_FOCUS_DELAY_NAME).then(ax.util.bind(function() {

            var epgFocusPromises = [
                sAppConfigManager.getPlaceholderLandscape(),
                sLinearManager.getProgramById(program_id, channelData._attrs.id),
                EndUserManager.checkUserPrivileges(program)
            ];

            promise.all(epgFocusPromises).then(ax.util.bind(function (program_id_loopback, outcomes) {
                var program = outcomes[1],
                    thumbnailUrl = outcomes[0],
                    userAccess = outcomes[2];

                program.set("id", program_id_loopback);
                // Safety against overwriting out of sequence due to asynchronous detail round-trip.
                if (this._program_id_last_shown === program_id_loopback) {
                    var finalTitle = program.get("title"),
                        finalMetadata = program.get("inlineMetadata"),
                        finalDescription = program.get("description"),
                        imagesArray = program.get("images"),
                        relativeImageUrl = ax.util.isArray(imagesArray) && imagesArray.length && imagesArray[0].file;

                    if (finalTitle) {
                        this._title.setText(finalTitle);
                    }
                    if (finalMetadata) {
                        this._metadata.setText(finalMetadata);
                    }
                    if (finalDescription) {
                        this._description.setText(finalDescription);
                    }
                    if (relativeImageUrl) {
                        sLinearManager.constructCMSUrlPromise(relativeImageUrl).then(ax.util.bind(function (url) {
                            this._thumbnail.setSrc(url);
                        }, this));
                    } else {
                        this._thumbnail.setSrc(thumbnailUrl);
                    }

                    if (!userAccess) {
                        // Get the appropriate image logo.
                        sAppConfigManager.getPackageImageForCode(channel).then(ax.util.bind(function(logo) {
                            this._packageNeededLogo.setSrc(logo);
                            this._packageNeededLogo.removeClass("hidden");
                        },this), ax.util.bind(function() {
                            // We failed to get a corresponding logo so hide it.
                            this._packageNeededLogo.addClass("hidden");
                        },this));

                        var missingLookup = "DetailPage.DetailPage_MissingEntitlement_" + channel,
                            missingMsg = sLanguageManager.getString(missingLookup);
                        // If we received the same text we sent that means there was no specific message available, default to the OTHER message.
                        if (missingMsg === missingLookup) {
                            missingMsg = sLanguageManager.getString("DetailPage.DetailPage_MissingEntitlement_OTHER");
                        }
                        this._packageNeededLabel.setText(missingMsg);
                        this._packageNeeded.removeClass("hidden");
                    }
                    else {
                        this._packageNeeded.addClass("hidden");
                    }
                }
            }, this, program_id));

        }, this));

    },

    _epgRequestListings: function(offset, callback, topChannelIndex, hidden) {
        if (!this.requestingListings || (!hidden && this.lastHidden)) {
            this.lastHidden = hidden;
            this.requestingListings = true;
            if(!hidden) loading.open("Loading listings...");
            var offsetDate = new Date((new Date().getTime() + (offset * MS_DAY)))
            var channelIds = this.getPageOfChannelIds(topChannelIndex);
            var retPromise = sLinearManager.getChannelListingsByDate(offsetDate, channelIds);
            this.waitForProgrammes(this, retPromise, offset, false, callback, topChannelIndex)();
        }
    },

    _epgRequestListingsErrorHandler: function() {
        new AlertDialog({
            buttonText: "OK",
            message: "Failed to load programme listings. Please try again later."
        });
    },

    _epgHorizonalScrollHandler: function(firstSlot, lastSlot) {
        this._arrows[LEFT].removeClass("hidden");
        this._arrows[RIGHT].removeClass("hidden");
        if (firstSlot) {
            this._arrows[LEFT].addClass("hidden");
        }
        if (lastSlot) {
            this._arrows[RIGHT].addClass("hidden");
        }
    },

    _epgVerticalScrollHandler: function(firstRow, lastRow) {
        if (this._epgGrid.verticalPagingDisabled()) {
            this._arrows[BOTTOM].removeClass("hidden");
            // if (firstRow) { console.log("*** Reached the top of the EPG grid."); }
            if (lastRow) { this._arrows[BOTTOM].addClass("hidden");
                console.log("*** Reached the bottom of the EPG grid."); }
        }
    },

    __setFooter: function (showWatchNow, onEPG) {
        var footer = {
            arrowAll: "Move",
            enter: "Select",
            back: "Back"
        };
        if (onEPG) {
            util.extend(footer, {
                colorRed: "Top Menu",
                colorGreen: "Categories",
                colorYellow: "Select Date",
                colorBlue: "On Now",
                prevNext: "Prev/Next Day"
            });
        }

        if (!showWatchNow) {
            footer.colorYellow = null;
        }

        mediator.publish("footerUpdate", footer);
    },

    focus: function (toFocus) {
        if (!this._closed) {
            focusManager.focus(toFocus);
        }
    },

    reset: function () {
        this._closed = true;
        this.removeListeners();
    }
});
});

/**
 * watchList - contain list of users fav items
 * @name watchList
 * @memberof tvedemo/tmpl
 * @module tvedemo/tmpl/watchList
 */
define("tvedemo/tmpl/watchList", [
    "xdk-ui-basic/Layout",
    "xdk-ui-basic/Label",
    "tvedemo/ext/ui/grid/LoopedGrid",
    "xdk-ax/Container",
    "storm/mgr/sLanguageManager"
], function (
    Layout,
    Label,
    LoopedGrid,
    Container,
    sLanguageManager
    ) {

    "use strict";

    return function () {
        return {
            klass: Layout,
            forwardFocus: true,
            alignment: Layout.VERTICAL,
            css: "subcontrollerPage watchList",
            children: [{
                klass: Container,
                id: "watchlistGridClipper",
                css: "watchlist-grid-clipper",
                children: [
                    {
                        klass: LoopedGrid,
                        forwardFocus: true,
                        alignment: LoopedGrid.VERTICAL,
                        id: "#moviesAssetGrid",
                        nextDown: "episodeSportGrid",
                        rows: 9,
                        cols: 1,
                        scrollFrontBoundary: 4,
                        scrollEndBoundary: 4
                    }
                ]
            }, {
                klass: Container,
                css: "middle-content",
                children: [{
                    klass: Container,
                    id: "descriptionContainer",
                    css: "description-container",
                    children: [{
                        klass: Label,
                        id: "title",
                        css: "title"
                    },{
                        klass: Label,
                        id: "meta",
                        css: "meta"
                    }]
                }]
            },{
                klass: LoopedGrid,
                forwardFocus: true,
                alignment: LoopedGrid.VERTICAL,
                id: "#episodeSportGrid",
                nextUp: "moviesAssetGrid",
                rows: 5,
                cols: 1,
                scrollFrontBoundary: 2,
                scrollEndBoundary: 2
            },{
                klass: Label,
                text: sLanguageManager.getString("Mystuff.Mystuff_labelno_watchlist_desc"),
                id: "empty-watchlist-label",
                css: "empty-watchlist-label"
            }]
        };    
    };
});
/**
 * The Watchlist view's controller.
 * @name Watchlist
 * @memberof tvedemo/ctrl
 * @class tvedemo/ctrl/Watchlist
 * @extends tvedemo/ctrl/RoutableController
 */
define("tvedemo/ctrl/Watchlist", [
    "xdk-base/ax",
    "xdk-base/promise",
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/mvc/view",
    "tvedemo/tmpl/watchList",
    "xdk-ax/focusManager",
    "xdk-ax/evt/type",
    "xdk-base/device/vKey",
    "tvedemo/mgr/sHistoryManager",
    "tvedemo/helper/dialogHelper",
    "xdk-base/util",
    "tvedemo/mgr/sEndUserManager",
    "xdk-ax/mediator",
    "xdk-base/console",
    "tvedemo/mgr/sAssetManager",
    "storm/mgr/sAppConfigManager",
    "xdk-ax/data/LocalDatasource",
    "tvedemo/wgt/ImageButton",
    "xdk-ax/Container",
    "xdk-ui-basic/Label"
], function (
    ax,
    promise,
    RoutableController,
    view,
    tmpl,
    focusManager,
    evtType,
    vKey,
    sHistoryManager,
    dialogHelper,
    util,
    sEndUserManager,
    mediator,
    console,
    sAssetManager,
    sAppConfigManager,
    LocalDatasource,
    ImageButton,
    Container,
    Label
    ) {

    "use strict";

    var ASSET_TYPE = {
            // Three specific types of user watchlist item are permitted by the SILK API v1.10.
            FILM : "Film",
            EPISODE : "Episode",
            SPORT : "Sport"
        },

        GRID_FOCUS_COLUMN_MOVIES = 4,
        GRID_FOCUS_COLUMN_EPISODES = 2,

        SERIES_IMAGE_MIN_WIDTH = 300,// Sizes based on UI design / likely CSS specification.
        SERIES_IMAGE_MIN_HEIGHT = 200,

        LONGEST_CLIPPED_LIST = 8; // If the user has more than {n} items in their list, let's just allow looped grid to flow out.


    return ax.klass.create(RoutableController, {
        getDefaultState: function () {
            return {};
        }
    }, {

        init: function () {
            this._super();
            this.setView(view.render(tmpl));
        },

        //override getState to handle latest state from the menu
        getState: function () {
            return this._super();
        },

        setup: function (context) {
            this._super(context);

            if (context.historyBack === true) {
                if (!sEndUserManager.getLoginStatus()) {
                    sHistoryManager.back();
                    return;
                }
            }
            
            this.currentView = this.getView();
            this.moviesGrid = this.currentView.find("moviesAssetGrid");
            this.episodeSportGrid = this.currentView.find("episodeSportGrid");
            this.moviesGridClipper = this.currentView.find("watchlistGridClipper");

            this._titleLabel = this.currentView.find("title");
            this._metaLabel = this.currentView.find("meta");

            this._emptyWatchlistLabel = this.currentView.find("empty-watchlist-label");
            this._emptyWatchlistLabel.hide();

            // Upper grid...

            this.movieGridFocusHandlerRef = util.bind(this.movieGridFocusHandler, this);
            this.movieGridClickHandlerRef = util.bind(this.movieGridClickHandler, this);
            this.movieDescriptionHandlerRef = util.bind(this.movieDescriptionHandler, this);

            this.moviesGrid.addEventListener(evtType.FOCUS, this.movieGridFocusHandlerRef);
            this.moviesGrid.addEventListener(evtType.CLICK, this.movieGridClickHandlerRef);
            this.moviesGrid.addEventListener(evtType.SELECTION_CHANGED, this.movieDescriptionHandlerRef);

            // Lower grid...

            this.episodeSportGridFocusHandlerRef = util.bind(this.episodeSportGridFocusHandler, this);
            this.episodeSportGridClickHandlerRef = util.bind(this.episodeSportGridClickHandler, this);

            this.episodeSportGrid.addEventListener(evtType.FOCUS, this.episodeSportGridFocusHandlerRef);
            this.episodeSportGrid.addEventListener(evtType.CLICK, this.episodeSportGridClickHandlerRef);

            context.setupPending = this.setUpAssetGrids().then(util.bind(function() {
                if (!this.moviesGrid.isHidden()) {
                    this.moviesGrid.select(0, GRID_FOCUS_COLUMN_MOVIES); // Zeroth data appears in a specific column.
                }
                if (!this.episodeSportGrid.isHidden()) {
                    this.episodeSportGrid.select(0, GRID_FOCUS_COLUMN_EPISODES); // Zeroth data appears in a specific column.
                }

                // Correct focus after grids are set up.
                if (!this.moviesGrid.isHidden() || !this.episodeSportGrid.isHidden()) {
                    this._emptyWatchlistLabel.hide();
                    focusManager.focus(this.getView());
                }
                else {
                    // If the watchlist is empty, focus on the menu.
                    this._emptyWatchlistLabel.show();
                    var subMenu = this.getView().getParent().getParent().find("list-sub-menu");
                    focusManager.focus(subMenu);

                }
            },this));
            
            this.trackLevel(2, undefined, true);
        },

        setUpAssetGrids: function() {

            var films = [],
                episodeSport = [];

            return sEndUserManager.getUserWatchList().then(util.bind(function (result) {
                console.info("Watchlist received", result);

                util.each(result, function(item){
                    var assetType = item.get("assetType");

                    if (assetType === ASSET_TYPE.FILM) {
                        films.push(item);

                    } else if((assetType === ASSET_TYPE.EPISODE) || (assetType === ASSET_TYPE.SPORT)) {
                        episodeSport.push(item);

                    } else {
                        console.warn("Ignoring unexpected assetType: " + assetType);
                    }
                });

                //
                // The looped grid component repeats the DS content over and over, to fill.
                //
                // When there are only a few items (especially 1 or 2) this looks terrible.
                //
                // So, for lists with small numbers of entries, we crop the list as it appears on screen,
                // such that each item appears exactly once in view. We do this in CSS, for lists of
                // between 1 and LONGEST_CLIPPED_LIST items...
                //

                for (var itemVisibleCount = 1; itemVisibleCount <= LONGEST_CLIPPED_LIST; itemVisibleCount++) {
                    if (films.length === itemVisibleCount) {
                        this.moviesGridClipper.addClass("item-count-" + itemVisibleCount);
                    } else {
                        this.moviesGridClipper.removeClass("item-count-" + itemVisibleCount);
                    }
                }

                return promise.all([
                    this.setMovieGridDatasource(this.moviesGrid, films),
                    this.setEpisodeGridDatasource(this.episodeSportGrid, episodeSport)
                ]);

            },this)).fail(function (reason) {
                console.info("Error while fetching watchlist ", reason);

                // @TODO Do we ever get front-facing errors from this call?
                dialogHelper.error({
                    reason: reason
                });
            });
        },

        setMovieGridDescriptionVisible: function(isVisible) {
            // Change visibility without affecting flow...
            if (isVisible) {
                this.getView().find("descriptionContainer").removeClass("hidden");
            } else {
                this.getView().find("descriptionContainer").addClass("hidden");
            }
        },

        // set a datasource to a grid, and if any error occurs, set the grid as invalid
        setMovieGridDatasource: function(grid, itemArray) {
            if (!itemArray.length) {
                grid.hide();
                this.getView().find("descriptionContainer").hide(); // Sets display: none, affecting flow.
                return false;
            }
            else {
                grid.show();
                this.getView().find("descriptionContainer").show(); // Sets display: block, affecting flow.
            }
            var moviesDataSource = new LocalDatasource(),
                dataLoader,
                opts = {
                    ids : itemArray
                };

            dataLoader = sAssetManager.getAssets(opts, ASSET_TYPE.FILM).then(function(assetsArray){
                dataLoader = sAssetManager.getDataLoaderFromArray(assetsArray);
                moviesDataSource.setDataLoader(dataLoader);
                return grid.setDatasource(moviesDataSource).then(null, function () {
                    grid.hide();
                });
            });

            grid.setDisplayStgy(function (asset) {
                var view = new Container({
                    forwardFocus: true
                });

                sAssetManager.getStormAssetDvdCover(asset).then(util.bind(function(targetImage){
                    new ImageButton({
                        parent: view,
                        src: targetImage.get("url"),
                        placeHolderPromise: sAppConfigManager.getPlaceholderPortrait
                    });
                },this), function(error){
                    console.log("getStormAssetDvdCover failed: " + error);
                }).done();

                return view;
            });
            return dataLoader;
        },

        // set a datasource to a grid, and if any error occurs, set the grid as invalid
        setEpisodeGridDatasource: function(grid, itemArray) {
            if (!itemArray.length) {
                grid.hide();
                return false;
            }
            else {
                grid.show();
            }
            var episodesDataSource = new LocalDatasource(),
                dataLoader,
                opts = {
                    ids : itemArray
                },
                titleFormatter = function(asset) {
                    var title= "",
                    seasonNumber = asset.get("seasonNumber"),
                    episodeNumber = asset.get("episodeNumber"),
                    seriesTitle = asset.get("title");

                    if (seasonNumber) {
                        title += "S" + seasonNumber + " ";
                    }
                    if (episodeNumber) {
                        title += "E" + episodeNumber;
                    }
                    if (title.length) {
                        title += ": ";
                    }
                    if (seriesTitle && seriesTitle.length) {
                        title += seriesTitle.toUpperCase();
                    }
                    return title;
                };

            dataLoader = sAssetManager.getAssets(opts, ASSET_TYPE.EPISODE).then(function(assetsArray) {
                dataLoader = sAssetManager.getDataLoaderFromArray(assetsArray);
                episodesDataSource.setDataLoader(dataLoader);

                return grid.setDatasource(episodesDataSource).then(null, function () {
                    grid.hide();
                });
            });


            grid.setDisplayStgy(function (asset) {
                var view = new Container({
                        forwardFocus: true
                    });

                sAssetManager.getStormAssetImageBySize(asset, SERIES_IMAGE_MIN_WIDTH, SERIES_IMAGE_MIN_HEIGHT).then(util.bind(function(targetImage){
                    var imageButton = new ImageButton({
                            parent: view,
                            src: targetImage.get("url"),
                            placeHolderPromise: sAppConfigManager.getPlaceholderLandscape
                        }),
                        textContainer = new Container({
                            parent: imageButton,
                            css: "textContainer"
                        }),
                        label = new Label({
                            parent: textContainer,
                            text: titleFormatter(asset),
                            css: "text"
                        });

                },this), function(error){
                    console.log("getStormAssetImageBySize failed: " + error);
                }).done();

                return view;
            });
            return dataLoader;
        },

        movieDescriptionHandler: function() {
            var asset = this.moviesGrid.getSelectedData();
            this._titleLabel.setText(asset.get("title"));

            var genre = asset.get("genreList");
            this._metaLabel.setText(genre.main.content + " | " + asset.get("year"));
        },

        movieGridClickHandler: function() {
            var asset = this.moviesGrid.getSelectedData();
            mediator.publish("navigate", {
                path: "Main/Movie",
                state: {
                    assetId: asset.get("id"),
                    catalog: asset.get("catalog")
                }
            });
            return false;
        },

        episodeSportGridFocusHandler: function() {
            this.setMovieGridDescriptionVisible(false);
        },

        movieGridFocusHandler: function() {
            this.setMovieGridDescriptionVisible(true);
        },

        episodeSportGridClickHandler: function() {
            var asset = this.episodeSportGrid.getSelectedData();

            if (asset.get("type") === ASSET_TYPE.SPORT) {
                mediator.publish("navigate", {
                    path: "Main/Sport",
                    state: {
                        assetId: asset.get("id"),
                        catalog: asset.get("catalog")
                    }
                });

            } else if (asset.get("type") === ASSET_TYPE.EPISODE) {

                // Note that watchlist only supports Film, Sport, and Episode items.
                // TV shows (in the sense of an aggregate thing containing seasons with episodes) are not covered here.

                mediator.publish("navigate", {
                    path: "Main/Episode",
                    state: {
                        selectedEpisodeId: asset.get("id"),
                        catalog: asset.get("catalog")
                    }
                });
            }

            return false;
        },
        reset: function () {

            //remove event listeners
            this.moviesGrid.removeEventListener(evtType.FOCUS, this.movieGridFocusHandlerRef);
            this.moviesGrid.removeEventListener(evtType.CLICK, this.movieGridClickHandlerRef);
            this.moviesGrid.removeEventListener(evtType.SELECTION_CHANGED, this.movieDescriptionHandlerRef);
            this.episodeSportGrid.removeEventListener(evtType.FOCUS, this.episodeSportGridFocusHandlerRef);
            this.episodeSportGrid.removeEventListener(evtType.CLICK, this.episodeSportGridClickHandlerRef);

            this._super();
        }
    });
});
define("storm/ctrl/Blank", [
    "tvedemo/ctrl/RoutableController",
    "xdk-ax/Container",
	"xdk-base/class"
], function(
	RoutableController,
	Container,
	klass
) {
	return klass.create(RoutableController, {}, {
		init: function () {
			this._super();
			this.setView(new Container({
				focusable: false
			}));
		}
	});
});
/**
 * Datasource Interface
 * @class tve/ext/ui/programguide/interface/Datasource
 */
define("tve/ext/ui/programguide/interface/Datasource", ["xdk-base/Interface"], function (Interface) {
    return Interface.create("Datasource", {
        /**
         * Get the total number of rows.
         * @method getTotalRowNumber
         * @public
         * @returns {Promise.<Integer>} the total row number
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/ext/ui/programguide/interface/Datasource#
         */
        getTotalRowNumber: [],

        /**
         * Get the data of one row by a given date.
         * @method getProgramGuideCellData
         * @public
         * @param {Integer} rowIndex the index number of the row
         * @param {Object} date The date object of the day, it can be at any time in hour and minute.
         * @returns {Promise.<Object>} an object includes startTime, endTime and data.
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/ext/ui/programguide/interface/Datasource#
         */
        getProgramGuideCellData: ["rowIndex", "date"],

        /**
         * Get the header data of one row
         * @method getRowHeaderData
         * @public
         * @param {Integer} rowIndex the index number of the row
         * @returns {Promise.<Object>} the header object
         * @throws {Promise.<ax/TVEError>} Internal error object
         * @memberof tve/ext/ui/programguide/interface/Datasource#
         */
        getRowHeaderData: ["rowIndex"]
    });
});
/**
 * ChannelListingDatasource is a custom data source class for {@link tve/ext/ui/ProgramGuide}.
 * This data source control how the program guide data looks like.
 *
 * @class tvedemo/ext/ui/programguide/ChannelListingDatasource
 * @augments tve/ext/ui/programguide/interface/Datasource
 */
define("tvedemo/ext/ui/programguide/ChannelListingDatasource",
    [
        "xdk-base/class",
        "xdk-base/promise",
        "xdk-base/console",
        "tve/TVEError",
        "tve/ext/ui/programguide/interface/Datasource",
        "tve/mgr/sLinearManager",
        "tvedemo/mgr/sEndUserManager"
    ],
    function (
        klass,
        promise,
        console,
        TVEError,
        ProgramGuideDataSource,
        sLinearManager,
        sEndUserManager
        ) {

        "use strict";

        return klass.create([ProgramGuideDataSource], {}, {
            
            filteredChannelIds: null,

            /**
             * Overrides parent init() function.
             * @method init
             * @protected
             * @param {String[]} channelIds the ids of channels
             * @memberOf tvedemo/ext/ui/programguide/ChannelListingDatasource#
             */
            init: function (channelIds) {
                this.__channelIds = channelIds || null;
            },

            /**
             * Get the total number of rows.
             * @method getTotalRowNumber
             * @public
             * @returns {Promise.<Number>} the total row number
             * @throws {Promise.<ax/TVEError>} Internal error object
             * @memberOf tvedemo/ext/ui/programguide/ChannelListingDatasource#
             */
            getTotalRowNumber: function () {
                if (this.__channelIds) {
                    return promise.resolve(this.__channelIds.length);
                }

                return sLinearManager.getChannels().then(function (channels) {
                    return channels.length;
                });
            },

            /**
             * Get the data of one row by a given date.
             * @method getProgramGuideCellData
             * @public
             * @param {Number} rowIndex the index number of the row
             * @param {Object} date The date object of the day, it can be at any time in hour and minute.
             * @returns {Promise.<Object>} an object includes startTime, endTime and data.
             * @throws {Promise.<ax/TVEError>} Internal error object
             * @memberOf tvedemo/ext/ui/programguide/ChannelListingDatasource#
             */
            getProgramGuideCellData: function (rowIndex, date) {
                var channelListingsHandler = function (listings) {
                    var programs = listings[rowIndex].get("programs"),
                        ret = [],
                        program;

                    for (var i = 0, l = programs.length; i < l; i++) {
                        program = programs[i];

                        ret[i] = {
                            id: program.get("id"),
                            startTime: program.get("startTime"),
                            endTime: program.get("endTime"),
                            data: program
                        };
                    }

                    return ret;
                };


                if (this.__channelIds) {
                    return sLinearManager.getChannelListingsByChannelIds(this.__channelIds, date).then(channelListingsHandler);
                }

                // if fetching all channels then grab only first 6 channels (EPG start)

                return sLinearManager.getChannelListingsByDate(date).then(channelListingsHandler);
            },

            /**
             * Get the header data of one row
             * @method getRowHeaderData
             * @public
             * @param {Number} rowIndex the index number of the row
             * @returns {Promise.<Object>} the header object
             * @throws {Promise.<ax/TVEError>} Internal error object
             * @memberOf tvedemo/ext/ui/programguide/ChannelListingDatasource#
             */
            getRowHeaderData: function (rowIndex) {
                var channelsHandler = function (channels) {
                    var channel = channels[rowIndex],
                        channelId = channel.get("id"),
                        mobilepc = channel.get("mobilepc");
                    
                    return sLinearManager.getChannelLogoUrl(channel).then(function (url) {
                        return {
                            id: channelId,
                            logo: url,
                            mobilepc: mobilepc
                        };
                    });
                };

                if (this.__channelIds) {
                    return sLinearManager.getChannelsByIds(this.__channelIds).then(channelsHandler);
                }

                return sLinearManager.getChannels().then(channelsHandler);
            }
        });

    });

/**
 *
 * Input Div is a input field which provide data input. As it is a div, so it is unable to handle click and moving the cursor by mouse.
 *
 * ###Dom Structure
 *
 *      <div class="wgt-input" id="input">
 *          <div class="container">
 *              <pre class="wrapper" style="left: 0px;"></pre>
 *              <pre class="wrapperCopy" style="left: 0px;"></pre>
 *              <div class="cursor" style="left: 0px; visibility: hidden;"></div>
 *          </div>
 *      </div>
 *
 * ###CSS
 * ####Structural CSS
 *      .wrapperCopy, .wrapper {
 *          position: absolute;
 *          left: 0px;
 *          margin: 0px;
 *      }
 *      .wrapperCopy{
 *          visibility: hidden;
 *      }
 *
 * ####Customizable CSS
 * .wgt-input .cursor - to set the style cursor of the input
 *
 * @class tvedemo/ext/ui/input/InputDivImpl
 * @param {Object} opts The options object
 * @param {Number} opts.maxLength The available length of the input
 * @param {Boolean} opts.isPassword True if it is password and it will be "*" for the input
 * @param {String} opts.text The default text of the input
 * @param {Number} opts.hideTimeout time to hide the password and only available when opts.isPassword true
 * @param {String} opts.passwordChar The char to replace the "*" which is the default character.
 */
define("tvedemo/ext/ui/input/InputDivImpl", [
    "xdk-ui-input/InputDivImpl",
    "xdk-base/class", 
    "xdk-base/console"
], function (
    InputDivImpl,
    klass,
    console
) {
    "use strict";
    
    return klass.create(InputDivImpl, {}, {
        
        /**
         * @memberof ax/ext/ui/input/InputDivImpl#
         * @private
         */
        init: function(opts) {
            opts = opts || {};
            this._super(opts);
        }
    });
});
/**
 *
 * Input Native widget use the input tag and is compatible to the mouse. User can click and move the cursor.
 *
 * ###Dom Structure
 *      <div class="wgt-input wgt-input-native" id="input">
 *          <div class="container">
 *              <input class="wgt-input-native-ele">
 *          </div>
 *      </div>
 *
 * ###CSS
 * ####Structural CSS
 *      //To display input properly.
 *      .wgt-input-native-ele{
 *          resize: none;
 *          margin: 0px;
 *          padding: 0px;
 *          border: 0px;
 *          outline: none;
 *          word-wrap: break-word;
 *          height: 100%;
 *      }
 *
 * ####Customizable CSS
 * .wgt-input - to set the size of the input
 *
 * @class tvedemo/ext/ui/input/InputNativeImpl
 * @param {Object} opts The options object
 * @param {Number} opts.maxLength The available length of the input
 * @param {Boolean} opts.isPassword True if it is password and it will be "*" for the input
 * @param {String} opts.text The default text of the input
 * @param {Number} opts.hideTimeout time to hide the password and only available when opts.isPassword true
 * @param {String} opts.passwordChar The char to replace the "*" which is the default character.
 */
define("tvedemo/ext/ui/input/InputNativeImpl", [
    "xdk-ui-input/InputNativeImpl",
    "xdk-base/class", 
    "xdk-base/console"
], function (
    InputNativeImpl,
    klass,
    console
) {
    "use strict";
    
    return klass.create(InputNativeImpl, {}, {
        
        init: function(opts) {
            
            console.log("Overridden InputNativeImpl init");
            
            opts = opts || {};
            this._super(opts);
            
            // Overrideing mouse out handler
            handleMouseOut = function(evt) {
                console.info(self.__inputState);
                console.info(evt);
                console.info("STORM inputNativeImpl: mouse out");
    
                //self.stopInput();
                return true;
            };
        }
    });
});
define("xdk-base/device/workstation/detection", [],function () {
    "use strict";
    var detection = (function () {
        var agent;
        if ( !! navigator && !! navigator.userAgent) {
            agent = navigator.userAgent.toLowerCase();
            if ((agent.indexOf("windows nt") !== -1) || (agent.indexOf("linux") !== -1 && agent.indexOf("x11") !== -1) || (agent.indexOf("macintel") !== -1) || (agent.indexOf("macintosh") !== -1)) {
                //only support chrome and firefox
                if (agent.indexOf("chrome") !== -1 || agent.indexOf("firefox") !== -1) {
                    return true;
                }
            }
        }
        return false;
    })();
    return detection;
});
/**
 * TvKey class to handle the key
 * @class xdk-base/device/workstation/TvKey
 * @extends ax/device/AbstractTvKey
 */
define("xdk-base/device/workstation/TvKey", ["xdk-base/device/shared/browser/TvKey", "xdk-base/class", "xdk-base/device/vKey", "xdk-base/util", "xdk-base/device/shared/browser/keyMap"], function (abstrBrowserTvKey, klass, VKey, util, keyMap) {
    "use strict";
    return klass.create(abstrBrowserTvKey, {}, {
        init: function () {
            //To get the keyboard keyCode since workstation support the keyboard
            var keyMapping = util.clone(keyMap.KEYBOARD_KEY, true);

            //extra device specific keys like color keys and back
            keyMapping.VKey[118] = VKey.RED; //F7
            keyMapping.VKey[119] = VKey.GREEN; //F8
            keyMapping.VKey[120] = VKey.YELLOW; //F9
            keyMapping.VKey[121] = VKey.BLUE; //F10
            keyMapping.VKey[27] = VKey.BACK; //the key esc
            keyMapping.VKey[145] = VKey.EXIT; //The scroll lock key

            //set the keyMap
            this.initKeyMapping(keyMapping, keyMap.KEYBOARD_CHAR);
        }
    });
});
/**
 * A helper to generate the unique id and store into the device storage.
 * @class xdk-base/device/helper/storageUnqiueId
 */
define("xdk-base/device/helper/storageUniqueId", [
    "require",
    "xdk-base/core",
    "xdk-base/exception"
], function (
    require,
    core,
    exception
) {
    "use strict";
    /**
     * Used as the key to save uuid in {@link xdk-base/device/AbstractStorage|storage}
     * @name UUID_KEY
     * @constant
     * @memberof xdk-base/device/helper/storageUnqiueId
     * @private
     */
    var UUID_KEY = "__UUID__",
        /**
         * To store the unique id
         * @name uuid
         * @memberof xdk-base/device/helper/storageUnqiueId
         * @private
         */
        uuid = null;
    return {
        /**
         * return the unique id and saved to storage, so it will alway return the same id
         * @method getUniqueID
         * @public
         * @returns {String} the device serial number
         * @memberof xdk-base/device/helper/storageUnqiueId
         */
        getUniqueID: function () {
            /*jshint bitwise:false*/
            var device, i, random;
            device = require("xdk-base/device");

            //To ensure the storage and enviornment is ready to use
            if (!device || !device.storage) {
                throw core.createException(exception.ILLEGAL_STATE, "device storage is not ready and fail to generate unique id");
            }

            if (uuid === null) {
                uuid = device.storage.get(UUID_KEY);

                if (!uuid) {
                    uuid = "";
                    for (i = 0; i < 32; i++) {
                        random = Math.random() * 16 | 0;

                        if (i === 8 || i === 12 || i === 16 || i === 20) {
                            uuid += "-";
                        }
                        uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random))
                            .toString(16);
                    }

                    device.storage.set(UUID_KEY, uuid);
                }
            }

            return uuid;
            /*jshint bitwise:true*/
        }
    };
});
/**
 * Id class to identification information of a device.
 * @class xdk-base/device/AbstractId
 * @augments ax/device/interface/Id
 */
define("xdk-base/device/AbstractId", [
    "xdk-base/class",
    "xdk-base/device/interface/Id",
    "require",
    "xdk-base/device/helper/storageUniqueId"
], function (
    klass,
    IId,
    require,
    storageUniqueId
) {
    "use strict";
    return klass.createAbstract([IId], {}, {
        /**
         * To return the device type
         * @method getDeviceType
         * @deprecated replaced with getHardwareType
         * @memberof xdk-base/device/workstation/Id#
         */
        getDeviceType: function () {
            return this.getHardwareType();
        },
        /**
         * Get the MAC address.
         * @name getMac
         * @function
         * @return {String} mac address. null if not available.
         * @memberof xdk-base/device/AbstractId#
         * @public
         */
        getMac: function () {
            return null;
        },
        /**
         * Get the system's firmware version.
         * @name getFirmware
         * @function
         * @return {String} firmware version."dummyFirmware" if not available.
         * @memberof xdk-base/device/AbstractId#
         * @public
         */
        getFirmware: function () {
            return "dummyFirmware";
        },
        /**
         * Get the year from the system's firmware version.
         * @name getFirmwareYear
         * @function
         * @memberof xdk-base/device/AbstractId#
         * @return {Number} firmware year Return 0 if not available.
         * @public
         */
        getFirmwareYear: function () {
            return 0;
        },
        /**
         * Get a uniqueID of the device. UUID is gernerated and stored in localStorage to pretent a
         * unique if device API is not available.
         * @name getUniqueID
         * @function
         * @return {String} unique ID
         * @memberof xdk-base/device/AbstractId#
         * @public
         */
        getUniqueID: function () {
            return storageUniqueId.getUniqueID();
        },
        /**
         * Get device's model number.
         * @name getModel
         * @function
         * @return {String} "dummyModel" if not available.
         * @memberof xdk-base/device/AbstractId#
         * @public
         */
        getModel: function () {
            return "dummyModel";
        },
        /**
         * Get device's internal IP.If there are no related api, it will return 0.0.0.0 and
         * developer may need to send ajax to public api service to get the ip.
         * @name getIP
         * @function
         * @memberof xdk-base/device/AbstractId#
         * @return {String} ip address."0.0.0.0" if it's not available.
         * @public
         */
        getIP: function () {
            return "0.0.0.0";
        }
    });
});
/**
 * Id class to handle the device information like firmware version
 * @class xdk-base/device/workstation/Id
 * @extends ax/device/AbstractId
 */
define("xdk-base/device/workstation/Id", ["xdk-base/class", "xdk-base/device/AbstractId", "xdk-base/device/interface/Id", "xdk-base/console"], function (klass, abstrId, IId, console) {
    "use strict";
    return klass.create(abstrId, [IId], {}, {
        /**
         * To return the device type as "workstation"
         * @method getDeviceType
         * @deprecated replaced with getHardwareType
         * @memberof xdk-base/device/workstation/Id#
         */
        getDeviceType: function () {
            return "Workstation";
        },
        /**
         * To return the hardware type
         * @method getHardwareType
         * @returns {ax/device/interface/Id.HARDWARE_TYPE} device type as {@link xdk-base/device/interface/Id.HARDWARE_TYPE.WORKSTATION}
         * @memberof xdk-base/device/workstation/Id#
         */
        getHardwareType: function () {
            return IId.HARDWARE_TYPE.WORKSTATION;
        },
        /**
         * To get the firmware version
         * @method getFirmware
         * @memberof xdk-base/device/workstation/Id#
         */
        getFirmware: function () {
            //to get the browser and version
            var name = "workstation",
                version = "DummyFirmware",
                ua = navigator.userAgent.toLowerCase();
            try {
                if (ua.indexOf("chrome") !== -1) {
                    name = "Chrome";
                    version = (/chrome\/([\d.]+)/.exec(ua))[1];
                } else if (ua.indexOf("firefox") !== -1) {
                    name = "Firefox";
                    version = (/firefox\/([\d.]+)/.exec(ua))[1];
                } else if (ua.indexOf("opera") !== -1) {
                    name = "opera";
                    version = (/version\/([\d.]+)/.exec(ua))[1];
                } else if (ua.indexOf("safari") !== -1) {
                    name = "safari";
                    version = (/version\/([\d.]+)/.exec(ua))[1];
                }
            } catch (ex) {
                console.warn("unable to determine the firmware");
            }
            return name + "/" + version;
        }
    });
});
/**
 * HTML5 System to handle the basic html5 system feature. It provides the visibility change.
 *
 * @class xdk-base/device/shared/Html5System
 */
define("xdk-base/device/shared/Html5System", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/core",
    "xdk-base/console",
    "require",
    "xdk-base/EventDispatcher",
    "xdk-base/device/interface/System"
], function (
    klass,
    util,
    core,
    console,
    require,
    EventDispatcher,
    ISystem
) {
    "use strict";

    return klass.createAbstract(EventDispatcher, [ISystem], {}, {
        /**
         * @protected
         * @name _device
         * @memberof xdk-base/device/shared/Html5System#
         */
        _device: undefined,

        /**
         * @protected
         * @name _document
         * @memberof xdk-base/device/shared/Html5System#
         */
        _document: undefined,

        /**
         * @private
         * @name __bindedOnVisibilityChange
         * @memberof xdk-base/device/shared/Html5System#
         */
        __bindedOnVisibilityChange: undefined,
        init: function () {
            this._document = core.root.document;
            this._device = require("xdk-base/device");

            if (!util.isUndefined(this._document)) {
                this._addVisibilityChangeListener();
            }
        },
        /**
         * Get device
         * @method _getDevice
         * @protected
         * @memberof xdk-base/device/shared/Html5System#
         */
        _getDevice: function () {
            return this._device;
        },
        /**
         * Get document which should be window.document
         * @method _getDevice
         * @protected
         * @memberof xdk-base/device/shared/Html5System#
         */
        _getDocument: function () {
            return this._document;
        },
        /**
         * To listen the page visibility change and notice deviceHandler resume and pause
         * @method _addVisibilityChangeListener
         * @protected
         * @memberof xdk-base/device/shared/Html5System#
         */
        _addVisibilityChangeListener: function () {
            var _document = this._getDocument(),
                visibility = this._getVisibility();

            if (util.isUndefined(visibility)) {
                return;
            }

            this.__bindedOnVisibilityChange = util.bind(this._onVisibilityChange, this);
            _document.addEventListener(visibility.eventName, this.__bindedOnVisibilityChange, false);
        },
        /**
         * To get visibility API detail
         * @method _getVisibility
         * @protected
         * @memberof xdk-base/device/shared/Html5System#
         */
        _getVisibility: function () {
            var _document = this._getDocument(),
                hidden, eventName;

            if (!util.isUndefined(_document.hidden)) {
                hidden = "hidden";
                eventName = "visibilitychange";
            } else if (!util.isUndefined(_document.mozHidden)) {
                hidden = "mozHidden";
                eventName = "mozvisibilitychange";
            } else if (!util.isUndefined(_document.msHidden)) {
                hidden = "msHidden";
                eventName = "msvisibilitychange";
            } else if (!util.isUndefined(_document.webkitHidden)) {
                hidden = "webkitHidden";
                eventName = "webkitvisibilitychange";
            } else {
                console.warn("Page Visibility API is not supported in this environment.");
                return;
            }

            return {
                hidden: hidden,
                eventName: eventName
            };
        },
        /**
         * Event visibilitychange listener
         * @method _onVisibilityChange
         * @protected
         * @param {Object} e Event
         * @memberof xdk-base/device/shared/Html5System#
         */
        _onVisibilityChange: function (e) {
            var device = this._getDevice(),
                deviceHandler = device.getDeviceHandler(),
                _document = this._getDocument(),
                visibility = this._getVisibility();

            if (_document[visibility.hidden]) {
                deviceHandler.onDevicePause();
            } else {
                deviceHandler.onDeviceResume();
            }
        },
        /**
         * @method deinit
         * @protected
         * @memberof  ax/device/shared/Html5System#
         */
        deinit: function () {
            var _document, visibility;

            if (!util.isUndefined(this.__bindedOnVisibilityChange)) {
                _document = this._getDocument();
                visibility = this._getVisibility();
                _document.removeEventListener(visibility.eventName, this.__bindedOnVisibilityChange);
            }
        },
        /**
         * To set the system mute
         * @public
         * @method setSystemMute
         * @param {Boolean} flag True if turn on the mute, false when turn off.
         * @param {Boolean} True when send the request successfully.
         * @memberof xdk-base/device/shared/Html5System#
         */
        setSystemMute: klass.abstractFn,
        /**
         * To exit the apps
         * @public
         * @param {Object} [opts]
         * @param {boolean} [opts.toTV=true] True when exit the application to TV. False when suspend the apps and to show the app bar.
         * @method exit
         * @memberof xdk-base/device/shared/Html5System#
         */
        exit: klass.abstractFn,
        /**
         * Has mouse on webos
         * @public
         * @method hasMouse
         * @returns {Boolean} true
         * @memberof xdk-base/device/shared/Html5System#
         */
        hasMouse: klass.abstractFn,
        /**
         * To get the display resolution
         * @public
         * @method getDisplayResolution
         * @return {Object} object {width:1280,height:720} or {width:1920, height1080}
         * @memberof xdk-base/device/shared/Html5System#
         */
        getDisplayResolution: klass.abstractFn,
        /**
         * webos supports SSL
         * @public
         * @method supportSSL
         * @return {Boolean} True
         * @memberof xdk-base/device/shared/Html5System#
         */
        supportSSL: klass.abstractFn,
        /**
         * webos supports SSL
         * @public
         * @method supportSSL
         * @return {Boolean} True
         * @memberof xdk-base/device/shared/Html5System#
         */
        getNetworkStatus: klass.abstractFn,
        /**
         * Determine whether support cross domain ajax.
         * @method hasSOP
         * @return {Boolean} Return true if cross domain ajax is not allowed natively. Proxy / Allow-Origin header setup may be needed.
         * @memberof xdk-base/device/shared/Html5System#
         */
        hasSOP: klass.abstractFn,

        /**
         * Setting the screen saver On/Off
         * @method setScreenSaver
         * @param {Boolean} flag True to turn on and off to turn off.
         * @return {Boolean}  Return false.
         * @memberof xdk-base/device/shared/Html5System#
         */
        setScreenSaver: klass.abstractFn,
        /**
         * Power off the system
         * @method powerOff
         * @return {Boolean} Return false
         * @memberof xdk-base/device/shared/Html5System#
         */
        powerOff: klass.abstractFn,
        /**
         * @method redraw
         * @param {HTMLElement} [element=document.body] the target element. Default will be document.body
         * @param {Boolean} false when not support
         * @memberof xdk-base/device/shared/Html5System#
         */
        redraw: klass.abstractFn,
        /**
         * @method hasFixedKeyboard
         * @return {Boolean} Return true.
         * @memberof xdk-base/device/shared/Html5System#
         */
        hasFixedKeyboard: klass.abstractFn
    });
});
/**
 * System class to handle the system api and connection checking
 *
 * ### Config Params
 *
 *  Attribute | Value
 * --------- | ---------
 * Key      | device.workstation.1080p
 * Type     | Boolean
 * Desc     | Set the workstation display resolution 1080p instead of 720p. Default will use the 720p
 * Default  | false
 * Usage    | {@link module:xdk-base/config}
 * --------- | ---------
 * Key      | device.workstation.resize
 * Type     | Boolean
 * Desc     | Set the workstation is resizable and display resolution is updated accroding the window size which will override the device.workstation.1080p setting
 * Default  | false
 * Usage    | {@link module:xdk-base/config}
 * @class xdk-base/device/workstation/System
 * @augments ax/device/shared/Html5System
 */
define("xdk-base/device/workstation/System", [
    "xdk-base/class",
    "xdk-base/device/shared/Html5System",
    "xdk-base/config",
    "xdk-base/device/shared/ConnectionPoller",
    "xdk-base/device/interface/System",
    "xdk-base/util",
    "xdk-base/core",
    "xdk-base/promise"
], function (
    klass,
    Html5System,
    config,
    ConnectionPoller,
    ISystem,
    util,
    core,
    promise
) {
    "use strict";

    return klass.create(Html5System, {}, {
        /**
         * @protected
         * @name _device
         * @memberof xdk-base/device/workstation/System#
         */
        _device: undefined,

        /**
         * @protected
         * @name _document
         * @memberof xdk-base/device/workstation/System#
         */
        _document: undefined,

        /**
         * @private
         * @name __bindedOnVisibilityChange
         * @memberof xdk-base/device/workstation/System#
         */
        __bindedOnVisibilityChange: undefined,

        /**
         * The number of network status change event listeners
         *
         * @private
         * @member {Number}
         * @memberof xdk-base/device/workstation/System#
         */
        __networkEventListenerCount: 0,

        init: function () {
            this._super();
            this.__checkNetworkStatus();

            var resizable = config.get("device.workstation.resize", false);

            if (resizable) {
                this.__addResizeListener();
            }
        },
        /**
         * set the resize listener
         * @method __addResizeListener
         * @private
         * @memberof xdk-base/device/workstation/System#
         */
        __addResizeListener: function () {
            core.root.addEventListener("resize", util.bind(function () {

                //receive resize change
                this.dispatchEvent(ISystem.EVT_RESIZE, this.getDisplayResolution());

            }, this));
        },
        /**
         * Has mouse on workstation
         * @public
         * @name hasMouse
         * @memberof xdk-base/device/workstation/System#
         */
        hasMouse: function () {
            return true;
        },
        /**
         * Has hardware keyboard
         * @public
         * @name hasFixedKeyboard
         * @memberof xdk-base/device/workstation/System#
         */
        hasFixedKeyboard: function () {
            return true;
        },
        /**
         * To get the display resolution and now it is either 1280x720 or 1920x1080.Default is 1280x720.To use 1080p
         * need to set "device.workstation.1080p" to be true
         * @public
         * @name getDisplayResolution
         * @return {Object} object {width:1280,height:720}
         * @memberof xdk-base/device/workstation/System#
         */
        getDisplayResolution: function () {
            var resizable = config.get("device.workstation.resize", false);

            if (resizable) {
                return {
                    width: (window.innerWidth !== null ? window.innerWidth : document.body !== null ? document.body.clientWidth : null),
                    height: (window.innerHeight !== null ? window.innerHeight : document.body !== null ? document.body.clientHeight : null)
                };
            }

            //the display resolution in workstation are 1280p and 1080p
            var resolution1080p = config.get("device.workstation.1080p", false);
            if (resolution1080p) {
                return {
                    width: 1920,
                    height: 1080
                };
            }
            return {
                width: 1280,
                height: 720
            };
        },
        /**
         * Workstation supports SSL
         * @public
         * @name supportSSL
         * @return {Boolean} True
         * @memberof xdk-base/device/workstation/System#
         */
        supportSSL: function () {
            return true;
        },
        /**
         * Override the abstract system and get the current network status
         * @method getNetworkStatus
         * @return {Promise.<Boolean>}  Return true if it is conencted to internet
         * @public
         * @memberof xdk-base/device/workstation/System#
         */
        getNetworkStatus: function () {
            return promise.resolve(this._isInternetConnected());
        },
        /**
         * To check the Internet connected or not. Relies on navigator.onLine
         * @method _isInternetConencted
         * @return {Boolean} Return true if it is connected
         * @protected
         * @memberof xdk-base/device/workstation/System#
         */
        _isInternetConnected: function () {
            return navigator.onLine;
        },
        /**
         * To override the abstract network status checking which replace the ajax network checking method. Now it will create a poller that keep tracking on the status of the device.
         * @method _postInit
         * @protected
         * @memberof xdk-base/device/workstation/System#
         */
        __checkNetworkStatus: function () {
            var checkStatus, onStatusChange;

            //the checking method
            checkStatus = util.bind(function (__checkStatusDoneCb) {

                __checkStatusDoneCb(this._isInternetConnected());

            }, this);

            //the checking callback
            onStatusChange = util.bind(function (status) {

                this.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, status);

            }, this);

            //start the poller, set check method and callback.
            this._internetPoller = new ConnectionPoller(checkStatus, onStatusChange, {
                networkStatus: this._isInternetConnected()
            });
        },
        /**
         * Overrides parent method to start the polling on add event listener.
         *
         * @method
         * @param {xdk-ax/evt/type|String} type event type
         * @param {Function} handler event listener function
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @memberof xdk-base/device/workstation/System#
         */
        addEventListener: function (type, handler, once) {
            if (this._internetPoller && type === ISystem.EVT_NETWORK_STATUS_CHANGED) {
                if (this.__networkEventListenerCount === 0) {
                    // start the polling when adding the event listener
                    this._internetPoller.startPolling();
                }

                this.__networkEventListenerCount++;
            }

            return this._super(type, handler, once);
        },
        /**
         * Overrides parent method to stop the polling on event listener remove.
         *
         * @method
         * @param {xdk-ax/evt/type|String} type Event type
         * @param {Function} [handler] event listener function.  If not provided, all listeners will be removed for the specific type.
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @memberof xdk-base/device/workstation/System#
         */
        removeEventListener: function (type, handler) {
            if (this._internetPoller && type === ISystem.EVT_NETWORK_STATUS_CHANGED) {
                this.__networkEventListenerCount--;

                if (this.__networkEventListenerCount === 0) {
                    // stop the polling if no more listener is listening
                    this._internetPoller.stopPolling();
                }
            }

            return this._super(type, handler);
        },
        /**
         * Setting the screen saver On/Off
         * @method setScreenSaver
         * @param {Boolean} flag True to turn on and off to turn off.
         * @return {Boolean}  Return false.
         * @memberof xdk-base/device/workstation/System#
         */
        /*jshint unused:false*/
        setScreenSaver: function (flag) {
            return false;
        },
        /*jshint unused:true*/
        /**
         * Setting the system to mute/unmute.
         * @method setSystemMute
         * @param {Boolean} flag True to mute and false to unmute
         * @return {Boolean} Return false;
         * @memberof xdk-base/device/workstation/System#
         */
        /*jshint unused:false*/
        setSystemMute: function (flag) {
            return false;
        },
        /*jshint unused:true*/
        /**
         * Power off the system
         * @method powerOff
         * @return {Boolean} Return false
         * @memberof xdk-base/device/workstation/System#
         */
        powerOff: function () {
            return false;
        },
        /**
         * @method redraw
         * @param {HTMLElement} [element=document.body] the target element. Default will be document.body
         * @param {Boolean} false when not support
         * @memberof xdk-base/device/workstation/System#
         */
        /*jshint unused:false*/
        redraw: function (element) {
            return false;
        },
        /*jshint unused:true*/
        /**
         * Exit the application
         * @method exit
         * @param {Object} [obj] To set the information when exit
         * @param {Boolean} [obj.toTV] True when exit back to TV source, false will go back to smartHub/App Store page.Default is true
         * @return {Boolean} Return false
         * @memberof xdk-base/device/workstation/System#
         */
        exit: function () {
            return false;
        },
        /**
         * Whether same-origin policy exists in the device (i.e. cross domain ajax is not allowed). Modern browsers should have this policy.
         * @name hasSOP
         * @method
         * @return {Boolean} Return true if cross domain ajax is not allowed natively. Proxy / Allow-Origin header setup may be needed.
         * @memberof xdk-base/device/workstation/System#
         */
        hasSOP: function () {
            return true;
        }
    });
});
/**
 * DevicePack class to handle the packaging for the workstation
 * @class xdk-base/device/workstation/DevicePackage
 * @extends ax/device/AbstractDevicePackage
 */
define("xdk-base/device/workstation/DevicePackage", [
    "xdk-base/device/AbstractDevicePackage",
    "xdk-base/device/shared/LocalStorage",
    "xdk-base/device/workstation/TvKey",
    "xdk-base/device/workstation/Id",
    "xdk-base/device/workstation/System",
    "xdk-base/device/Media",
    "xdk-base/class",
    "xdk-base/util"
], function (
    AbsDevicePackage,
    LocalStorage,
    TvKey,
    Id,
    System,
    Media,
    klass,
    util
) {
    "use strict";
    return klass.create(AbsDevicePackage, {}, {
        /**
         * [Backward Compatible only] To be true when device package version >= 2.3
         * @property {Boolean} shouldSetup Should this setup method in AbstractDevicePackage run
         * @name _shouldSetup
         * @memberof xdk-base/device/workstation/DevicePackage#
         */
        _shouldSetup: true,
        /**
         * To return platform id of this abstraction
         * @method getId
         * @returns {String} the id of the workstation device package
         * @memberof xdk-base/device/workstation/DevicePackage#
         * @public
         */
        getId: function () {
            return "workstation";
        },
        /**
         * To init the workstation device package and packed the item need to be initialize
         * @method setup
         * @param {Function} onDeviceLoaded Device ready callback
         * @returns {ax/device/workstation/DevicePackage} device package itself.
         * @memberof xdk-base/device/workstation/DevicePackage#
         * @public
         */
        setup: function (onDeviceLoaded) {
            var interfaceTypes;

            this._super(onDeviceLoaded);

            interfaceTypes = this.getInterfaceTypes();

            util.each(interfaceTypes, util.bind(function (pair) {
                this.addInterfaceType(pair.key, pair.value.handle, pair.value.interfaceObj);
            }, this));

            this.ready();
        },
        /**
         * To get the default player. Default will be {@link xdk-base/device/shared/Html5Player}
         * @method getDefaultPlayer
         * @returns {String[]} Array of the player list
         * @memberof xdk-base/device/workstation/DevicePackage#
         * @public
         */
        getDefaultPlayer: function () {
            return ["xdk-base/device/shared/Html5Player"];
        },
        /**
         * To init each modules like id, sMedia, system and tvkey
         * @method getInterfaceTypes
         * @memberof xdk-base/device/workstation/DevicePackage#
         * @public
         */
        getInterfaceTypes: function () {
            var ret = {};
            ret[AbsDevicePackage.STORAGE] = {
                handle: AbsDevicePackage.STORAGE_HANDLE,
                interfaceObj: new LocalStorage()
            };

            ret[AbsDevicePackage.MEDIA_PLAYER] = {
                handle: AbsDevicePackage.MEDIA_PLAYER_HANDLE,
                interfaceObj: Media.singleton()
            };

            ret[AbsDevicePackage.TV_KEY] = {
                handle: AbsDevicePackage.TV_KEY_HANDLE,
                interfaceObj: new TvKey()
            };

            ret[AbsDevicePackage.ID] = {
                handle: AbsDevicePackage.ID_HANDLE,
                interfaceObj: new Id()
            };

            ret[AbsDevicePackage.SYSTEM] = {
                handle: AbsDevicePackage.SYSTEM_HANDLE,
                interfaceObj: new System()
            };

            return ret;
        }
    });
});
/**
 * Detection of Samsung by checking the userAgent for "maple" Return true if it is samsung
 * @module tvedemo/ext/device/samsung/detection
 */
define("tvedemo/ext/device/samsung/detection", [], function () {
	var detection = (function () {
		var agent = navigator.userAgent.toLowerCase();
		if (agent.indexOf("maple") !== -1) {
			return true;
		}
		return false;
	})();
	return detection;
});

/**
 * Detection of Samsung by checking the userAgent for "maple" Return true if it is samsung
 * @module xdk-ext-device-samsung/detection
 */
define("xdk-ext-device-samsung/detection", [], function () {
    "use strict";
    var detection = (function () {
        var agent = navigator.userAgent.toLowerCase();
        if (agent.indexOf("maple") !== -1) {
            return true;
        }
        return false;
    })();
    return detection;
});
/**
 * A native API loader plugin that is responsible to load Samsung API objects.
 * Parameters can be specified in the definition separated using pipe character (|) to control the load.
 * Configurable behavior include locateAPI where it won't locate the API directly by accessing the window.
 *
 * e.g `$MANAGER_WIDGET/Common/API/Widget` will be automatically loaded and return the plugin window.Common.API.Widget.
 *
 * However, some samsung native apis don't follow the same practice.
 * e.g `$MANAGER_WIDGET/Common/webapi/1.0/webapis` is not following the rule, it will load as window.webapis instead of `window.Common.webapis.1.0.0.webapis`.
 * So empty object(indicate the library is loaded) will be returned and developers need to map themselves the module.
 *
 * To disable locateAPI, specify locateAPI=false. [default will be true]
 * @example
 * // load a samsung native api
 * require(["xdk-ext-device-samsung/loader/nativeAPI!locateAPI=false|$MANAGER_WIDGET/Common/webapi/1.0/webapis"], function () {
 *     // map the webapis apis
 *     globals.webapis = window.webapis;
 * });
 *
 * @module xdk-ext-device-samsung/loader/nativeAPI
 */
define("xdk-ext-device-samsung/loader/nativeAPI", [
    "xdk-ext-device-samsung/detection",
    "xdk-base/QueryString",
    "xdk-base/util"
], function (
    detection,
    QueryString,
    util
) {
    "use strict";
    var exports = {
        /**
         * If the plugin has a dynamic property set to true, then it means
         * the loader MUST NOT cache the value of a normalized plugin dependency,
         * instead call the plugin's load method for each instance of a plugin dependency.
         * @property {Boolean} dynamic
         * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
         */
        dynamic: false,

        /**
         * pluginBuilder is a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build.
         * Without this property, the optimization WILL fail.
         * @see {@link http://requirejs.org/docs/plugins.html#apipluginbuilder}
         * @property {String} pluginBuilder
         * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
         */
        pluginBuilder: "./nativeAPIBuilder"

    };

    var modules = {},
        // delimiter for loader parameter
        PARAM_DELIMITER = "|";

    /**
     * Instantiate the API object.
     * @private
     * @method
     * @param {String} name The API name
     * @returns {Object} The newly created API object
     * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
     */

    function locateAPI(name) {
        var parts,
            obj = window;

        // remove the place holder of the API name
        name = name.replace("$MANAGER_WIDGET/", "");

        parts = name.split("/");
        while (parts.length > 0 && obj) {
            obj = obj[parts.shift()];
        }

        // obj could be the actual API object or undefined
        return obj;
    }

    /**
     * Load a resource.
     * Assuming the resource IDs do not need special ID normalization.
     * @method
     * @param {String} resourceId The resource ID that the plugin should load. This ID MUST be normalized.
     * @param {Function} require A local require function. Will not be used.
     * @param {Function} load A function to call once the value of the resource ID has been determined.
     * @param {Object} [opts] Option
     * @param {Function} [opts.onFailure] failure callback
     * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
     */
    exports.load = function (resourceId, require, load, opts) {
        var loadOption = parseResourceId(resourceId);
        resourceId = loadOption.id;

        //Avoiding running this loading modules in optimized(concat) version
        if (!detection) {
            load({});
            return;
        }

        if (modules[resourceId]) {
            load(modules[resourceId]);
            return;
        }

        var path = resourceId;
        if (resourceId.lastIndexOf(".js") < (resourceId.length - 3)) {
            path = resourceId + ".js";
        }

        // require a *.js, no path resolving should be done
        // expecting nothing from the callback as the native API is not a module but a script with global object(s)
        require([path], function () {
            var apiObject = {};
            //locate the api object when setting true.
            if (loadOption.locateAPI) {
                apiObject = locateAPI(resourceId);
            }
            modules[resourceId] = apiObject;
            load(modules[resourceId]);
        }, opts.onFailure);
    };

    /**
     * Parse the "resource id", get the locateAPI config and the real resource id from it.
     * @method
     * @private
     * @param {String} resourceId The resource id
     * @returns {Object} The parsed object, containing the resource id and the parameters
     * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
     */
    function parseResourceId(resourceId) {
        var tokens = resourceId.split(PARAM_DELIMITER),
            param;

        // no delimiter in the resource id, no more process
        if (tokens.length === 1) {
            return {
                id: resourceId,
                locateAPI: true
            };
        }

        param = parseLoadingOption(tokens[0]);

        return util.extend({
            id: tokens[1]
        }, param);
    }

    /**
     * Parse the loading option.
     * @method
     * @private
     * @param {String} queryString The parameter list in the loader dependency
     * @returns {Object} The parsed object, containing 1 property: locateAPI (Boolean)
     * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
     */
    function parseLoadingOption(queryString) {
        var param = QueryString.parse(queryString);

        param.locateAPI = param.locateAPI === "true";

        return param;
    }


    return exports;
});
/* global curWidget:false,FileSystem:false */
/**
 * To provide the localstorage class based
 *
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * --------- | ---------
 * Key:    | samsung.storage.uniquePrefix
 * Desc    | The prefix in the samsung
 * Type    | String
 * Default  |  {@link xdk-base/device/AbstractStorage#_uniquePrefix}
 * Usage | {@link module:xdk-base/config}
 * ----------------------------------
 *  Attribute | Value
 * --------- | ---------
 * Key:    | samsung.storage.fileName
 * Desc    | The file name of text file
 * Type    | String
 * Default  | "AccedoXDK.txt"
 * Usage | {@link module:xdk-base/config}
 *
 * @class xdk-ext-device-samsung/FileStorage
 * @augments ax/device/AbstractStorage
 */
define("xdk-ext-device-samsung/FileStorage", ["xdk-base/class", "xdk-base/device/AbstractStorage", "xdk-base/config", "xdk-base/console", "xdk-base/util"], function (klass, AbstractStorage, config, console, util) {
    "use strict";
    return klass.create(AbstractStorage, {}, {
        /**
         * To save the data, Only access to the file system to get the data. And then the data will be stored.
         * @private
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        __tempData: null,
        /**
         * To open the samsung new system
         * @private
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        __fileSystemObj: null,
        /**
         * To get the curWidget id which is the app folder and then store the file inside that folder
         * which will be removed when the apps is deleted
         * @private
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        __appId: null,
        /**
         * The file Name which save the data
         * @private
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        __fileName: null,

        init: function () {
            this.__appId = curWidget.id;
            this._uniquePrefix = config.get("samsung.storage.uniquePrefix", this._uniquePrefix);
            this.__fileName = this.__appId + "/" + config.get("samsung.storage.fileName", "AccedoXDK.txt");
            this.__fileSystemObj = new FileSystem();
        },
        /**
         * to set the variable
         * @public
         * @method set
         * @param {String} k keys
         * @param {String} v values
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        set: function (k, v) {
            console.log("this one is using file Storage0");
            //to load the cookies when the cookies is not loaded yet
            if (!this.__tempData) {
                this.__getFile();
            }

            this.__tempData[k] = v;
            this.__setFile();
        },
        /**
         * to get the variable
         * @public
         * @method set
         * @param {String} k keys
         * @return {String} v values
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        get: function (k) {
            //to load the cookies when the cookies is not loaded yet
            if (!this.__tempData) {
                this.__getFile();
            }

            var value;

            if (this.__tempData && this.__tempData[k]) {
                value = this.__tempData[k];

                if (!util.isUndefined(value)) {
                    return value;
                }
            }

            return null;
        },
        /**
         * to unset the variable
         * @public
         * @method unset
         * @param {String} k keys
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        unset: function (k) {
            //to load the cookies when the cookies is not loaded yet
            if (!this.__tempData) {
                this.__getFile();
            }

            if (this.__tempData && !util.isUndefined(this.__tempData[k])) {
                this.__tempData[k] = null;
                delete this.__tempData[k];
                this.__setFile();
            }
        },
        /**
         * Direct overrideing clear as samsung has it"s own Unique Id API
         * @public
         * @method clear
         * @memberof xdk-ext-device-samsung/FileStorage#
         */
        clear: function () {
            this.__tempData = {};
            this.__setFile();
        },
        /**
         * to get the file from the device
         * @private
         * @method __getFile
         * @memberof xdk-base/device/shared/CookiesStorage
         */
        __getFile: function () {
            var jsFileObj, stringResult = "",
                i, l, cookies, cookieString;

            if (this.__fileSystemObj.isValidCommonPath(this.__fileName)) {
                console.debug("[XDK] File found: " + this.__fileName);
                jsFileObj = this.__fileSystemObj.openCommonFile(this.__fileName, "r");
                stringResult += jsFileObj.readLine();
                this.__fileSystemObj.closeCommonFile(jsFileObj);
                cookies = stringResult.split(";");

                for (i = 0, l = cookies.length; i < l; i++) {
                    cookieString = util.strip(cookies[i]);
                    if (util.startsWith(cookieString, this._uniquePrefix + "=")) {
                        cookieString = cookieString.substring((this._uniquePrefix + "=").length);
                        if (cookieString) {
                            try {
                                this.__tempData = util.parse(decodeURIComponent(cookieString));
                                return;
                            } catch (e) {
                                console.warn("[XDK] unable to load the file");
                            }
                        }
                    }
                }
            } else {
                console.debug("no file: " + this.__fileName);
            }
            this.__tempData = {};
        },
        /**
         * to save the string into the file
         * @private
         * @method __setFile
         * @memberof xdk-base/device/shared/CookiesStorage
         */
        __setFile: function () {
            if (!this.__tempData) {
                console.warn("Object is undefined and unable to set into the file");
                return false;
            }

            var days = 365,
                date, expires, dataString, jsFileObj;

            if (!util.isEmpty(this.__tempData)) {
                date = (new Date());
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toGMTString();
            } else {
                expires = "; expires= -1";
            }

            dataString = this._uniquePrefix + "=" + encodeURIComponent(util.stringify(this.__tempData)) + expires + "; path=/";
            console.debug("[XDK] File storage save the String" + dataString);

            if (!this.__fileSystemObj.isValidCommonPath(this.__appId)) {
                console.debug("Going to create common dir: " + this.__appId);
                this.__fileSystemObj.createCommonDir(this.__appId);
            } else {
                console.debug("it has a new dir");
            }

            jsFileObj = this.__fileSystemObj.openCommonFile(this.__fileName, "w");
            jsFileObj.writeLine(dataString);
            this.__fileSystemObj.closeCommonFile(jsFileObj);
        }
    });
});



/**
 * To return the global objects used in the platform
 * @module xdk-ext-device-samsung/globals
 * @property {Object} widgetAPI Widget Object <http://www.samsungdforum.com/Guide/ref00006/common_module_widget_object.html>
 * @property {Object} tvKey an object that defines the TV key code <http://www.samsungdforum.com/Guide/ref00006/common_module_tvkeyvalue_object.html>
 * @property {Object} pluginAPI Plugin Objects <http://www.samsungdforum.com/Guide/ref00006/common_module_plugin_object.html>
 * @property {Object} appCommon AppCommon plugin is for the basic TV functions <http://www.samsungdforum.com/Guide/ref00014/sef_plugin_appcommon.html>
 * @property {Object} NNaviPlugin Samsung Smart TV-specific commands on the DTV platform <http://www.samsungdforum.com/Guide/ref00011/deviceapi_nnavi.html>
 * @property {Object} mwPlugin TVMW plugin handles the functions for basic application <http://www.samsungdforum.com/Guide/ref00014/sef_plugin_tvmw.html>
 * @property {Object} mwPlugin2  deals with basic functions of TV <http://www.samsungdforum.com/Guide/ref00011/deviceapi_window.html>
 * @property {Object} tvPlugin handle basic tv function <http://www.samsungdforum.com/Guide/ref00011/deviceapi_tv.html>
 * @property {Object} networkPlugin controls and gets network-related information <http://www.samsungdforum.com/Guide/ref00011/deviceapi_network.html>
 * @property {Object} taskManagerPlugin  TV inter-task actions <http://www.samsungdforum.com/Guide/ref00011/deviceapi_taskmanager.html>
 * @property {Object} audioPlugin audio-related functions <http://www.samsungdforum.com/Guide/ref00011/deviceapi_audio.html>
 * @property {Object} pluginObject3D handles the TV screen commands <http://www.samsungdforum.com/Guide/ref00011/deviceapi_screen.html>
 * @property {Object} widevinePlugin external widget <http://www.samsungdforum.com/Guide/ref00014/sef_plugin_externalwidgetinterface.html>
 * @property {Object} timePlugin handles the TV time <http://www.samsungdforum.com/Guide/ref00011/deviceapi_time.html>
 * @property {Object} sefPlugin sef plugin <http://www.samsungdforum.com/Guide/ref00014/index.html>
 * @property {Object} infolinkPlayer infolink player plugin <http://www.samsungdforum.com/Guide/ref00011/deviceapi_player.html>
 * @property {Object} webapis web device api <http://www.samsungdforum.com/Guide/ref00008/index.html> Only available on 2012+
 */
define("xdk-ext-device-samsung/globals", ["./loader/nativeAPI!$MANAGER_WIDGET/Common/API/Widget", "./loader/nativeAPI!$MANAGER_WIDGET/Common/API/Plugin", "./loader/nativeAPI!$MANAGER_WIDGET/Common/API/TVKeyValue"], function (Widget, Plugin, TVKeyValue) {
    "use strict";
    var samsungObj, obj;
    samsungObj = document.createElement("div");
    samsungObj.id = "samsungDeviceObject";
    document.body.appendChild(samsungObj);
    /*jshint multistr: true */
    samsungObj.innerHTML = "<object id='pluginNetwork' border=0 classid='clsid:SAMSUNG-INFOLINK-NETWORK'></object>\
    <object id='pluginObjectAudio' border=0 classid='clsid:SAMSUNG-INFOLINK-AUDIO' style='opacity:0.0;background-color:#000000;width:0px;height:0px;'></object>\
    <object id='pluginObjectTVMW' border=0 classid='clsid:SAMSUNG-INFOLINK-TVMW'></object>\
    <object id='pluginObjectNNavi' border=0 classid='clsid:SAMSUNG-INFOLINK-NNAVI'></object>\
    <object id='pluginObjectAppCommon' border=0 classid='clsid:SAMSUNG-INFOLINK-APPCOMMON'></object>\
    <div id='InfolinkContainer' class='playerContainer'><object id='infolinkPlayer' border=0 classid='clsid:SAMSUNG-INFOLINK-PLAYER' style='position:absolute;'></object></div>\
    <object id='pluginObjectTV' border=0 classid='clsid:SAMSUNG-INFOLINK-TV'></object>\
    <object id='pluginObjectExternal' border=0 classid='clsid:SAMSUNG-INFOLINK-EXTERNALWIDGETINTERFACE'></object>\
    <object id='TimePlugin' border=0 classid='clsid:SAMSUNG-INFOLINK-TIME'></object>\
    <object id='pluginObjectWindow' border=0 classid='clsid:SAMSUNG-INFOLINK-WINDOW'></object>\
    <object id='pluginObjectTaskManager' border=0 classid='clsid:SAMSUNG-INFOLINK-TASKMANAGER'></object>\
    <object id='pluginObjectScreen3D' border=0 classid='clsid:SAMSUNG-INFOLINK-SCREEN'></object>\
    <div id='SefPlayerContainer' class='playerContainer'><object id='pluginSef' border=0 classid='clsid:SAMSUNG-INFOLINK-SEF' style='position:fixed;width:0px;height:0px'></object></div>\
    <object id='pluginSefDownload' border=0 classid='clsid:SAMSUNG-INFOLINK-SEF' style='position:absolute;width:0px;height:0px'></object>";

    obj = {
        widgetAPI: new Widget(),
        tvKey: new TVKeyValue(),
        pluginAPI: new Plugin(),
        appCommon: document.getElementById("pluginObjectAppCommon"),
        NNaviPlugin: document.getElementById("pluginObjectNNavi"),
        mwPlugin: document.getElementById("pluginObjectTVMW"),
        mwPlugin2: document.getElementById("pluginObjectWindow"),
        tvPlugin: document.getElementById("pluginObjectTV"),
        networkPlugin: document.getElementById("pluginNetwork"),
        taskManagerPlugin: document.getElementById("pluginObjectTaskManager"),
        audioPlugin: document.getElementById("pluginObjectAudio"),
        pluginObject3D: document.getElementById("pluginObjectScreen3D"),
        widevinePlugin: document.getElementById("pluginObjectExternal"),
        //widevine ID
        timePlugin: document.getElementById("TimePlugin"),
        //TV channel
        sefPlugin: document.getElementById("pluginSef"),
        infolinkPlayer: document.getElementById("infolinkPlayer"),
        webapis: null,
        //download
        download: document.getElementById("pluginSefDownload")
    };
    
    return obj;
});
/**
 * TvKey class to handle the key
 * @class xdk-ext-device-samsung/TvKey
 * @extends ax/device/AbstractTvKey
 */
define("xdk-ext-device-samsung/TvKey", [
    "xdk-base/device/shared/browser/TvKey",
    "xdk-base/class",
    "xdk-base/console",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-ext-device-samsung/globals",
    "xdk-base/device/interface/Id",
    "require"
], function (
    browserTvKey,
    klass,
    console,
    VKey,
    util,
    global,
    IId,
    require) {
    "use strict";
    return klass.create(browserTvKey, {
        /**
         * @name CH_UP
         * @property {String} id Virtual Key ID. "samsung:vkey:chup"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        CH_UP: {
            id: "samsung:vkey:chup"
        },
        /**
         * @name CH_DOWN
         * @property {String} id Virtual Key ID. "samsung:vkey:chdown"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        CH_DOWN: {
            id: "samsung:vkey:chdown"
        },
        /**
         * @name TOOLS
         * @property {String} id Virtual Key ID. "samsung:vkey:tools"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        TOOLS: {
            id: "samsung:vkey:tools"
        },
        /**
         * @name INFO
         * @property {String} id Virtual Key ID. "samsung:vkey:info"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        INFO: {
            id: "samsung:vkey:info"
        },
        /**
         * @name EMODE
         * @property {String} id Virtual Key ID."samsung:vkey:emode"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        EMODE: {
            id: "samsung:vkey:emode"
        },
        /**
         * @name DMA
         * @property {String} id Virtual Key ID. "samsung:vkey:dma"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        DMA: {
            id: "samsung:vkey:dma"
        },
        /**
         * @name PRECH
         * @property {String} id Virtual Key ID."samsung:vkey:prech"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        PRECH: {
            id: "samsung:vkey:prech"
        },
        /**
         * @name FAVCH
         * @property {String} id Virtual Key ID. "samsung:vkey:favch"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        FAVCH: {
            id: "samsung:vkey:favch"
        },
        /**
         * @name CHLIST
         * @property {String} id Virtual Key ID. "samsung:vkey:chlist"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        CHLIST: {
            id: "samsung:vkey:chlist"
        },
        /**
         * @name TTX_MIX
         * @property {String} id Virtual Key ID. "samsung:vkey:ttxmix"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        TTX_MIX: {
            id: "samsung:vkey:ttxmix"
        },
        /**
         * @name GUIDE
         * @property {String} id Virtual Key ID. "samsung:vkey:guide"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        GUIDE: {
            id: "samsung:vkey:guide"
        },
        /**
         * @name SUBTITLE
         * @property {String} id Virtual Key ID.  "samsung:vkey:subtitle"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        SUBTITLE: {
            id: "samsung:vkey:subtitle"
        },
        /**
         * @name ASPECT
         * @property {String} id Virtual Key ID. "samsung:vkey:aspect"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        ASPECT: {
            id: "samsung:vkey:aspect"
        },
        /**
         * @name  DOLBY_SRR
         * @property {String} id Virtual Key ID. "samsung:vkey:dolbysrr"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        DOLBY_SRR: {
            id: "samsung:vkey:dolbysrr"
        },
        /**
         * @name MTS
         * @property {String} id Virtual Key ID. "samsung:vkey:mts"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        MTS: {
            id: "samsung:vkey:mts"
        },
        /**
         * @name WHEELDOWN
         * @property {String} id Virtual Key ID. "samsung:vkey:wheeldown"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        WHEELDOWN: {
            id: "samsung:vkey:wheeldown"
        },
        /**
         * @name WHEELUP
         * @property {String} id Virtual Key ID. "samsung:vkey:wheelup"
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        WHEELUP: {
            id: "samsung:vkey:wheelup"
        }
    }, {
        _keyMapping: null,
        init: function () {
            this._keyMapping = {
                VKey: {}
            };
            this._keyMapping.VKey[global.tvKey.KEY_UP] = VKey.UP; //"up";
            this._keyMapping.VKey[global.tvKey.KEY_DOWN] = VKey.DOWN; //"down";
            this._keyMapping.VKey[global.tvKey.KEY_LEFT] = VKey.LEFT; //"left";
            this._keyMapping.VKey[global.tvKey.KEY_RIGHT] = VKey.RIGHT; //"right";
            this._keyMapping.VKey[global.tvKey.KEY_ENTER] = VKey.OK; //"ok";
            this._keyMapping.VKey[global.tvKey.KEY_RED] = VKey.RED; //"red";
            this._keyMapping.VKey[global.tvKey.KEY_GREEN] = VKey.GREEN; //"green";
            this._keyMapping.VKey[global.tvKey.KEY_YELLOW] = VKey.YELLOW; //"yellow";
            this._keyMapping.VKey[global.tvKey.KEY_BLUE] = VKey.BLUE; //"blue";
            this._keyMapping.VKey[global.tvKey.KEY_RETURN] = VKey.BACK; //"back";
            this._keyMapping.VKey[global.tvKey.KEY_EXIT] = VKey.EXIT; //"exit";
            this._keyMapping.VKey[global.tvKey.KEY_PLAY] = VKey.PLAY; //"play";
            this._keyMapping.VKey[global.tvKey.KEY_PAUSE] = VKey.PAUSE; //"pause";
            this._keyMapping.VKey[global.tvKey.KEY_STOP] = VKey.STOP; //"stop";
            this._keyMapping.VKey[global.tvKey.KEY_FF] = VKey.FF; //"ff";
            this._keyMapping.VKey[global.tvKey.KEY_RW] = VKey.RW; //"rw";

            this._keyMapping.VKey[global.tvKey.KEY_FF_] = VKey.NEXT; //"next";
            this._keyMapping.VKey[global.tvKey.KEY_RW_] = VKey.PREV; //"prev";
            this._keyMapping.VKey[global.tvKey.KEY_REWIND_] = VKey.PREV; //"prev";

            this._keyMapping.VKey[global.tvKey.KEY_0] = VKey.KEY_0; //"0";
            this._keyMapping.VKey[global.tvKey.KEY_1] = VKey.KEY_1; //"1";
            this._keyMapping.VKey[global.tvKey.KEY_2] = VKey.KEY_2; //"2";
            this._keyMapping.VKey[global.tvKey.KEY_3] = VKey.KEY_3; //"3";
            this._keyMapping.VKey[global.tvKey.KEY_4] = VKey.KEY_4; //"4";
            this._keyMapping.VKey[global.tvKey.KEY_5] = VKey.KEY_5; //"5";
            this._keyMapping.VKey[global.tvKey.KEY_6] = VKey.KEY_6; //"6";
            this._keyMapping.VKey[global.tvKey.KEY_7] = VKey.KEY_7; //"7";
            this._keyMapping.VKey[global.tvKey.KEY_8] = VKey.KEY_8; //"8";
            this._keyMapping.VKey[global.tvKey.KEY_9] = VKey.KEY_9; //"9";
            this._keyMapping.VKey[global.tvKey.KEY_CH_UP] = this.constructor.CH_UP; //channel up
            this._keyMapping.VKey[global.tvKey.KEY_CH_DOWN] = this.constructor.CH_DOWN; //channel down

            // Key support for TV panel
            this._keyMapping.VKey[global.tvKey.KEY_PANEL_CH_UP] = this._keyMapping.VKey[global.tvKey.KEY_UP]; // same as KEY_UP
            this._keyMapping.VKey[global.tvKey.KEY_PANEL_CH_DOWN] = this._keyMapping.VKey[global.tvKey.KEY_DOWN]; // same as KEY_DOWN
            this._keyMapping.VKey[global.tvKey.KEY_PANEL_VOL_UP] = this._keyMapping.VKey[global.tvKey.KEY_RIGHT]; // same as KEY_RIGHT
            this._keyMapping.VKey[global.tvKey.KEY_PANEL_VOL_DOWN] = this._keyMapping.VKey[global.tvKey.KEY_LEFT]; // same as KEY_LEFT
            this._keyMapping.VKey[global.tvKey.KEY_PANEL_SOURCE] = this._keyMapping.VKey[global.tvKey.KEY_ENTER]; // same as KEY_OK
            this._keyMapping.VKey[global.tvKey.KEY_PANEL_MENU] = this._keyMapping.VKey[global.tvKey.KEY_RETURN]; // same as KEY_BACK

            //According to http://www.samsungdforum.com/Guide/art00046/index.html, we will register full widget key and those keys are able to be captured.
            //Some keys are excluded, KEY_VOL_UP, KEY_VOL_DOWN, KEY_MUTE, KEY_SOURCE, KEY_MENU, KEY_POWER, KEY_INFOLINK, KEY_CONTENT, KEY_WLINK are not registered 
            //since it should be preserved as default behaviour.
            this._keyMapping.VKey[global.tvKey.KEY_TOOLS] = this.constructor.TOOLS;
            this._keyMapping.VKey[global.tvKey.KEY_INFO] = this.constructor.INFO;
            this._keyMapping.VKey[global.tvKey.KEY_EMODE] = this.constructor.EMODE;
            this._keyMapping.VKey[global.tvKey.KEY_DMA] = this.constructor.DMA;
            this._keyMapping.VKey[global.tvKey.KEY_PRECH] = this.constructor.PRECH;
            this._keyMapping.VKey[global.tvKey.KEY_FAVCH] = this.constructor.FAVCH;
            this._keyMapping.VKey[global.tvKey.KEY_CHLIST] = this.constructor.CHLIST;
            this._keyMapping.VKey[global.tvKey.KEY_TTX_MIX] = this.constructor.TTX_MIX;
            this._keyMapping.VKey[global.tvKey.KEY_GUIDE] = this.constructor.GUIDE;
            this._keyMapping.VKey[global.tvKey.KEY_SUBTITLE] = this.constructor.SUBTITLE;
            this._keyMapping.VKey[global.tvKey.KEY_ASPECT] = this.constructor.ASPECT;
            this._keyMapping.VKey[global.tvKey.KEY_DOLBY_SRR] = this.constructor.DOLBY_SRR;
            this._keyMapping.VKey[global.tvKey.KEY_MTS] = this.constructor.MTS;
            this._keyMapping.VKey[global.tvKey.KEY_WHEELDOWN] = this.constructor.WHEEL_DOWN;
            this._keyMapping.VKey[global.tvKey.KEY_WHEELUP] = this.constructor.WHEEL_UP;

            //XDK-2075 Although it is not included in the global tvkey, it is the same for various TV.(it will dispatch when long press ff/rw)
            this._keyMapping.VKey[1080] = VKey.PREV;
            this._keyMapping.VKey[1078] = VKey.NEXT;

            this.initKeyMapping(this._keyMapping);
        },
        getVirtualKey: function (evt) {
            if (this._keyMapping.VKey[evt.keyCode]) {
                switch (evt.keyCode) {
                case global.tvKey.KEY_POWER:
                case global.tvKey.KEY_EXIT:
                case global.tvKey.KEY_PANEL_VOL_DOWN:
                case global.tvKey.KEY_PANEL_VOL_UP:
                case global.tvKey.KEY_PANEL_CH_UP:
                case global.tvKey.KEY_PANEL_CH_DOWN:
                case global.tvKey.KEY_PANEL_MENU:
                case global.tvKey.KEY_PANEL_SOURCE:
                case global.tvKey.KEY_RETURN:
                    global.widgetAPI.blockNavigation(evt);
                    break;
                }
            }
            return this._super(evt);
        },
        /**
         * To handle the initial key handling
         * @protected
         * @method initKeyHandling
         * @memberof xdk-ext-device-samsung/TvKey#
         */
        initKeyHandling: function () {
            var device = require("xdk-base/device"),
                year = device.id.getFirmwareYear(),
                type = device.id.getHardwareType();

            //only handle keydown in ss
            document.onkeydown = util.bind(function (evt) {
                return this.keyHandler(evt);
            }, this);

            // hack for 2011 device"s smart-hub key exits to TV channel
            if (year === 2011) {
                // for 2011 device, doing below assignment will actually add another event listener
                document.onkeydown = function (evt) {
                    console.log("samsung on key down");
                    // 2011's smart-hub key is bugged, it exits to channel, so need to handle ourselves
                    if (evt.keyCode === global.tvKey.KEY_INFOLINK || evt.keyCode === global.tvKey.KEY_CONTENT) {
                        console.debug("[XDK]Smart-hub key receiced! Exiting application...");
                        device.system.exit({
                            toTV: false
                        });
                        evt.preventDefault();
                        return false;
                    }
                    return true;
                };
            }

            //Ensure those keys are registered and unregistered
            util.delay(1).then(function () {
                // bring global variable into local scope for performance
                var ac = global.appCommon;

                //we will use samsung registFullWidgetKey to register all the common keys.
                // commons keys other that will be registered here.
                ac.RegisterKey(global.tvKey.KEY_PANEL_CH_UP);
                ac.RegisterKey(global.tvKey.KEY_PANEL_CH_DOWN);
                ac.RegisterKey(global.tvKey.KEY_PANEL_VOL_UP);
                ac.RegisterKey(global.tvKey.KEY_PANEL_VOL_DOWN);
                ac.RegisterKey(global.tvKey.KEY_PANEL_ENTER);
                ac.RegisterKey(global.tvKey.KEY_PANEL_SOURCE);
                ac.RegisterKey(global.tvKey.KEY_PANEL_MENU);
                ac.RegisterKey(global.tvKey.KEY_EXIT);

                // 2013
                global.pluginAPI.registKey(global.tvKey.KEY_TOOLS);

                //register the channel up and down keys, which doesn't work on samsung 2012
                //and some 2013 TV, so register for all devices

                ac.RegisterKey(global.tvKey.KEY_CH_DOWN);
                ac.RegisterKey(global.tvKey.KEY_CH_UP);

                if (year <= 2012) {
                    if (type === IId.HARDWARE_TYPE.TV && year <= 2010) {
                        ac.UnregisterKey(global.tvKey.KEY_WLINK); // Smart-hub key another version
                    } else {
                        ac.RegisterKey(global.tvKey.KEY_WLINK); // Smart-hub key another version
                    }
                    ac.RegisterKey(global.tvKey.KEY_CONTENT); // Smart-hub key
                    ac.RegisterKey(global.tvKey.KEY_INFOLINK); // Smart-hub key another version
                } else {
                    ac.UnregisterKey(global.tvKey.KEY_INFOLINK);
                    ac.UnregisterKey(global.tvKey.KEY_CONTENT);
                    //ac.UnregisterKey(global.tvKey.KEY_WLINK); //2013 will unregister tools key
                }

                //To Ensure the following keys are not registered to use the default behaviour.
                ac.UnregisterKey(global.tvKey.KEY_VOL_UP);
                ac.UnregisterKey(global.tvKey.KEY_VOL_DOWN);
                ac.UnregisterKey(global.tvKey.KEY_MUTE);
                ac.UnregisterKey(global.tvKey.KEY_POWER);
                ac.UnregisterKey(global.tvKey.KEY_SOURCE);
                ac.UnregisterKey(global.tvKey.KEY_MENU);
            }).done();
        }
    });
});
/**
 * Id class to handle the device information like firmware version
 * @class xdk-ext-device-samsung/Id
 * @extends ax/device/AbstractId
 */
define("xdk-ext-device-samsung/Id", [
    "xdk-base/class",
    "xdk-base/device/AbstractId",
    "xdk-base/device/interface/Id",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-ext-device-samsung/globals",
    "require"
], function (
    klass,
    abstrId,
    IId,
    util,
    console,
    globals,
    require) {
    "use strict";
    return klass.create(abstrId, [IId], {}, {
        /**
         * To store the mac address
         * @private
         * @memberof xdk-ext-device-samsung/Id#
         */
        __mac: null,
        /**
         * To store the firmware
         * @private
         * @memberof xdk-ext-device-samsung/Id#
         */
        __firmware: null,
        /**
         * To store widevine SDI ID
         * @private
         * @memberof xdk-ext-device-samsung/Id#
         */
        __widevineSDIID: null,
        /**
         * To save widevine ESN
         * @private
         * @memberof xdk-ext-device-samsung/Id#
         */
        __widevineESN: null,
        /**
         * To save device type
         * @private
         * @deprecated replaced with __hardwareType
         * @memberof xdk-ext-device-samsung/Id#
         */
        __deviceType: null,
        /**
         * To save hardware type
         * @private
         * @memberof xdk-ext-device-samsung/Id#
         */
        __hardwareType: null,
        init: function () {
            require(["xdk-ext-device-samsung/PrivilegedAPI"], util.bind(function (api) {
                //default value
                this.__widevineESN = "SSBDPE000793631B";
                this.__widevineSDIID = api._getSDIID();

                var firmwareStr = parseInt(this.getFirmware().substr(this.getFirmware().lastIndexOf("-") + 1), 10);
                if (this.getFirmwareYear() > 2010 || (firmwareStr >= 1003 && this.getHardwareType() !== IId.HARDWARE_TYPE.TV)) {
                    this.__widevineESN = api._getESN();
                } else {
                    console.debug("[XDK] no value widevineESN fine. Mac address would be used");
                    this.__widevineESN = this.getMac();
                }

                if (!util.isString(this.__widevineESN) || this.__widevineESN.length > 16) {
                    this.__widevineESN = this.getMac();
                }


                console.debug("[XDK] widevine SDIID " + this.__widevineSDIID);
                console.debug("[XDK] widevine ESN " + this.__widevineESN);
            }, this), function (err) {
                console.error("[XDK] Unable to load the privillegedAPI file" + err);
            });
        },
        /**
         * To return the device type as "samsung"
         * @method getDeviceType
         * @public
         * @deprecated replaced with getHardwareType
         * @return {String} type of the device e.g Bluray, TV
         * @memberof xdk-ext-device-samsung/Id#
         */
        getDeviceType: function () {

            if (this.__deviceType) {
                return this.__deviceType;
            }

            var deviceType = "";

            console.debug("[XDK] get the Device Type" + window.location);
            if (window.location.search.indexOf("product=") === -1) {
                deviceType = "emulator";
            } else {
                try {
                    var str = window.location.search[window.location.search.indexOf("product=") + 8],
                        productType;
                    switch (str) {
                    case "2":
                        try {
                            productType = globals.tvPlugin.GetBDProductType();
                            /*
                                 0 - PL_TV_BDPRODUCT_TYPE_UNKNOWN
                                 1 - PL_TV_BDPRODUCT_TYPE_SINGLE
                                 2 - PL_TV_BDPRODUCT_TYPE_HTS
                                 3 - PL_TV_BDPRODUCT_TYPE_HDD
                                 */
                            if (productType === 2) {
                                deviceType = "Home Theatre";
                            } else {
                                deviceType = "Bluray";
                            }
                        } catch (err) {
                            console.warn("Unable to get the product type error: " + err);
                            deviceType = "Bluray"; //if error, regard the device as bd
                        }
                        break;
                    case "1":
                        deviceType = "Monitor";
                        break;
                    default:
                        deviceType = "TV";
                        break;
                    }
                } catch (e) {
                    console.warn("Unable to get the product type error: " + e);
                    return false;
                }
            }

            this.__deviceType = deviceType;
            return this.__deviceType;
        },
        /**
         * To return the hardware type
         * @method getHardwareType
         * @public
         * @return {ax/device/interface/Id.HARDWARE_TYPE} type of the hardware {@link xdk-base/device/interface/Id.HARDWARE_TYPE.BD} or
          {@link xdk-base/device/interface/Id.HARDWARE_TYPE.HOME_THEATRE} or 
          {@link xdk-base/device/interface/Id.HARDWARE_TYPE.TV} or 
          {@link xdk-base/device/interface/Id.HARDWARE_TYPE.MONITOR} or 
          {@link xdk-base/device/interface/Id.HARDWARE_TYPE.EMULATOR}
         * @memberof xdk-ext-device-samsung/Id#
         */
        getHardwareType: function () {

            if (this.__hardwareType) {
                return this.__hardwareType;
            }

            var hardwareType = "";

            console.debug("[XDK] get the Device Type" + window.location);
            if (window.location.search.indexOf("product=") === -1) {
                hardwareType = IId.HARDWARE_TYPE.EMULATOR;
            } else {
                try {
                    var str = window.location.search[window.location.search.indexOf("product=") + 8],
                        productType;
                    switch (str) {
                    case "2":
                        try {
                            productType = globals.tvPlugin.GetBDProductType();
                            /*
                                 0 - PL_TV_BDPRODUCT_TYPE_UNKNOWN
                                 1 - PL_TV_BDPRODUCT_TYPE_SINGLE
                                 2 - PL_TV_BDPRODUCT_TYPE_HTS
                                 3 - PL_TV_BDPRODUCT_TYPE_HDD
                                 */
                            if (productType === 2) {
                                hardwareType = IId.HARDWARE_TYPE.HOME_THEATRE;
                            } else {
                                hardwareType = IId.HARDWARE_TYPE.BD;
                            }
                        } catch (err) {
                            console.warn("Unable to get the product type error: " + err);
                            hardwareType = IId.HARDWARE_TYPE.BD; //if error, regard the device as bd
                        }
                        break;
                    case "1":
                        hardwareType = IId.HARDWARE_TYPE.MONITOR;
                        break;
                    default:
                        hardwareType = IId.HARDWARE_TYPE.TV;
                        break;
                    }
                } catch (e) {
                    console.warn("Unable to get the product type error: " + e);
                    return false;
                }
            }

            this.__hardwareType = hardwareType;

            return this.__hardwareType;
        },
        /**
         * return the mac address
         * @method getMac
         * @return {String} mac address
         * @memberof xdk-ext-device-samsung/Id#
         * @public
         */
        getMac: function () {
            if (this.__mac) {
                return this.__mac;
            }

            //no mac address
            if (window.location.toString().indexOf("product=") === -1) {
                return null;
            } else {
                globals.networkPlugin.CreatePlugin();
                var type = globals.networkPlugin.GetActiveType();
                //1 if active interface is WIRED,
                //0 if active interface is WIRELESS,
                //-1 if there is no active connection
                if (type > -1) {
                    this.__mac = globals.networkPlugin.GetMAC(type);
                    return this.__mac;
                }
            }
            return null;
        },
        /**
         * To get the firmware version
         * @method getFirmware
         * @public
         * @return {String} the firmware of the devices
         * @memberof xdk-ext-device-samsung/Id#
         */
        getFirmware: function () {
            if (this.__firmware) {
                return this.__firmware;
            }
            var firmwareStr;
            try {
                firmwareStr = globals.NNaviPlugin.GetFirmware();
                firmwareStr = util.strip(firmwareStr);
            } catch (e) {
                console.warn("Unable to get the firmware error" + e);
            }

            if (!util.isUndefined(firmwareStr) && firmwareStr.length > 0) {
                this.__firmware = firmwareStr;
            } else {
                this.__firmware = "dummyFirmware";
            }
            return this.__firmware;
        },
        /**
         * return the firmware year
         * @method getFirmwareYear
         * @returns {Number|Boolean} the firmware year, otherwise it will return false
         * @memberof xdk-ext-device-samsung/Id#
         * @public
         */
        getFirmwareYear: function () {
            var str = this.getFirmware(),
                year;

            if (!util.isUndefined(str)) {
                year = parseInt(str.substr(10, 4), 10);
                return isNaN(year) ? 0 : year;
            }
            return false;
        },
        /**
         * To get the unique ID. If no unique id.if will generate a UUID by XDK
         * @method getUniqueID
         * @public
         * @returns {String} the the duid from the samsung, otherwise it will return the uuid
         * @memberof xdk-ext-device-samsung/Id#
         */
        getUniqueID: function () {

            if (this.getHardwareType() === IId.HARDWARE_TYPE.EMULATOR) {
                return "dummyUniqueId";
            }

            var mac = this.getMac();
            console.debug("[XDK] get Mac" + mac);
            try {
                return globals.NNaviPlugin.GetDUID(mac);
            } catch (e) {
                console.debug("[XDK] fail to get DUID from the device and use UUID");
                return this._super();
            }
        },
        /**
         * To get the model of the device. If no related information. "dummySamsungmodel" will be returned
         * @method getModel
         * @public
         * @returns {String} the model numebr
         * @memberof xdk-ext-device-samsung/Id#
         */
        getModel: function () {
            var model = globals.tvPlugin.GetProductCode(0);
            if (model) {
                return model;
            }
            return "dummySamsungmodel";
        },
        /**
         * To get IP address
         * @method getIP
         * @public
         * @return {String} the IP address
         * @memberof xdk-ext-device-samsung/Id#
         */
        getIP: function () {
            if (this.getFirmwareYear() > 2010) {
                var ip = globals.networkPlugin.GetHostAddr();
                if (ip) {
                    return ip;
                }
            } else {
                console.warn("[XDK] IP function is not supported in 2010 devices");
            }
            return "0.0.0.0";
        },
        /**
         * To get the widevine SDI ID
         * @method getWidevineSDIID
         * @public
         * @return {String} the widevine sdi id
         * @memberof xdk-ext-device-samsung/Id#
         */
        getWidevineSDIID: function () {
            return this.__widevineSDIID;
        },
        /**
         * To get the widevine ESN
         * @method getWidevineESN
         * @public
         * @return {String} the widevine ESN
         * @memberof xdk-ext-device-samsung/Id#
         */
        getWidevineESN: function () {
            return this.__widevineESN;
        }
    });
});
/**
 * System class to handle the system related functionality.
 *
 * System also provide a internet status checking fallback handling to all platforms. Using device.internet-poll.url config.
 *
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * ---------  | ---------
 * Key        | device.ajax-network-check.url
 * Type       | String
 * Desc       | The url to check internet status by ajax call.  Null disables internet checking
 * Default    | null
 * Usage      | {@link module:xdk-base/config}
 * --------------------------
 *  Attribute | Value
 * ---------  | ---------
 * Key        | device.ajax-network-check.timeout
 * Type       | Number
 * Desc       | Connection timeout in second
 * Default    | 10
 * Usage      | {@link module:xdk-base/config}
 *  -----------------------------
 * Attribute | Value
 * --------- | ---------
 * Key       | device.ajax-network-check.consec-failure-threshold
 * Type      | Number
 * Desc      |  How many polling failures to consider the internet is disconnected.
 * Default   | device.connection-poller.consec-failure-threshold
 * Usage     | {@link module:xdk-base/config}
 * --------------------------
 * Attribute | Value
 * --------- | ---------
 * Key       | device.ajax-network-check.interval
 * Type      | Number
 * Desc      | Polling interval in second
 * Default   | device.connection-poller.interval
 * Usage     | {@link module:xdk-base/config}
 *
 * @class xdk-base/device/AbstractSystem
 * @augments ax/device/interface/System
 * @fires ax/device/interface/System.EVT_NETWORK_STATUS_CHANGED
 *
 */
define("xdk-base/device/AbstractSystem", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/device/shared/ConnectionPoller",
    "xdk-base/console",
    "xdk-base/core",
    "xdk-base/ajax",
    "xdk-base/device/interface/System",
    "xdk-base/EventDispatcher",
    "xdk-base/promise"
], function (
    klass,
    util,
    config,
    ConnectionPoller,
    console,
    core,
    ajax,
    ISystem,
    EventDispatcher,
    promise
) {
    "use strict";
    return klass.createAbstract(EventDispatcher, [ISystem], {}, {
        /**
         * The internet connection poller used in the abstract system
         * @private
         * @name _internetPoller
         * @type {ax/device/shared/ConnectionPoller}
         * @memberof xdk-base/device/AbstractSystem#
         */
        _internetPoller: null,
        /**
         * The current network status
         * @private
         * @name __networkStatus
         * @type {Boolean}
         * @memberof xdk-base/device/AbstractSystem#
         */
        __networkStatus: true,
        init: function () {
            this._super();
            this._postInit();
        },
        /**
         * Setting the screen saver On/Off
         * @name setScreenSaver
         * @method
         * @param {Boolean} flag True to turn on and off to turn off.
         * @return {Boolean}  Return true if success or no state change. Return false if system API not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        /*jshint unused:false */
        setScreenSaver: function (flag) {
            return false;
        },
        /*jshint unused:true */
        /**
         * Setting the system to mute/unmute.
         * @name setSystemMute
         * @method
         * @param {Boolean} flag True to mute and false to unmute
         * @return {Boolean}  Return true if
         * success or no state change. Return false if system API not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        /*jshint unused:false */
        setSystemMute: function (flag) {
            return false;
        },
        /*jshint unused:true */
        /**
         * Power off the system
         * @name powerOff
         * @method
         * @return {Boolean} Return false if system API not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        powerOff: function () {
            return false;
        },
        /**
         * Exit the application
         * @name exit
         * @method
         * @param {Object} [obj] To set the information when exit
         * @param {Boolean} [obj.toTV] True when exit back to TV source, false will go back to smartHub/App Store page.Default is true
         * @return {Boolean} Return false if system API not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        exit: function () {
            return false;
        },
        /**
         * Determine whether device support mouse
         * @name hasMouse
         * @method
         * @return {Boolean} Return true if the platform has pointer devices/emulation support.Return false if not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        hasMouse: function () {
            return false;
        },
        /**
         * Determine whether device support hardware keyboard
         * @name hasFixedKeyboard
         * @method
         * @return {Boolean} Return true if the platform has hardware keyboard support..Return false if not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        hasFixedKeyboard: function () {
            return false;
        },
        /**
         * @typedef Resolution
         * @type {Object}
         * @property {Number} width in pixels
         * @property {Number} height in pixels
         * @memberof xdk-base/device/AbstractSystem
         */
        /**
         * Get the getDisplayResolution
         * @name getDisplayResolution
         * @method
         * @return {ax/device/AbstractSystem.Resolution} Return the display resolution from of the platform.Return {width:0,height:0} if not available.
         * @memberof xdk-base/device/AbstractSystem#
         */
        getDisplayResolution: function () {
            return {
                width: 0,
                height: 0
            };
        },
        /**
         * Whether SSL is supported in the device
         * @name suportSSL
         * @method
         * @return {Boolean} Return true if the platform support SSL certificate verification.
         * @memberof xdk-base/device/AbstractSystem#
         */
        supportSSL: function () {
            return false;
        },

        /**
         * Whether same-origin policy exists in the device (i.e. cross domain ajax is not allowed). Modern browsers should have this policy.
         * @name hasSOP
         * @method
         * @return {Boolean} Return true if cross domain ajax is not allowed natively. Proxy / Allow-Origin header setup may be needed.
         * @memberof xdk-base/device/AbstractSystem#
         */
        hasSOP: function () {
            return true;
        },
        /**
         * Get the current network status. If there is connection poller which is polling, it will get the status from connection poller.
         * Otherwise, it will try to do a ajax call to determine the current status if there is internet check url.
         * If none of the above case, it will reject the promise (is connected to network)
         * @method getNetworkStatus
         * @return {Promise.<Boolean>}  Return true if it is connected to internet.
         * @throws {Promise.<Undefined>}  Reject promise if no method to determine the network status.
         * @public
         * @memberof xdk-base/device/AbstractSystem#
         */
        getNetworkStatus: function () {
            var internetCheckUrl;

            //if there is internet poller and polling then no need to use an ajax to test. Directly obtain the result from the connection poller.
            if (this._internetPoller && this._internetPoller.isPolling()) {
                return promise.resolve(this._internetPoller.isConnected());
            }

            //do the ajax call to examine the network connection when not polling
            internetCheckUrl = config.get("device.ajax-network-check.url", null);

            if (internetCheckUrl) {

                return ajax.request(internetCheckUrl, {
                    timeOut: config.get("device.ajax-network-check.timeout", 10)
                }).then(
                    function () {
                        console.info("[System]Successfully sent the ajax via " + internetCheckUrl);
                        return true;
                    },
                    function () {
                        console.info("[System]Unsuccessfully sent the ajax via " + internetCheckUrl);
                        return false;
                    }
                );
            }

            return promise.reject();
        },
        /**
         * set the current network status checking using the ajax network checking method
         * @method _postInit
         * @protected
         * @memberof xdk-base/device/AbstractSystem#
         */
        _postInit: function () {
            var internetCheckUrl = config.get("device.ajax-network-check.url", null),
                checkStatus, onStatusChange;

            if (!internetCheckUrl) {
                return;
            }

            //the checking method
            checkStatus = util.bind(function (__checkStatusDoneCb) {

                if (!internetCheckUrl) {
                    throw core.createException("PollingUrlNotSet", "You must set polling URL using setPollingUrl().");
                }
                ajax.request(internetCheckUrl, {
                    timeOut: config.get("device.ajax-network-check.timeout", 10)
                }).then(
                    function () {
                        console.info("[System]Successfully sent the ajax via " + internetCheckUrl);
                        __checkStatusDoneCb(true);
                    },
                    function () {
                        console.info("[System]Unsuccessfully sent the ajax via " + internetCheckUrl);
                        __checkStatusDoneCb(false);
                    }
                ).done();
            }, this);

            //the onStatusChange
            onStatusChange = util.bind(function (status) {
                this.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, status);
            }, this);

            //start the poller, set check method and onStatusChange
            this._internetPoller = new ConnectionPoller(checkStatus, onStatusChange, {
                consecFailureThreshold: config.get("device.ajax-network-check.consec-failure-threshold"),
                pollingInterval: config.get("device.ajax-network-check.interval")
            });

        },
        /**
         * Overrides parent method to start the polling on add event listener
         * @method addEventListener
         * @param {xdk-ax/evt/type|String} type event type
         * @param {Function} handler event listener function
         * @param {Boolean} [once] set to true if listener will be called only once
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @public
         * @memberof xdk-base/device/AbstractSystem#
         */
        addEventListener: function (type, handler, once) {
            var ret = this._super(type, handler, once);

            if (this._internetPoller && type === ISystem.EVT_NETWORK_STATUS_CHANGED) {
                //start the polling when adding the event listener
                this._internetPoller.startPolling();
            }

            return ret;
        },
        /**
         * Overrides parent method to remove the polling on event listener remove
         * @method removeEventListener
         * @param {xdk-ax/evt/type|String} type Event type
         * @param {Function} [handler] event listener function.  If not provided, all listeners will be removed for the specific type.
         * @returns {ax/EventDispatcher} current event dispatcher, for easier chaining
         * @public
         * @memberof xdk-base/device/AbstractSystem#
         */
        removeEventListener: function (type, handler) {
            if (this._internetPoller && type === ISystem.EVT_NETWORK_STATUS_CHANGED) {
                //stop the polling when remove the event listener
                this._internetPoller.stopPolling();
            }

            return this._super(type, handler);
        },
        /**
         * Dummy function to redraw the element
         * @param {HTMLElement} [element=document.body] the target element. Default will be document.body
         * @public
         * @memberof xdk-base/device/AbstractSystem#
         */
        /*jshint unused:false*/
        redraw: function (element) {
            //dummy function for those with no redraw
        }
    });
});
/**
 * System class to handle the system api and connection checking
 *
 * @class xdk-ext-device-samsung/System
 * @augments ax/device/AbstractSystem
 */
define("xdk-ext-device-samsung/System", [
    "xdk-base/class",
    "xdk-base/device/AbstractSystem",
    "xdk-base/device/shared/ConnectionPoller",
    "xdk-ext-device-samsung/globals",
    "xdk-base/console",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/device/interface/System",
    "require",
    "xdk-base/config"
], function (
    klass,
    abstrSystem,
    ConnectionPoller,
    global,
    console,
    util,
    promise,
    ISystem,
    require,
    config
) {
    "use strict";

    return klass.create(abstrSystem, {}, {
        /**
         * To save the status of the screen saver
         * @private
         * @name __screenSaverOn
         * @memberof xdk-ext-device-samsung/System#
         */
        __screenSaverOn: true,
        /**
         *To check if it exiting to smart hub or tv source. If it is exiting to smart hub,it won't set TVsource to fullscreen
         * @private
         * @name __exitingToSmartHub
         * @memberof xdk-ext-device-samsung/System#
         */
        __exitingToSmartHub: false,
        /**
         * To handle the exit issue
         * @private
         * @name __handleExitIssue
         * @memberof xdk-ext-device-samsung/System#
         */
        __handleExitIssue: function (callback) {

            if (!callback) {
                callback = function () {
                    global.widgetAPI.sendReturnEvent();
                };
            }

            var okToExit = true;
            // var device = require("xdk-base/device");
            //handle video player, make sure it is deinited
            //@todo
            /*
             if (!device.video.deinit()) {
             console.debug("[XDK] mediaPlayer not yet deinited");
             okToExit = false;
             }*/

            if (okToExit) {
                console.debug("[XDK] exit callback");
                util.delay(1).then(callback).done(); //Ho: allow time for it to deinit...
            } else {
                console.debug("[XDK] >>> not all exit issue get handle, waiting...");
                util.delay(1).then(util.bind(this.__handleExitIssue, this, callback)).done();
            }

        },
        /**
         * To set the screen saver
         * @public
         * @method setScreenSaver
         * @param {Boolean} turnOn True if turn on the screen saver, false when turn off.
         * @memberof xdk-ext-device-samsung/System#
         */
        setScreenSaver: function (turnOn) {
            if (this.__screenSaverOn !== turnOn) {
                if (turnOn) {
                    console.debug("[XDK] >> Turn On Screen Saver");
                    global.pluginAPI.setOnScreenSaver();
                } else {
                    console.debug("[XDK] >> Turn Off Screen Saver");
                    global.pluginAPI.setOffScreenSaver();
                }
                this.__screenSaverOn = turnOn;
            } else {
                console.debug("[XDK] >> Screensaver status unchanged as " + (this.__screenSaverOn ? "ON" : "OFF"));
            }
        },
        /**
         * To set the system mute
         * @public
         * @method setSystemMute
         * @param {Boolean} turnOn True if turn on the mute, false when turn off.
         * @memberof xdk-ext-device-samsung/System#
         */
        setSystemMute: function (turnOn) {
            if (global.audioPlugin.GetSystemMute() !== turnOn) {
                //Mute
                if (turnOn) {
                    global.audioPlugin.SetSystemMute(1);
                    console.debug("[XDK] >> Mute the TV");
                } else {
                    global.audioPlugin.SetSystemMute(0);
                    console.debug("[XDK] >> UnMute the TV");
                }
            } else {
                console.debug("[XDK] >> Screensaver status unchanged as " + (this.__screenSaverOn ? "ON" : "OFF"));
            }
        },
        /**
         * To power off the device
         * @public
         * @method powerOff
         * @memberof xdk-ext-device-samsung/System#
         */
        powerOff: function () {
            this.__handleExitIssue(function () {
                var device = require("xdk-base/device"),
                    key = global.tvKey.KEY_POWER;
                if (device && device.id && device.id.getFirmwareYear() === 2014) {
                    //XDK-3168 fail to use the KEY_POWER to power off on 2014, use the PANEL_POWER instead of
                    key = global.tvKey.KEY_PANEL_POWER;
                }
                // turn off the tv
                console.debug("[XDK] >> TURN OFF TV tvKey.KEY_POWER: " + key);
                global.appCommon.SendKeyToTVViewer(key);
            });
        },
        /**
         * To exit
         * @public
         * @param {Boolean} [param.toTV] Set to true if explicitly return to tv channel, false will return to where the app is launched from. Default: true
         * @method exit
         * @memberof xdk-ext-device-samsung/System#
         */
        exit: function (param) {
            var toTV = true;
            if (param && typeof param.toTV === "boolean") {
                toTV = param.toTV;
            }

            this.__handleExitIssue(util.bind(function () {
                if (!toTV) {
                    this.__exitingToSmartHub = true;
                    console.debug(">> exit to where the app is launched from");
                    //only press smarthub btn will set the TV source to small screen
                    global.widgetAPI.sendReturnEvent();
                } else {
                    console.debug(">> exit to TV and channel");
                    global.widgetAPI.sendExitEvent();
                }
            }, this));
        },
        /**
         * Has mouse on samsung when the firmware year is larger than 2011. Some usb keyboard will have a mousepad or use usb.
         * @public
         * @method hasMouse
         * @memberof xdk-ext-device-samsung/System#
         */
        hasMouse: function () {
            var device = require("xdk-base/device");
            if (device && device.id) {
                if (device.id.getFirmwareYear() > 2011) {
                    return true;
                }
            }
            return false;
        },
        /**
         * To get the display resolution
         * @public
         * @method getDisplayResolution
         * @return {Object} object {width:1280,height:720}
         * @memberof xdk-ext-device-samsung/System#
         */
        getDisplayResolution: function () {

            var innerWidth = window.innerWidth !== null ? window.innerWidth : document.body !== null ? document.body.clientWidth : null;


            if (innerWidth < 1270) {
                return {
                    width: 960,
                    height: 540
                };
            }

            if (innerWidth > 1290) {
                return {
                    width: 1920,
                    height: 1080
                };
            }

            return {
                width: 1280,
                height: 720
            };

        },
        /**
         * Samsung supports SSL
         * @public
         * @method supportSSL
         * @return {Boolean} True
         * @memberof xdk-ext-device-samsung/System#
         */
        supportSSL: function () {
            return true;
        },
        /**
         * Samsung doesnt have same-origin policy (cross domain ajax restriction)
         * @public
         * @name hasSOP
         * @return {Boolean} False
         * @memberof xdk-ext-device-samsung/System#
         */
        hasSOP: function () {
            return false;
        },
        /**
         * Get the current network status from the device API
         * @method getNetworkStatus
         * @return {Promise.<Boolean>}  Return true if it is connected to internet.
         * @public
         * @memberof xdk-ext-device-samsung/System#
         */
        getNetworkStatus: function () {
            return promise.resolve(this._isInternetConnected());
        },
        /**
         * override the abstract system network status checking and use the connect poller for checking the status via isInternetConnected function
         * @method _postInit
         * @protected
         * @memberof xdk-ext-device-samsung/System#
         */
        _postInit: function () {
            var checkStatus, onStatusChange;

            checkStatus = util.bind(function (cbDone) {
                if (this._isInternetConnected()) {
                    cbDone(true);
                } else {
                    cbDone(false);
                }
            }, this);

            //the checking callback
            onStatusChange = util.bind(function (status) {
                this.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, status);
            }, this);

            this._internetPoller = new ConnectionPoller(checkStatus, onStatusChange, {
                networkStatus: this._isInternetConnected()
            });
        },
        /**
         * Check if the the device is connected to internet
         *
         * @method
         * @return {Boolean} true if the device is connected to lan and both internet by the device api
         * @protected
         * @memberof xdk-ext-device-samsung/System#
         */
        _isInternetConnected: function () {
            if (this.__isEmulator()) {
                //emulator as unable to determine the network status on emulator
                return true;
            }

            var connection = false;
            var type = global.networkPlugin.GetActiveType();

            if (type === -1) {
                return false;
            }

            // if the network is not connected physically, internet shouldn't be connected
            if (!this._isLANConnected()) {
                return false;
            }

            try {
                connection = global.networkPlugin.CheckGateway(type) > 0;
                console.debug("[XDK] isInternetConencted:" + connection);
            } catch (e) {
                console.warn("unable to detect the internet Connection" + e);
            }

            return connection;
        },
        /**
         * is physical Lan connected
         * @method _isLANConnected
         * @return {Boolean} true if it is connected
         * @protected
         * @memberof xdk-ext-device-samsung/System#
         */
        _isLANConnected: function () {
            if (this.__isEmulator()) {
                //emulator as unable to determine the network status on emulator
                return true;
            }

            var connection = false;
            var type = global.networkPlugin.GetActiveType();

            if (type === -1) {
                return false;
            }

            try {
                connection = global.networkPlugin.CheckPhysicalConnection(type) > 0;
            } catch (e) {
                console.warn("unable to detect the lan Connection" + e);
            }

            return connection;
        },

        /**
         * Checks if the running device is an emulator.
         *
         * @method
         * @private
         * @returns {Boolean} True if it is an emulator, false otherwise
         * @memberof xdk-ext-device-samsung/System#
         */
        __isEmulator: function () {
            return window.location.search.indexOf("product=") < 0;
        }
    });
});
/**
 * Id class to handle the device information like firmware version
 * @class xdk-ext-device-samsung/webAPI/Id
 * @augments xdk-ext-device-samsung/Id
 */
define("xdk-ext-device-samsung/webAPI/Id", ["xdk-base/class", "xdk-ext-device-samsung/Id", "xdk-base/util", "xdk-base/console", "xdk-ext-device-samsung/globals", "xdk-base/device/interface/Id"], function (klass, samsungId, util, console, globals, IId) {
    "use strict";
    return klass.create(samsungId, [IId], {}, {
        /**
         * The mac address
         * @private
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        __mac: null,
        /**
         * To ip address
         * @private
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        __ip: "0.0.0.0",
        /**
         * To firmware version
         * @private
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        __firmware: null,
        /**
         * To save the device type
         * @private
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        __deviceType: null,
        /**
         * To save the device hardware type
         * @private
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        __hardwareType: null,
        init: function () {

            var successCB, errorCB;

            successCB = util.bind(function (networks) {

                var i, len;

                console.info("[XDK] receive " + networks.length + " network information");

                for (i = 0, len = networks.length; i < len; i++) {

                    console.info("[XDK] Available Network interface is " + networks[i].interfaceType);

                    //save the network info
                    if (networks[i].isActive()) {
                        this.__ip = networks[i].ip;
                        this.__mac = networks[i].mac;
                        console.info("[XDK] get the ip and mac address ip " + this.__ip + "  mac : " + this.__mac);
                        return;
                    }
                }

            }, this);

            errorCB = function (error) {
                console.info("[XDK] fail to get the available networks");
            };

            if (globals.webapis) {
                //get the mac
                try {
                    globals.webapis.network.getAvailableNetworks(successCB, errorCB);
                } catch (error) {
                    console.info("[XDK] Fail to get the available network" + error.name);
                }
            } else {
                console.info("[XDK] no available webapi and fail to get the id information.");
            }

            console.info("[XDK] loaded the webAPI Id");

            this._super();
        },
        /**
         * To return the device type
         * @method getDeviceType
         * @public
         * @return {String} type of the device e.g Bluray, TV
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        getDeviceType: function () {

            if (this.__deviceType) {
                return this.__deviceType;
            }

            var deviceType = "emulator",
                str, position = window.location.search.indexOf("product=");

            //use window.location.search first 
            //http://www.samsungdforum.com/Guide/d60/index.html
            if (position !== -1) {

                str = window.location.search[position + 8];

                switch (str) {
                case "2":
                    deviceType = "Bluray";
                    break;
                case "1":
                    deviceType = "Monitor";
                    break;
                case "0":
                    deviceType = "TV";
                    break;
                }

            } else {

                //get the product type
                try {
                    str = globals.webapis.tv.info.getProduct();
                    switch (str) {
                    case globals.webapis.tv.info.PRODUCT_TYPE_BD:
                        deviceType = "Bluray";
                        break;
                    case globals.webapis.tv.info.PRODUCT_TYPE_MONITOR:
                        deviceType = "Monitor";
                        break;
                    case globals.webapis.tv.info.PRODUCT_TYPE_TV:
                        deviceType = "TV";
                        break;
                    }
                } catch (ex) {

                    //http://www.samsungdforum.com/Guide/ref00008/tvinformation/dtv_tvinformation_module.html#ref00008-tvi-getproduct
                    //with error type "UnknownError" in any other error case.
                    //with error type "NotSupportedError" if the feature is not supported.
                    //with error type "SecurityError" if this functionality is not allowed.

                    console.info("[XDK] WEB API Error Unable to get the device type " + ex.name + " msg : " + ex.message);

                }

            }

            this.__deviceType = deviceType;

            return this.__deviceType;

        },
        /**
         * To return the hardware type
         * @method getHardwareType
         * @public
         * @return {ax/device/interface/Id.HARDWARE_TYPE} type of the device hardware as {@link xdk-base/device/interface/Id.HARDWARE_TYPE.BD} 
           or {@link xdk-base/device/interface/Id.HARDWARE_TYPE.MONITOR}
           or {@link xdk-base/device/interface/Id.HARDWARE_TYPE.TV}
           or {@link xdk-base/device/interface/Id.HARDWARE_TYPE.EMULATOR}  
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        getHardwareType: function () {

            if (this.__hardwareType) {
                return this.__hardwareType;
            }

            var hardwareType = IId.HARDWARE_TYPE.EMULATOR,
                str, position = window.location.search.indexOf("product=");

            //use window.location.search first 
            //http://www.samsungdforum.com/Guide/d60/index.html
            if (position !== -1) {

                str = window.location.search[position + 8];

                switch (str) {
                case "2":
                    hardwareType = IId.HARDWARE_TYPE.BD;
                    break;
                case "1":
                    hardwareType = IId.HARDWARE_TYPE.MONITOR;
                    break;
                case "0":
                    hardwareType = IId.HARDWARE_TYPE.TV;
                    break;
                }

            } else {

                //get the product type
                try {
                    str = globals.webapis.tv.info.getProduct();
                    switch (str) {
                    case globals.webapis.tv.info.PRODUCT_TYPE_BD:
                        hardwareType = IId.HARDWARE_TYPE.BD;
                        break;
                    case globals.webapis.tv.info.PRODUCT_TYPE_MONITOR:
                        hardwareType = IId.HARDWARE_TYPE.MONITOR;
                        break;
                    case globals.webapis.tv.info.PRODUCT_TYPE_TV:
                        hardwareType = IId.HARDWARE_TYPE.TV;
                        break;
                    }
                } catch (ex) {

                    //http://www.samsungdforum.com/Guide/ref00008/tvinformation/dtv_tvinformation_module.html#ref00008-tvi-getproduct
                    //with error type "UnknownError" in any other error case.
                    //with error type "NotSupportedError" if the feature is not supported.
                    //with error type "SecurityError" if this functionality is not allowed.

                    console.info("[XDK] WEB API Error Unable to get the device type " + ex.name + " msg : " + ex.message);

                }

            }

            this.__hardwareType = hardwareType;

            return this.__hardwareType;

        },
        /**
         * return the mac address
         * @method getMac
         * @return {String} mac address
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         * @public
         */
        getMac: function () {
            return this.__mac;
        },
        /**
         * To get the firmware version
         * @method getFirmware
         * @public
         * @return {String} the firmware of the devices
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        getFirmware: function () {

            if (this.__firmware) {
                return this.__firmware;
            }

            var firmwareStr = globals.webapis.tv.info.getFirmware();

            if (!util.isUndefined(firmwareStr) && firmwareStr.length > 0) {
                this.__firmware = firmwareStr;
            } else {
                this.__firmware = "dummyFirmware";
            }

            return this.__firmware;
        },
        /**
         * return the firmware year
         * @method getFirmwareYear
         * @returns {String} the firmware year, otherwise it will return false
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         * @public
         */
        getFirmwareYear: function () {
            var str = this.getFirmware(),
                year;

            if (!util.isUndefined(str)) {
                year = parseInt(str.substr(10, 4), 10);
                return isNaN(year) ? 0 : year;
            }
            return false;
        },
        /**
         * To get the unique ID. If no unique id.if will generate a UUID by XDK
         * @method getUniqueID
         * @public
         * @returns {String} the the duid from the samsung, otherwise it will return the uuid
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        getUniqueID: function () {

            var uniqueId;

            try {
                uniqueId = globals.webapis.tv.info.getDeviceID();
            } catch (ex) {
                console.info("[XDK] WEB API Error Unable to get the device id " + ex.name + " msg : " + ex.message);
            }

            if (uniqueId) {
                return uniqueId;
            }

            console.info("[XDK] fail to get DUID from the device and use UUID");
            return this._super();
        },
        /**
         * To get the model of the device. If no related information. "dummySamsungmodel" will be returned
         * @method getModel
         * @public
         * @returns {String} the model numebr
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        getModel: function () {
            //webapis.tv.info.getModel() is different from the original model number.
            //e.g "13_X12_2D" which is not expected model number
            var model = globals.webapis._plugin("TV", "GetProductCode");

            if (model) {
                return model;
            }

            return "dummySamsungmodel";
        },
        /**
         * To get IP address
         * @method getIP
         * @public
         * @return {String} the IP address
         * @memberof xdk-ext-device-samsung/webAPI/Id#
         */
        getIP: function () {
            return this.__ip;
        }
    });
});
/**
 * System class to handle the system api and connection checking
 * @class xdk-ext-device-samsung/webAPI/System
 * @augments xdk-ext-device-samsung/System
 */
define("xdk-ext-device-samsung/webAPI/System", ["xdk-base/class", "xdk-ext-device-samsung/System", "xdk-ext-device-samsung/globals", "xdk-base/console", "xdk-base/util", "xdk-base/EventDispatcher", "xdk-base/device/interface/System"], function(klass, samsungSystem, globals, console, util, EventDispatcher, ISystem) {
    "use strict";
    return klass.create(samsungSystem, {}, {
        /**
         * To set the system mute
         * @public
         * @method setSystemMute
         * @param {Boolean} turnOn True if turn on the mute, false when turn off.
         * @memberof xdk-ext-device-samsung/webAPI/System#
         */
        setSystemMute: function(turnOn) {
            if (globals.webapis.audiocontrol.getMute() !== turnOn) {
                //Mute
                globals.webapis.audiocontrol.setMute(turnOn);
                console.debug("[XDK] >>" + (turnOn ? " Mute" : "Unmute") + " the TV");
            } else {
                console.debug("[XDK] >> Screensaver status unchanged as mute is " + turnOn);
            }
        } 
    });
});
/**
 * DevicePack class to handle the packaging for the Samsung
 * Samsung firmware year larger than 2011 will have mouse support
 * Storage will make use of file to store that data is only removed when delete the app.
 *
 * ###Support Models
 *
 * * 2010
 * * 2011
 * * 2012
 * * 2013
 * * 2014
 *
 * ###Media Player
 *
 * * {@link xdk-ext-device-samsung/InfolinkPlayer} Infolink Player
 * Support format: MP4 ASF HLS HAS MP3 WIDEVINE WMDRM PLAYREADY
 * * {@link xdk-ext-device-samsung/SefPlayer} Sefplayer (Supported in 2011+)
 * Support format: MP4 ASF HLS HAS MP3 WIDEVINE WMDRM PLAYREADY VERIMATRIX
 * Support multiple audio tracks
 * * {@link xdk-ext-device-samsung/webAPI/AVPlayer} AVPlayer
 * Support format: MP4 ASF HLS HAS MP3 WIDEVINE WMDRM PLAYREADY (Supported in 2012+ and those device with webapis)
 * * {@link xdk-base/device/shared/FlashPlayer} Flash player (Supported in 2012+)
 * Support format: RTMP (MP4 is removed from the supported list due to device limitation)
 * * {@link xdk-base/device/shared/Html5Player} HTML5 player (Supported in 2012+)
 * Support format: MP4
 *
 *
 * If there is no setting available player in the config, the following default player will be applied.
 * Default: xdk-ext-device-samsung/InfolinkPlayer
 *
 * ###Strategy
 * * {@link xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy} SefPlayerMultiAudioTrackStgy
 * Support only on the SEF Player. And it allows users to switch the audio channels of the videos.
 * * {@link xdk-ext-device-samsung/webAPI/AVPlayerMultiAudioTracksStgy} AVPlayerMultiAudioTrackStgy
 * Support only on the AVPlayer. And it allows users to switch the audio channels of the videos.
 * ###Resources
 *
 * * <https://accedobroadband.jira.com/wiki/display/ATEC/Samsung+Smart+TV>
 * * <http://www.samsungdforum.com/>
 *
 * ###Remark
 * {@link xdk-ext-device-samsung/globals} To get the global object of samsung like tvplugin, infolink player or system..etc.
 * _sswidget_ is a reserved module path for samsung plugins/widgets, please do not define any module under this path.
 *
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * --------- | ---------
 * Key:    | samsung.initDelay
 * Desc    | Time (s) to delay the init in sec for some special handling like setBannerState
 * Type    | Number
 * Default  | 0.5
 * Usage | {@link module:xdk-base/config}
 * @class xdk-ext-device-samsung/DevicePackage
 * @extends ax/device/AbstractDevicePackage
 */
define("xdk-ext-device-samsung/DevicePackage", [
    "xdk-ext-device-samsung/loader/nativeAPI",
    "xdk-base/device/AbstractDevicePackage",
    "xdk-ext-device-samsung/FileStorage",
    "xdk-ext-device-samsung/TvKey",
    "xdk-ext-device-samsung/Id",
    "xdk-ext-device-samsung/System",
    "xdk-base/device/Media",
    "xdk-base/class",
    "xdk-base/console",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-ext-device-samsung/globals",
    "xdk-ext-device-samsung/webAPI/Id",
    "xdk-ext-device-samsung/webAPI/System",
    "require"
], function (
    nativeAPI,
    AbstractDevicePackage,
    FileStorage,
    TvKey,
    Id,
    System,
    Media,
    klass,
    console,
    util,
    config,
    globals,
    WebAPIId,
    WebAPISystem,
    require
) {
    "use strict";
    var sMedia = Media.singleton(),
        id,
        system;

    return klass.create(AbstractDevicePackage, {}, {
        /**
         * To indicate if it is ready
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        initedPlayList: false,
        /*
         * To indicate if it is initied
         * @name inited
         * @memberof xdk-base/device/samsung/DevicePackage#
         * @protected
         */
        inited: false,
        /**
         * To inited Device
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        initedDevice: false,
        /**
         * [Backward Compatible only] To be true when device package version >= 2.3, determine whether to run setup method in AbstractDevicePackage
         * @property {Boolean} _shouldSetup
         * @memberof xdk-ext-device-samsung/DevicePackage#
         * @protected
         */
        _shouldSetup: true,
        /**
         * To return platform id of this abstraction
         * @method
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        getId: function () {
            return "samsung";
        },
        /**
         * setup the device package
         * @param {Function} onDeviceLoaded callback when the device is loaded.
         * @returns {xdk-ext-device-samsung/DevicePackage} abstract device package itself
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        setup: function (onDeviceLoaded) {
            this._super(onDeviceLoaded);

            //assume to use the old id to find the firmware year 
            id = new Id();

            //according to guideline, it supports since 2012
            if (id.getFirmwareYear() >= 2012) {
                console.info("[XDK] Try to load the webapi on the device with firmware year >= 2012");
                require(["xdk-ext-device-samsung/loader/nativeAPI!locateAPI=false|$MANAGER_WIDGET/Common/webapi/1.0/webapis"], util.bind(function () {
                    //to assign back the value to the globals
                    globals.webapis = window.webapis;
                    console.info("[XDK] load the web api successfully");
                    this.__loadPackage();
                }, this), util.bind(function () {
                    console.info("[XDK] fail to load the device webapi");
                    this.__loadPackage();
                }, this));

                return;
            }

            this.__loadPackage();
            console.info("[XDK] Didn't try to load the webapis");
        },
        /**
         * To load the package
         * @method __loadPackage
         * @private
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        __loadPackage: function () {

            var interfaceTypes, ready;

            //init Interface
            interfaceTypes = this.getInterfaceTypes();

            util.each(interfaceTypes, util.bind(function (pair) {
                this.addInterfaceType(pair.key, pair.value.handle, pair.value.interfaceObj);
            }, this));

            //inti samsung step
            this.samsungInit();

            ready = util.bind(function () {
                this.initedPlayList = true;

                if (this.inited) {
                    return;
                }

                if (this.initedPlayList && this.initedDevice) {
                    console.info("[XDK]Ready to load after the play list ready");
                    this.inited = true;
                    this.ready();
                }
            }, this);

            this._preparePlayerList(ready);
        },
        /**
         * To set the default player to be {@link xdk-ext-device-samsung/InfolinkPlayer}
         * @method getDefaultPlayer
         * @returns {String[]} Array of the player list
         * @public
         * @memberof xdk-ext-device-samsung/DevicePackagel#
         */
        getDefaultPlayer: function () {
            return ["xdk-ext-device-samsung/InfolinkPlayer"];
        },
        /**
         * To init each modules like id, media, system and tvkey
         * @method getInterfaceTypes
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        getInterfaceTypes: function () {
            console.info("[XDK] Get the interfaceType" + globals.webapis);
            //to create the system and id when no webapis
            if (!globals.webapis) {
                system = new System();
            } else {
                console.info("[XDK] Using the webAPI samsung set");

                console.info("[XDK] Run the System");
                system = new WebAPISystem();

                console.info("[XDK] Run the id");
                //to override with the one used in the init
                id = new WebAPIId();
            }
            console.info("[XDK] Start to load other parts");
            var ret = {};
            ret[AbstractDevicePackage.STORAGE] = {
                handle: AbstractDevicePackage.STORAGE_HANDLE,
                interfaceObj: new FileStorage()
            };

            ret[AbstractDevicePackage.TV_KEY] = {
                handle: AbstractDevicePackage.TV_KEY_HANDLE,
                interfaceObj: new TvKey()
            };

            ret[AbstractDevicePackage.MEDIA_PLAYER] = {
                handle: AbstractDevicePackage.MEDIA_PLAYER_HANDLE,
                interfaceObj: sMedia
            };

            ret[AbstractDevicePackage.ID] = {
                handle: AbstractDevicePackage.ID_HANDLE,
                interfaceObj: id
            };

            ret[AbstractDevicePackage.SYSTEM] = {
                handle: AbstractDevicePackage.SYSTEM_HANDLE,
                interfaceObj: system
            };

            //@todo 3D
            return ret;
        },
        /**
         * To set when the samsung device package is loaded.
         * @method
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        samsungOnLoad: function () {
            console.info("[XDK] Samsung onload fired!");
            console.info("[XDK] Samsung onload: window.location.href: " + window.location.href);

            if (id.getFirmwareYear() < 2012) {
                document.body.style.position = "fixed";
            }

            //@workaround to remove handling on the starting Parameter
            /*
             try {
             accedo.device.samsung.DevicePackage._startingParameters = accedo.QueryString.getValue("data");
             accedo.device.samsung.DevicePackage._startingParameters = eval("(" + decodeURIComponent(accedo.device.samsung.DevicePackage._startingParameters) + ")");
             alert("starting Parameters acquired: " + accedo.Object.toJSON(accedo.device.samsung.DevicePackage._startingParameters));
             } catch (e) {
             alert("error acquiring starting parameters:" + e);
             }
             */

            //@workaround To remove the set screen saver as according to the requirement, screensaver is only turn off when playing the video/
            //So it shouldn't be turned off at the begining.
            //special handle for putting off screensaver all the time
            /*accedo.Fn.delay(function() {
             system.setScreenSaver(false);
             alert("[ON SHOW] turn off screen saver");
             }, 10);*/

            //Delay is implemented to allow time for plugin to initialize
            //(otherwise code below may get ignored by the device)
            util.delay(config.get("samsung.initDelay", 0.5)).then(util.bind(function () {
                //According to guideline, normal app should set to be 1
                globals.NNaviPlugin.SetBannerState(1);
                console.info("[XDK] Samsung onload: setBannerState");

                globals.pluginAPI.setOffIdleEvent();
                console.info("[XDK] Samsung onload: setOffIdleEvent");

                this.initedDevice = true;

                if (this.inited) {
                    return;
                }

                if (this.initedPlayList && this.initedDevice) {
                    console.info("[XDK]Ready to load after the setBanner State");
                    this.inited = true;
                    this.ready();
                }
            }, this)).done();

            //register part widget key
            globals.pluginAPI.registPartWidgetKey();
            console.info("[XDK] Samsung onload: registPartWidgetKey");

            //register full widget key
            globals.pluginAPI.registFullWidgetKey();
            console.info("[XDK] Samsung onload: registFullWidgetKey");
        },
        /**
         * To unset when the samsung device package is unloaded.
         * @method
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        samsungOnUnload: function () {
            console.info("[XDK] Samsung onunload fired!");
            sMedia.stop();
            sMedia.setFullscreen();

            //@workaround Not sure what to do with the mPlugin and setFull screen
            //@todo: widevine connection stage crashing issue
        },
        /**
         * To initialize the samsung device
         * @method
         * @protected
         * @memberof xdk-ext-device-samsung/DevicePackage#
         */
        samsungInit: function () {
            console.info("[XDK] Samsung Device package initializing...");

            // samsung onLoad Handling instead of using window.onShow
            domReady(util.bind(this.samsungOnLoad, this));

            var sEnv = require("xdk-base/Env").singleton();

            // set onunload function
            sEnv.addEventListener(sEnv.EVT_ONUNLOAD, util.bind(this.samsungOnUnload, this));
            console.info("[XDK] Assigned onunload function");

            // samsung package relies on Env.EVT_ONUNLOAD event
            // however, devices > 2012 use window.onHide for onunload, which Env does not aware of
            // therefore we dispatch EVT_ONUNLOAD through Env here
            if (id.getFirmwareYear() > 2011) {
                window.onHide = util.bind(sEnv.dispatchEvent, sEnv, sEnv.EVT_ONUNLOAD);
            }

            // call the samsung device to show the widget
            globals.widgetAPI.sendReadyEvent();
            console.info("[XDK] Sent ready event");
        }
    });
});
/**
 * TvKey class to handle the key, overriding the original Samsung TvKey handling to register smart-hub key.
 *
 * @class tvedemo/ext/device/samsung/TvKey
 * @extends ax/ext/device/samsung/TvKey
 */
define("tvedemo/ext/device/samsung/TvKey", [
        "xdk-ext-device-samsung/TvKey", "xdk-base/class", "xdk-base/console", "xdk-base/device/vKey",
        "xdk-base/util", "xdk-ext-device-samsung/globals"
    ],
    function (samsungTvKey, klass, console, VKey,
        util, global) {

        "use strict";

        var NEXTKEY = 1078,
            PREVIOUSKEY = 1080;

        return klass.create(samsungTvKey, {
            /**
             * @name SMART_HUB
             * @property {String} id Virtual Key ID. "samsung:vkey:smarthub"
             * @memberOf tvedemo/ext/device/samsung/TvKey#
             */
            SMART_HUB: {
                id: "samsung:vkey:smarthub"
            }
        }, {
            init: function () {
                this._super();

                // map the smarthub keys
                this._keyMapping.VKey[global.tvKey.KEY_INFOLINK] = this.constructor.SMART_HUB;
                this._keyMapping.VKey[global.tvKey.KEY_CONTENT] = this.constructor.SMART_HUB;
                this._keyMapping.VKey[global.tvKey.KEY_WLINK] = this.constructor.SMART_HUB;

                // Samsung Next chapter key.
                this._keyMapping.VKey[NEXTKEY] = VKey.NEXT;

                // Samsung Previous chapter key.
                this._keyMapping.VKey[PREVIOUSKEY] = VKey.PREV;

                this.initKeyMapping(this._keyMapping);
            },
            /**
             * To handle the initial key handling.
             * This method is a direct copy from the orginal TvKey, with some minor changes to handle the smart-hub key.
             * `this._super()` cannot be used as we cannot remove the onkeydown listener added by the super class.
             * @protected
             * @method initKeyHandling
             * @memberOf tvedemo/ext/device/samsung/TvKey#
             */
            initKeyHandling: function (dispatchKey) {
                //only handle keydown in ss
                document.onkeydown = util.bind(function (evt) {
                    return this.keyHandler(evt, dispatchKey);
                }, this);

                var device = amd.require("xdk-base/device"),
                    year = device.id.getFirmwareYear(),
                    type = device.id.getDeviceType();

                // hack for 2011 device"s smart-hub key exits to TV channel
                if (year === 2011) {
                    // for 2011 device, doing below assignment will actually add another event listener
                    document.onkeydown = function (evt) {
                        console.log("samsung on key down");
                        // 2011's smart-hub key is bugged, it exits to channel, so need to handle ourselves
                        if (evt.keyCode === global.tvKey.KEY_INFOLINK || evt.keyCode === global.tvKey.KEY_CONTENT) {
                            // the following lines are removed from the default TvKey implementation
                            // this will stop the default behavior
                            // ---
                            // console.debug("[XDK]Smart-hub key receiced! Exiting application...");
                            // device.system.exit({
                            //     toTV: false
                            // });
                            evt.preventDefault();
                            return false;
                        }
                        return true;
                    };
                }

                //Ensure those keys are registered and unregistered
                util.delay(1).then(function () {
                    // bring global variable into local scope for performance
                    var ac = global.appCommon;

                    //we will use samsung registFullWidgetKey to register all the common keys.
                    // commons keys other that will be registered here.
                    ac.RegisterKey(global.tvKey.KEY_PANEL_CH_UP);
                    ac.RegisterKey(global.tvKey.KEY_PANEL_CH_DOWN);
                    ac.RegisterKey(global.tvKey.KEY_PANEL_VOL_UP);
                    ac.RegisterKey(global.tvKey.KEY_PANEL_VOL_DOWN);
                    ac.RegisterKey(global.tvKey.KEY_PANEL_ENTER);
                    ac.RegisterKey(global.tvKey.KEY_PANEL_SOURCE);
                    ac.RegisterKey(global.tvKey.KEY_PANEL_MENU);
                    ac.RegisterKey(global.tvKey.KEY_EXIT);

                    // 2013
                    global.pluginAPI.registKey(global.tvKey.KEY_TOOLS);

                    if (year <= 2012) {
                        if (type === "tv" && year <= 2010) {
                            ac.UnregisterKey(global.tvKey.KEY_WLINK); // Smart-hub key another version
                        } else {
                            ac.RegisterKey(global.tvKey.KEY_WLINK); // Smart-hub key another version
                        }
                        ac.RegisterKey(global.tvKey.KEY_CONTENT); // Smart-hub key
                        ac.RegisterKey(global.tvKey.KEY_INFOLINK); // Smart-hub key another version
                    
                    } else if(year === 2014){// NOTE: leave default smart-hub action in Samsung 2014
                        ac.UnregisterKey(global.tvKey.KEY_CONTENT); // Smart-hub key
                        ac.UnregisterKey(global.tvKey.KEY_INFOLINK); // Smart-hub key another version
                        ac.UnregisterKey(global.tvKey.KEY_WLINK); // Smart-hub key yet another version (added for demo)
                    
                    } else {
                        ac.RegisterKey(global.tvKey.KEY_CONTENT); // Smart-hub key
                        ac.RegisterKey(global.tvKey.KEY_INFOLINK); // Smart-hub key another version
                        ac.RegisterKey(global.tvKey.KEY_WLINK); // Smart-hub key yet another version (added for demo)
                    }

                    //To Ensure the following keys are not registered to use the default behaviour.
                    ac.UnregisterKey(global.tvKey.KEY_VOL_UP);
                    ac.UnregisterKey(global.tvKey.KEY_VOL_DOWN);
                    ac.UnregisterKey(global.tvKey.KEY_MUTE);
                    ac.UnregisterKey(global.tvKey.KEY_POWER);
                    ac.UnregisterKey(global.tvKey.KEY_SOURCE);
                    ac.UnregisterKey(global.tvKey.KEY_MENU);
                }).done();
            }
        });
    });
/**
 * Append Sef playready plugin to globals object.
 * @module tvedemo/ext/device/samsung/globals
 * @property {Object} sefPlayreadyPlugin sef plugin <http://www.samsungdforum.com/Guide/ref00014/index.html>
 */
define("tvedemo/ext/device/samsung/globals", ["xdk-ext-device-samsung/globals"], 
    function (globals) {
    "use strict";

    var samsungDeviceObject = document.getElementById("samsungDeviceObject"),
        sefPlayreadyPluingContainer = document.createElement("div");
        
    
    sefPlayreadyPluingContainer.id = "sefPlayreadyPluingContainer";
    sefPlayreadyPluingContainer.innerHTML = "<object id='sefPlayreadyPlugin' border=0 classid='clsid:SAMSUNG-INFOLINK-SEF'></object>";

    if (samsungDeviceObject) {
        samsungDeviceObject.appendChild(sefPlayreadyPluingContainer);
    }

    globals.sefPlayreadyPlugin = document.getElementById("sefPlayreadyPlugin");
    
    return globals;
});
/**
 * Id class to handle the device information like firmware version.
 * @class tvedemo/ext/device/samsung/Id
 * @extends ax/ext/device/samsung/Id
 */
define("tvedemo/ext/device/samsung/Id", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/console",
    "tvedemo/ext/device/samsung/globals",
    "xdk-ext-device-samsung/Id"
    ], function (
        klass,
        util,
        console,
        globals,
        Id
    ) {

    "use strict";

    var requiredFirmwares;

    return klass.create(Id, {}, {

        /**
         * Retrieve firmware version of the tv.
         * @return {String/Boolean} Firmware version if no failure occurs, false if any failure occurs.
         */
        getSamsung2014Firmware: function () {
            var sefPlugin = globals.sefPlayreadyPlugin,
                version;

            if (sefPlugin) {

                try {
                    sefPlugin.Open("Device","1.000","Device");
                    version = sefPlugin.Execute("Firmware");
                    sefPlugin.Close();

                } catch (exception) {
                    version = false;
                }

            } else {
                version = false;
            }

            return version;
        },

        /**
         * Check if a Samsung 2014 firmware will be able to run the app.
         * @param  {String} samsung2014Firmware Firmware of the TV.
         * @return {Boolean}                    True if the firmware of the TV will be able to handle the app, otherwise false.
         */
        checkIfSamsung2014FirmwareIsAllowed: function (samsung2014Firmware) {

            if (!util.isString(samsung2014Firmware)) {
                return false;
            }

            var firmwareIsAllowed = false;

            // Check if the provided firmware is among the allowed ones and that its version is equal to or higher than the required one.
            util.each(requiredFirmwares, function (requiredFirmware) {
                var firmwareMatch = new RegExp(requiredFirmware.firmwareMatch),
                    otnVersionMatch = new RegExp(requiredFirmware.otnVersionMatch),
                    firmwareOtnVersion = otnVersionMatch && util.isArray(otnVersionMatch.exec(samsung2014Firmware)) && otnVersionMatch.exec(samsung2014Firmware)[1];

                if (firmwareMatch && firmwareMatch.test(samsung2014Firmware)) {

                    if (firmwareOtnVersion >= requiredFirmware.otnVersionRequired) {
                        firmwareIsAllowed = true;

                        return util.breaker;
                    }
                }

            });

            return firmwareIsAllowed;
        },

        /**
         * Set firmware identifier which will be used to check that device firmware will be able to start playback.
         * @param  {Object[]} firmwareIdentifiers List with firmware identifiers.
         * @return {Boolean}                      True if firmware identifiers has been updated, otherwise false.
         */
        setRequiredSamsung2014FirmwareIdentifiers: function (firmwareIdentifiers) {

            if (!util.isArray(firmwareIdentifiers)) {
                return false;
            }

            requiredFirmwares = firmwareIdentifiers;

            return true;
        }
    });
});
/**
 * This class overrides the original Samsung device package to facilitate the custom TV key handling.
 *
 * @class tvedemo/ext/device/samsung/DevicePackage
 * @extends ax/ext/device/samsung/DevicePackage
 */
define("tvedemo/ext/device/samsung/DevicePackage", [
        "xdk-base/class",
        "xdk-base/device/AbstractDevicePackage",
        "xdk-ext-device-samsung/DevicePackage",
        "tvedemo/ext/device/samsung/TvKey",
        "tvedemo/ext/device/samsung/Id",
        "xdk-base/console"
    ],
    function (
        klass,
        AbstractDevicePackage,
        SamsungDevicePackage,
        TvKey,
        Id,
        console
        ) {

        "use strict";

        return klass.create(SamsungDevicePackage, {}, {
            /**
             * To init each modules like id, media, system and tvkey
             * @method getInterfaceTypes
             * @protected
             * @returns {Object} the device interface object
             * @memberof tvedemo/ext/device/samsung/DevicePackage#
             */
            getInterfaceTypes: function () {
                console.info("[DevicePackage] tvedemo samsung device package in place");

                var ret = this._super();

                // override the original TvKey
                ret[AbstractDevicePackage.TV_KEY] = {
                    handle: AbstractDevicePackage.TV_KEY_HANDLE,
                    interfaceObj: new TvKey()
                };

                ret[AbstractDevicePackage.ID] = {
                    handle: AbstractDevicePackage.ID_HANDLE,
                    interfaceObj: new Id()
                };

                return ret;
            },

            deinit: function() {
                AbstractDevicePackage.deinit();
            }
        });
    });

/**
 * Samsung Sef player which only available from 2012 samsung devices.
 * @class xdk-ext-device-samsung/SefPlayer
 * @augments ax/device/interface/Player
 * @author Daniel Deng <daniel.deng@accedo.tv>
 */
define("xdk-ext-device-samsung/SefPlayer", [
    "xdk-base/class",
    "xdk-base/device/Media",
    "xdk-base/console",
    "xdk-base/Element",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-ext-device-samsung/globals",
    "xdk-base/ajax",
    "xdk-base/EventDispatcher",
    "xdk-base/device/interface/Id",
    "xdk-base/device/interface/Player",
    "require"
], function (
    klass,
    Media,
    console,
    Element,
    core,
    util,
    globals,
    ajax,
    EventDispatcher,
    IId,
    IPlayer,
    require
) {
    "use strict";

    var PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS;

    function _getDeviceAPI(api) {
        var device = require("xdk-base/device");
        return device[api];
    }

    function _getResolution() {
        return _getDeviceAPI("system").getDisplayResolution();
    }


    var sMedia = Media.singleton(),

        sefClass = klass.create(EventDispatcher, [IPlayer], {
            /**
             * Event: subtitle
             *
             * @event EVT_SUBTITLE
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer
             */
            EVT_SUBTITLE: "sefplayer:subtitle",
            /**
             * Event: screen-size-change
             *
             * @event EVT_SCREEN_SIZE_CHANGED
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer
             */
            EVT_SCREEN_SIZE_CHANGED: "sefplayer:screen-size-change",
            /**
             * Number of pause retry to perform in order to make sure the player is paused successfully
             * @property {Number} 10 times to retry
             * @memberof xdk-ext-device-samsung/SefPlayer
             */
            PAUSE_RETRY: 10,
            /**
             * Interval to retry the perform player pause api util player pauses successfully, reaching the max pause retry or player is not in pause state anymore.
             * @property {Number} 200ms
             * @memberof xdk-ext-device-samsung/SefPlayer
             */
            PAUSE_INTERVAL: 200
        }, {
            /**
             * The id of the player
             * @name __id
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __id: null,
            /**
             * current 3D mode
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _current3dType: 0,
            /**
             * previous 3D mode
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _previous3dType: 0,
            /**
             * connection time limit
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _connectionTimeLimit: 90,
            /**
             * the media plugin object
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _plugin: null,
            /**
             * In case the player plugin object needs to be moved, this is the plugin object container
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _pluginContainer: null,
            /**
             * JSON containing current window size
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _currentWindowSize: null,
            /**
             * playback current time
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _curTime: 0,
            /**
             * media duration
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _duration: 0,
            /**
             * is the player ready for playback
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _prepared: false,
            /**
             * playback Speed
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _playbackSpeed: 1,
            /**
             * is there any stop function withholding
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _withHoldingStop: false,
            /**
             * media container format
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _type: null,
            /**
             * DRM technology being used
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _drm: null,
            /**
             * Cookie information intended for DRM server
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _cookie: null,
            /**
             * cookie url for authentication
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _authCookiesUrl: null,
            /**
             * custom data for playready
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _playReadyCustomData: null,
            /**
             * DRM server location
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _DRMServer: null,
            /**
             * is currently using 3D
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _is3d: false,
            /**
             * current 3D type
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _3dType: "off",
            /**
             * will be set to true whenever current playback time has been reported by plugin
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _curTimeReported: false,
            /**
             * To indicate the meta data info is ready or not
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _infoReady: false,
            /**
             * To handle the multi audio track strategy
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __multiAudioStgy: null,
            /**
             * To ignore the first buffering
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __ignoreFirstBuffering: false,
            /**
             * @method
             * @memberof xdk-ext-device-samsung/SefPlayer#
             * @return {ax/device/interface/Player~PlayerCapabilites}
             */
            getCapabilities: function () {
                return {
                    type: ["mp4", "asf", "hls", "has", "dash", "mp3"],
                    drms: ["wmdrm", "playready", "widevine", "verimatrix"]
                };
            },
            /**
             * To initialize the plugin player
             * @method
             * @memberof xdk-ext-device-samsung/SefPlayer#
             * @private
             */
            init: function (devicePackage) {
                var Id = devicePackage.getInterface(devicePackage.constructor.ID),
                    self = this;
                //SEF player doesn't support in 2010 so filter it
                if (Id.getFirmwareYear() < 2011) {
                    throw core.createException("SefPluginNotSupported", "Sef plugin is not supported when less than 2011.");
                }

                this._plugin = globals.sefPlugin;

                if (!this._plugin || (this._plugin && !this._plugin.Open)) {
                    throw core.createException("SefPluginNotFound", "Sef plugin is not found, player cannot be init");
                }

                this._plugin.Open("Player", "0001", "InitPlayer");


                //it is unable to bind the callback function into plugin onEvent, so assign it by the global.
                window.__sefOnEvent = function __sefOnEvent(eventType, param1, param2) {
                    console.info("[Samsung SEF] OnEvent() - eventType : " + eventType + ", param1 : " + param1 + ", param2 : " + param2);

                    switch (eventType) {
                    case 1:
                        self._onConnectionFailed();
                        break;
                    case 2:
                        self._onAuthenticationFailed();
                        break;
                    case 3:
                        self._onStreamNotFound();
                        break;
                    case 4:
                        self._onNetworkDisconnected();
                        break;
                    case 6:
                        self._onRenderError(param1);
                        break;
                    case 8:
                        self._onRenderingComplete();
                        break;
                    case 9:
                        // stream info ready event
                        self._setDuration();
                        self.__infoReady = true;

                        //remove the connection time out since the meta data is ready
                        self.__removeConnectionTimeout();

                        break;
                    case 11:
                        self._onBufferingStart();
                        break;
                    case 12:
                        self._onBufferingComplete();
                        break;
                    case 13:
                        self._onBufferingProgress();
                        break;
                    case 14:
                        // current playback time
                        self._onCurrentPlayTime(param1);
                        break;
                    case 19:
                        // subtitle received
                        console.info("dispatch the subtitle event");
                        self.dispatchEvent(self.constructor.EVT_SUBTITLE, param1);
                        break;
                    default:
                        self._onUnknownEvent(eventType, param1, param2);
                        break;
                    }
                };
            },
            /**
             * To prepare the plugin player for video playback
             * @method
             * @memberof xdk-ext-device-samsung/SefPlayer#
             * @public
             */
            prepare: function (opts) {
                if (this._prepared) {
                    return;
                }
                console.debug("opts" + opts);
                this._prepared = true;
                this._plugin.OnEvent = "window.__sefOnEvent";
            },
            /**
             * To reset the plugin player when it is not currently used
             * @method
             * @memberof xdk-ext-device-samsung/SefPlayer#
             * @public
             */
            reset: function () {
                if (!this._prepared) {
                    return;
                }
                this._prepared = false;

                delete this._plugin.OnEvent;

                //enable screen saver when there is no player
                _getDeviceAPI("system").setScreenSaver(true);
            },
            /**
             * Safely de-init and remove the mediapPyer
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             * @ignore
             */
            deinit: function () {
                console.info("samsung media deinit");
                if (!this._prepared) {
                    return;
                }
                if (!this._inited) {
                    return;
                }

                if (_getDeviceAPI("id").getHardwareType() !== IId.HARDWARE_TYPE.TV) {
                    this._current3dType = 0;
                    this._previous3dType = 0;
                    if (globals.pluginObject3D && globals.pluginObject3D.Check3DEffectMode(0) === 1) {
                        globals.pluginObject3D.Set3DEffectMode(0);
                    }
                }

                this.stop();

                this.reset();

                this._inited = false;

                console.info("samsung media deinit success");
                delete window.__sefOnEvent;
                return;
            },
            /**
             * Place the video plugin object as child, to fight the z-index problem on old devices below 2012
             * @method
             * @param {xdk-base/Element|Element|xdk-ax/AbstractComponent} parent The parent element to contain the video plugin object
             * @param {Boolean} [forecExecute] If true, execute this even on new devices that do not need this workaround
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            placeVideoObject: function (parent, forceExecute) {
                if (!forceExecute && _getDeviceAPI("id").getFirmwareYear() > 2011) {
                    console.warn("placeVideoObject() is a workaround method for 2011 devices or older, to fight the z-index problem!");
                    return;
                }
                if (!parent) {
                    console.error("Parent element of the video plugin object must be specified!");
                    return;
                }

                console.info("Moving samsung player plugin object..." + parent);

                if (parent.getRoot) { // this is component
                    parent = parent.getRoot();
                } else if (parent.nodeName) {
                    parent = new Element(parent);
                }

                this._plugin.parentNode.removeChild(this._plugin);

                if (this._pluginContainer) {
                    this._pluginContainer.detach();
                    this._pluginContainer = null;
                }

                //to ensure the container is removed from dom
                var containerEle = document.getElementById("SefPlayerContainer");
                if (containerEle) {
                    containerEle.parentNode.removeChild(containerEle);
                }

                this._pluginContainer = new Element("div", {
                    id: "SefPlayerContainer",
                    css: "playerContainer"
                }, parent);

                this._pluginContainer.getHTMLElement().innerHTML = "<object id='pluginSef' border=0 classid='clsid:SAMSUNG-INFOLINK-SEF' style='position:fixed;'></object>";
                this._plugin = this._pluginContainer.getHTMLElement().childNodes[0];
                this._plugin.Open("Player", "0001", "InitPlayer");
                globals.sefPlugin = this._plugin;
                this._plugin.OnEvent = "window.__sefOnEvent";
            },
            /**
             * set the window size
             * @param {Object} obj containing width, height, left, top of the screen
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            setWindowSize: function (obj) {

                if (!this._plugin) {
                    console.warn("[SefPlayer] Fail to set the size due to no player Object");
                    return;
                }

                var resolution = _getResolution(),
                    objClassName = "playerObject";

                //determine whether it is relative to parent which add a relative class with "position:relative"
                if (obj.relativeToParent) {
                    objClassName += " relative";
                }

                //determine whether it is fullscreen and add a fullscreen selector
                if (obj.width === resolution.width && obj.height === resolution.height) {
                    objClassName += " fullscreen";
                    if (this._pluginContainer) {
                        this._pluginContainer.addClass("fullscreen");
                    }
                } else {
                    if (this._pluginContainer) {
                        this._pluginContainer.removeClass("fullscreen");
                    }
                }

                this._plugin.className = objClassName;

                this._plugin.style.top = obj.top + "px";
                this._plugin.style.left = obj.left + "px";
                this._plugin.style.width = obj.width + "px";
                this._plugin.style.height = obj.height + "px";

                this.show();

                this._setPlayerSize(obj);
                this._currentWindowSize = obj;

                if (sMedia.isState(sMedia.PAUSED)) {
                    // to prevent the player from resuming on its own. Samsung is not to be trusted.
                    this._plugin.Execute("Pause");
                }
                console.info("Dispatch the size change event");
                this.dispatchEvent(this.constructor.EVT_SCREEN_SIZE_CHANGED, obj);
            },
            /**
             * Show the player
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            show: function () {
                if (this._plugin) {
                    this._plugin.style.visibility = "visible";
                }
            },
            /**
             * Hide the player
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            hide: function () {
                if (this._plugin) {
                    this._plugin.style.visibility = "hidden";
                }
            },
            /**
             * set the window size to be fullscrenn
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            setFullscreen: function () {
                var resolution = _getResolution();
                this.setWindowSize({
                    top: 0,
                    left: 0,
                    height: resolution.height,
                    width: resolution.width
                });
            },
            /**
             * set the player plugin size
             * @method
             * @protected
             * @param {object} obj the object of the dimension.
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _setPlayerSize: function (obj) {
                var pos, offset, coef, x, y, w, h, resolution = _getResolution();
                pos = {
                    x: obj.left,
                    y: obj.top
                };
                //if it is inside the container, the position will be updated with respect to its parent container when parent node is set.
                if (this._pluginContainer && (obj.width !== resolution.width || obj.height !== resolution.height)) {
                    offset = this._pluginContainer.cumulativeOffset();
                    if (offset.x) {
                        pos.x = offset.x;
                    }
                    if (offset.y) {
                        pos.y = offset.y;
                    }
                }
                if (this._plugin !== null) {
                    coef = 1;
                    x = pos.x;
                    y = pos.y;
                    w = obj.width;
                    h = obj.height;
                    if (_getDeviceAPI("id").getFirmwareYear() !== 2010) { // 2010 device should only use 1
                        coef = (resolution.width === 960 ? 1 : 960 / 1280);
                    }

                    this._plugin.Execute("SetDisplayArea", Math.round(x * coef), Math.round(y * coef), Math.round(w * coef), Math.round(h * coef));
                }
            },
            /**
             * Loads a media from a URL and prepares the media player before playing
             * @method
             * @param {String}  mediaUrlurl string of the media
             * @param {Object} [opts] Optional - extra prarameter needed
             * @param {String} [opts.drm] DRM technology to use
             * @param {String} [opts.type] media container format to use
             * @param {String} [opts.drmUrl] (Widevine || Playready || Verimatrix) Set the DRM license url
             * @param {String} [opts.userData] (Widevine) Set the user data
             * @param {String} [opts.deviceId] (Widevine)  the device id
             * @param {String} [opts.deviceTypeId] (Widevine)the device type id when using widevine
             * @param {String} [opts.drmCurTime] (Widevine) cur time param when using widevine
             * @param {String} [opts.iSeek] (Widevine) i-seek param when using widevine
             * @param {String} [opts.extraString] (Widevine) extra string param when using widevine
             * @param {String} [opts.portal] (Widevine)portal param when using widevine
             * @param {String} [opts.authCookiesUrl] (WMDRM) Set the url to get the authentication cookies
             * @param {String} [opts.customData] (PlayerReady) to set custom data
             * @param {String} [opts.startBitrate] (PlayerReady) To set the initial bitrate for PlayReady e.g ("AVERAGE"/"LOWEST"/"HIGHEST"/"CHECK"/"532000")
             * @param {String} [opts.bitrate] (PlayerReady) Set bitrate range for PlayReady e.g ("305000~937000")
             * @param {String} [opts.skipBitrate] (PlayerReady) Set the bitrate value after skip for PlayReady e.g ("CHECK"/"LOWEST"/"AVERAGE"/"HIGHEST")
             * @param {String} [opts.cookie] (PlayerReady) Set the COOKIE information for PlayReady
             * @param {Number} [opts.timeOut] (PlayerReady) Set the Network timeout value(in seconds) for PlayReady
             * @param {Number} [opts.startFragment] (PlayerReady) Set the fragment in live streaming (e.g 5) startFragment
             * @param {String} [opts.startBitrate] (HLS || HAS) To set the initial bitrate e.g 2600000
             * @param {Number} [opts.bitratesFrom] (HLS || HAS) the lowest bitrate setting
             * @param {Number} [opts.bitratesTo] (HLS || HAS) the highest bitrate setting
             * @param {Boolean} [opts.use3d] true if to use 3D
             * @param {String} [opts.type3d] the type of 3D
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            load: function (mediaUrl, opts) {
                opts = opts || {};
                this._drm = opts.drm;
                this._type = opts.type;

                var component = "",
                    deviceId, iSeek, drmCurTime, drmUrl, extraString, userData, deviceType, bitrates, portal, tempStr;

                if (opts.parentNode) {
                    this.placeVideoObject(opts.parentNode, true);
                }

                if (opts.drm === "widevine") {
                    component = "WV";
                    deviceId = "60";
                    iSeek = "TIME";
                    drmCurTime = "PTS";
                    drmUrl = "";
                    extraString = "";
                    userData = "";
                    deviceType = "";
                    portal = "";

                    if (!util.isUndefined(opts.drmUrl)) {
                        drmUrl = opts.drmUrl;
                    }
                    if (!util.isUndefined(opts.deviceId)) {
                        deviceId = opts.deviceId;
                    }
                    if (!util.isUndefined(opts.iSeek)) {
                        iSeek = opts.iSeek;
                    }
                    if (!util.isUndefined(opts.drmCurTime)) {
                        drmCurTime = opts.drmCurTime;
                    }
                    if (!util.isUndefined(opts.extraString)) {
                        extraString = opts.extraString;
                    }
                    if (!util.isUndefined(opts.deviceTypeId)) {
                        deviceType = "|DEVICE_TYPE_ID=" + opts.deviceTypeId;
                    }
                    if (!util.isUndefined(opts.userData)) {
                        userData = "|USER_DATA=" + opts.userData;
                    }
                    if (!util.isUndefined(opts.portal)) {
                        portal = "|PORTAL=" + opts.portal;
                    }

                    mediaUrl += "|DRM_URL=" + drmUrl + "|DEVICE_ID=" + deviceId + "|I_SEEK=" + iSeek + "|CUR_TIME=" + drmCurTime + userData + portal + extraString + deviceType + "|COMPONENT=" + component;

                    console.info("Sef Player: widevine turned on");

                } else if (opts.drm === "wmdrm") {
                    component = "WMDRM";
                    if (opts.authCookiesUrl && this._authCookiesUrl !== opts.authCookiesUrl) {
                        this._authCookiesUrl = opts.authCookiesUrl;
                        console.info("Sef Player: send a request to get the cookies");
                        ajax.request(opts.authCookiesUrl, {
                            method: "GET",
                            async: false,
                            onSuccess: util.bind(function (transport) {
                                if (transport.getResponseHeader("Set-Cookie")) {
                                    this._cookie = transport.getResponseHeader("Set-Cookie");
                                    _getDeviceAPI("storage").set("accedoDRMCookie", this._cookie);
                                    _getDeviceAPI("storage").save();
                                    console.info("Sef Player: get the set-cookies in response:" + this._cookie);
                                } else {
                                    _getDeviceAPI("storage").load();
                                    if (_getDeviceAPI("storage").get("accedoDRMCookie")) {
                                        this._cookie = _getDeviceAPI("storage").get("accedoDRMCookie");
                                    }
                                    console.info("Sef Player: no set cookie in response and try to get it from storage:" + this._cookie);
                                }

                                console.info("Sef Player: got cookie:" + this._cookie);
                            }, this),
                            onFailure: function (transport) {
                                //unable to get the response from the request and suppose to be wrong,throw error
                                console.error("Sef Player: fail to get the cookie" + transport);
                            }
                        });
                    } else {
                        //either already have no url or same url as before and then try to get the cookie from the storage
                        if (_getDeviceAPI("storage").get("accedoDRMCookie")) {
                            this._cookie = _getDeviceAPI("storage").get("accedoDRMCookie");
                        }

                        console.info("Sef Player: got cookie from storage:" + this._cookie);
                    }

                    mediaUrl += "|COMPONENT=" + component;

                    console.info("Sef Player: WMDRM turned on");

                } else if (opts.drm === "playready") {
                    tempStr = "";

                    if (opts.customData) {
                        this._playReadyCustomData = opts.customData;
                    }

                    if (opts.drmUrl) {
                        this._DRMServer = opts.drmUrl;
                    }

                    if (!util.isUndefined(opts.startBitrate)) {
                        tempStr += "|STARTBITRATE=" + opts.startBitrate;
                    }

                    if (!util.isUndefined(opts.bitrate)) {
                        tempStr += "|BITRATE=" + opts.bitrate;
                    }

                    if (!util.isUndefined(opts.skipBitrate)) {
                        tempStr += "|SKIPBITRATE=" + opts.skipBitrate;
                    }

                    if (!util.isUndefined(opts.cookie)) {
                        tempStr += "|COOKIE=" + opts.cookie;
                    }

                    if (!util.isUndefined(opts.timeOut)) {
                        tempStr += "|NETWORKTIMEOUT=" + opts.timeOut;
                    }

                    if (!util.isUndefined(opts.startFragment)) {
                        tempStr += "|STARTFRAGMENT=" + opts.startFragment;
                    }

                    mediaUrl += tempStr;

                    console.info("Sef Player: Sef Player: playReady turned on");

                }

                if (opts.type === "hls") {
                    component = "HLS";

                    bitrates = "";

                    if (opts.bitratesFrom && opts.bitratesTo && (opts.bitratesFrom) < (opts.bitratesTo)) {
                        bitrates += "|BITRATES=" + opts.bitratesFrom + "~" + opts.bitratesTo;
                    }

                    if (!util.isUndefined(opts.startBitrate)) {
                        bitrates += "|STARTBITRATE=" + opts.startBitrate;
                    }

                    mediaUrl += bitrates + "|COMPONENT=" + component;

                } else if (opts.type === "has" || opts.type === "dash") {
                    component = "HAS";

                    bitrates = "";

                    if (opts.bitratesFrom && opts.bitratesTo && (opts.bitratesFrom) < (opts.bitratesTo)) {
                        bitrates += "|BITRATES=" + opts.bitratesFrom + "~" + opts.bitratesTo;
                    }

                    if (!util.isUndefined(opts.startBitrate)) {
                        bitrates += "|STARTBITRATE=" + opts.startBitrate;
                    }


                    mediaUrl += bitrates + "|COMPONENT=" + component;
                }

                if (opts.drm === "verimatrix" && opts.type === "hls") {

                    mediaUrl += "|DRM_TYPE=VERIMATRIX";


                    console.info("__attemptPlay VERIMATRIX");

                    var serviceProvider = "";
                    var verimatrixProperties = "";

                    if (!util.isUndefined(opts.serviceProvider)) {
                        console.info("opts.serviceProvider is required by Verimatrix DRM");
                        serviceProvider = opts.serviceProvider;
                    }

                    if (!util.isUndefined(opts.iptvServerIp)) {
                        console.info("setting iptvServerIp " + opts.iptvServerIp);
                        verimatrixProperties += "i=" + opts.iptvServerIp;
                    }

                    if (!util.isUndefined(opts.webServerIp)) {
                        console.info("setting webServerIp " + opts.webServerIp);
                        verimatrixProperties += "|w=" + opts.webServerIp;
                    }

                    console.info("Sef Player: Initializing Verimatrix with data: serviceProvider:" + serviceProvider + " properties:" + verimatrixProperties);

                    this._plugin.Open("DRM", "1.000", "DRM");

                    var response = this._plugin.Execute("Initialize", 3, serviceProvider, verimatrixProperties);

                    console.info("DRM plugin initialization response: " + response);

                }

                if (opts.use3d) {
                    this._is3d = true;
                    this._3dType = "sideBySide";

                    if (opts.type3d) {
                        this._3dType = opts.type3d;
                    }
                } else {
                    this._is3d = false;
                    this._3dType = "off";
                }

                //if it is audio type,no matter whether it set the window size before,it will also change back to 0,0,0,0
                if (!util.isUndefined(opts.type) && opts.type === "mp3") {
                    this._currentWindowSize = this.AUDIO_SIZE;
                    this.setWindowSize(this._currentWindowSize);
                }

                this.url = mediaUrl;
                return mediaUrl;
            },
            /**
             * play the media
             * @method
             * @param {Object} opts object containing the options
             * @param {Number} opts.sec Play the video at the specified second
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            play: function (opts) {
                //disable the screen saver when playing
                _getDeviceAPI("system").setScreenSaver(false);
                console.info("Sef Player: play requested with url " + this.url);
                var playResult = this.__attemptPlay(opts);
                if (playResult === -1 || playResult === "-1" || playResult === false) {
                    sMedia._onError(PLAYBACK_ERRORS.GENERIC.LOAD);
                    return false;
                }

                //only change state when the video is stopped
                if (sMedia.isState(sMedia.STOPPED)) {
                    sMedia._onConnecting();

                    //create the connection timeout
                    this.show();
                    this.__createConnectionTimeout();
                }

                //Carry out 3D handling for 2011 devices
                if (this._is3d && _getDeviceAPI("id").getFirmwareYear() >= 2011) {
                    console.info("Sef Player: turning on 3D mode");
                    if (this._current3dType !== this._3dType) {
                        this._previous3dType = this._current3dType;
                    }
                    this._current3dType = this._3dType;

                    if ((globals.pluginObject3D.Flag3DEffectSupport && globals.pluginObject3D.Flag3DEffectSupport() === 1) || (globals.pluginObject3D.Flag3DTVConnect && globals.pluginObject3D.Flag3DTVConnect() === 1)) {

                        if (this._3dType === "sideBySide") {
                            this._plugin.SetPlayerProperty(2, "3", 1);
                        }

                    }
                }
                return playResult;
            },
            /**
             * Really calls plugin object to play the media
             * @method
             * @param {Object} opts object containing the options
             * @param {Number} [opts.sec] Play the video at the specified second
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __attemptPlay: function (opts) {
                var ret, sec;
                opts = opts || {};
                sec = opts.sec || 0;

                // if the media is already playing, don't have to start playback
                // (reset playback speed to 1 if it is not)
                switch (sMedia.getState()) {

                case sMedia.PLAYING:
                case sMedia.SPEEDING:

                    if (!util.isUndefined(opts.sec)) {
                        this.seek(opts.sec);
                    }

                    console.info("[XDK] AVPlayer set the playback speed to 1 when pressing play");

                    if (this._playbackSpeed !== 1) {
                        this.speed(1);
                    }

                    return;

                case sMedia.PAUSED:

                    if (!util.isUndefined(opts.sec)) {
                        this.seek(opts.sec);
                    }
                    this.resume();

                    return;
                }

                // need to init player before setting screen size
                ret = this._plugin.Execute("InitPlayer", this.url);

                // some devices will make the video fullscreen when finished playback
                // so reset the window size to counter that glitch
                if (this._currentWindowSize) {
                    console.info("Sef Player: set the window size to " + this._currentWindowSize.width + "x" + this._currentWindowSize.height);
                    this.setWindowSize(this._currentWindowSize);
                }

                // playback from stopped
                this._withHoldingStop = false;
                this._playbackSpeed = 1;
                this._curTime = 0;
                this._duration = 0;
                this.__infoReady = false;

                //XDK-3174 ignore the checking on 2012 TV for extra buffering when playing with seconds
                if (_getDeviceAPI("id").getFirmwareYear() > 2012) {
                    this.__ignoreFirstBuffering = !!sec;
                }

                console.info("Sef Player: will play from the beginning");

                if ("wmdrm" === this._drm) {
                    if (this._cookie) {
                        this._plugin.Execute("SetPlayerProperty", 1, this._cookie, this._cookie.length);
                        console.info("Sef Player: set the cookies to the player" + this._cookie);
                    }
                } else if ("playready" === this._drm) {

                    console.info("Sef Player: play PlayReady: " + this.url);

                    if (this._playReadyCustomData) {
                        this._plugin.Execute("SetPlayerProperty", 3, this._playReadyCustomData, this._playReadyCustomData.length);
                        console.info("Sef Player: set the custom data" + this._playReadyCustomData);
                    }

                    if (this._DRMServer) {
                        this._plugin.Execute("SetPlayerProperty", 4, this._DRMServer, this._DRMServer.length);
                        console.info("Sef Player: set the DRMServer " + this._DRMServer);
                    }

                }

                return this.__startPlayback(sec);
            },

            /**
             * Starts playback on the native player plugin.
             *
             * @method
             * @private
             * @param {Number} [sec]  Starting position of the playback. If not specified, the plugin would determine the position.
             * @returns {Number} The playback result code, -1 if failed.
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __startPlayback: function (sec) {
                try {
                    if (util.isNumber(sec)) {
                        return this._plugin.Execute("StartPlayback", sec);
                    } else {
                        return this._plugin.Execute("StartPlayback");
                    }
                } catch (e) {
                    console.error("Play Ready Error: " + e.message);
                    return -1;
                }
            },
            /**
             * pause the video item
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            pause: function () {
                var ret = this.__doPause(),
                    pauseTries = 0;

                //change the state 
                sMedia._onPause();

                //enable the screen saver when it is paused
                _getDeviceAPI("system").setScreenSaver(true);

                //No need to retry if pauses successfully
                if (ret) {
                    return;
                }

                //remove the previous timer
                if (this.__pauseTimer) {
                    clearInterval(this.__pauseTimer);
                }

                //XDK-2842, it fails to pause in the early stage, so keep trying several times(max:10 times/2s) to make sure pause successfully.
                this.__pauseTimer = setInterval(util.bind(function () {

                    // Stop to retry again if more than 10 times
                    if (pauseTries > this.constructor.PAUSE_RETRY) {
                        console.warn("Fail to pause " + pauseTries + " times");
                        clearInterval(this.__pauseTimer);
                        return;
                    }

                    if (!sMedia.isState(sMedia.PAUSED)) {
                        console.debug("No need to further pause since it is not in pause state");
                        clearInterval(this.__pauseTimer);
                        return;
                    }

                    if (this.__doPause()) {
                        console.debug("paused successfully");
                        clearInterval(this.__pauseTimer);
                        return;
                    }

                    console.debug("wait for the next pause");
                    pauseTries++;

                }, this), this.constructor.PAUSE_INTERVAL);
            },
            /**
             * pause the video action
             * @method __doPause
             * @returns {Boolean} True if it pauses successfully.
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __doPause: function () {
                return this._plugin.Execute("Pause") === 1;
            },
            /**
             * stop the video item
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            stop: function () {
                console.info("Sef player: stop requested");

                this.hide();
                this._stopPlayback();
                sMedia._onStopped();
                return true;
            },
            /**
             * stop the video playback for real
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _stopPlayback: function () {
                console.info("Sef Player: stop action enforced");
                if (this._plugin !== null) {

                    if (this._is3d && _getDeviceAPI("id").getFirmwareYear() >= 2011) {
                        console.info("Sef Player: turn on 3D mode");

                        if ((globals.pluginObject3D.Flag3DEffectSupport && globals.pluginObject3D.Flag3DEffectSupport() === 1) || (globals.pluginObject3D.Flag3DTVConnect && globals.pluginObject3D.Flag3DTVConnect() === 1)) {

                            this._plugin.Execute("SetPlayerProperty", 2, "3", 0);

                        }
                    }

                    this._plugin.Execute("Stop");
                    //XDK-2845 Timing issue with finished event and trying to update player object.  Added delay to wait until object is available again.
                    util.delay(0.5).done(util.bind(this.hide, this));
                }

                this.__removeConnectionTimeout();

                this._curTimeReported = false; // reset as no current playback time reported by plugin
                //enable the screen saver when it is stopped
                _getDeviceAPI("system").setScreenSaver(true);
            },
            /**
             * create the connection time out
             * @method  __createConnectionTimeout
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __createConnectionTimeout: function () {
                this.connectionTimer = core.getGuid();
                console.info("Sef Player: create connection timeout");
                util.delay(this._connectionTimeLimit, this.connectionTimer).then(util.bind(function () {
                    console.info("Sef Player: connection timeout");
                    this._onConnectionTimeout();
                }, this)).done();
            },
            /**
             * remove connection timeout
             * @method __removeConnectionTimeout
             * @private
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            __removeConnectionTimeout: function () {
                //remove the connection time out when stop
                if (this.connectionTimer) {
                    util.clearDelay(this.connectionTimer);
                    console.info("Sef Player: remove connection timeout");
                    this.connectionTimer = null;
                }
            },
            /**
             * resume the video item
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            resume: function () {
                this._plugin.Execute("Resume");

                // disable the screen saver when resume playing
                _getDeviceAPI("system").setScreenSaver(false);

                sMedia._onPlaying();

                if (this._playbackSpeed !== 1) {
                    this._playbackSpeed = 1;
                    this._plugin.Execute("SetPlaybackSpeed", this._playbackSpeed);
                }
            },
            /**
             * seek to a specific time
             * @method
             * @param {Number} sec the number of second you want to seek to (in sec)
             * @memberof xdk-ext-device-samsung/SefPlayer#
             * @public
             */
            seek: function (sec) {
                //workaround to seek when speeding.
                if (sMedia.isState(sMedia.SPEEDING)) {
                    sec = Math.max(sec, 1);
                }
                //get current time in sec
                var curTime = this.getCurTime();
                this.skip(sec - curTime);
            },
            /**
             * skip the video for a few second
             * @method
             * @param {Number} sec number of second to skip (10 by default)
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            skip: function (sec) {
                //Note: haven't been test for non progressive usage.
                var boundaryTime = 1,
                    curTime = this.getCurTime(),
                    duration = this.getDuration();

                if (!sec) {
                    return;
                }

                //3000 because some video(http://av.vimeo.com/44206/716/14097677.mp4?aksessionid=5ac5cb7b639a84db8c1fd46388ca4b20&token=1361333279_7b2482145462029a47655992e4df9289) is unable to jumpForward properly on 2012BDP/2012TV.
                //If less than 3000, some videos will not jump but dispatch onRenderComplete event
                //To summarize, here is my testing result 1:04 video and 1000s
                //on 2010 TV will go to 0:58 and play so it doesn't matter on the boundary case
                //on 2011 TV will go properly and go to 1:03s and then play
                //on 2012 TV/BDP will go back to the previous skip time and then play a few second then suddenly jump to 1:04 then stop. So if set to 3s,it can jump successfully to the desired time and play.
                if (_getDeviceAPI("id").getFirmwareYear() === 2012) {
                    boundaryTime = 3;
                }


                if (curTime + sec > duration - boundaryTime) { // make sure do not skip outside of boundary
                    sec = duration - boundaryTime - curTime;
                } else if (curTime + sec < 0) {
                    sec = -curTime;
                }
                if (_getDeviceAPI("id").getFirmwareYear() <= 2011 && this._type !== "hls") {
                    sec = Math.ceil(sec * 0.95);
                    console.info("Sef Player: Trying to correct skip gap... gap is now:" + sec);
                }
                console.debug("Sef Player: Skip with gap: " + sec);
                if (!sec) { // request a 0 second jump to device does work well!
                    return;
                }
                if (sec < 0) {
                    this._plugin.Execute("JumpBackward", Math.round(sec) * -1);
                } else {
                    this._plugin.Execute("JumpForward", Math.round(sec));
                }
            },
            /**
             * set the playback speed of the media
             * @method
             * @param {Number} speed speed number, better to be multiple of 2 and within -16 to 16
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            speed: function (speed) {
                // does not work on paused state as well
                if (sMedia.isState(sMedia.PAUSED)) {
                    this._plugin.Execute("Resume");
                }

                // speeding in HLS and DASH disabled since it is not possible due to device limitation
                if (this._type === "hls" || this._type === "dash") {
                    console.warn("Sef Player:Speeding during HLS playback is not supported by device!");
                    //since it resume and change back to the state for playing
                    sMedia._onPlaying();
                    return;
                }

                speed = Math.floor(speed);

                if (speed > 16) {
                    speed = 16;
                }
                if (speed < -16) {
                    speed = -16;
                }

                this._playbackSpeed = speed;
                //Warning: not all device and media type would support this function
                if (speed === 1) {
                    this._plugin.Execute("SetPlaybackSpeed", 1);
                    sMedia._onPlaying();
                    return;
                }

                this._plugin.Execute("SetPlaybackSpeed", speed);
                sMedia._onSpeeding();
            },
            /**
             * get bitrate and available bitrates
             * @method
             * @return {ax/device/interface/Player~MediaBitrates}
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            getBitrates: function () {
                if (this._currentBitrate === null || this._availableBitrates === null) {
                    return false;
                }

                return {
                    currentBitrate: this._currentBitrate,
                    availableBitrates: this._availableBitrates
                };
            },
            /**
             * get and return playbackSpeed
             * @method
             * @return {Number} playback speed
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            getPlaybackSpeed: function () {
                return this._playbackSpeed;
            },
            /**
             * set the current time
             * @method
             * @param {Number} time current time in milliseconds
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _setCurTime: function (time) {
                var curBitrate, availBitrateString, sortNumeric, availBitrate, i;

                console.info("Sef Player: set current time to:" + time);
                this._curTime = time;
                sMedia._onTimeUpdate(time / 1000);

                //3D handling for 2010 devices
                //@TODO
                /*
                     if (id.getFirmwareYear() < 2011) {
                     if (time > 0 && time < 5000 && this._is3d) {
                     console.info("Sef Player: turn on 3D mode");
                     
                     //set 3d type
                     if (this._current3dType !== this._3dType) {
                     //check whether it is 2d to 3d or off currently
                     current3dEffect = globals.pluginObject3D.Get3DEffectMode();
                     if (current3dEffect === 7) {
                     this._current3dType = "2dTo3d";
                     }else{
                     this._current3dType = "off";
                     }
                     this._previous3dType = this._current3dType;
                     }
                     this._current3dType = this._3dType;
                     
                     accedo.device.threeD.switch3DmodeFor2010Device();
                     
                     } else if(time > 0 && time < 5000  && !this._is3d && this._current3dType === 2) {
                     console.info("Sef Player: turn off 3D mode");
                     console.info("Sef Player: previous3D: " + this._previous3dType + " currentMode: " + this._current3dType);
                     if (this._previous3dType === "2dTo3d") {
                     this._previous3dType =  this._current3dType;
                     this._current3dType = "2dTo3d";
                     } else {
                     this._previous3dType = this._current3dType;
                     this._current3dType = "off";
                     }
                     
                     accedo.device.threeD.switch3DmodeFor2010Device();
                     console.info("Sef Player: after >> previous3D: " + this._previous3dType + " currentMode: " + this._current3dType);
                     }
                     }*/

                if (sMedia.isState(sMedia.BUFFERING) || sMedia.isState(sMedia.STOPPED) || sMedia.isState(sMedia.PAUSED)) {
                    return;
                }

                //upagte bitrates
                curBitrate = this._plugin.Execute("GetCurrentBitrates");

                if (typeof curBitrate === "number") {
                    this._currentBitrate = parseInt(curBitrate, 10);
                }
                availBitrateString = this._plugin.Execute("GetAvailableBitrates");

                sortNumeric = function (a, b) {
                    return Number(a) - Number(b);
                };

                if (typeof availBitrateString === "string") {
                    availBitrate = availBitrateString.split("|");
                    for (i = 0; i < availBitrate.length - 1; i++) {
                        availBitrate[i] = parseInt(availBitrate[i], 10);
                    }
                    this._availableBitrates = availBitrate.sort(sortNumeric);
                }
            },
            /**
             * Returns the current time (0 if never played)
             * @method
             * @param {boolean} seconds When true, the return value is in seconds
             * @returns {Integer|false} current time in milliseconds (or seconds according to the 'seconds' param)
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            getCurTime: function () {
                return Math.floor(this._curTime / 1000);
            },
            /**
             * set the total time by reading the media's duration. It will be called when the media is loaded
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _setDuration: function () {
                this._duration = this._plugin.Execute("GetDuration");
            },
            /**
             * get total time of the media
             * @method
             * @public
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            getDuration: function () {
                return Math.floor(this._duration / 1000);
            },
            /**
             * function to be triggered by the plugin player when the current playback time is progressing
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onCurrentPlayTime: function (time) {
                this._setCurTime(time);
                if (this._curTimeReported) {
                    return;
                }
                console.info("Sef Player: plugin reported current playback time for the first time.");
                this._curTimeReported = true; // indicate current playback time has been reported by plugin
            },
            /**
             * function to be triggered by the plugin player when the stream is not found
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onStreamNotFound: function () {
                console.info("Sef Player: onStreamNotFound");
                //enable the screen saver since it is not playing any video
                _getDeviceAPI("system").setScreenSaver(true);
                sMedia._onError(PLAYBACK_ERRORS.NETWORK.FILE);
            },
            /**
             * function to be triggered when the connection is timed out
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onConnectionTimeout: function () {
                console.info("Sef Player: onConnectionTimeout");
                // this._stopPlayback(); //Ho: yet to decide use _stopPlayback or not

                //enable the screen saver since it is not playing any video
                _getDeviceAPI("system").setScreenSaver(true);
                sMedia._onError(PLAYBACK_ERRORS.NETWORK.TIMEOUT);
            },
            /**
             * function to be triggered by the plugin player when the connection is failed
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onConnectionFailed: function () {
                console.info("Sef Player: onConnectionFailed");
                this._stopPlayback();
                sMedia._onError(PLAYBACK_ERRORS.NETWORK.FAILED);
            },
            /**
             * function to be triggered by the plugin player when there is rendering error
             * @method
             * @param {Number} param the parameter
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onRenderError: function (param) {
                console.info("Sef Player: onRenderError " + param);
                this._stopPlayback();
                sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, null, param);
            },
            /**
             * function to be triggered by the plugin player when there is custom error from external plugin like widevine
             * @method
             * @param {Integer} error code ID
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onUnknownEvent: function (eventType, param1, param2) {
                console.info("Sef Player: onUnknownEvent " + eventType + "with the following parameters" + param1 + "," + param2);
            },
            /**
             * function to be triggered by the plugin player when there is authentication failure
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onAuthenticationFailed: function () {
                console.info("Sef Player: [xdk Samsung] onAuthenticationFailed ");
                this._stopPlayback();
                sMedia._onError(PLAYBACK_ERRORS.DRM.FAILED);
            },
            /**
             * function to be triggered by the plugin player the network is disconnected
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onNetworkDisconnected: function () {
                console.info("Sef Player: [xdk Samsung] nNetworkDisconnected ");

                //as video playback cannot be resumed/recovered. Stop the playback.
                this._stopPlayback();

                sMedia._onError(PLAYBACK_ERRORS.NETWORK.DISCONNECTED);
            },
            /**
             * function to be triggered by the plugin player when the media rendering is complete
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onRenderingComplete: function () {
                this._stopPlayback();
                sMedia._onFinish();
            },
            /**
             * function to be triggered by the plugin player when the buffering is in progress
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onBufferingProgress: function () {
                //ignore the first buffering
                if (this.__ignoreFirstBuffering) {
                    return;
                }

                if (this._withHoldingStop === true) {
                    console.info("Sef Player: carry out withholding stop action");
                    this.stop();
                    this._withHoldingStop = false;
                    return;
                }

                sMedia._onBufferingProgress();
            },
            /**
             * function to be triggered by the plugin player when the buffering is started
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onBufferingStart: function () {
                //XDK-2851 If playing with second, it will undergo extra buffering stage, so ignore the first buffering stage.
                //And handle the actual buffering in the second time.
                //XDK-3174 There is no extra buffering state when playing with second, so ignore the check case above.
                if (this.__ignoreFirstBuffering) {
                    return;
                }

                if (this._withHoldingStop === true) {
                    console.info("Sef Player: carry out withholding stop action");
                    this.stop();
                    this._withHoldingStop = false;
                    return;
                }

                sMedia._onBufferingStart();
            },
            /**
             * function to be triggered by the plugin player when the buffering is completed
             * @method
             * @protected
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            _onBufferingComplete: function () {
                //unlock the blocking on the first buffering.
                if (this.__ignoreFirstBuffering) {
                    this.__ignoreFirstBuffering = false;
                    return;
                }

                sMedia._onBufferingFinish();

                if (sMedia.isState(sMedia.STOPPED)) {
                    return;
                }

                var self = this;

                // hackish workaround for 2010 BDP refuses to start playback (bug XDK-322)
                if (_getDeviceAPI("id").getHardwareType() === IId.HARDWARE_TYPE.BD && _getDeviceAPI("id").getFirmwareYear() === 2010 && !this._curTimeReported) {
                    console.info("Sef Player: 2010 BDP playback failure detection in effect!");
                    util.delay(function () {
                        if (!self._curTimeReported) { // still not start playback at device side
                            console.info("Sef Player: 2010 BDP playback failure detected! Work-around action taken!");
                            self.pause();
                            self.resume();
                        } else {
                            console.info("Sef Player: 2010 BDP playback success detected! Work-around action not taken.");
                        }
                    }, 1.5);
                }
            },
            /**
             * Get back the path
             * @method
             * @public
             * @return {String} the path of the player
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            getId: function () {
                return this.__id;
            },
            /**
             * set the id of the player
             * @method
             * @public
             * @param {String} id the path of the player
             * @memberof xdk-ext-device-samsung/SefPlayer#
             */
            setId: function (id) {
                this.__id = id;
            }
        });
    return sefClass;
});
/**
 * Override problematic areas of XDK SefPlayer implementation, and potentially extend others.
 *
 * @class tvedemo/ext/device/samsung/SefPlayer
 * @extends ax/ext/device/samsung/SefPlayer
 */
define("tvedemo/ext/device/samsung/SefPlayer", [
    "xdk-ext-device-samsung/SefPlayer",
    "xdk-base/class",
    "xdk-base/device/Media",
    "xdk-base/console",
    "xdk-base/Element",
    "xdk-base/core",
    "xdk-base/util",
    "tvedemo/ext/device/samsung/globals"
    ], function (
    sefPlayer,
    klass,
    Media,
    console,
    Element,
    core,
    util,
    globals
    ) {

        "use strict";

        var sMedia = Media.singleton();

        function _getDeviceAPI(api) {
            var device = amd.require("xdk-base/device");
            return device[api];
        }

        return klass.create(sefPlayer, {}, {
            /**
             * Playready error codes.
             * @type {Object}
             * @memberOf tvedemo/ext/device/samsung/SefPlayer
             */
            _playReadyErrorTable: {

                // 2012 always throw error -2147172273, -1 = unknown.
                "-2147172273": -1,
                "-2147170812": 0x8004c604,
                "-2147170811": 0x8004c605,

                // 2014 throws error 24586 when it receives join domain error from server.
                "24586": 0x8004c605
            },

            /**
             * More human readable translations of Samsung playready error codes.
             * @type {Object}
             * @memberOf tvedemo/ext/device/samsung/SefPlayer
             */
            _playReadyErrorTableReadable: {

                // 2012 Always gives the same errorCode.
                "-2147172273": "unknown_server_error",
                "-2147170812": "internal_server_error",
                "-2147170811": "join_domain",
                "24586": "join_domain"
            },

            /**
             * Counter to make sure that join domain request loops does not occur.
             * @type {Number}
             * @memberOf tvedemo/ext/device/samsung/SefPlayer
             */
            joinDomainAttempts: 0,

            /**
             * Time to wait for a second more desriptive error message in case an error with undefined error code is received (30 seconds).
             * @type {Number}
             * @memberOf tvedemo/ext/device/samsung/SefPlayer
             */
            undefinedErrorTimeout: 30000,

            init: function(devicePackage) {
                this._super(devicePackage);

                this._pluginPlayReady = globals.sefPlayreadyPlugin;

                // Override window.__sefOnEvent of ax/ext/device/samsung/SefPlayer to make sure that playready events is also handled.
                var xdkSefOnEvent = window.__sefOnEvent;

                window.__sefOnEvent = util.bind(function __sefOnEvent(eventType, eventInformation, extraEventInformation) {

                    switch (eventType) {
                        case 100:

                            // Event type 100 is a playready event.
                            this._onPlayReadyError(eventInformation);
                            break;
                        default:
                            xdkSefOnEvent && xdkSefOnEvent(eventType, eventInformation, extraEventInformation);
                            break;
                    }
                }, this);

                this.__stateChangeHandler = util.bind(function (stateChange) {

                    // Playback has started to work.
                    // Any actions taken to other errors has solved the issue that cause the unknown error,
                    // don't propagate the unkown error to the UI.
                    if ((stateChange && stateChange.toState !== sMedia.STOPPED) && this.__unknownPlayreadyErrorTimeout) {

                        console.log("state changed clear unknown error timoeout");
                        clearTimeout(this.__unknownPlayreadyErrorTimeout);

                        // Enable handling of aftercoming unknown playready errors.
                        this.__unknownPlayreadyErrorTimeout = null;
                    }

                }, this);
                sMedia.addEventListener(sMedia.EVT_STATE_CHANGED, this.__stateChangeHandler);
            },

            /**
             * Loads media from an URL and prepares the media player before playing.
             * @param {String}  mediaUrlurl string of the media
             * @param {Object} [opts] Optional - extra prarameter needed
             * @param {String} [opts.drm] DRM technology to use
             * @param {String} [opts.type] media container format to use
             * @param {String} [opts.drmUrl] (Widevine || Playready || Verimatrix) Set the DRM license url
             * @param {String} [opts.userData] (Widevine) Set the user data
             * @param {String} [opts.deviceId] (Widevine)  the device id
             * @param {String} [opts.deviceTypeId] (Widevine)the device type id when using widevine
             * @param {String} [opts.drmCurTime] (Widevine) cur time param when using widevine
             * @param {String} [opts.iSeek] (Widevine) i-seek param when using widevine
             * @param {String} [opts.extraString] (Widevine) extra string param when using widevine
             * @param {String} [opts.portal] (Widevine)portal param when using widevine
             * @param {String} [opts.authCookiesUrl] (WMDRM) Set the url to get the authentication cookies
             * @param {String} [opts.customData] (PlayerReady) to set custom data
             * @param {String} [opts.startBitrate] (PlayerReady) To set the initial bitrate for PlayReady e.g ("AVERAGE"/"LOWEST"/"HIGHEST"/"CHECK"/"532000")
             * @param {String} [opts.bitrate] (PlayerReady) Set bitrate range for PlayReady e.g ("305000~937000")
             * @param {String} [opts.skipBitrate] (PlayerReady) Set the bitrate value after skip for PlayReady e.g ("CHECK"/"LOWEST"/"AVERAGE"/"HIGHEST")
             * @param {String} [opts.cookie] (PlayerReady) Set the COOKIE information for PlayReady
             * @param {Number} [opts.timeOut] (PlayerReady) Set the Network timeout value(in seconds) for PlayReady
             * @param {Number} [opts.startFragment] (PlayerReady) Set the fragment in live streaming (e.g 5) startFragment
             * @param {Number} [opts.bitratesFrom] (HLS || HAS) the lowest bitrate setting
             * @param {Number} [opts.bitratesTo] (HLS || HAS) the highest bitrate setting
             * @param {Boolean} [opts.use3d] true if to use 3D
             * @param {String} [opts.type3d] the type of 3D
             * @return {String} url of the media.
             * @memberof tvedemo/ext/device/samsung/SefPlayer
             */
            load: function(mediaUrl, opts) {
                var url;

                opts = opts || {};

                this.joinDomainAttempts = 0;

                if (opts.serviceId) {
                    this._serviceId = opts.serviceId;
                    this._serviceIdFormat = opts.serviceIdFormat;
                    this._denseServiceId = opts.denseServiceId;
                }

                url = this._super(mediaUrl, opts);

                return url;
            },

            /**
             * Really calls plugin object to play the media
             * @method
             * @param {Object} opts object containing the options
             * @param {Number} [opts.sec] Play the video at the specified second
             * @private
             * @memberof ax/ext/device/samsung/SefPlayer#
             */
            __attemptPlay: function(opts) {
                var ret, sec;
                opts = opts || {};
                sec = opts.sec || 0;

                this._playOptions = opts;

                console.warn("Using patched SefPlayer __attemptPlay()");

                if (sMedia.isState(sMedia.PAUSED)) {
                    return this.resume();
                }

                // some devices will make the video fullscreen when finished playback
                // so reset the window size to counter that glitch
                if (this._currentWindowSize) {
                    console.log("[XDK] setting the window size!!");
                    this.setWindowSize(this._currentWindowSize);
                }

                ret = this._plugin.Execute("InitPlayer", this.url);

                if (sec && "wmdrm" !== this._drm && "playready" !== this._drm) {
                    console.log("Sef Player: playback at certain position");
                    return this._plugin.Execute("StartPlayback", sec);
                }

                if (sMedia.isState(sMedia.PLAYING) || sMedia.isState(sMedia.SPEEDING)) {
                    console.log("Sef Player: only resetting playback speed");
                    if (this._playbackSpeed !== 1) {
                        return this.speed(1);
                    }
                    return true;
                }

                // playback from stopped
                this._withHoldingStop = false;
                this._playbackSpeed = 1;
                this._curTime = 0;
                this._duration = 0;
                this.__infoReady = false;


                console.log("Sef Player: will play from the beginning");

                if ("wmdrm" === this._drm) {

                    if (this._cookie) {
                        this._plugin.Execute("SetPlayerProperty", 1, this._cookie, this._cookie.length);
                        console.log("Sef Player: set the cookies to the player" + this._cookie);
                    }

                    try {
                        return this._plugin.Execute("StartPlayback", sec);
                    } catch (e) {
                        console.error("WMDRM Error: " + e.message);
                        return false;
                    }

                }

                if ("playready" === this._drm) {
                    console.log("Sef Player: using PlayReady: " + this.url);

                    if (this._playReadyCustomData) {
                        this._plugin.Execute("SetPlayerProperty", 3, this._playReadyCustomData, this._playReadyCustomData.length);
                        console.log("Sef Player: set the custom data" + this._playReadyCustomData);
                    }

                    if (this._DRMServer) {
                        this._plugin.Execute("SetPlayerProperty", 4, this._DRMServer, this._DRMServer.length);
                        console.log("Sef Player: set the DRMServer " + this._DRMServer);
                    }

                    try {
                        return this._plugin.Execute("StartPlayback", sec);
                    } catch (e) {
                        console.error("Play Ready Error: " + e.message);
                        return false;
                    }
                }

                console.warn("Fixing drop through");

                try {
                    return this._plugin.Execute("StartPlayback", sec);
                } catch (e) {
                    console.error("StartPlayback: " + e.message);
                    return false;
                }
            },

            /**
             * Function to be triggered by the plugin player when there is a playready error.
             * @function _onPlayReadyError
             * @return {void}
             */
            _onPlayReadyError: function(playreadyError) {

                console.log("Encountered playready error: " + playreadyError);

                if (!playreadyError && !this.__unknownPlayreadyErrorTimeout) {

                    console.log("unknown playready error received, start unkown error timoeout");

                    this.__unknownPlayreadyErrorTimeout = setTimeout(util.bind(function () {

                        this._stopPlayback();
                        sMedia._onError({
                            errorCode: "SEFPlayer:unknownPlayreadyError",
                            errorMessage: "Sef player encountered an unknown playready error"
                        });

                    }, this), this.undefinedErrorTimeout);

                    return;
                }

                // If a better error code is received, don't care about the undefined error any more.
                if (this.__unknownPlayreadyErrorTimeout) {

                    console.log("received a more proper error, stop unknown error timeout");
                    clearTimeout(this.__unknownPlayreadyErrorTimeout);

                    // Enable handling of aftercoming unknown playready errors.
                    this.__unknownPlayreadyErrorTimeout = null;
                }

                var errorCode = this._playReadyErrorTable[playreadyError],
                    errorMessage = this._playReadyErrorTableReadable[playreadyError];

                if ((errorMessage === "join_domain" || errorMessage === "unknown_server_error") && this.joinDomainAttempts < 1) {
                    this.joinDomain();

                } else {
                    this._stopPlayback();
                    sMedia._onError({
                        errorCode: errorCode,
                        errorMessage: errorMessage
                    });
                }
            },

            /**
             * Playready only function, join domain. Defaults to current data set.
             * @function joinDomain
             * @param domainController {String} The URL to the domainController
             * @param dsId            {String} The id for the service
             * @param accountId        {String}
             * @param customData       {String} customdata to send in GET format (eg. assetID=123&license=false)
             * @return                 {void}
             */
            joinDomain: function(domainController, dsId, accountId, customData, dsIdFormat) {

                if (this.joinDomainAttempts >= 1) {
                    return;
                }

                this._plugin.Execute("Stop");

                this.joinDomainAttempts++;

                domainController = domainController || this._DRMServer;

                accountId = accountId || null;
                customData = customData || this._playReadyCustomData;

                var firmwareYear = _getDeviceAPI("id").getFirmwareYear(),
                    firmware,
                    isRequiredFirmwareVersion;

                if (firmwareYear === 2014) {

                    firmware = _getDeviceAPI("id").getSamsung2014Firmware();
                    isRequiredFirmwareVersion = _getDeviceAPI("id").checkIfSamsung2014FirmwareIsAllowed(firmware);

                    if (isRequiredFirmwareVersion) {
                        dsId = dsId || this._serviceId;
                        dsIdFormat = dsIdFormat || this._serviceIdFormat;

                        console.log("dsId: " + dsId);
                        console.log("dsIdFormat: " + dsIdFormat);

                        this._pluginPlayReady.Open("PlayReadyDrm",  "1.000",  "PlayReadyDrm");
                        this._pluginPlayReady.Execute("JoinDomain", domainController, "{" + dsId + "}",  "{" + dsIdFormat + "}", customData, customData.length);

                        this._pluginPlayReady.Close();

                        this.play(this._playOptions);

                    } else {
                        sMedia._onError("SEFPlayer:firmwareUpgradeRequired", "Firmware upgrade required");
                    }

                } else {
                    dsId = dsId || this._denseServiceId;

                    console.log("dsId: " + dsId);

                    this._pluginPlayReady.Open("PlayReadyDrm",  "1.000",  "PlayReadyDrm");
                    var xmlInitiator = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                                        "<PlayReadyInitiator xmlns=\"http://schemas.microsoft.com/DRM/2007/03/protocols/\">" +
                                             "<JoinDomain>" +
                                                "<DomainController>" + domainController + "</DomainController>" +
                                                "<DS_ID>" + dsId + "</DS_ID>" +
                                                (accountId ? "<AccountID>" + accountId + "</AccountID>" : "") +
                                             "<CustomData>" + customData + "</CustomData>" +
                                             "</JoinDomain>" +
                                        "</PlayReadyInitiator>";
                    this._pluginPlayReady.Execute("ProcessInitiatorsFromXml",  xmlInitiator, xmlInitiator.length);

                    this._pluginPlayReady.Close();

                    this.play(this._playOptions);
                }
            },

            deinit: function () {
                this._playOptions = {};
                sMedia.removeEventListener(sMedia.EVT_STATE_CHANGED, this.__stateChangeHandler);

                this._super();
            }
        });
    });
/**
 * MultipleAudioTrackStgy Interface is to provide multiple audio track function for media like play ready smooth streaming.
 * 
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * --------- | ---------
 * Key:    | device.multiAudioTrackStgy
 * Desc    | To set the multiAudioTrackStgy to the specific video player
 * Type    | String
 * Default  | (NA)
 * Usage | {@link module:xdk-base/config}
 * @class xdk-ext-device-samsung/DevicePackage
 * @extends ax/device/AbstractDevicePackage
 * @name MultipleAudioTrackStgy
 * @class xdk-base/device/interface/MultipleAudioTrackStgy
 * @example
 * //in the xdk.config.js
 * "device.multiAudioTrackStgy": {
 *       "xdk-ext-device-samsung/SefPlayer": "xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy",
 *       "xdk-ext-device-ps3/PSPlayer": "xdk-ext-device-ps3/PSPlayerMultiAudioTracksStgy"
 *       "xdk-ext-device-playstation/PSPlayer": "xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy"
 * }
 *
 * //in the usage part
 * sMedia.getAudioTracks().then(function(tracks){
 *   if(tracks.length>0){
 *       sMedia.setAudiotrack(tracks[0]); // set the audio track to be first one.
 *       sMedia.getAudioTrackAttr(tracks[0], MultipleAudioTrackStgy.LANGCODE, "eng"); //get the langCode of the first audio track.
 *   }
 * },function(){
 *     //no audio track supports or fail to get the audio tracks
 * });
 *
 * sMedia.getCurrentAudioTrackId().then(function(id){
 *     //get the current audio track id, It may be null since some devices may not able to get the current track id at the first time.
 * })
 *
 */
define("xdk-base/device/interface/MultipleAudioTrackStgy", ["xdk-base/Interface"], function(Interface) {
    "use strict";
    var MultipleAudioTrackStgy = Interface.create("MultipleAudioTrackStgy", {
        /**
         * Get ids of Audio Tracks.
         * @method getAudioTracks
         * @public
         * @returns {Promise.<String[]>} id The id of the track which is mainly for switching the audio track via setAudioTrack
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} unsupported feature
         * @memberof xdk-base/device/interface/MultipleAudioTrackStgy
         */
        getAudioTracks: [],
        /**
         * Set audio track by id
         * @method setAudioTrack
         * @public
         * @param {String} id The id of the audio track
         * @returns {Promise.<Boolean>} Return the result after call in a promise
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} missing parameter.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} unsupported
         * @memberof xdk-base/device/interface/MultipleAudioTrackStgy
         */
        setAudioTrack: ["id"],
        /* Get audio track attribute
         * @method getAudioTrackAttr
         * @public
         * @param {String} id The id of the audio track
         * @param {String} attr The attribute name {@link xdk-base/device/interface/MultipleAudioTrackStgy.LANGCODE}
         * @param {String} defaultValue The default value of the attribute
         * @returns {Promise.<String>} return the retrieved value or default value if unable to find on the device and given that default value
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} no correct id
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof xdk-base/device/interface/MultipleAudioTrackStgy
         */
        getAudioTrackAttr: ["id", "attr", "defaultValue"],
        /* Get current audio track id
         * @method getCurrentAudioTrackId
         * @public
         * @returns {Promise.<String|null>} The id of the audio track. Some audio track is unable to obtain the current track id, it will return null.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof xdk-base/device/interface/MultipleAudioTrackStgy
         */
        getCurrentAudioTrackId: []
    });
    /**
     * The language code according to <http://en.wikipedia.org/wiki/ISO_639> and return the 3 digit code
     * @name LANGCODE
     * @constant
     * @type {String}
     * @memberof xdk-base/device/interface/MultipleAudioTrackStgy
     */
    MultipleAudioTrackStgy.LANGCODE = "LANGCODE";

    return MultipleAudioTrackStgy;

});
/**
 * Id class to handle the device information like firmware version
 * @class xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy
 * @augments ax/device/interface/MultipleAudioTrackStgy
 */
define("xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy", ["xdk-base/class", "xdk-base/console", "xdk-base/device/interface/MultipleAudioTrackStgy", "xdk-base/promise", "xdk-base/core", "xdk-base/util", "xdk-base/exception"], function(klass, console, MultipleAudioTrackStgy, promise, core, util, exception) {
    "use strict";
    var SefMultiAudioTracks = klass.create([MultipleAudioTrackStgy], {}, {
        /**
         * player instance
         * @name __player
         * @private
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        __player: null,
        /**
         * store the current audio track id
         * @name __currentAudioTrackId
         * @private
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        __currentAudioTrackId: null,
        /**
         *
         * @method
         * @param {Object} player the player instance that will use this multi audio track strategy
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        init: function(player) {
            //since it need the player state and do some checking and thus linking them.
            this.__player = player;
        },
        /**
         * Get ids of Audio Tracks. It will delay 10s when the info is not ready yet.
         * Tested on Samsung 2013 devices only which support playready.
         * @method
         * @public
         * @returns {Promise.<String[]>} A list of audio track object with id
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        getAudioTracks: function() {
            console.info("[XDK SEF] getting the audio track information and current state of metadata: " + this.__player.__infoReady);

            if (!this.__player.__infoReady) {
                //since the data is not ready yet, then delay 10s to check again
                console.info("[XDK SEF] Delay 10s to get the audio track info again");
                return util.delay(10).then(util.bind(this.getAudioTracks, this));

            }

            var noOfAudioStream, audioTracksArr, i;

            console.info("[XDK SEF] Start getting the info for audio track");

            noOfAudioStream = this.__player._plugin.Execute("GetTotalNumOfStreamID", 1);

            console.info("[XDK SEF] " + noOfAudioStream + " audio track(s) is(are) found.");

            audioTracksArr = [];

            for (i = 0; i < noOfAudioStream; i++) {
                //it depends on the video itself.
                //convert the id into string to ensure the standard of string type id
                audioTracksArr.push(i.toString());

                console.info("[XDK SEF] Audio Track " + i);
            }

            console.info("[XDK SEF]Audio Tracks: " + audioTracksArr);

            return promise.resolve(audioTracksArr);

        },
        /**
         * Set audio track by id
         * @method
         * @public
         * @param {String} id The id of the audio track
         * @returns {Promise.<Boolean>} Return the result after call in a promise
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} wrong formated parameter.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} player is not ready yet
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        setAudioTrack: function(id) {
            if (!this.__player.__infoReady) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Sef player is not ready yet."));
            }

            this.__currentAudioTrackId = id;

            if (util.isString(id)) {
                id = parseInt(id, 10);
            }

            console.info("[XDK SEF]Set stream ID to: " + id);

            this.__player._plugin.Execute("SetStreamID", 1, id);
            return promise.resolve(true);
        },
        /**
         * Set audio track by id
         * @method
         * @public
         * @param {String} id The id of the audio track
         * @param {String} attr The media audio track attribute {@link xdk-base/device/interface/MultipleAudioTrackStgy#LANGCODE}
         * @returns {Promise.<String>} Return the result of the property
         * @throws {Promise.<module:xdk-base/exception.ILLEGAL_ARGUMENT>} wrong formated parameter.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} player is not ready yet
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        getAudioTrackAttr: function(id, attr, defaultValue) {
            if (!this.__player.__infoReady) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Sef player is not ready yet."));
            }

            if (util.isString(id)) {
                id = parseInt(id, 10);
            }

            switch (attr) {
                case MultipleAudioTrackStgy.LANGCODE:
                    //sample "eng|audio_eng"
                    return promise.resolve(this.__player._plugin.Execute("GetStreamLanguageCode", "1", id).split("|")[0]);
                default:
                    if (!util.isUndefined(defaultValue)) {
                        return promise.resolve(defaultValue);
                    }
            }
            //return reject if no available value for attr and no default Value
            return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "No available attribute"));
        },
        /* Get current audio track id
         * @method getCurrentAudioTrackId
         * @public
         * @returns {Promise.<String|null>} The id of the audio track. Some audio track is unable to obtain the current track id, it will return null.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof xdk-ext-device-samsung/SefPlayerMultiAudioTracksStgy#
         */
        getCurrentAudioTrackId: function() {
            return promise.resolve(this.__currentAudioTrackId);
        }
    });
    return SefMultiAudioTracks;
});
/**
 * PrivilegedAPI will store those functions that are unable to pass the security check
 * @class xdk-ext-device-samsung/PrivilegedAPI
 */
define("xdk-ext-device-samsung/PrivilegedAPI", ["xdk-base/class", "xdk-ext-device-samsung/globals", "xdk-base/console"], function (klass, Global, console) {
    "use strict";
    return klass.create({
        /**
         * get SDI_ID is unable to pass the security check on 2P012,
         * @private
         * @memberof xdk-ext-device-samsung/PrivilegedAPI#
         */
        _getSDIID: function () {
            //to avoid the missing plugin
            if (!Global.NNaviPlugin || !Global.NNaviPlugin.GetFirmware) {
                return false;
            }

            if (parseInt(Global.NNaviPlugin.GetFirmware().substr(10, 4), 10) >= 2011) {
                try {
                    var result = Global.widevinePlugin.GetSDI_ID();
                    if (result !== "ERROR") {
                        console.debug("[XDK] widevine sdi_id: " + result);
                        return result;
                    }
                } catch (e) {
                    console.warn("[XDK] error to get widevine sdi_id: ");
                }
            }
            return false;
        },
        /**
         * get widevine ESN is unable to pass the security check on 2012,
         * @private
         * @memberof xdk-ext-device-samsung/PrivilegedAPI#
         */
        _getESN: function () {
            try {
                var result = Global.widevinePlugin.GetESN("WIDEVINE");
                console.debug("[XDK] Get the widevine ESN " + result);
                return result;

            } catch (e) {
                console.warn("[XDK] error to get widevine ESN " + this.__widevineESN);
            }
            return false;
        }
    }, {});
});
/**
 * Detection of tizen by checking the tizen object. Return true if it is tizen
 * @module xdk-ext-device-tizen/detection
 */
define("xdk-ext-device-tizen/detection", [], function () {
    "use strict";
    var detection = (function () {
        //tizen.tv doesn't appear on the private sdk, so checking on the tizen.tv is ignored
        //http://www.samsungdforum.com/TizenGuide/?FolderName=tizen201&FileName=index.html
        //Mozilla/5.0(Linux;Tizen 2.3) AppleWebKit/538.1 (KHTML, like Gecko)Version/2.3 TV Safari/538.1
        return typeof tizen !== "undefined";
    })();
    return detection;
});
/**
 * The browser device package
 * @class xdk-base/device/shared/browser/DevicePackage
 * @augments ax/device/interface/DevicePackage
 */
define("xdk-base/device/shared/browser/DevicePackage", [
    "xdk-base/class",
    "xdk-base/core",
    "xdk-base/console",
    "xdk-base/device/playerRegistry",
    "xdk-base/device/interface/Player",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/promise",
    "require",
    "xdk-base/device/interface/DevicePackage",
    "xdk-base/device/basicInterfaces"
], function (
    klass, 
    core, 
    console, 
    playerRegistry,
    IPlayer,
    util,
    config,
    promise,
    require,
    IDevicePackage,
    basicInterfaces
) {
    "use strict";
    var devicePackage = klass.createAbstract([IDevicePackage], {}, {
        
        setup: function(onDeviceLoaded) {
            this.__onDeviceReady = onDeviceLoaded;
            console.info("set up abstractDevicePackage");
            core.root.onunload = this.deinit;

            return this;
        },
        /**
         * To get the unique indicator for each device package
         * @return {String} the id name e.g workstation
         *
         * @method getId
         * @abstract
         * @memberof xdk-base/device/shared/browser/DevicePackage#
         */
        getId: klass.abstractFn,
        /**
         * To get the default player. Default will be [] array.
         * @method getDefaultPlayer
         * @returns {String[]} Array of the player list
         * @memberof xdk-base/device/shared/browser/DevicePackage#
         */
        getDefaultPlayer: function () {
            return [];
        },
        /**
         * To unlod the playerRegistry and deinit all the player
         * @method deinit
         * @memberof xdk-base/device/shared/browser/DevicePackage#
         */
        deinit: function () {
            var device = require("xdk-base/device");

            console.info("[XDK] DOM Unloaded");

            playerRegistry.deinit();
            
            //deinit device module
            device.deinit();
        }
    });
    return devicePackage;
});
/**
 * TvKey class to handle the key
 *
 * ###Configuration Parameters
 *
 *  Attribute | Value
 * --------- | ---------
 * Key:    | device.tizen.tvkey.registerExitKey
 * Desc    | determines whether to register the Exit key
 * Type    | Boolean
 * Default  |  true
 * Usage | {@link module:xdk-base/config}
 *
 * @class xdk-ext-device-tizen/TvKey
 * @augments ax/device/shared/browser/TvKey
 */
define("xdk-ext-device-tizen/TvKey", [
    "xdk-base/device/shared/browser/TvKey",
    "xdk-base/class",
    "xdk-base/device/vKey",
    "xdk-base/util",
    "xdk-base/device/shared/browser/keyMap",
    "xdk-base/console",
    "require",
    "xdk-base/config"
], function (
    browserTvKey,
    klass,
    VKey,
    util,
    keyMap,
    console,
    require,
    config
) {
    "use strict";
    return klass.create(browserTvKey, {
        /**
         * @name CH_UP
         * @property {String} id Virtual Key ID. "tizen:vkey:chup"
         * @memberof xdk-ext-device-tizen/TvKey
         */
        CH_UP: {
            id: "tizen:vkey:chup"
        },
        /**
         * @name CH_DOWN
         * @property {String} id Virtual Key ID. "tizen:vkey:chdown"
         * @memberof xdk-ext-device-tizen/TvKey
         */
        CH_DOWN: {
            id: "tizen:vkey:chdown"
        },
        /**
         * @name TOOLS
         * @property {String} id Virtual Key ID. "tizen:vkey:tools"
         * @memberof xdk-ext-device-tizen/TvKey
         */
        TOOLS: {
            id: "tizen:vkey:tools"
        },
        /**
         * @name INFO
         * @property {String} id Virtual Key ID. "tizen:vkey:info"
         * @memberof xdk-ext-device-tizen/TvKey
         */
        INFO: {
            id: "tizen:vkey:info"
        },
        /**
         * @name GUIDE
         * @property {String} id Virtual Key ID. "tizen:vkey:guide"
         * @memberof xdk-ext-device-tizen/TvKey
         */
        GUIDE: {
            id: "tizen:vkey:guide"
        },
        /**
         * @name MTS
         * @property {String} id Virtual Key ID. "tizen:vkey:mts"
         * @memberof xdk-ext-device-tizen/TvKey
         */
        MTS: {
            id: "tizen:vkey:mts"
        },
        /**
         * @name  MENU
         * @property {String} id Virtual Key ID. "tizen:vkey:menu
         * @memberof xdk-ext-device-tizen/TvKey
         */
        MENU: {
            id: "tizen:vkey:menu"
        },
        /**
         * @name  EXTRA
         * @property {String} id Virtual Key ID. "tizen:vkey:extra
         * @memberof xdk-ext-device-tizen/TvKey
         */
        EXTRA: {
            id: "tizen:vkey:extra"
        }
    }, {
        init: function () {
            var keyMapping = util.clone(keyMap.KEYBOARD_KEY, true),
                charMapping = util.clone(keyMap.KEYBOARD_CHAR, true),
                registerExitKey = config.get("device.tizen.tvkey.registerExitKey", true),
                targetSupportedKeys, i, supportedKeys;

            //target supported key mapping
            targetSupportedKeys = {
                //support the color keys
                "ColorF0Red": VKey.RED,
                "ColorF1Green": VKey.GREEN,
                "ColorF2Yellow": VKey.YELLOW,
                "ColorF3Blue": VKey.BLUE,

                //support the playback keys
                "MediaFastForward": VKey.FF,
                "MediaPause": VKey.PAUSE,
                "MediaPlay": VKey.PLAY,
                "MediaRewind": VKey.RW,
                "MediaStop": VKey.STOP,
                "MediaPlayPause": VKey.PLAY_PAUSE,
                //Next and Prev key on the TV screen remote doesn't work and not available to register, pending for the Samsung reply.
                "MediaTrackNext": VKey.NEXT,
                "MediaTrackPrevious": VKey.PREV,

                //Extra on the univeral remote control
                "Extra": this.constructor.EXTRA,

                //support functional keys (basic function keys and some keys that are available on the previous samsung device packages)
                // it may need to verify on the real devices whether it will block the default behaviour on TV.
                "Tools": this.constructor.TOOLS,
                "Back": VKey.BACK,
                "Info": this.constructor.INFO,
                "MTS": this.constructor.MTS,
                "Guide": this.constructor.GUIDE,
                "ChannelUp": this.constructor.CH_UP,
                "ChannelDown": this.constructor.CH_DOWN
            };

            if (registerExitKey) {
                targetSupportedKeys.Exit = VKey.EXIT;
            }

            //support the number keys
            for (i = 0; i < 10; i++) {
                targetSupportedKeys[i] = VKey["KEY_" + i];
            }

            //get the device supported keys which return an array of supported key from the device
            supportedKeys = tizen.tvinputdevice.getSupportedKeys();

            util.each(supportedKeys, function (supportedKey) {
                var keyObj = targetSupportedKeys[supportedKey.name];
                //register the keys when matching the target supported keys
                if (keyObj) {
                    tizen.tvinputdevice.registerKey(supportedKey.name);
                    keyMapping.VKey[supportedKey.code] = keyObj;
                }
            });

            //some keys are no need to register and directly map
            keyMapping.VKey[10009] = VKey.BACK;

            //XDK-2622 Added Numpad Enter key which is charCode 13.
            charMapping.VKey[13] = VKey.OK;

            //after register the keys, they are available to use on the window onkeydown
            this.initKeyMapping(keyMapping, charMapping);
        }
    });
});
/**
 * A native API loader plugin that is responsible to load tizen API files.
 *
 * The loader will return a the window.module name back.
 *
 * e.g `$WEBAPIS/webapis/webapis` will be automatically loaded and return window.webapis.
 *
 * // load the webapis
 * require(["xdk-ext-device-tizen/loader/nativeAPI!$WEBAPIS/webapis/webapis"], function (webapis) {
 *     // get the webapis apis
 *
 * });
 *
 * @module xdk-ext-device-tizen/loader/nativeAPI
 */
define('xdk-ext-device-tizen/loader/nativeAPI',[
    "xdk-ext-device-tizen/detection",
    "xdk-base/QueryString",
    "xdk-base/util"
], function (
    detection,
    QueryString,
    util
) {
    "use strict";
    var exports = {
        /**
         * If the plugin has a dynamic property set to true, then it means
         * the loader MUST NOT cache the value of a normalized plugin dependency,
         * instead call the plugin's load method for each instance of a plugin dependency.
         * @property {Boolean} dynamic
         * @memberof module:xdk-ext-device-tizen/loader/nativeAPI
         */
        dynamic: false,

        /**
         * pluginBuilder is a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build.
         * Without this property, the optimization WILL fail.
         * @see {@link http://requirejs.org/docs/plugins.html#apipluginbuilder}
         * @property {String} pluginBuilder
         * @memberof module:xdk-ext-device-tizen/loader/nativeAPI
         */
        pluginBuilder: "./nativeAPIBuilder"

    };

    var modules = {};
    /**
     * Instantiate the API object.
     * @private
     * @method
     * @param {String} name The API name
     * @returns {Object} The newly created API object
     * @memberof module:xdk-ext-device-samsung/loader/nativeAPI
     */

    function locateAPI(name) {
        var obj = window;

        // remove the place holder of the API name
        name = name.replace("$WEBAPIS/", "");
        name = name.split("/").pop();

        return obj[name];
    }

    /**
     * Load a resource.
     * Assuming the resource IDs do not need special ID normalization.
     * @method
     * @param {String} resourceId The resource ID that the plugin should load. This ID MUST be normalized.
     * @param {Function} require A local require function. Will not be used.
     * @param {Function} load A function to call once the value of the resource ID has been determined.
     * @param {Object} [opts] Option
     * @param {Function} [opts.onFailure] failure callback
     * @memberof module:xdk-ext-device-tizen/loader/nativeAPI
     */
    exports.load = function (resourceId, require, load, opts) {
        //Avoiding running this loading modules in optimized(concat) version
        if (!detection) {
            load({});
            return;
        }

        if (modules[resourceId]) {
            load(modules[resourceId]);
            return;
        }

        var path = resourceId;
        if (resourceId.lastIndexOf(".js") < (resourceId.length - 3)) {
            path = resourceId + ".js";
        }

        // require a *.js, no path resolving should be done
        // expecting nothing from the callback as the native API is not a module but a script with global object(s)
        require([path], function () {

            modules[resourceId] = locateAPI(resourceId);

            load(modules[resourceId]);
        }, opts.onFailure);
    };


    return exports;
});

/**
 * Id class to handle the device information like firmware version
 * @class xdk-ext-device-tizen/Id
 */
define("xdk-ext-device-tizen/Id", [
    "xdk-base/class",
    "xdk-base/device/interface/Id",
    "xdk-base/util",
    "xdk-base/promise",
    "xdk-base/console",
    "xdk-base/device/helper/storageUniqueId",
    "./loader/nativeAPI!$WEBAPIS/webapis/webapis"
], function (
    klass,
    IId,
    util,
    promise,
    console,
    storageUniqueId,
    webapis
) {
    "use strict";
    return klass.create([IId], {}, {
        /**
         * Get the MAC address.
         * @method getMac
         * @return {String} null when not available
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getMac: function () {
            return webapis.network.getMac();
        },
        /**
         * To return the device type
         * @method getDeviceType
         * @deprecated replaced with getHardwareType
         * @returns {ax/device/interface/Id.HARDWARE_TYPE} hardware type
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getDeviceType: function () {
            return this.getHardwareType();
        },
        /**
         * To return the hardware type
         * @method getHardwareType
         * @returns {ax/device/interface/Id.HARDWARE_TYPE} hardware type
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getHardwareType: function () {
            if (navigator.userAgent.indexOf("sdk") !== -1) {
                // an emulator
                return IId.HARDWARE_TYPE.EMULATOR;
            } else {
                // real device
                return IId.HARDWARE_TYPE.TV;
            }

        },
        /**
         * To get the version of the Web API in the [Major].[Minor] format.
         * @method getFirmware
         * @returns {String} the firmware version. Return "dummyFirmware" when no related information
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getFirmware: function () {
            return webapis.productinfo.getFirmware();
        },
        /**
         * Get the firmware year
         * @method getFirmwareYear
         * @memberof xdk-ext-device-tizen/Id#
         * @return {Number} Return 0 if not available.
         * @public
         */
        getFirmwareYear: function () {
            var smartTVServerVersion = webapis.productinfo.getSmartTVServerVersion(),
                year;

            if (util.isUndefined(smartTVServerVersion)) {
                return 0;
            }
            year = parseInt(smartTVServerVersion.substr(10, 4), 10);
            return isNaN(year) ? 0 : year;
        },
        /**
         * To get the device unique id
         * @method getUniqueID
         * @returns {String} the unique id
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getUniqueID: function () {
            return webapis.productinfo.getDuid();
        },
        /**
         * To get the device model
         * @method getModel
         * @returns {String} the model name of the current device. Return "dummyModel" when no information
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getModel: function () {
            return webapis.productinfo.getRealModel();
        },
        /**
         * To get the IPv4 address
         * @method getIP
         * @returns {String} the ip address. Return 0.0.0.0 when no available ip
         * @memberof xdk-ext-device-tizen/Id#
         * @public
         */
        getIP: function () {
            return webapis.network.getIp();
        }
    });
});
/**
 * System class to handle the system api and connection checking
 * @class xdk-ext-device-tizen/System
 * @augments ax/device/shared/Html5System
 */
define("xdk-ext-device-tizen/System", [
    "xdk-base/class",
    "xdk-base/device/shared/Html5System",
    "xdk-base/console",
    "xdk-base/promise",
    "xdk-base/util",
    "xdk-base/device/interface/System",
    "require",
    "./loader/nativeAPI!$WEBAPIS/webapis/webapis"
], function (
    klass,
    Html5System,
    console,
    promise,
    util,
    ISystem,
    require,
    webapis
) {
    "use strict";

    return klass.create(Html5System, {
        /**
         * To store the key id of the isPaused state in the device storage.
         * @name LIFE_CYCLE_IS_PAUSED
         * @constant
         * @memberof xdk-ext-device-tizen/System
         * @public
         */
        LIFE_CYCLE_IS_PAUSED: "__XDK:life-cycle-pause"
    }, {
        /**
         * To store the resolution size
         * @private
         * @name __resolution
         * @memberof xdk-ext-device-tizen/System#
         */
        __resolution: null,
        /**
         * To store the network status
         * @private
         * @name __online
         * @memberof xdk-ext-device-tizen/System#
         */
        __online: true,
        init: function () {
            this._super();

            var deferObj = promise.defer();

            this.__readyPromise = deferObj.promise;

            this.__online = this.__checkNetworkStatus();
            this.__addNetworkStateChangeListener();

            //XDK-2488 Since the window.innerWidth is affected by the meta content width size, 
            //used the internal api to get the absolute resolution independent of css and meta viewport
            tizen.systeminfo.getPropertyValue("DISPLAY", util.bind(function (displayInfo) {

                this.__resolution = {
                    width: displayInfo.resolutionWidth,
                    height: displayInfo.resolutionHeight
                };

                deferObj.resolve(true);

            }, this));

        },
        /**
         * to handle when visibility change, and store the life cycle status
         * @method _onVisibilityChange
         * @protected
         * @memberof xdk-ext-device-tizen/System#
         */
        _onVisibilityChange: function (e) {

            var _document = this._getDocument(),
                visibility = this._getVisibility(),
                device = require("xdk-base/device");

            if (_document[visibility.hidden]) {
                device.storage.set(this.constructor.LIFE_CYCLE_IS_PAUSED, true);
            } else {
                device.storage.unset(this.constructor.LIFE_CYCLE_IS_PAUSED);
            }

            this._super(e);
        },
        /**
         * Eden Accelerator deep linking support
         * Obtain the launch parameter (if any) for the app
         * @method _fetchDeeplinkingData
         * @protected
         * @memberof xdk-ext-device-tizen/System#
         */
        _fetchDeeplinkingData: function () {
            var reqAppControl = tizen.application.getCurrentApplication().getRequestedAppControl(),
                launchData,
                actionData;

            if (!reqAppControl) {
                return null;
            }

            launchData = reqAppControl.appControl && reqAppControl.appControl.data;

            if (!launchData || !launchData.length || !launchData[0].value || !launchData[0].value.length) {
                return null;
            }

            // The Eden parameter is passed in the first item of the array
            actionData = launchData[0].value[0];

            try {
                actionData = util.parse(actionData);
            } catch(e) {
                actionData = null;
            }

            return actionData;
        },
        /**
         * To get the promise for the initialization
         * @method getInitPromise
         * @returns {module:xdk-base/promise}
         * @memberof xdk-ext-device-tizen/System#
         */
        getInitPromise: function () {
            return this.__readyPromise;
        },
        /**
         * Turn off the screen
         * @name powerOff
         * @method
         * @memberof xdk-ext-device-tizen/System#
         */
        powerOff: function () {
            //Turns off the screen// no api
            return false;
        },
        /**
         * Exit the application
         * @name exit
         * @method
         * @param {Object} [opts] the exit properties
         * @param {Boolean} [opts.toTV] whether exit or hide the application. True will exit the application and false will hide the application.
         * @memberof xdk-ext-device-tizen/System#
         */
        exit: function (opts) {
            if (!tizen.application) {
                return;
            }

            opts = opts || {
                toTV: true
            };

            if (opts.toTV) {
                tizen.application.getCurrentApplication().exit();
                return;
            }

            tizen.application.getCurrentApplication().hide();
        },
        /**
         * To get the display resolution
         * @public
         * @method
         * @name getDisplayResolution
         * @return {Object} object {width:1920,height:1080}
         * @memberof xdk-ext-device-tizen/System#
         */
        getDisplayResolution: function () {
            return this.__resolution;
        },
        /**
         * @public
         * @method supportSSL
         * @return {Boolean} True
         * @memberof xdk-ext-device-tizen/System#
         */
        supportSSL: function () {
            return true;
        },
        /**
         * Override the abstract system and return the current network status
         * @method getNetworkStatus
         * @return {Promise.<Boolean>}  Return the current network status
         * @public
         * @memberof xdk-ext-device-tizen/System#
         */
        getNetworkStatus: function () {
            return promise.resolve(this.__online);
        },
        /**
         * Handling the network status checking
         * @method __checkNetworkStatus
         * @return {Boolean} Return whether the device is connected to gateway
         * @private
         * @memberof xdk-ext-device-tizen/System#
         */
        __checkNetworkStatus: function() {
            var isConnected;
            try {
                isConnected = !!webapis.network.isConnectedToGateway();
            } catch (e) {
                console.warn("webapis.network.isConnectedToGateway() fails with error: " + e);
                isConnected = false;
            }
            return isConnected;
        },
        /**
         * Add event listener to network state change (whether connected to gateway) event
         * @method __addNetworkStateChangeListener
         * @private
         * @memberof xdk-ext-device-tizen/System#
         */
        __addNetworkStateChangeListener: function() {
            var networkApi = webapis.network,
                networkStates = networkApi.NetworkState || {};

            networkApi.addNetworkStateChangeListener(util.bind(function(states, data) {
                if (data === states.GATEWAY_CONNECTED) {
                    this.__online = true;
                } else if (data === states.GATEWAY_DISCONNECTED) {
                    this.__online = false;
                } else {
                    this.__online = this.__checkNetworkStatus();
                }

                this.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, this.__online);
            }, this, networkStates));
        },
        /**
         * To set the system mute
         * @public
         * @method setSystemMute
         * @param {Boolean} flag True if turn on the mute, false when turn off.
         * @memberof xdk-ext-device-tizen/System#
         */
        setSystemMute: function (flag) {
            if (tizen.tvaudiocontrol) {
                tizen.tvaudiocontrol.setMute(flag);
            }
        },
        /**
         * Has mouse on tizen
         * @public
         * @method hasMouse
         * @returns {Boolean}  Return true
         * @memberof xdk-ext-device-tizen/System#
         */
        hasMouse: function () {
            return true;
        },
        /**
         * Determine whether support cross domain ajax.
         * @method hasSOP
         * @return {Boolean} Return true if cross domain ajax is not allowed natively. Proxy / Allow-Origin header setup may be needed.
         * @memberof xdk-ext-device-tizen/System#
         */
        hasSOP: function () {
            return true;
        },
        /**
         * Setting the screen saver On/Off
         * @method setScreenSaver
         * @param {Boolean} flag True to turn on and off to turn off.
         * @return {Boolean}  Return false.
         * @memberof xdk-ext-device-tizen/System#
         */
        /*jshint unused:false*/
        setScreenSaver: function (flag) {
            var state = webapis.appcommon.AppCommonScreenSaverState,
                value = state.SCREEN_SAVER_OFF;

            if (flag) {
                value = state.SCREEN_SAVER_ON;
            }

            webapis.appcommon.setScreenSaver(value, function () {
                console.log("Set the screensaver to be active properly");
            }, function () {
                console.log("Fail to set the screensaver to be active.");
            });

            return true;
        },
        /*jshint unused:true*/
        /**
         * @method redraw
         * @param {HTMLElement} [element=document.body] the target element. Default will be document.body
         * @param {Boolean} false when not support
         * @memberof xdk-base/device/tizen/System#
         */
        /*jshint unused:false*/
        redraw: function (element) {
            return false;
        },
        /*jshint unused:true*/
        /**
         * @method hasFixedKeyboard
         * @return {Boolean} Return false
         * @memberof xdk-ext-device-tizen/System#
         */
        hasFixedKeyboard: function () {
            return true;
        }
    });
});
/**
 * DevicePack class to handle the packaging for the tizen.
 * This device package is for the tizen web app and not support for tizen native app or Hybrid app.
 * Since it is based on the real device, it may not be compatible on emulator or simulator. (Refer XDK-2580 for more details)
 *
 * ###Media Player
 * * {@link xdk-ext-device-tizen/Html5Player}
 * Support format: MP4, ASF
 *
 * * {@link xdk-ext-device-tizen/AVPlayer}
 * Support format: MP4, HLS, ASF, Playready, widevine, Dash
 * Default: xdk-ext-device-tizen/AVPlayer
 *
 * ###External Files
 * External resources are available in src/res folder
 *
 * 1. config.xml - tizen use config.xml as a configuration file.
 * It can set the application(widget) name, version and privilege..etc.
 * Since the tizen device package access the device api, some privileges are set in the config.xml
 * Usage : Copy to the root folder (e.g src folder). Please make sure the location of the config.xml may conflict with the samsung config.xml
 * Reference : <https://developer.tizen.org/dev-guide/2.2.1/org.tizen.web.appprogramming/html/app_dev_process/set_widget_web.htm>
 *
 * ###Adopt, develop and package the tizen application
 *
 * 1. Obtain the Tizen IDE and set the security profiles (which is the author certificate) in the prefernces>Samsung TV SDK>Security Profiles
 * 2. Create a new Tizen Project with Basic template basic application
 * 3. Import the src folder
 * 4. Build the package to create the .wgt file
 *
 * ###Privilege
 * In order to make application working properly, Tizen device packge will include the following privileges.
 * If missing any privileges in the config.xml, it may fail to initialize the device package properly or block some usages.
 *
 * 1. "http://tizen.org/privilege/tv.inputdevice" To get the input and key event
 * 2. "http://developer.samsung.com/privilege/network.public" To get the network information and status
 * 3. "http://developer.samsung.com/privilege/productinfo" To get the device product information
 * 4. "http://tizen.org/privilege/tv.audio" To control the audio of the TV like mute
 * 5. "http://developer.samsung.com/privilege/drmplay" To support the drm for the AVPlayer, if it is not included, it will fail to play the drm.
 * 6. "http://developer.samsung.com/privilege/drminfo" To get the drm info when playing widevine drm.
 *
 * ###Configuration for the resource
 * XDK default config.xml for tizen won't set any access in the Content Security Policy.  Developers need to manually configure the permission in order  
 * to access the external resources like images, video, ajax, etc.  
 * Without setting those permission, application itself will fail to load external resources and materials.  
 * e.g If you are going to allow the permisson to allow all requests for specific domain, you can simply mention in the properties of config.xml    
 * <access origin="http://www.accedo.tv" subdomains="true"/>  
 * For more specific rules, you may also use `<tizen:content-security-policy>` property.  
 * Reference: <https://developer.tizen.org/dev-guide/2.2.1/org.tizen.web.appprogramming/html/basics_tizen_programming/web_security_privacy.htm#content>
 *
 * ###Configuration for Eden deep linking feature
 * In config.xml, we need to inform the Tizen OS of the accelerator endpoint url using <metadata> tag.
 * Example: <tizen:metadata key="accelerator_endpoint_url" value="https://myserver.com/accelerator.json"/>
 * For more details, please refer to the reference below.
 * Reference: <https://accedobroadband.jira.com/wiki/pages/viewpage.action?pageId=134481260>
 * 
 * ###Resources
 *
 * * <https://accedobroadband.jira.com/wiki/display/XDKDEV/Samsung+Tizen+TV>
 * * <https://accedobroadband.jira.com/wiki/pages/viewpage.action?pageId=68288776>
 * * <https://developer.tizen.org/>
 *
 *
 * @class xdk-ext-device-tizen/DevicePackage
 * @extends ax/device/AbstractDevicePackage
 * @author Thomas Lee <thomas.lee@accedo.tv>
 */
define("xdk-ext-device-tizen/DevicePackage", [
    "xdk-base/device/shared/browser/DevicePackage",
    "xdk-base/device/shared/LocalStorage",
    "xdk-ext-device-tizen/TvKey",
    "xdk-ext-device-tizen/Id",
    "xdk-ext-device-tizen/System",
    "xdk-base/device/Media",
    "xdk-base/class",
    "xdk-base/config",
    "xdk-base/util",
    "xdk-base/device/basicInterfaces",
    "xdk-base/promise"
], function (
    browserDevicePackage,
    LocalStorage,
    TvKey,
    Id,
    System,
    Media,
    klass,
    config,
    util,
    basicInterfaces,
    promise
) {
    "use strict";

    var system = new System(),
        id = new Id(),
        storage = new LocalStorage();

    return klass.create(browserDevicePackage, {}, {
        /**
         * To return platform id of this device package
         * @method
         * @return {String} the id name
         * @memberof xdk-ext-device-tizen/DevicePackage#
         * @protected
         */
        getId: function () {
            return "tizen";
        },
        /**
         * To setup the tizen device package and then call ready to invoke the device module
         * @method setup
         * @param {Function} onDeviceLoaded Device ready callback
         * @returns {ax/device/tizen/DevicePackage} device package itself.
         * @memberof xdk-ext-device-tizen/DevicePackage#
         * @protected
         */
        setup: function (onDeviceLoaded) {
            this._super(onDeviceLoaded);

            system.getInitPromise().then(util.bind(function () {
                var interfaces = this.__setupInterfaces(),
                    isPaused = storage.get(system.LIFE_CYCLE_IS_PAUSED, false),
                    deeplinkData = system._fetchDeeplinkingData();

                onDeviceLoaded(interfaces, {
                    isPaused: !!isPaused,
                    deeplinkData: deeplinkData
                });
            }, this)).done();
        },
        /**
         * To get the default player. Default will be {@link xdk-ext-device-tizen/Html5Player}
         * @method getDefaultPlayer
         * @returns {String[]} Array of the player list
         * @memberof xdk-ext-device-tizen/DevicePackage#
         */
        getDefaultPlayer: function () {
            return ["xdk-ext-device-tizen/AVPlayer"];
        },
        /**
         * To init each modules like id, sMedia, system and tvkey
         * @method __setupInterfaces
         * @memberof xdk-base/device/amazon/DevicePackage#
         * @private
         */
        __setupInterfaces: function () {
            var intfs = {};

            intfs[basicInterfaces.STORAGE] = storage;
            intfs[basicInterfaces.MEDIA_PLAYER] = Media.singleton();
            intfs[basicInterfaces.TV_KEY] = new TvKey();
            intfs[basicInterfaces.ID] = id;
            intfs[basicInterfaces.SYSTEM] = system;

            return intfs;
        },
        /**
         * To deinit the device pacakge
         * @method deinit
         * @protected
         * @memberof xdk-ext-device-tizen/DevicePackage#
         */
        deinit: function () {

            storage.unset(system.LIFE_CYCLE_IS_PAUSED);

            this._super();
        }
    });
});
/*globals webapis:true*/
/**
 * The avplayer using webapis.avplay which is the tizen player supported by samsung. It provides video playback
 * and support various drms and encryption.
 * @class ax/ext/device/tizen/AVPlayer
 */
define("tvedemo/ext/device/tizen/AVPlayer", [
    "xdk-base/class",
    "xdk-base/device/interface/Player",
    "xdk-base/exception",
    "xdk-base/core",
    "xdk-base/util",
    "xdk-base/config",
    "xdk-base/device/Media",
    "xdk-base/console",
    "xdk-base/Env"
], function (
    klass,
    IPlayer,
    exception,
    core,
    util,
    config,
    Media,
    console,
    Env
) {
    "use strict";
    var sMedia, avplayer, sEnv,
        resolution = null,
        getResolution = function () {
            resolution = resolution || require("xdk-base/device").system.getDisplayResolution();
            return resolution;
        },
        PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS,
        PLAYREADY_TYPE = "PLAYREADY",
        WIDEVINE_TYPE = "WIDEVINE";

    return klass.create([IPlayer], {}, {
        /**
         * To store the player id
         * @private
         * @name __id
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __id: null,
        /**
         * To store the status whether the object is prepared
         * @private
         * @name __prepared
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __prepared: false,
        /**
         * To determine whether the avplayer is loaded or not
         * @private
         * @name __loaded
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __loaded: false,
        /**
         * To store the status whether the player is connected
         * @private
         * @name __connected
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __connected: false,
        /**
         * Time out(sec) for the player connection
         * @private
         * @name __connectionTimeLimit
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __connectionTimeLimit: config.get("device.player.connection-timeout", 90),
        /**
         * Time out object for the player connection
         * @private
         * @name __connectionTimeOut
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __connectionTimeOut: null,
        /**
         * player current time
         * @private
         * @name __currentTime
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __currentTime: 0,
        /**
         * player playback speed
         * @private
         * @name __playbackSpeed
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __playbackSpeed: 1,
        /**
         * withhold play
         * @private
         * @name __withholdPlay
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __withholdPlay: false,
        /**
         * player seek time
         * @private
         * @name __seekTime
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __seekTime: 0,
        init: function () {
            sMedia = Media.singleton();
            sEnv = Env.singleton();
            if (!webapis || !webapis.avplay) {
                throw core.exception(core.createException(exception.ILLEGAL_STATE, "fail to load the avplayer api"));
            }
            avplayer = webapis.avplay;
        },
        /**
         * To get the capabilities of the player
         * @method getCapabilities
         * @returns {ax/device/interface/Player~PlayerCapabilites}
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        getCapabilities: function () {
            return {
                type: ["mp4", "asf", "hls", "has", "mp3", "dash"],
                drms: ["aes128", "playready", "widevine"]
            };
        },
        /**
         * to prepare the video and create the drm agent if necessary
         * @method prepare
         * @param {Object}  [opts]  extra prarameter needed for the URL
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        prepare: function (opts) {
            if (this.__prepared) {
                return;
            }

            opts = opts || {};

            if (!opts.parentNode) {
                opts.parentNode = document.body;
            }

            this.__parentNode = opts.parentNode;

            //prepare for the player obejct
            this.__playerContainer = document.createElement("div");
            this.__playerContainer.className = "playerContainer";
            this.__playerContainer.innerHTML = "<OBJECT id='av-player' type='application/avplayer' style='position:absolute;width:100%;height:100%;'></OBJECT>";

            this.__parentNode.appendChild(this.__playerContainer);

            this.__playerObject = document.getElementById("av-player");

            //set listener in the idle state

            var operationResult = avplayer.setListener({
                onbufferingstart: util.bind(this.__onBufferingStart, this),
                onbufferingprogress: util.bind(this.__onBufferingProgress, this),
                onbufferingcomplete: util.bind(this.__onBufferingComplete, this),
                oncurrentplaytime: util.bind(this.__onCurrentPlayTime, this),
                onevent: util.bind(this.__onEventCallback, this),
                onsubtitlecallback: util.bind(this.__onSubtitleCallback, this),
                ondrmevent: util.bind(this.__onDRMCallback, this),
                onerror: function(eventType) {
                    console.log("event type error : " + eventType);
                },
                onstreamcompleted: util.bind(this.__onFinished, this)
            });
            console.info("[avplayer.js][prepare] add listener result " + operationResult);

            this.__prepared = true;

            this.__handleResumeRef = util.bind(this.__handleResume, this);
            this.__handlePauseRef = util.bind(this.__handlePause, this);

            //handle the player suspend and restore
            sEnv.addEventListener(sEnv.EVT_ONRESUME, this.__handleResumeRef);
            sEnv.addEventListener(sEnv.EVT_ONPAUSE, this.__handlePauseRef);
        },
        /**
         * pause the avplayer when it is suspended.
         * @method __handlePause
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __handlePause: function () {
            if (avplayer.suspend) {
                avplayer.suspend();
            }
        },
        /**
         * restore the avplayer when it is resumed. If video was playing when it is paused, video will play from the last played url and time.
         * @method __handleResume
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __handleResume: function () {
            if (avplayer.restore && this.__loaded) {

                if (this.__drmOptions) {
                    avplayer.restore(this.__url, this.__currentTime, true);
                    avplayer.setDrm(this.__drmOptions.type, this.__drmOptions.prop, this.__drmOptions.drmString);

                    //this.__seekTime = this.__currentTime - 1;
                    
                    try {
                        avplayer.prepare();
                        avplayer.play();

                        sMedia.__multiAudioStgy.setAudioTrack(sMedia.__multiAudioStgy.__currentAudioTrackId);
                        
                        // This is needed to have sound re-appear.
                        this.seek(this.__currentTime - 1);
                    } catch(e) {
                        console.error(e);
                        this.__prepareFail(e);
                    }

                    //avplayer.prepareAsync(util.bind(this.__prepareSuccess, this), util.bind(this.__prepareFail, this));

                } else { // For trailer or non drm video we can just restore.
                    avplayer.restore();
                }
            }
        },
        /**
         * resets the video player, to non-playing mode
         * @method
         * @protected
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        reset: function () {
            this.__drmOptions = false;
            this.__hide();
            this.__parentNode.removeChild(this.__playerContainer);
            this.__prepared = false;
            this.__connected = false;
            this.__loaded = false;

            sEnv.removeEventListener(sEnv.EVT_ONRESUME, this.__handleResumeRef);
            sEnv.removeEventListener(sEnv.EVT_ONPAUSE, this.__handlePauseRef);
        },
        /**
         * perform the do Load which set the url and possible attributes with respect to the drm.
         * @method
         * @param {String} mediaUrl the media url
         * @param {Object} opts the media options
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __doLoad: function (mediaUrl, opts) {
            //from none state to idle state
            var operationResult = avplayer.open(mediaUrl),
                drmParam = {},
                drmParamString;

            console.info("[AVplayer.js][load] initialize the player result " + operationResult);

            if (opts.drm === "playready") {
                //try to set the configuration for the playready
                if (!util.isUndefined(opts.drmUrl)) {
                    drmParam.LicenseServer = opts.drmUrl;
                }

                if (!util.isUndefined(opts.customData)) {
                    drmParam.CustomData = opts.customData;
                }

                if (!util.isUndefined(opts.httpHeader)) {
                    drmParam.HttpHeader = opts.httpHeader;
                }

                if (!util.isUndefined(opts.soapHeader)) {
                    drmParam.soapHeader = opts.soapHeader;
                }

                if (!util.isUndefined(opts.cookie)) {
                    drmParam.Cookie = opts.cookie;
                }

                if (!util.isUndefined(opts.deleteLicenseAfterUse)) {
                    drmParam.DeleteLicenseAfterUse = opts.deleteLicenseAfterUse;
                }

                drmParamString = util.stringify(drmParam);

                //set the properties when it is not empty
                if (drmParamString !== "{}") {
                    avplayer.setDrm(PLAYREADY_TYPE, "SetProperties", drmParamString);
                    console.info("[AVPlayer.js][load] set the properties " + drmParamString + " for the playready");

                    this.__drmOptions = {
                        type: PLAYREADY_TYPE,
                        prop: "SetProperties",
                        drmString: drmParamString
                    };
                }

            } else if (opts.drm === "widevine") {

                var drmUrl = "",
                    iSeek = "",
                    drmCurTime = "",
                    userData = "",
                    portal = "",
                    deviceType = 60,
                    deviceId = webapis.drminfo.getEsn(WIDEVINE_TYPE);

                if (!util.isUndefined(opts.drmUrl)) {
                    drmUrl = opts.drmUrl;
                }

                if (!util.isUndefined(opts.iSeek)) {
                    iSeek = opts.iSeek;
                }
                if (!util.isUndefined(opts.drmCurTime)) {
                    drmCurTime = opts.drmCurTime;
                }

                if (!util.isUndefined(opts.userData)) {
                    userData = opts.userData;
                }

                if (!util.isUndefined(opts.portal)) {
                    portal = opts.portal;
                }

                if (!util.isUndefined(opts.deviceTypeId)) {
                    deviceType = opts.deviceTypeId;
                }

                drmParamString = "DEVICE_ID=" + deviceId + "|DEVICE_TYPE_ID=" + deviceType + "|STREAM_ID=|IP_ADDR=|DRM_URL=" + drmUrl + "|PORTAL=" + portal + "|I_SEEK=" + iSeek + "|CUR_TIME=" + drmCurTime + "|USER_DATA=" + userData;
                avplayer.setStreamingProperty(WIDEVINE_TYPE, drmParamString);
                console.info("[AVPlayer.js][load] set the properties " + drmParamString + " for the widevine");

            }
        },
        /**
         * to set the url and load the video
         * @method load
         * @param {String}  mediaUrl  url the URL address of the media
         * @param {Object}  [opts]  extra prarameter needed for the URL
         * @param {String} [opts.drm] DRM technology to use
         * @param {String} [opts.type] media container format to use
         * @param {String} [opts.drmUrl] (PlayReady|Widevine) Set the DRM license url
         * @param {String} [opts.cookie] (PlayReady) Set the COOKIE information for PlayReady
         * @param {String} [opts.customData] (PlayReady) to set custom data
         * @param {String} [opts.httpHeader] (PlayReady) add custom http header
         * @param {String} [opts.soapHeader] (PlayReady) add custom soap header
         * @param {String} [opts.deleteLicenseAfterUse] (PlayReady) Enable deletion of license after use.
         * @param {String} [opts.userData] (Widevine) Set the user data
         * @param {String} [opts.deviceTypeId] (Widevine)the device type id when using widevine
         * @param {String} [opts.drmCurTime] (Widevine) cur time param when using widevine
         * @param {String} [opts.iSeek] (Widevine) i-seek param when using widevine
         * @param {String} [opts.portal] (Widevine)portal param when using widevine
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        load: function (mediaUrl, opts) {
            //return when not prepared
            if (!this.__prepared) {
                return false;
            }

            if (this.__url !== mediaUrl) {
                try {
                    avplayer.close();
                } catch (ex) {
                    // AVPlayer state machine changed in firmware 1141
                    // means calling close too early will cause error
                    console.info("[AVplayer.js][load] Error occurred due to close being called too early");
                }
            }

            var operationResult;

            if (opts.parentNode && this.__parentNode !== opts.parentNode) {
                this.__parentNode.removeChild(this.__playerContainer);
                this.__parentNode = opts.parentNode;
                this.__parentNode.appendChild(this.__playerContainer);
            }

            this.__url = mediaUrl;
            this.__mediaOpts = opts;
            this.__connected = false;

            this.__type = opts.type || null;
            this.__drm = opts.drm || null;

            this.__doLoad(mediaUrl, opts);

            operationResult = avplayer.setTimeoutForBuffering(10);
            console.info("[AVplayer.js][load] set timeout for buffering result " + operationResult);

            //hide the object
            this.__hide();
            this.__loaded = true;
        },
        /**
         * to hide the player
         * @method __hide
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @private
         */
        __hide: function () {
            this.__playerContainer.style.visibility = "hidden";
        },
        /**
         * to show the player
         * @method __show
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @private
         */
        __show: function () {
            this.__playerContainer.style.visibility = "visible";
        },
        /**
         * to block the status change and handling when paused or speeding or stopped
         * @method __needStateChangeBlock
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @private
         */
        __needStateChangeBlock: function () {
            console.log("[AVPLAYER] - __state: " + sMedia.__state);
            if (sMedia.isState(sMedia.PAUSED) || sMedia.isState(sMedia.SPEEDING) || sMedia.isState(sMedia.STOPPED)) {
                return true;
            }
            return false;
        },
        /**
         * on buffering start callback
         * @method __onBufferingStart
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onBufferingStart: function () {
            if (this.__needStateChangeBlock()) {
                return;
            }

            if (sMedia.__state === sMedia.PLAYING || sMedia.__state === sMedia.PAUSED) {
                this.__lastPlayState = sMedia.__state;
            }

            sMedia._onBufferingStart();
            console.info("[AVPlayer.js][__onBufferingStart] buffering start");

            this.__removeConnectionTimeOut();
        },
        /**
         * on buffering progress callback
         * @method __onBufferingProgress
         * @param {Number} percent the percentage of the buffering progress
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onBufferingProgress: function (percent) {
            if (this.__needStateChangeBlock()) {
                return;
            }

            sMedia._onBufferingProgress(percent);
        },
        /**
         * buffering complete callback
         * @method __onBufferingComplete
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onBufferingComplete: function () {
            //delay the buffering complete when it is not yet connected/pr
            this.__delayBufferingComplete = !this.__connected;

            if (this.__needStateChangeBlock() || !this.__connected) {
                return;
            }

            this._onBufferingFinish();
        },

        /**
         * Should be calld when buffering has finished
         * @method
         * @protected
         * @memberof xdk-base/device/Media#
         */
        _onBufferingFinish: function () {
            if (sMedia.isState(sMedia.STOPPED)) {
                return;
            }

            //when skipping, the state turned into buffering complete, the previous state should be playing.
            //so after skipping, it should back to play state instead of buffering.

            //if previous state of buffering is connecting, it will change into play instead of.
            if (sMedia.__prevState === sMedia.CONNECTING || sMedia.__prevState === sMedia.BUFFERING) {
                sMedia._changeState(sMedia.PLAYING);
                return;
            }

            if (sMedia.__prevState === sMedia.SKIPPING) {
                console.log("[AVPLAYER] prevstate was skipping");
                sMedia.__prevState = this.__lastPlayState;
            }

            console.debug("change back to prev state" + sMedia.__prevState);
            sMedia._changeState(sMedia.__prevState);
        },
        /**
         * It will be fired the prepareAsync done callback after the first buffering complete
         * @method __prepareSuccess
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __prepareSuccess: function () {
            this.__connected = true;

            console.info("[AVPlayer.js][__prepareSuccess] prepare Success" + this.__seekTime + " - " + this.__withholdPlay);

            if (this.__seekTime > 0) {
                this.__withholdPlay = true;
                //XDK-2616 Fail to seekTo second in aes128, use jumpForward instead of seek.
                if (this.__drm === "aes128") {
                    avplayer.jumpForward(this.__seekTime * 1000);
                } else {
                    this.seek(this.__seekTime);
                }
                this.__seekTime = 0;
            }

            //to change the state into buffering complete which is delayed
            if (this.__delayBufferingComplete) {
                sMedia._onBufferingFinish();
            }

            if (this.__withholdPlay) {
                this.__withholdPlay = false;
                var playResult = avplayer.play();
                console.info("[AVPlayer.js][__prepareSuccess] play result " + playResult);
            }
        },
        /**
         * It will be fired the prepareAsync fail callback
         * @method __prepareFail
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __prepareFail: function (e) {
            console.log("------- __prepareFail --------- ", e);
            console.log(arguments);
            this.__stopPlayback();
            sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, "Fail to prepare the video", e);
        },
        /**
         * the current play time update callback
         * @method __onCurrentPlayTime
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onCurrentPlayTime: function (currentTime) {
            this.__currentTime = currentTime / 1000;
            sMedia._onTimeUpdate(this.getCurTime());
        },
        /**
         * the event callback
         * @method __onEventCallback
         * @param {String} eventType the type of event
         * @param {String} eventData data of the event
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onEventCallback: function (eventType, eventData) {
            console.info("[AVPlayer.js][__onEventCallback] Event type error : " + eventType + ", eventData: " + eventData);
        },
        /**
         * the subtitle event callback
         * @method __onSubtitleCallback
         * @param {Number} duration the time
         * @param {String} text of the subtitle
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onSubtitleCallback: function (duration, text, data3, data4) {
            console.info("[AVPlayer.js][__onSubtitleCallback] Subtitle Changed. Duration" + duration + " text : " + text + " data " + data3 + "; " + data4);
        },
        /**
         * the drm callback
         * @method __onDRMCallback
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onDRMCallback: function (drmEvent, drmData) {
            console.info("[AVPlayer.js][__onDRMCallback] DRM callback: " + drmEvent + ", data: " + drmData);
        },
        /**
         * called when the video finish
         * @method __onFinished
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onFinished: function () {
            console.info("[AVPlayer.js] onFinish");
            this.__stopPlayback();
            sMedia._onFinish();
        },
        /**
         * stop the play
         * @method __stopPlayback
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __stopPlayback: function () {
            var stopResult;
            //pause the player and avoid the on time update event
            try {
                stopResult = avplayer.stop();
            } catch (ex) {
                console.info("[AVPlayer.js][__stopPlayback] failed with exception: " + ex);
            }
            
            console.info("[AVPlayer.js][__stopPlayback] call stop" + stopResult);
            this.__hide();

            //reset the witholdPlay to avoid the video to be played when buffering complete.
            this.__withholdPlay = false;

            //remove the connection time out when stop the playback
            this.__removeConnectionTimeOut();

            this.__connected = false;
            this.__loaded = false;
        },
        /**
         * throw error when connection timeout
         * @method __onConnectionTimeout
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __onConnectionTimeout: function () {
            sMedia._onError(PLAYBACK_ERRORS.NETWORK.TIMEOUT);
            console.info("[AVPlayer.js][__onConnectionTimeout] Connection error");
        },
        /**
         * remove the connection timeout
         * @method __removeConnectionTimeOut
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __removeConnectionTimeOut: function () {
            if (this.__connectionTimeOut !== null) {
                util.clearDelay(this.__connectionTimeOut);
                this.__connectionTimeOut = null;
            }
        },
        /**
         * play the video item
         * @method
         * @param {Object} opts object containing the required options
         * @param {Number} opts.sec Play the video at the specified second
         * @public
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        play: function (opts) {
            console.info("[AVPlayer.js][play] play the video from " + (opts.sec ? opts.sec : "start") + " while the media is " + (this.__connected ? "" : "not ") + "connected.");
            var playResult, prepareResult;
            var played = false; // whether avplayer.play() has been called

            this.__withholdPlay = false;
            this.__seekTime = 0;

            this.__show();

            if (!this.__connected) {

                //XDK-2621 it will crash when play again the same widevine url, it needs to load again before play.
                if (!this.__loaded && this.__drm === "widevine") {
                    this.__doLoad(this.__url, this.__mediaOpts);
                }
                //from idle state to ready state
                this.__withholdPlay = true;

                console.info("[AVPlayer.js][play] begin to prepare the video" + avplayer.getState());

                //there are two ways (prepare and prepareAsync), prepare will run synchronous and may block the process.
                //Replaced with prepareAsync, it will undergo the flow asynchronously(buffering start, buffering complete and the prepareAsync success callback)
                //If play in buffering start/complete, it will throw error. So the seeking and withhold play handling will be placed inside the prepareAsync callback.
                prepareResult = avplayer.prepareAsync(util.bind(this.__prepareSuccess, this), util.bind(this.__prepareFail, this));

                console.info("[AVPlayer.js][play] prepare result for the media player playback " + prepareResult);

                sMedia._onConnecting();
                this.__connectionTimeOut = core.getGuid();
                util.delay(this.__connectionTimeLimit, this.__connectionTimeOut)
                    .then(util.bind(this.__onConnectionTimeout, this), function () {
                        // ignore clear delay
                        return;
                    }).done();
            }

            if (opts.sec) {
                //perform directly if paused, playing, speeding
                if (sMedia.isState(sMedia.PAUSED)) {
                    sMedia._onBufferingStart();
                    avplayer.play();
                    played = true;
                    this.seek(opts.sec);
                } else if (sMedia.isState(sMedia.PLAYING)) {
                    this.seek(opts.sec);
                } else {
                    this.__withholdPlay = true;
                    this.__seekTime = opts.sec;
                }
            }

            //reset the speed to 1 when play.
            if (this.__playbackSpeed > 1) {
                avplayer.setSpeed(1);
                this.__playbackSpeed = 1;
            }

            //run only if it is not withhold and not speeding. it will cause error when call play again during speeding
            if (!this.__withholdPlay && !sMedia.isState(sMedia.SPEEDING) && !played) {
                playResult = avplayer.play();
                console.info("[AVPlayer.js][play] play result " + playResult);
            }

            if (this.__connected) {
                sMedia._onPlaying();
            }
        },
        /**
         * stop the video playback
         * @method
         * @public
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        stop: function () {
            this.__stopPlayback();
            sMedia._onStopped();
        },
        /**
         * pause the video item
         * @method
         * @public
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        pause: function () {
            var pauseResult = avplayer.pause();
            console.info("[AVPlayer.js][pause] pause result " + pauseResult);
            sMedia._onPause();
            this.__withholdPlay = false;
            //fail to display the correct time and duration
            this.__updateCurrentTime();
        },
        /**
         * resume playing the video
         * @method
         * @public
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        resume: function () {
            var playResult = avplayer.play();
            console.info("[AVPlayer.js][resume] play result " + playResult);
            sMedia._onPlaying();
        },
        /**
         * Seek to specifiy position of the video
         * @method
         * @param {Number} sec the position to seek to in seconds
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        seek: function (sec) {
            var isSpeeding = this.__playbackSpeed > 1;

            //no response when seekTo 0, so convert to sec from 0s to 1s, which will be further converted into 1000ms.
            //XDK-2612 Fail to seek time to 0 in asf, so try to standardise all media to 0.5s. The device will start at 0 in fact.
            if (sec === 0) {
                sec = 0.5;
            }

            //since it is so strange when seek close to the duration and result in no response,
            //the maximium value for the seek will be a sec before the end 
            //and then convert the time to ms format
            sec = Math.min(this.getDuration() - 1, sec) * 1000;

            //fail to seekTo when speeding
            if (isSpeeding) {
                avplayer.setSpeed(1);
            }

            var seekResult = avplayer.seekTo(sec);

            //rollback the speeding status
            if (isSpeeding) {
                avplayer.setSpeed(this.__playbackSpeed);
            }

            //update the current time
            this.__updateCurrentTime();
            console.info("[AVPlayer.js][seek] seek result " + seekResult);
        },
        /**
         * Update the current time automatically.
         * @method
         * @private
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        __updateCurrentTime: function () {
            this.__onCurrentPlayTime(webapis.avplay.getCurrentTime());
        },
        /**
         * Skip the playback forward/backward for certain seconds
         * @method
         * @param {Number} sec number of seconds to skip (10 by default)
         * @public
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        skip: function (sec) {
            var skipResult,
                isSpeeding = this.__playbackSpeed > 1;
            var limit = this.getDuration() - 2;
            var current = this.getCurTime();

            //fail to jumpForward/Backward when speeding
            if (isSpeeding) {
                avplayer.setSpeed(1);
            }

            //XDK-2620 Sometimes, it will stuck when skipping but in fact it skips properly
            //adding try catch make it not blocking to the player
            try {
                if (sec < 0) {
                    skipResult = avplayer.jumpBackward(-sec * 1000);
                } else {
                    sec = current + sec >= limit ? limit - current : sec;
                    skipResult = avplayer.jumpForward(sec * 1000);
                }
            } catch (ex) {
                //fail to run but suppose work properly.
                console.info("The skip operation may have been failed due to the following reason: " + ex);
            }

            //roll back the speeding
            if (isSpeeding) {
                avplayer.setSpeed(this.__playbackSpeed);
            }

            //since it won't update the current time when paused or skipping, so update the time directly
            if (sMedia.isState(sMedia.PAUSED) || sMedia.isState(sMedia.SKIPPING)) {
                this.__updateCurrentTime();
            }
            console.info("[AVPlayer.js][skip] skip " + sec + " result " + skipResult);
        },
        /**
         * Speed up/down the media playback, media with drm aes128 or type hls fail to speed 
         * @method
         * @param {Number} speed the playback speed to set
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        speed: function (speed) {

            if (this.__drm === "aes128" || this.__type === "hls") {
                console.warn("[AVPlayer.js][speed] speed is not supported for this type.");
                return;
            }

            var result;
            //from -8x to 8x, it will give "UNKNOWN_ERROR_EVENT_FROM_PLAYER" when calling 16x.
            if (speed > 8) {
                speed = 8;
            }

            if (speed < -8) {
                speed = -8;
            }

            if (sMedia.isState(sMedia.PAUSED)) {
                //first make it play before speeding
                avplayer.play();
            }

            try {
                result = avplayer.setSpeed(speed);
            } catch (ex) {
                console.warn("[AVPlayer.js][speed] Error occur when speeding");
                return;
            }

            this.__playbackSpeed = speed;

            console.info("[AVPlayer.js][speed] set speed " + speed + " result:" + result);

            if (speed === 1) {
                sMedia._onPlaying();
                return;
            }

            sMedia._onSpeeding();
        },
        /**
         * Sets video window size
         * @method
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        getPlaybackSpeed: function () {
            return this.__playbackSpeed;
        },
        /**
         * Sets video window size
         * @method
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        setWindowSize: function (param) {
            this.__playerContainer.style.position = "absolute";
            this.__playerContainer.style.left = param.left + "px";
            this.__playerContainer.style.top = param.top + "px";
            this.__playerContainer.style.width = param.width + "px";
            this.__playerContainer.style.height = param.height + "px";

            avplayer.setDisplayRect(param.left, param.top, param.width, param.height);
        },
        /**
         * set the video to be full screen
         * @method
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        setFullscreen: function () {
            this.setWindowSize({
                top: 0,
                left: 0,
                height: getResolution().height,
                width: getResolution().width
            });
        },
        /**
         * Get the media bitrates
         * @method
         * @return {ax/device/interface/Player~MediaBitrates} current bitrate and available bitrates
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        getBitrates: function () {
            var info = avplayer.getTotalTrackInfo();
            //0: video, 1: audio, 2:subtitle
            info = util.parse(info[0].extra_info);
            return {
                currentBitrate: info.Bit_rate,
                availableBitrates: avplayer.getStreamingProperty("AVAILABLE_BITRATE")
            };
        },
        /**
         * Get the current playback time
         * @method
         * @return {Number} the current playback time
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        getCurTime: function () {
            return this.__currentTime;
        },
        /**
         * to get the total time of the video
         * @method
         * @return {number} the total time of the video
         * @memberof ax/ext/device/tizen/AVPlayer#
         * @public
         */
        getDuration: function () {
            return avplayer.getDuration() / 1000;
        },
        /**
         * set the id of the player
         * @method
         * @public
         * @param {String} id the path of the player
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        getId: function () {
            return this.__id;
        },
        /**
         * set the id of the player
         * @method
         * @public
         * @param {String} id the path of the player
         * @memberof ax/ext/device/tizen/AVPlayer#
         */
        setId: function (id) {
            this.__id = id;
        }
    });
});
/*globals webapis:true*/
define("tvedemo/ext/device/tizen/AVPlayerMultiAudioTracksStgy",[
    "xdk-base/class",
    "xdk-base/promise",
    "xdk-base/core",
    "xdk-base/console",
    "xdk-base/util",
    "xdk-base/exception",
    "xdk-base/device/interface/MultipleAudioTrackStgy"
], function (
    klass,
    promise,
    core,
    console,
    util,
    exception,
    MultiAudioTracksStgy
) {
    "use strict";

    var avplayer = webapis.avplay;

    var AVPlayerMultiAudioTracksStgy = klass.create([MultiAudioTracksStgy], {

        AudioType: "AUDIO"

    },
    {
        __player: null,
        __currentAudioTrackId: null,


        init: function (player)
        {
            this.__player = player;
        },

        getAudioTracks: function()
        {
            var totalTracks = avplayer.getTotalTrackInfo() || [],
                audioTracks = [];

            console.log("[ Multi lang ] " + totalTracks.length);
            for (var i = 0; i < totalTracks.length; i++)
            {
                console.log("[Multi lang] - " + totalTracks[i].type);
                if (totalTracks[i].type === AVPlayerMultiAudioTracksStgy.AudioType)
                {
                    audioTracks.push(i.toString());
                }
            }

            return promise.resolve(audioTracks);
        },

        _setAudioTrack: function(trackIndex, retryAttempts) {
            retryAttempts = retryAttempts || 0;
            return this.getCurrentAudioTrackId().then(util.bind(function(currentIndex) {
                console.log("[XDK Tizen] currentIndex: " + currentIndex + " - trackIndex: " + trackIndex);
                if(currentIndex !== trackIndex) { // If we attempt to set the currentStream the TV might crash
                    console.log("[XDK Tizen] Set audio stream ID to: " + trackIndex);
                    try {
                        avplayer.setSelectTrack(AVPlayerMultiAudioTracksStgy.AudioType, trackIndex);

                        this.__currentAudioTrackId = trackIndex;
                    } catch(e) {
                        console.error("Could not setSelectTrack");
                        console.error(e)

                        if (retryAttempts === 0) {
                            return util.delay(2).then(util.bind(this._setAudioTrack, this, trackIndex, retryAttempts++))
                        }
                    }

                    console.log("[XDK Tizen] Audio track changed!");
                    return promise.resolve(true);
                } else {
                    console.log("[XDK Tizen] Attempted to set current audio track!");
                    return promise.reject(false);
                }
            }, this));
        },

        setAudioTrack: function (trackIndex)
        { 
            var attemptSetAudioTrack;
            if (util.isString(trackIndex)) {
                trackIndex = parseInt(trackIndex, 10);
            }

            if (!util.isNumber(trackIndex))
            {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Invalid audio track index."));
            }

            attemptSetAudioTrack = util.bind(function() {
                console.log("[ MULTI LANG ] attempt to set audio track");
                console.log("STATE: " + avplayer.getState());
                if(avplayer.getState() === "PLAYING" || avplayer.getState() === "PAUSED") {
                    return this._setAudioTrack(trackIndex);
                } else if(avplayer.getState() === "READY") { // buffering/connecting
                    return util.delay(1).then(attemptSetAudioTrack);
                } else { // non-playable state eg. error or stopped.
                    return promise.reject(false);
                }
            }, this);

            return attemptSetAudioTrack();
        },

        getAudioTrackAttr: function (id, attr, defaultValue)
        {
            if (util.isString(id)) {
                id = parseInt(id, 10);
            }

            switch (attr)
            {
                case MultiAudioTracksStgy.LANGCODE:
                    var tracks = avplayer.getTotalTrackInfo();
                    console.log("[multi lang track attr]: " + tracks.length);
                    if (id < 0 || id >= tracks.length) {
                        return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Invalid id: " + id));
                    }

                    var trackInfo;
                    try {
                        trackInfo = util.parse(tracks[id].extra_info);
                    } catch (e) {
                        console.error("Could not parse track info");
                        console.error(e);
                        return promise.reject(core.createException(exception.INTERNAL, "Could not parse track info"));
                    }
                    console.log("TRACKINFO " + trackInfo.language);
                    return promise.resolve(trackInfo.language);

                default:
                    if (!util.isUndefined(defaultValue))
                    {
                        return promise.resolve(defaultValue);
                    }
            }

            return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "No available attribute"));
        },

        getCurrentAudioTrackId: function () {
            var currentTracks,
                currentTrack = {};

            try {
                currentTracks = avplayer.getCurrentStreamInfo();
            } catch(e) {
                console.error("Could not getCurrentAudioTrackId");
                console.error(e);

                return promise.reject();
            }
            
            for (var i = 0, len = currentTracks.length; i < len; i++) {
                 currentTrack = currentTracks[i];
                 break;
            }

            console.log("GET CURRENT AUDIO TRACK ID: ", currentTrack);
            return promise.resolve(currentTrack.index);
        }
    });

    return AVPlayerMultiAudioTracksStgy;
});

/**
 * Detection of lg by checking the userAgent for "lg" Return true if it is lg
 * @module tvedemo/ext/device/lg/detection
 */
define("tvedemo/ext/device/lg/detection", [], function () {
    var detection = (function () {
        var agent = navigator.userAgent.toLowerCase();
        if (agent.indexOf("lg") !== -1) {
            return true;
        }
        return false;
    })();
    return detection;
});
/**
 * TvKey class to handle the key
 * @class xdk-ext-device-lg/TvKey
 * @extends ax/device/AbstractTvKey
 */
define("xdk-ext-device-lg/TvKey", ["xdk-base/device/shared/browser/TvKey", "xdk-base/class", "xdk-base/device/vKey", "xdk-base/util", "xdk-base/device/shared/browser/keyMap"], function (browserTvKey, klass, VKey, util, keyMap) {
    "use strict";
    return klass.create(browserTvKey, {}, {
        init: function () {
            var keyMapping = util.clone(keyMap.REMOTE, true);

            keyMapping.VKey[403] = VKey.RED; //"red";
            keyMapping.VKey[404] = VKey.GREEN; //"green";
            keyMapping.VKey[405] = VKey.YELLOW; //"yellow";
            keyMapping.VKey[406] = VKey.BLUE; //"blue";
            keyMapping.VKey[461] = VKey.BACK; //"back";
            keyMapping.VKey[415] = VKey.PLAY; //"play";
            keyMapping.VKey[19] = VKey.PAUSE; //"pause";
            keyMapping.VKey[413] = VKey.STOP; //"stop";
            keyMapping.VKey[417] = VKey.FF; //"ff";
            keyMapping.VKey[412] = VKey.RW; //"rw";
            keyMapping.VKey[118] = VKey.RED; //F7
            keyMapping.VKey[119] = VKey.GREEN; //F8
            keyMapping.VKey[120] = VKey.YELLOW; //F9

            //previ and next are not on the bdp remote control
            keyMapping.VKey[424] = VKey.PREV;
            keyMapping.VKey[425] = VKey.NEXT;
            
            this.initKeyMapping(keyMapping);
        }
    });
});
/**
 * To return the global objects used in the platform
 * @property {Object} netcastInfo the object with type=application/x-netcast-info
 * @module xdk-ext-device-lg/globals
 */
define("xdk-ext-device-lg/globals", [], function () {
    "use strict";
    var lgObj, obj;
    lgObj = document.createElement("div");
    lgObj.id = "lgDeviceObject";

    document.body.appendChild(lgObj);

    lgObj.innerHTML = "<object type='application/x-netcast-info' id='deviceInfo' width='0px' height='0px'></object>";

    obj = {
        netcastInfo: document.getElementById("deviceInfo")
    };
    return obj;
});

/**
 * Id class to handle the device information like firmware version
 * @class xdk-ext-device-lg/Id
 * @extends ax/device/AbstractId
 */
define("xdk-ext-device-lg/Id", ["xdk-base/class", "xdk-base/device/AbstractId", "xdk-base/device/interface/Id", "xdk-ext-device-lg/globals"], function (klass, abstrId, IId, globals) {
    "use strict";
    return klass.create(abstrId, [IId], {}, {
        /**
         * To save the hardware type which will be determined in the userAgent
         * @name __hardwareType
         * @memberof xdk-ext-device-lg/Id#
         */
        __hardwareType: "",
        /**
         * To save the device type which will be determined in the userAgent
         * @name __deviceType
         * @deprecated replaced with __hardwareType
         * @memberof xdk-ext-device-lg/Id#
         */
        __deviceType: "",
        /**
         * To save the firmware year type which will be determined in the userAgent
         * @name __firmwareYear
         * @memberof xdk-ext-device-lg/Id#
         */
        __firmwareYear: null,
        init: function () {
            var ua, firm;
            ua = navigator.userAgent;
            //simple userAgent checking and find the device information
            if (ua.indexOf("NetCast.Media") !== -1) {
                this.__hardwareType = IId.HARDWARE_TYPE.BD;
                this.__deviceType = "Bluray";
            } else if (ua.indexOf("NetCast-") !== -1) { // no device type, regard as emulator
                this.__hardwareType = IId.HARDWARE_TYPE.EMULATOR;
                this.__deviceType = "Emulator";
            } else {
                this.__hardwareType = IId.HARDWARE_TYPE.TV;
                this.__deviceType = IId.HARDWARE_TYPE.TV;
            }

            //If running on WebOS in compatability mode (with Netcast trustlevel) get the correct firmwareyear
            firm = ua.match(/webOS.TV-[0-9]+/g); 
            if (firm && firm.length > 0) {
                this.__firmwareYear = parseInt(firm[0].split("-")[1], 10);
            } else {
                firm = ua.split("NetCast");
                if (firm.length > 1) {
                    this.__firmwareYear = parseInt(firm[1].split("-")[1].substring(0, 4), 10);
                }
            }
        },
        /**
         * To return the device type as "lg"
         * @method getDeviceType
         * @returns {String} the device type
         * @deprecated replaced with getHardwareType
         * @memberof xdk-ext-device-lg/Id#
         */
        getDeviceType: function () {
            return this.__deviceType;
        },
        /**
         * To return the device type
         * @method getHardwareType
         * @returns {ax/device/interface/Id.HARDWARE_TYPE} the device type as {@link xdk-base/device/interface/Id.HARDWARE_TYPE.BD} or  {@link xdk-base/device/interface/Id.HARDWARE_TYPE.TV} or  {@link xdk-base/device/interface/Id.HARDWARE_TYPE.EMULATOR}
         * @memberof xdk-ext-device-lg/Id#
         */
        getHardwareType: function () {
            return this.__hardwareType;
        },
        /**
         * return the mac address
         * @function getMac
         * @returns {String} the mac address
         * @public
         * @memberof xdk-ext-device-lg/Id#
         */
        getMac: function () {
            var device = globals.netcastInfo;
            if (device) {
                return device.net_macAddress;
            }
            return null;
        },
        /**
         * To get the firmware version
         * @method getFirmware
         * @returns {String} the firmware version
         * @memberof xdk-ext-device-lg/Id#
         */
        getFirmware: function () {
            var device = globals.netcastInfo;
            if (!device) {
                return "LGDummyFirmware";
            } else {
                return device.swVersion;
            }
        },
        /**
         * return the firmware year
         * @function getFirmwareYear
         * @returns {Number} the firmware year
         * @public
         * @memberof xdk-ext-device-lg/Id#
         */
        getFirmwareYear: function () {
            return this.__firmwareYear;
        },
        /**
         * return the unique id
         * @function getUniqueID
         * @public
         * @returns {String} the device serial numebr
         * @memberof xdk-ext-device-lg/Id#
         */
        getUniqueID: function () {
            var device = globals.netcastInfo;
            if (device) {
                return device.serialNumber;
            } else {
                return this._super();
            }
        },
        /**
         * return model
         * @function getModel
         * @return {String} the device model name
         * @public
         * @memberof xdk-ext-device-lg/Id#
         */
        getModel: function () {
            var device = globals.netcastInfo;
            if (device) {
                return device.modelName;
            } else {
                return "LGDummyModel";
            }

        },
        /**
         * return the IP address
         * @function getIP
         * @return {String} the IP address
         * @public
         * @memberof xdk-ext-device-lg/Id#
         */
        getIP: function () {
            var device = globals.netcastInfo;
            if (device) {
                return device.net_ipAddress;
            } else {
                return this._super();
            }
        }
    });
});
/**
 * System class to handle the system api and connection checking
 *
 * There are internet connected API (global.netcastInfo.net_isConnected) in LG but it costs many resource and thus uses the default ajax one.
 * @class xdk-ext-device-lg/System
 * @augments ax/device/AbstractSystem
 */
define("xdk-ext-device-lg/System", ["xdk-base/class", "xdk-base/device/AbstractSystem", "xdk-base/console"], function (klass, abstrSystem, console) {
    "use strict";
    return klass.create(abstrSystem, {}, {
        /**
         * To store the screen saver status
         * @private
         * @name __screenSaverOn
         * @memberof xdk-ext-device-lg/System#
         */
        __screenSaverOn: true,
        // default should be false as we won't turn off
        /**
         * To store the internet Poller
         * @private
         * @name __internetPoller
         * @memberof xdk-ext-device-lg/System#
         */
        __internetPoller: null,
        /**
         * To set the screen saver
         * @public
         * @method setScreenSaver
         * @param {Boolean} turnOn True if turn on the screen saver, false when turn off.
         * @memberof xdk-ext-device-lg/System#
         */
        setScreenSaver: function (turnOn) {
            if (this.__screenSaverOn !== turnOn && window.NetCastSetScreenSaver) {
                if (turnOn) {
                    console.debug("[XDK] Turn On Screen Saver");
                    window.NetCastSetScreenSaver("enabled");
                } else {
                    console.debug("[XDK] Turn Off Screen Saver");
                    window.NetCastSetScreenSaver("disabled");
                }
                this._screenSaverOn = turnOn;
            } else {
                console.debug("[XDK] >> Screensaver status unchanged as " + (this.__screenSaverOn ? "ON" : "OFF"));
            }
        },
        /**
         * To exit the apps
         * @public
         * @method exit
         * @memberof xdk-ext-device-lg/System#
         */
        exit: function (param) {
            var toTV = true;
            if (param && typeof param.toTV === "boolean") {
                toTV = param.toTV;
            }

            if (window.NetCastBack) {
                window.NetCastBack();
            } else {
                if (toTV) {
                    if (window.NetCastExit) {
                        window.NetCastExit();
                        return;
                    }
                } 

                //old method to back the app store
                window.NetCastReturn(461);
            }
        },
        /**
         * Has mouse on lg
         * @public
         * @method hasMouse
         * @returns {Boolean} true
         * @memberof xdk-ext-device-lg/System#
         */
        hasMouse: function () {
            return true;
        },
        /**
         * To get the display resolution
         * @public
         * @method getDisplayResolution
         * @return {Object} object {width:1280,height:720}
         * @memberof xdk-ext-device-lg/System#
         */
        getDisplayResolution: function () {
            return {
                width: (window.innerWidth !== null ? window.innerWidth : document.body !== null ? document.body.clientWidth : null),
                height: (window.innerHeight !== null ? window.innerHeight : document.body !== null ? document.body.clientHeight : null)
            };
        },
        /**
         * lg supports SSL
         * @public
         * @method supportSSL
         * @return {Boolean} True
         * @memberof xdk-ext-device-lg/System#
         */
        supportSSL: function () {
            return true;
        }
    });
});
/**
 *
 * DevicePack class to handle the packaging for the LG
 *
 * * LG has mouse support.
 *
 * ###Support Models
 *
 * * 2010
 * * 2011
 * * 2012
 * * 2013
 *
 * ###Media Player
 *
 * * {@link xdk-ext-device-lg/LgPlayer} Native LG Player
 * Support format: MP4 ASF HLS HAS MP3 WIDEVINE WMDRM PLAYREADY VERIMATRIX
 * * {@link xdk-base/device/shared/Html5Player} HTML5 player (Supported in 2012, 2013)
 * Support format: MP4
 * * {@link xdk-base/device/shared/FlashPlayer} Flash player (Supported in 2012, 2013)
 * Support format: RTMP (MP4 support is removed)
 *
 * If there is no setting available player in the config, the following default player will be applied.
 * Default: xdk-ext-device-lg/LgPlayer
 *
 * ###Resources
 * * <https://accedobroadband.jira.com/wiki/display/ATEC/LG+Smart+TV>
 * * <http://developer.lge.com/>
 *
 * ###Remark
 * {@link xdk-ext-device-lg/globals} To get the global object of netcastInfo object and run the lg api
 * @class xdk-ext-device-lg/DevicePackage
 * @extends ax/device/AbstractDevicePackage
 */
define("xdk-ext-device-lg/DevicePackage", ["xdk-base/device/AbstractDevicePackage", "xdk-base/device/shared/LocalStorage", "xdk-ext-device-lg/TvKey", "xdk-ext-device-lg/Id", "xdk-ext-device-lg/System", "xdk-base/device/Media", "xdk-base/class", "xdk-base/config", "xdk-base/util"], function (abstrDevicePackage, LocalStorage, TvKey, Id, System, Media, klass, config, util) {
    "use strict";
    return klass.create(abstrDevicePackage, {}, {
        /**
         * [Backward Compatible only] To be true when device package version >= 2.3, determine whether to run setup method in AbstractDevicePackage
         * @property {Boolean} _shouldSetup
         * @memberof xdk-ext-device-lg/DevicePackage#
         * @protected
         */
        _shouldSetup: true,
        /**
         * To return platform id of this abstraction
         * @method
         * @return {String} the id "lg"
         * @protected
         * @memberof xdk-ext-device-lg/DevicePackage#
         */
        getId: function () {
            return "lg";
        },
        /**
         * setup the device package
         * @param {Function} onDeviceLoaded callback when the device is loaded.
         * @returns {xdk-ext-device-lg/DevicePackage} abstract device package itself
         * @memberof xdk-ext-device-lg/DevicePackage#
         */
        setup: function(onDeviceLoaded) {
            var interfaceTypes, ready;

            this._super(onDeviceLoaded);

            interfaceTypes = this.getInterfaceTypes();

            util.each(interfaceTypes, util.bind(function (pair) {
                this.addInterfaceType(pair.key, pair.value.handle, pair.value.interfaceObj);
            }, this));

            document.body.setAttribute("onselectstart", "return false");

            ready = util.bind(this.ready, this);

            this._preparePlayerList(ready);
        },
        /**
         * To get the default player. Default will be {@link xdk-ext-device-lg/LgPlayer}
         * @function getDefaultPlayer
         * @returns {String[]} Array of the player list
         * @public
         * @memberof xdk-ext-device-lg/DevicePackage#
         */
        getDefaultPlayer: function() {
            return ["xdk-ext-device-lg/LgPlayer"];
        },
        /**
         * To init each modules like id, media, system and tvkey
         * @method getInterfaceTypes
         * @protected
         * @return {Object} the interfacesof tvkey, id, storage, player and system
         * @memberof xdk-ext-device-lg/DevicePackage#
         */
        getInterfaceTypes: function () {
            var ret = {};
            ret[abstrDevicePackage.STORAGE] = {
                handle: abstrDevicePackage.STORAGE_HANDLE,
                interfaceObj: new LocalStorage()
            };

            ret[abstrDevicePackage.TV_KEY] = {
                handle: abstrDevicePackage.TV_KEY_HANDLE,
                interfaceObj: new TvKey()
            };

            ret[abstrDevicePackage.MEDIA_PLAYER] = {
                handle: abstrDevicePackage.MEDIA_PLAYER_HANDLE,
                interfaceObj: Media.singleton()
            };

            ret[abstrDevicePackage.ID] = {
                handle: abstrDevicePackage.ID_HANDLE,
                interfaceObj: new Id()
            };

            ret[abstrDevicePackage.SYSTEM] = {
                handle: abstrDevicePackage.SYSTEM_HANDLE,
                interfaceObj: new System()
            };

            //@todo 3D, tvchannel
            return ret;
        }
    });
});
/**
 * (extended) System class to handle the system api and connection checking
 *
 * There are internet connected API (global.netcastInfo.net_isConnected) in LG but it costs many resource and thus uses the default ajax one.
 * @class tvedemo/ext/device/lg/System
 * @extends ax/device/AbstractSystem
 */
define("tvedemo/ext/device/lg/System", ["xdk-base/class", "xdk-ext-device-lg/System", "xdk-base/device/AbstractSystem", "xdk-base/console"], function (klass, System, abstrSystem, console) {
    "use strict";
    return klass.create(System, {}, {
        /**
         * To exit the apps
         * @public
         * @method exit
         * @memberof tvedemo/ext/device/lg/System#
         */
        exit: function (param) {
            var toTV = true;
            if (param && typeof param.toTV === "boolean") {
                toTV = param.toTV;
            }
            
            if (toTV) {
                if (window.NetCastExit) {
                    window.NetCastExit();
                    return;
                }
            } 

            if (window.NetCastBack) {
                window.NetCastBack();
            } else {

                //old method to back the app store
                window.NetCastReturn(461);
            }
        }
    });
});
/**
 * This class overrides the original LG device package to facilitate the custom TV key handling.
 *
 * @class tvedemo/ext/device/lg/DevicePackage
 * @extends ax/ext/device/lg/DevicePackage
 */
define("tvedemo/ext/device/lg/DevicePackage", [
        "xdk-base/class",
        "xdk-base/device/AbstractDevicePackage",
        "xdk-ext-device-lg/DevicePackage",
        "tvedemo/ext/device/lg/System",
        "xdk-base/console"
    ],
    function (
        klass,
        abstrDevicePackage,
        LgDevicePackage,
        System,
        console
        ) {

        "use strict";

        return klass.create(LgDevicePackage, {}, {
            init: function (callback) {
                this._super(callback);
                console.log("Init LgDevicePackage");
            },
            /**
             * To init each modules like id, media, system and tvkey
             * @method getInterfaceTypes
             * @protected
             * @returns {Object} the device interface object
             * @memberof tvedemo/ext/device/samsung/DevicePackage#
             */
            getInterfaceTypes: function () {
                console.info("[DevicePackage] tvedemo LG device package in place");

                var ret = this._super();
                
                try {
                    // override the original System
                    ret[abstrDevicePackage.SYSTEM] = {
                        handle: abstrDevicePackage.SYSTEM_HANDLE,
                        interfaceObj: new System()
                    };
                }
                catch (e)
                {
                    console.error(e.message);
                }
                
                /*

                ret[AbstractDevicePackage.ID] = {
                    handle: AbstractDevicePackage.ID_HANDLE,
                    interfaceObj: new Id()
                };
                */

                return ret;
            },
            
            /**
             * To get the default player. Default will be {@link tvedemo/ext/device/lg/LgPlayer}
             * @function _getDefaultPlayer
             * @returns {String[]} Array of the player list
             * @memberof tvedemo/ext/device/lg/DevicePackage#
             */
            _getDefaultPlayer: function() {
                return ["tvedemo/ext/device/lg/LgPlayer"];
            },

            deinit: function() {
                AbstractDevicePackage.deinit();
            }
        });
    });
/**
 * To return the global objects used in the platform
 * @property {Object} netcastInfo the object with type=application/x-netcast-info
 * @module tvedemo/ext/device/lg/globals
 */
define("tvedemo/ext/device/lg/globals", [], function () {
    "use strict";
    var lgObj, obj;
    lgObj = document.createElement("div");
    lgObj.id = "lgDeviceObject";

    document.body.appendChild(lgObj);

    lgObj.innerHTML = "<object type='application/x-netcast-info' id='deviceInfo' width='0px' height='0px'></object>";

    obj = {
        netcastInfo: document.getElementById("deviceInfo")
    };
    return obj;
});

/**
 * Id class to handle the device information like firmware version.
 * @class tvedemo/ext/device/lg/Id
 * @extends ax/ext/device/lg/Id
 */
define("tvedemo/ext/device/lg/Id", [
    "xdk-base/class",
    "xdk-base/util",
    "xdk-base/console",
    "tvedemo/ext/device/lg/globals",
    "xdk-ext-device-lg/Id"
    ], function (
        klass,
        util,
        console,
        globals,
        Id
    ) {

    "use strict";

    return klass.create(Id, {}, {

    });
});

define('css!xdk-ext-device-lg/css/LgPlayer',[],function(){});
/**
 * lg video player.
 * @class xdk-ext-device-lg/LgPlayer
 * @augments ax/device/interface/Player
 */
define("xdk-ext-device-lg/LgPlayer", [
    "xdk-base/core",
    "xdk-base/class",
    "xdk-base/device/Media",
    "xdk-base/device/shared/opif/DrmAgent",
    "xdk-base/console",
    "xdk-base/util",
    "xdk-ext-device-lg/globals",
    "xdk-base/device/AbstractPlayer",
    "xdk-base/device/interface/Player",
    "require",
    "css!./css/LgPlayer"
], function (core,
    klass,
    Media,
    DrmAgent,
    console,
    util,
    globals,
    AbstractPlayer,
    IPlayer,
    require) {
    "use strict";

    function _getDeviceAPI(api) {
        var device = require("xdk-base/device");
        return device[api];
    }

    function _getResolution() {
        return _getDeviceAPI("system").getDisplayResolution();
    }

    /**
     * the stopped state in LG Player
     * @constant
     */
    var LG_STATE_STOPPED = 0,
        /**
         * the playing state in LG Player
         * @constant
         */
        LG_STATE_PLAYING = 1,
        /**
         * the paused state in LG Player
         * @constant
         */
        LG_STATE_PAUSED = 6,
        /**
         * the connecting state in LG Player
         * @constant
         */
        LG_STATE_CONNECTING = 3,
        /**
         * the buffering state in LG Player
         * @constant
         */
        LG_STATE_BUFFERING = 4,
        /**
         * the finished state in LG Player
         * @constant
         */
        LG_STATE_FINISHED = 5,
        /**
         * Enum Player Actions to handle the previous action on player logic.
         * @constant
         */
        LG_ACTION_LOAD = 0,
        LG_ACTION_PLAY = 1,
        LG_ACTION_SEEK = 2,
        LG_ACTION_SPEED = 3,
        LG_ACTION_STOP = 4,
        /**
         * System id used for playready license acquisition
         * @constant
         */
        SYSTEM_ID = "urn:dvb:casystemid:19219",
        /**
         * PlayReady license acquisitor for LG 2012 TV
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        playReadyLAModule,
        sMedia = Media.singleton();

    var PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS;

    return klass.create(AbstractPlayer, {}, {
        /**
         * lg player object
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        __firmwareYear: null,
        /**
         * lg player object
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _playerObject: null,
        /**
         * container name of lg video
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _CONTAINER_NAME: "LgPlayerContainer",
        /**
         * container name of lg video
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _playerContainer: null,
        /**
         * To indicate whether to open the videoDebug
         * @name _videoDebugOn
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _videoDebugOn: false,
        /**
         * the status of video progress checking
         * @name _checkingProgres
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _checkingProgress: false,
        /**
         * the interval time (in ms)of the video progress checking
         * @name _checkingInterval
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _checkingInterval: 500,
        /**
         * connection time limit
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _connectionTimeLimit: 90,
        /**
         * JSON containing current window size
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _currentWindowSize: null,
        /**
         * playback current time
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _curTime: 0,
        /**
         * media duration
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _duration: 0,
        /**
         * is the player ready for playback
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _prepared: false,
        /**
         * playback Speed
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _playbackSpeed: 1,
        /**
         * is there any stop function withholding
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _withHoldingStop: false,
        /**
         * media container format
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _type: null,
        /**
         * DRM technology being used
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _drm: null,
        /**
         * drm url for playready
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _playReadyDrmUrl: null,
        /**
         * cache last drm url for playready
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _lastPlayReadyDrmUrl: null,
        /**
         * playready custom data
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _playReadyCustomData: null,
        /**
         * cache last custom data for playready
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _lastPlayReadyCustomData: null,
        /**
         * is currently using 3D
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _is3d: false,
        /**
         * current 3D type
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _type3d: "off",
        /**
         * previous Action by the player (load,play,seek,speed,stop)
         * @name _previousAction
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _previousAction: null,
        /**
         * holds the previous state property
         * @name _previousState
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _previousState: null,
        /**
         * to determine if it is resume play
         * @name _resumePlay
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _resumePlay: false,
        /**
         * the second start to play when it is resume play cases.
         * @name _resumePlaySec
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _resumePlaySec: 0,
        /**
         * the time gap between the current time and target time.
         * @name _skipGap
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _skipGap: null,
        /* save the paused time and use it to update
         * @name _skipGap
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        __pausedTime: null,
        /**
         * save the last options for widevine
         * @name __lastWidevineOpts
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        __lastWidevineOpts: null,
        /**
         * check if widevine options are already loaded
         * @name __widevineLoaded
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        __widevineLoaded: false,
        init: function (devicePackage) {
            //save the firmware year which is used to determine the availability on the audio track
            var Id = devicePackage.getInterface(devicePackage.constructor.ID);
            this.__firmwareYear = Id.getFirmwareYear();
        },
        /**
         * To get the capabilities of the lg player
         * @method getCapabilities
         * @return {ax/device/interface/Player~PlayerCapabilites}
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        getCapabilities: function () {
            return {
                type: ["mp4", "asf", "hls", "has", "mp3"],
                drms: ["wmdrm", "widevine", "verimatrix", "playready"]
            };
        },
        /**
         * To initialize the plugin player
         * @method prepare
         * @param {Object} opts options object need to prepare creating the player
         * @memberof xdk-ext-device-lg/LgPlayer#
         * @public
         */
        prepare: function (opts) {
            var defaultVideoObject, playReadyAgent;
            if (this._prepared) {
                //XDK-2571 Need to reset the player if the previous played video has drm or current video has drm, otherwise it will throw 4001 error.
                if (this._drm || opts.drm) {
                    this.reset();
                } else {
                    return;
                }

            }
            this._prepared = true;

            //create debug console
            if (this._videoDebugOn) {
                this.videoDebug.create();
                this.videoDebug.show();
            } else {
                this.videoDebug.hide();
            }

            //default parent node should be the body
            this._parentNode = window.document.getElementsByTagName("body")[0];

            //create div container tag
            this._playerContainer = document.createElement("div");
            this._playerContainer.id = this._CONTAINER_NAME;
            this._playerContainer.className = "playerContainer";

            this._parentNode.appendChild(this._playerContainer);
            if (opts.use3d) {
                this._type3d = "side_by_side";
                if (opts.type3d) {
                    this._type3d = opts.type3d;
                }
                if (this._support3D(opts.type3d)) {
                    this._is3d = true;
                } else {
                    this._type3d = "off";
                }
            }

            opts.bufferingTime = opts.bufferingTime || 10;

            defaultVideoObject = true;

            //create the player object
            if (opts) {

                switch (opts.drm) {
                case "widevine":
                case "verimatrix":
                    this._playerContainer.innerHTML = "<object type='application/x-netcast-av' drm_type ='" + opts.drm + "' id='LgPlayer' class='playerObject'" + (this._is3d ? "mode3D='" + this._type3d + "'" : "") + " preBufferingTime='" + opts.bufferingTime + "'></object>";
                    defaultVideoObject = false;
                    break;
                case "playready":
                    this._playerContainer.innerHTML = "<object type='application/vnd.ms-sstr+xml' id='LgPlayer' class='playerObject'></object>";
                                    
                    // Set Up DRM license Agent
                    // clean up the playReady check for license sent
                    this.videoDebug.pushMsg("Create DRM Agent for playReady");
                    if (!document.getElementById("drmAgent")) {
                        playReadyAgent = document.createElement("object");
                        playReadyAgent.id = "drmAgent";
                        playReadyAgent.type = "application/oipfDrmAgent";
                        playReadyAgent.style.width = 0;
                        playReadyAgent.style.height = 0;
                        this._parentNode.appendChild(playReadyAgent);
                    }
                    if (!this._playReadyAgent) {
                        this._playReadyAgent = document.getElementById("drmAgent");
                        playReadyLAModule = new DrmAgent(this._playReadyAgent, SYSTEM_ID);
                    }

                    this._lastPlayReadyDrmUrl = null;
                    this._lastPlayReadyCustomData = null;

                    defaultVideoObject = false;
                    break;
                }
            }

            if (defaultVideoObject) {
                //construct the player object
                this._playerContainer.innerHTML = "<object type='application/x-netcast-av' id='LgPlayer' class='playerObject'" + (this._is3d ? "mode3D='" + this._type3d + "'" : "") + " preBufferingTime='" + opts.bufferingTime + "'></object>";
            }

            this._playerObject = this._playerContainer.firstChild;
            this.videoDebug.pushMsg("setting player Object");
            this._playerObject.autoStart = true;
            this._playerObject.onPlayStateChange = util.bind(this._onPlayStateChange, this);
            this._playerObject.onReadyStateChange = util.bind(this._onReadyStateChange, this);
            this._playerObject.onBuffering = util.bind(this._onBuffering, this);
            this._playerObject.onError = util.bind(this._onError, this);
            this._inited = true;
            //@workaround to wait for checkCondition and execute callback. But now if no need to wait time out, it works properly.
            /**
             wait for checkCondition to become true, then execute callback
             function waitFor(checkCondition, callback, checkInterval, checkCountLimit, onLimitExceedCallback) {
             if (typeof(checkInterval) !== 'number') {
             checkInterval = 500;
             }
             if (typeof(checkCountLimit) !== 'number') {
             checkCountLimit = -1;
             }
             
             if (checkCountLimit === 0) { // count limit reached
             if(onLimitExceedCallback){
             onLimitExceedCallback();
             }
             return;
             } else if (!checkCondition()) {
             if (checkCountLimit > 0) {
             checkCountLimit--;
             }
             setTimeout(function(){
             waitFor(checkCondition, callback, checkInterval, checkCountLimit, onLimitExceedCallback);
             }, checkInterval);
             return;
             }
             callback();
             }
             
             
             
             waitFor( // wait for the object to be ready
             accedo.util.bind(function(){ // make sure the context is correct
             accedo.console.info("Waiting for video player object init...");
             return !!document.getElementById("playerObject");
             }, this),
             accedo.util.bind(function(){
             accedo.console.info("Video player object ready, proceeding...");
             this._playerObject = document.getElementById("playerObject");
             
             this._playerObject.autoStart = true;
             this._playerObject.onPlayStateChange = accedo.util.bind(this._onPlayStateChange, this);
             this._playerObject.onReadyStateChange = accedo.util.bind(this._onReadyStateChange, this);
             this._playerObject.onBuffering = accedo.util.bind(this._onBuffering, this);
             this._playerObject.onError = accedo.util.bind(this._onError, this);
             
             this.videoDebug.pushMsg("player loading finished");
             this._onLoadCallback();
             this.videoDebug.pushMsg("_onLoadCallback finished");
             
             this._inited = true;
             }, this),
             500 // check interval in milliseconds
             );**/

            //set back the current size if created again
            if (this._currentWindowSize) {
                this.setWindowSize(this._currentWindowSize);
            }

            this.videoDebug.pushMsg("player is initialized");
            return true;
        },
        /**
         * To reset the plugin player when it is not currently used
         * @param {Boolean} Force reset (only reset when deinit in playReady)
         * @method reset
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        reset: function (force) {
            if (!this._prepared) {
                return;
            }
            this._prepared = false;

            if (this._progressCheckFuncId) {
                window.clearInterval(this._progressCheckFuncId);
            }

            if (this._playerObject) {
                if (this._drm !== "playready" || force) {
                    if (!sMedia.isState(sMedia.STOPPED)) {
                        this._playerObject.stop();
                    }
                    //reset the value
                    this._playerObject.onPlayStateChange = null;
                    this._playerObject.onReadyStateChange = null;
                    this._playerObject.onBuffering = null;
                    this._playerObject.onError = null;

                    this._playerContainer.removeChild(this._playerObject);
                    this._parentNode.removeChild(this._playerContainer);
                    this._playerObject = null;
                    delete this._playerObject;

                } else {
                    this.videoDebug.pushMsg("Skip cleaning callback for playReady");
                }

                this._onLoadCallback = null;
                this.videoURL = null;
                this.onSetCurTime = null;
                this.event = null;
                this.statusChangeCallback = null;
            }
            this.videoDebug.pushMsg("Video player reset success");
        },
        /**
         * Safely de-init and remove the mediapPyer
         * @function deinit
         * @public
         * @ignore
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        deinit: function () {
            if (!this._prepared) {
                return;
            }
            console.info("lg media deinit");

            if (!this._inited) {
                return;
            }

            this.stop();

            this.reset(true); // force reset
            this._inited = false;

            console.info("lg media deinit success");
            return;
        },
        /**
         * Set the player debug mode on/off
         * @function _setVideoDebug
         * @memberof xdk-ext-device-lg/LgPlayer#
         * @private
         */
        _setVideoDebug: function (onOff) {
            this._videoDebugOn = onOff;
            if (this._videoDebugOn) {
                if (!this.videoDebug.isCreated) {
                    this.videoDebug.create();
                }
                this.videoDebug.show();
            } else {
                this.videoDebug.hide();
                this.videoDebug.deinit();
                this.videoDebug.isCreated = false;
            }
        },
        /**
         * set the window size
         * @param {Object} object containing width, height, left, top of the screen
         * @method
         * @param {Object} param window size parameter
         * @param {Boolean} param.relativeToParent True if relative to the parent position and then use the css position:relative. \
         *                   Default will be false and use position:fixed
         * @param {Integer} param.top window top
         * @param {Integer} param.left window left
         * @param {Integer} param.width window width
         * @param {Integer} param.height window height
         * @memberof xdk-ext-device-lg/LgPlayer#
         * @public
         */
        setWindowSize: function (obj) {

            if (!this._playerObject) {
                console.warn("[LgPlayer] Fail to set the size due to no playerObject");
                return;
            }

            var objClassName = "playerObject";

            //determine whether it is relative to parent which add a relative class with "position:relative"
            if (obj.relativeToParent) {
                objClassName += " relative";
            }

            //determine whether it is fullscreen and add a fullscreen selector
            if (obj.width === _getResolution().width && obj.height === _getResolution().height) {
                objClassName += " fullscreen";
            }

            this._playerObject.className = objClassName;

            this._playerObject.style.width = obj.width + "px";
            this._playerObject.style.height = obj.height + "px";
            this._playerObject.style.left = obj.left + "px";
            this._playerObject.style.top = obj.top + "px";

            this._currentWindowSize = obj;

            return;
        },
        /**
         * set the window size to be fullscrenn
         * @method setFullscreen
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        setFullscreen: function () {
            this.setWindowSize({
                top: 0,
                left: 0,
                height: _getResolution().height,
                width: _getResolution().width
            });
        },
        /**
         * load media url and opts
         * @method
         * @param {String} mediaUrl  url string of the media
         * @param {Object} [opts] Optional - extra prarameter needed
         * @param {String} [opts.drm] DRM technology to use
         * @param {string} [opts.type] media container format to use
         * @param {String} [opts.drmUrl] (Widevine || Playready || Verimatrix) Set the DRM license url
         * @param {String} [opts.optData] (Widevine) Set the custom data
         * @param {String} [opts.portal] (Widevine) Set the portal
         * @param {String} [opts.deviceId] (Widevien) Set the device id
         * @param {String} [opts.streamId] (Widevine) Set the stream id
         * @param {String} [opts.clientIp] (Widevine) Set the client IP
         * @param {String} [opts.drmAckUrl] (Widevine) Set the drm acknowledge url
         * @param {String} [opts.heartbeatUrl] (Widevine) Set the heartbeat url
         * @param {Stinrg} [opts.heartbeatPeriod] (Widevine) Set the hearbeat period
         * @param {String{ [opts.deviceType] (Widevine) Set the widevine type
         * @param {String} [opts.authCookiesUrl] (WMDRM) Set the url to get the authentication cookies
         * @param {String} [opts.customerName] (Verimatrix) Set the customer name
         * @param {Boolean} [opts.use3d] true if to use 3D
         * @param {String} [opts.type3d] the type of 3D
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        load: function (mediaUrl, opts) {
            this._previousAction = LG_ACTION_LOAD;
            //move to the correct place
            if (this._playerObject && opts.parentNode) {
                this._parentNode = opts.parentNode;
                this._parentNode.appendChild(this._playerContainer);
            }
            opts = opts || {};
            this._drm = opts.drm;
            this._type = opts.type;
            this._playerObject.data = mediaUrl;
            this.videoDebug.pushMsg("set video url: " + mediaUrl);

            if (opts.drm === "widevine") {
                if (!util.isUndefined(opts.drmUrl)) {
                    this._playerObject.setWidevineDrmURL(opts.drmUrl);
                    this.videoDebug.pushMsg("set widewine DRM url" + opts.drmUrl);
                }
                if (!util.isUndefined(opts.userData)) {
                    this._playerObject.setWidevineUserData(opts.userData);
                    this.videoDebug.pushMsg("set widevine user data" + opts.userData);
                }
                if (!util.isUndefined(opts.portal)) {
                    this._playerObject.setWidevinePortalID(opts.portal);
                    this.videoDebug.pushMsg("set widewine portal" + opts.portal);
                }

                // other optional parameters for widevine playback
                if (!util.isUndefined(opts.deviceId)) {
                    this._playerObject.setWidevineDeviceID(opts.deviceId);
                }
                if (!util.isUndefined(opts.streamId)) {
                    this._playerObject.setWidevineStreamID(opts.streamId);
                }
                if (!util.isUndefined(opts.clientIp)) {
                    this._playerObject.setWidevineClientIP(opts.clientIp);
                }
                if (!util.isUndefined(opts.drmAckUrl)) {
                    this._playerObject.setWidevineDrmAckURL(opts.drmAckUrl);
                }
                if (!util.isUndefined(opts.heartbeatUrl)) {
                    this._playerObject.setWidevineHeartbeatURL(opts.heartbeatUrl);
                }
                if (!util.isUndefined(opts.heartbeatPeriod)) {
                    this._playerObject.setWidevineHeartbeatPeriod(opts.heartbeatPeriod);
                }
                if (!util.isUndefined(opts.deviceType)) {
                    this._playerObject.setWidevineDeviceType(opts.deviceType);
                }
                this.__lastWidevineOpts = opts;
                this.__widevineLoaded = true;
                this.videoDebug.pushMsg("set widewine parameters finished.");
            } else if (opts.drm === "wmdrm" && opts.authCookiesUrl) {
                //to open an iframe and set cookie so that it will have a cookie when play at checking license stage
                if (!this._iframe) {
                    this._iframe = document.createElement("iframe");
                    this._iframe.style.width = "0px";
                    this._iframe.style.height = "0px";
                    this._iframe.style.visibility = "hidden";
                    this._playerContainer.appendChild(this._iframe);
                    this.videoDebug.pushMsg("create the iframe to set-cookie");
                }
                this._iframe.setAttribute("src", opts.authCookiesUrl);
                this.videoDebug.pushMsg("set the url to the iframe" + opts.authCookiesUrl);
            } else if (opts.drm === "verimatrix") {
                if (opts.customerName && opts.drmUrl) {
                    globals.netcastInfo.setVMconfigData(1, opts.customerName, opts.drmUrl);
                }
            } else if (opts.drm === "playready") {
                if (_getDeviceAPI("id").getFirmwareYear() < 2012) {
                    var warningMsg = "playReady may not be supported on this device. 2012 or after only.";
                    this.videoDebug.pushMsg(warningMsg);
                    console.warn(warningMsg);
                }

                if (opts.drmUrl) {
                    this._playReadyDrmUrl = opts.drmUrl;
                }
                if (opts.customData) {
                    this._playReadyCustomData = opts.customData;
                }
            }

            //if it is audio type,no matter whether it set the window size before,it will also change back to 0,0,0,0
            if (!util.isUndefined(opts.type) && opts.type === "mp3") {
                this.type = "audio";
                this._currentWindowSize = this.AUDIO_SIZE;
                this.setWindowSize(this._currentWindowSize);
            }

            this.url = mediaUrl;
            return mediaUrl;
        },
        /**
         * To check if the device support the specific 3D mode
         * @function _support3D
         * @param {String} mode the mode of the 3D
         * @return {Boolean} true if the device supports.
         * @private
         */
        _support3D: function (mode) {
            var deviceObject = globals.netcastInfo;
            if (_getDeviceAPI("id").getFirmwareYear() >= 2011) {
                if (deviceObject.support3D && deviceObject.support3DMode) {
                    if (deviceObject.support3DMode[mode]) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * play the video item
         * @function play
         * @param { Object } opt object containing the required options
         * @param { Number } opt.sec Play the video at the specified second
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        play: function (opts) {
            //deprecated opts.useEvtSeek option which use old evt to skip the video
            //now it will determine the firmware year and 2011 devices will use the old evt to skip and 
            //newer devices will use native seek directly

            // if pausing, juz go directly to playAction
            if (sMedia.isState(sMedia.PAUSED) || sMedia.isState(sMedia.SPEEDING)) {
                this.playAction(opts);
                return;
            }

            var callback, warningMsg;
            if (this._drm === "playready") {
                if (this._playReadyDrmUrl) {
                    if (this._lastPlayReadyDrmUrl !== this._playReadyDrmUrl || this._lastPlayReadyCustomData !== this._playReadyCustomData) {
                        this._lastPlayReadyDrmUrl = this._playReadyDrmUrl;
                        this._lastPlayReadyCustomData = this._playReadyCustomData;
                        callback = util.bind(function () {
                            this.stop();
                            this.playAction(opts);
                        }, this);

                        playReadyLAModule.sendLicenseRequest(this._playReadyDrmUrl, this._playReadyCustomData).
                        then(callback).
                        fail(function (reason) {
                            console.info("[LgPlayer] sendLicenseRequest failed: " + reason);
                            // notify the upper layer through sMedia
                            sMedia._onError(PLAYBACK_ERRORS.DRM.FAILED, {
                                code: null,
                                msg: reason
                            }, reason);
                        }).done();
                    } else {
                        // license is set, play directly
                        this.playAction(opts);
                    }
                } else {
                    warningMsg = "playReady custom Param is missing! Try to play anyway";
                    this.videoDebug.pushMsg(warningMsg);
                    console.warn(warningMsg);
                    this.playAction(opts);
                }
            } else if (this._drm === "widevine") {
                // if not loaded but play widevine, juz call load first
                if (!this.__widevineLoaded) {
                    this.__lastWidevineOpts.forceReload = true;
                    sMedia.load(this.url, this.__lastWidevineOpts);
                    // the window size may distort after reload, reset it.
                    this.setWindowSize(this._currentWindowSize);
                }
                this.__widevineLoaded = false;
                this.playAction(opts);
            } else {
                this.playAction(opts);
            }
        },
        /**
         * real play action on the video item
         * @function playAction
         * @param { Object } opt object containing the required options
         * @param { Number } opt.sec Play the video at the specified second
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        playAction: function (opts) {
            opts = opts || {};

            var sec = opts.sec || 0,
                useEvtSeek,
                __reset, __doPlay;

            //on the LG 2011, it is unable to use the native skip directly, so default for the 2011 device will be true.
            //XDK-2658 On LG, Widevine fails to seek before play, so use evt seek method to seek after play
            if (sec > 0 && (this.__firmwareYear === 2011 || this._drm === "widevine")) {
                useEvtSeek = true;
            } else {
                useEvtSeek = false;
            }

            this.videoDebug.pushMsg("press play");
            this.__pausedTime = null;

            if (!this._checkingProgress) {
                this.videoDebug.pushMsg("Play progress checking started!");
                this._progressCheckFuncId = window.setInterval(util.bind(function () {
                    this.videoDebug.updateMediaInfo(this._playerObject.mediaPlayInfo());
                    this._setCurTime(this._playerObject.mediaPlayInfo().currentPosition);
                }, this), this._checkingInterval);
                this._checkingProgress = true;
            }

            this._playerContainer.style.display = "block";
            this.videoDebug.pushMsg("LG media play called. before playing action: " + this._previousAction);
            this._previousAction = LG_ACTION_PLAY;
            this._previousState = LG_STATE_PLAYING;
            this._playbackSpeed = 1;

            if (!this._inited) {
                this.videoDebug.pushMsg("media not ready! ignoring the play command...");
                return false;
            }

            __reset = util.bind(function () {
                this._withHoldingPause = false;
                this._withHoldingStop = false;
                this._playbackSpeed = 1;
                this._curTime = 0;
                this._duration = 0;
                this._playerObject.data = this.url;
            }, this);

            __doPlay = util.bind(function (sec) {
                this.videoDebug.pushMsg("State" + this._checkingProgress);
                if (sec) {
                    if (useEvtSeek) {
                        this.videoDebug.pushMsg("Seek using callback event");
                        this._resumePlay = true;
                        this._resumePlaySec = sec;
                    }
                    this._playerObject.play(this._playbackSpeed);
                    if (!useEvtSeek) {
                        this.videoDebug.pushMsg("Native Seek");
                        this._playerObject.seek(sec * 1000);
                    }
                } else {
                    this._playerObject.play(this._playbackSpeed);
                }
            }, this);


            switch (sMedia.getState()) {
            case sMedia.STOPPED:
            case sMedia.CONNECTING:
                this._statusChange(LG_STATE_CONNECTING);
                __reset();
                __doPlay(sec);
                return true;
                // keep going
            case sMedia.SPEEDING:
                __doPlay(sec);
                return true;
            case sMedia.PAUSED:
                //if the current status is speeding and then call play, it should reset the playback speed to 1
                this._playbackSpeed = 1;
                __doPlay(sec);
                return true;
            case sMedia.PLAYING:
            case sMedia.BUFFERING:
                __doPlay(sec);
                return true;
            default:
                return false;
            }
        },
        /**
         * pause the video item
         * @function pause
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        pause: function () {
            this.videoDebug.pushMsg("player begins to be paused");
            if (sMedia.isState(sMedia.BUFFERING) || sMedia.isState(sMedia.CONNECTING)) {
                this.videoDebug.pushMsg("pending pause");
                this._withHoldingPause = true;
                return false;
            }
            //XDK-1703 current time is wrong and then we need to save it for skip and update
            //save the pause time
            this.__pausedTime = this.getCurTime();
            this._playerObject.play(0);
            this.videoDebug.pushMsg("player is paused");
            sMedia._onPause();
            this._previousState = LG_STATE_PAUSED;
        },
        /**
         * stop the video item
         * @function stop
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        stop: function () {
            this._previousAction = LG_ACTION_STOP;
            this.videoDebug.pushMsg("player begins to be stopped");
            if (sMedia.isState(sMedia.CONNECTING)) {
                //stopping a widevine video during the connection stage is FATAL.
                this.videoDebug.pushMsg("Pending stop");

                this._withHoldingStop = true;

                return false;
            } else if (sMedia.isState(sMedia.STOPPED)) {
                this._stopPlayback();
                return true;
            }
            this._stopPlayback();
            this.videoDebug.pushMsg("TO STOP" + sMedia.getState());
            sMedia._onStopped();
            this._previousState = LG_STATE_STOPPED;
            return true;
        },
        /**
         * stop the playback
         * @function _stopPlayback
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _stopPlayback: function () {
            if (this._checkingProgress) {
                window.clearInterval(this._progressCheckFuncId);
                this._checkingProgress = false;
                this.videoDebug.pushMsg("Play progress checking stopped!");
            }
            if (this._playerObject) {
                this._playerObject.stop();
                this.videoDebug.pushMsg("PlayObject is stopped");
            }
            this._playerContainer.style.display = "none";
        },
        /**
         * resume the video item
         * @function resume
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        resume: function () {
            this.playAction();
            this.videoDebug.pushMsg("PlayObject is resumed");
            return true;
        },
        /**
         * to seek the player current Time
         * @function setPlayerTime
         * @param {Number} sec the number of second you want to seek for (in sec)
         * @memberof xdk-ext-device-lg/LgPlayer#
         * @public
         */
        seek: function (sec) {
            if (!this._inited || sec < 0 || !this.url) {
                return false;
            }

            //if the time is larger than the duration, then it will seek the time of total duration.
            if (sec > this.getDuration()) {
                sec = this.getDuration();
            }

            //update the paused time when paused after seek
            if (sMedia.isState(sMedia.PAUSED)) {
                this.__pausedTime = sec;
                sMedia._onTimeUpdate(sec);
            }

            this._previousAction = LG_ACTION_SEEK;
            this._playerObject.seek(sec * 1000);
            return true;

        },
        /**
         * skip the video for a few second
         * @param param {Integer} number of second to skip (10 by default)
         * @function skip
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        skip: function (sec) {
            var curTime = this.getCurTime();

            this._skipGap = sec;

            this.seek(curTime + sec);
        },
        /**
         * set the playback speed of the media
         * @function speed
         * @param {Integer} speed, better to be multiple of 2 and within -16 to 16
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        speed: function (speed) {
            speed = Math.floor(speed);

            if (speed > 16) {
                speed = 16;
            }
            if (speed < -16) {
                speed = -16;
            }

            this._playbackSpeed = speed;
            this._previousAction = LG_ACTION_SPEED;
            //Warning: not all device and media type would support this function
            if (speed === 1) {
                this._playerObject.play(1);
                sMedia._onPlaying();
                return;
            } else {
                this._playerObject.play(this._playbackSpeed);
            }

            sMedia._onSpeeding();
        },
        /**
         * Get bitrate and available bitrates
         * @function getBitrates
         * @return {ax/device/interface/Player~MediaBitrates}
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        getBitrates: function () {
            if (this._currentBitrate === null || this._availableBitrates === null) {
                return false;
            }

            return {
                currentBitrate: this._currentBitrate,
                availableBitrates: this._availableBitrates
            };
        },
        /**
         * get and return playbackSpeed
         * @function getPlaybackSpeed
         * @return {Integer} speed
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        getPlaybackSpeed: function () {
            return this._playbackSpeed;
        },
        /**
         * set the current time
         * @function _setCurTime
         * @param {Integer} time  current time in milliseconds
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _setCurTime: function (time) {
            if (sMedia.isState(sMedia.PAUSED)) {
                return;
            }
            var sortNumeric, i, mediaInfo = this._playerObject.mediaPlayInfo(),
                cbitrate = mediaInfo.bitrateInstant,
                abitrateValue = mediaInfo.bitrateTarget,
                abitrate;
            //to ensure total time is set
            if (!this.getDuration()) {
                this._setDuration();
            }
            if (this._curTime > this._duration) {
                this._curTime = this._duration;
            }


            this._curTime = parseInt(time, 10);

            if (sMedia.isState(sMedia.SKIPPING) || sMedia.isState(sMedia.BUFFERING)) { // reset null when buffering and skipping
                this._skipGap = null;
            }

            if (this._skipGap !== null) {
                if (this._skipGap > 0) { // fast forward
                    time = (sMedia.__updatedTime * 1000 > time) ? sMedia.__updatedTime * 1000 : time;
                } else { // backward
                    time = (sMedia.__updatedTime * 1000 < time) ? sMedia.__updatedTime * 1000 : time;
                }
                this._skipGap = null;
            }
            sMedia._onTimeUpdate(time / 1000);

            if (!mediaInfo) {
                return;
            }

            //upagte bitrates
            if (typeof cbitrate === "string") {
                this._currentBitrate = parseInt(cbitrate, 10);
            } else {
                this._currentBitrate = cbitrate || 0;
            }

            sortNumeric = function (a, b) {
                return Number(a) - Number(b);
            };

            if (typeof abitrateValue === "string") {
                abitrate = abitrateValue.split("|");
                // console.log("abitrate: " + abitrate);
                for (i = 0; i < abitrate.length - 1; i++) {
                    abitrate[i] = parseInt(abitrate[i], 10);
                }
                this._availableBitrates = abitrate.sort(sortNumeric);
            } else {
                this._availableBitrates = [];
                this._availableBitrates.push(abitrateValue || 0);
            }
        },
        /**
         * Returns the current time (0 if never played)
         * @returns {Integer|false} current time in milliseconds (or seconds according to the 'seconds' param)
         * @public
         * @method getCurTime
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        getCurTime: function () {
            //XDK-1703 current time is wrong and then we need to save it for skip and update
            if (sMedia.isState(sMedia.PAUSED) && util.isNumber(this.__pausedTime)) {
                return this.__pausedTime;
            }
            return Math.floor(this._curTime / 1000);
        },
        /**
         * set the total time by reading the media's duration. It will be called when the media is loaded
         * @function _setDuration
         * @memberof xdk-ext-device-lg/LgPlayer#
         * @private
         */
        _setDuration: function () {

            var mediaInfo;
            if (!this._playerObject) {
                return;
            }
            mediaInfo = this._playerObject.mediaPlayInfo();
            if (mediaInfo && mediaInfo.duration) {
                this._duration = mediaInfo.duration;
            }
        },
        /**
         * get total time of the media
         * @function getDuration
         * @public
         * @returns {Integer} total time in seconds
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        getDuration: function () {
            return Math.floor(this._duration / 1000);
        },
        /**
         * function to be triggered by the plugin player when the play state changes
         * @function _onPlayStateChange
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _onPlayStateChange: function () {
            var playState = this._playerObject.playState;

            this.videoDebug.pushMsg("PlayState: " + playState);
            this.videoDebug.updatePlayState(playState);
            this.videoDebug.updateMediaInfo(this._playerObject.mediaPlayInfo());

            this.videoDebug.pushMsg("previous action was " + this._previousAction);
            this.videoDebug.pushMsg("playbackSpeed: " + this._playbackSpeed);

            if (this._previousAction === LG_ACTION_SPEED || this._previousAction === LG_ACTION_SEEK) {
                if (this._previousState === LG_STATE_PAUSED) {
                    this.videoDebug.pushMsg("Pausing");
                    this._playerObject.play(0);
                    sMedia._onPause();
                } else {
                    this.videoDebug.pushMsg("Resume with speed: " + this._playbackSpeed);
                    this._playerObject.play(this._playbackSpeed);
                    sMedia._onPlaying();
                }
            }

            //switch back the playstate number into correct state
            this._statusChange(playState);
            if (!this.getDuration()) {
                this._setDuration();
            }
        },
        /**
         * Handling on the player when the status change
         * @function _statusChange
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _statusChange: function (playState) {
            /*case 0 : STOPPED;
             case 1 : PLAYING;
             case 2 : PAUSED;
             case 3:  CONNECTING;
             case 4:  BUFFERING;
             case 5:  FINISHED;
             case 6:  ERROR;*/
            if (this._connectionTimer) {
                util.clearDelay(this._connectionTimer);
                this._connectionTimer = null;
            }

            //block the state change when speeding.
            if (this._playbackSpeed > 1) {
                return;
            }

            switch (playState) {
            case LG_STATE_STOPPED:
                //Stopped
                this._skipGap = null;
                break;
            case LG_STATE_PLAYING:
                //Playing
                this._previousAction = LG_ACTION_PLAY;
                sMedia._onPlaying();
                this.videoDebug.pushMsg("On Playing, check if _resumePlay is true: " + this._resumePlay);
                if (this._resumePlay) {

                    this.videoDebug.pushMsg("resume play and then seek player time");
                    this._resumePlay = false;
                    var resumeTries = 0;
                    //it may need time to load and then seek time
                    this._resumeTimer = setInterval(util.bind(function () {
                        if (resumeTries > 10) {
                            clearInterval(this._resumeTimer);
                            return;
                        }

                        if (this.getDuration() > 0) {
                            this._playerObject.seek(this._resumePlaySec * 1000);
                            this._resumePlaySec = 0;
                            clearInterval(this._resumeTimer);
                        }
                        resumeTries++;
                    }, this), 1000);
                }
                break;
            case LG_STATE_CONNECTING:
                //connecting
                sMedia._onConnecting();
                this.videoDebug.pushMsg("lg player :create connection timer");
                this._connectionTimer = core.getGuid();
                util.delay(this._connectionTimeLimit, this._connectionTimer).then(util.bind(function () {
                    this._onConnectionTimeout();
                }, this)).done();
                break;
            case LG_STATE_BUFFERING:
                //Buffering
                this.videoDebug.pushMsg("set the buffering time out");
                //case when the player changes into buffering state but it doesn't really buffer and
                //thus a further checking on the buffer Remain whether is -1 and throw connection error.
                this._connectionTimer = core.getGuid();
                util.delay(this._connectionTimeLimit, this._connectionTimer).then(util.bind(function () {
                    var infoObj = this._playerObject.mediaPlayInfo();
                    //checking if it is buffering state and buffer remain is -1
                    if (sMedia.isState(sMedia.BUFFERING) && infoObj && infoObj.bufRemain === -1) {
                        this.videoDebug.pushMsg("buffering timeout");
                        this._onConnectionTimeout();
                    }
                }, this)).done();
                break;
            case LG_STATE_FINISHED:
                //Finished
                this._stopPlayback();
                sMedia._onFinish();
                this._skipGap = null;
                break;
            }
        },
        /**
         * connection time out function
         * @function _onConnectionTimeout
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _onConnectionTimeout: function () {
            this.videoDebug.pushMsg("lg player:on connection timeout");
            this._stopPlayback();
            sMedia._onError(PLAYBACK_ERRORS.NETWORK.TIMEOUT);
        },
        /**
         * function to be triggered by the plugin player when there is rendering error
         * @function _onError
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _onError: function () {
            /*
             0 A/V format not supported
             1 Cannot connect to server or connection lost
             2 Unidentified error
             3/1000 File is not found
             4/1001 Invalid protocol
             5/1002 DRM failure
             6/1003 Play list is empty
             7/1004 Unrecognized play list
             8/1005 Invalid ASX format
             9/1006 Error in downloading play list
             10/1007 Out of memory
             11/1008 Invalid URL list format
             12/1009 Not playable in play list
             1100 Unidentified WM-DRM error
             1101 Incorrect license in local license store
             1102 Fail in receiving correct license from server
             1103 Stored license is expired
             */
            var errorCode = this._playerObject.error,
                explain, internalError;

            switch (errorCode) {
            case 0:
                internalError = PLAYBACK_ERRORS.RENDER.UNSUPPORTED;
                explain = "A/V format not supported";
                break;
            case 1:
                internalError = PLAYBACK_ERRORS.NETWORK.DISCONNECTED;
                explain = "Cannot connect to server or connection lost";
                break;
            case 2:
                internalError = PLAYBACK_ERRORS.GENERIC.UNKNOWN;
                explain = "Unidentified error";
                break;
            case 3:
            case 1000:
                internalError = PLAYBACK_ERRORS.NETWORK.FILE;
                explain = "File is not found";
                break;
            case 4:
            case 1001:
                internalError = PLAYBACK_ERRORS.NETWORK.PROTOCOL;
                explain = "Invalid protocol";
                break;
            case 5:
            case 1002:
                internalError = PLAYBACK_ERRORS.DRM.FAILED;
                explain = "DRM failure";
                break;
            case 6:
            case 1003:
                internalError = PLAYBACK_ERRORS.RENDER.PLAYLIST;
                explain = "Play list is empty";
                break;
            case 7:
            case 1004:
                internalError = PLAYBACK_ERRORS.RENDER.PLAYLIST;
                explain = "Unrecognized play list";
                break;
            case 8:
            case 1005:
                internalError = PLAYBACK_ERRORS.RENDER.UNSUPPORTED;
                explain = "Invalid ASX format";
                break;
            case 9:
            case 1006:
                internalError = PLAYBACK_ERRORS.RENDER.PLAYLIST;
                explain = "Error in downloading play list";
                break;
            case 10:
            case 1007:
                internalError = PLAYBACK_ERRORS.RENDER.DEVICE;
                explain = "Out of memory";
                break;
            case 11:
            case 1008:
                internalError = PLAYBACK_ERRORS.RENDER.PLAYLIST;
                explain = "Invalid URL list format";
                break;
            case 12:
            case 1009:
                internalError = PLAYBACK_ERRORS.RENDER.PLAYLIST;
                explain = "Not playable in play list";
                break;
            case 1100:
                internalError = PLAYBACK_ERRORS.DRM.FAILED;
                explain = "Unidentified WM-DRM error";
                break;
            case 1101:
                internalError = PLAYBACK_ERRORS.DRM.INVALID;
                explain = "Incorrect license in local license store";
                break;
            case 1102:
                internalError = PLAYBACK_ERRORS.DRM.FAILED;
                explain = "Fail in receiving correct license from server";
                break;
            case 1103:
                internalError = PLAYBACK_ERRORS.DRM.INVALID;
                explain = "Stored license is expired";
                break;
            }

            this.videoDebug.pushMsg("Error: " + errorCode);
            this.videoDebug.pushMsg("this.url" + this.url);
            this.videoDebug.updateError(errorCode);
            this.videoDebug.updateMediaInfo(this._playerObject.mediaPlayInfo());

            this._stopPlayback();
            sMedia._onError(internalError, {
                code: errorCode,
                msg: explain
            }, this._playerObject.error);
        },
        /**
         * function to be triggered by the plugin player when there is buffering
         * @function _onBuffering
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _onBuffering: function (isStart) {
            //block the state change when speeding.
            if (this._playbackSpeed > 1) {
                return;
            }

            var buffering = this._playerObject.playState;
            this.videoDebug.pushMsg("Buffering: " + buffering + "   isStart:" + isStart);
            this.videoDebug.updateBuffering(buffering);
            this.videoDebug.updateMediaInfo(this._playerObject.mediaPlayInfo());

            if (isStart) { // buffering started
                sMedia._onBufferingStart();
                util.delay(0.5).then(util.bind(this._bufferingProgressChecker, this)).done(); /* delay 0.5 seconds*/
            } else { // buffering completed
                sMedia._onBufferingFinish();

                util.delay(1).then(util.bind(function () {
                    if (sMedia.isState(sMedia.PAUSED) || this._withHoldingPause) {
                        this.pause();
                        this._withHoldingPause = false;
                    }
                }, this)).done();
            }
        },
        /**
         * To check the buffering progress
         * @function _bufferingProgressChecker
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _bufferingProgressChecker: function () {
            if (sMedia.isState(sMedia.SKIPPING)) {
                this.videoDebug.pushMsg("currently skipping when buffering progress check");
            } else if (sMedia.isState(sMedia.BUFFERING)) {
                if (sMedia.isState(sMedia.STOPPED) || this._withHoldingStop) {
                    this.videoDebug.pushMsg("the video suppose to stop in buffering progressChecked");
                    this.stop();
                    this._withHoldingPause = false;
                    this._withHoldingStop = false;
                    return;
                }

                //schedule next buffering progress check
                util.delay(0.5).then(util.bind(this._bufferingProgressChecker, this)).done(); /* delay 0.5 seconds*/
            }
        },
        /**
         * To show the player
         * @function show
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        show: function () {
            if (this._videoDebugOn) {
                this.videoDebug.show();
            } else {
                this.videoDebug.hide();
            }

            this._playerContainer.style.visibility = "visible";
        },
        /**
         * To hide the player
         * @function hide
         * @public
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        hide: function () {
            this.videoDebug.hide();
            this._playerContainer.style.visibility = "hidden";
        },
        /**
         * function to be triggered by the plugin player when the ready state changes
         * @function _onReadyStateChange
         * @private
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        _onReadyStateChange: function () {
            var readyState = this._playerObject.readyState;

            this.videoDebug.pushMsg("ReadyState: " + readyState);
            this.videoDebug.updateReadyState(readyState);
            this.videoDebug.updateMediaInfo(this._playerObject.mediaPlayInfo());
            this._setDuration();
        },
        /**
         * video debug object
         * @function videoDebug
         * @protected
         * @memberof xdk-ext-device-lg/LgPlayer#
         */
        videoDebug: {
            isCreated: false,
            messageSlot: [],
            create: function () {
                if (this.isCreated) {
                    return;
                }
                var con, title;
                con = document.createElement("div");
                con.className = "lgVideoDebugConsole";

                title = document.createElement("div");
                title.innerHTML = "Video Debug";
                title.className = "title";
                con.appendChild(title);

                this.content = document.createElement("div");
                this.content.innerHTML = "";
                this.content.className = "content";
                con.appendChild(this.content);

                this.playState = document.createElement("div");
                this.playState.innerHTML = "PlayState: N/A";
                this.playState.className = "playState";
                con.appendChild(this.playState);

                this.readyState = document.createElement("div");
                this.readyState.innerHTML = "ReadyState: N/A";
                this.readyState.className = "readyState";
                con.appendChild(this.readyState);

                this.buffering = document.createElement("div");
                this.buffering.innerHTML = "buffering: N/A";
                this.buffering.className = "buffering";
                con.appendChild(this.buffering);

                this.error = document.createElement("div");
                this.error.innerHTML = "error: N/A";
                this.error.className = "error";
                con.appendChild(this.error);

                this.mediaInfo = document.createElement("div");
                this.mediaInfo.innerHTML = "MediaInfo:<br/>N/A";
                this.mediaInfo.className = "mediaInfo";
                con.appendChild(this.mediaInfo);

                document.getElementsByTagName("body")[0].appendChild(con);
                this.container = con;
                this.isCreated = true;

                console.info("videoDebug is created");
            },
            deinit: function () {
                this.container.remove();
            },
            show: function () {
                if (!this.isCreated) {
                    return;
                }
                this.container.style.visibility = "visible";
            },
            hide: function () {
                if (!this.isCreated) {
                    return;
                }
                this.container.style.visibility = "hidden";
            },
            pushMsg: function (logMessage) {
                console.log(logMessage);
                var i;
                if (!this.isCreated) {
                    return;
                }
                this.messageSlot.push(logMessage);
                while (this.messageSlot.length > 15) {
                    this.messageSlot.shift();
                }
                this.content.innerHTML = "";
                for (i = 0; i < this.messageSlot.length; i++) {
                    this.content.innerHTML += this.messageSlot[i] + "<br/>";
                }

            },
            updatePlayState: function (playerStateMessage) {
                if (!this.isCreated) {
                    return;
                }

                /*
                 *0 stopped
                 1 playing
                 2 paused
                 3 connecting
                 4 buffering
                 5 finished
                 6 error
                 */

                var explain = "";

                switch (playerStateMessage) {
                case 0:
                    explain = "stopped";
                    break;
                case 1:
                    explain = "playing";
                    break;
                case 2:
                    explain = "paused";
                    break;
                case 3:
                    explain = "connecting";
                    break;
                case 4:
                    explain = "buffering";
                    break;
                case 5:
                    explain = "finished";
                    break;
                case 6:
                    explain = "error";
                    break;
                }

                this.playState.innerHTML = "PlayState: " + playerStateMessage + " " + explain;
            },
            updateReadyState: function (readyStateMessage) {
                if (!this.isCreated) {
                    return;
                }
                this.readyState.innerHTML = "ReadyState: " + readyStateMessage;
            },
            updateBuffering: function (bufferMessage) {
                if (!this.isCreated) {
                    return;
                }
                this.buffering.innerHTML = "buffering: " + bufferMessage;
            },
            updateError: function (errorMessage) {
                if (!this.isCreated) {
                    return;
                }

                /*
                 *  0 A/V format not supported
                 1 Cannot connect to server or connection lost
                 2 Unidentified error
                 3/1000 File is not found
                 4/1001 Invalid protocol
                 5/1002 DRM failure
                 6/1003 Play list is empty
                 7/1004 Unrecognized play list
                 8/1005 Invalid ASX format
                 9/1006 Error in downloading play list
                 10/1007 Out of memory
                 11/1008 Invalid URL list format
                 12/1009 Not playable in play list
                 1100 Unidentified WM-DRM error
                 1101 Incorrect license in local license store
                 1102 Fail in receiving correct license from server
                 1103 Stored license is expired
                 */

                var explain = "";

                switch (errorMessage) {
                case 0:
                    explain = "A/V format not supported";
                    break;
                case 1:
                    explain = "Cannot connect to server or connection lost";
                    break;
                case 2:
                    explain = "Unidentified error";
                    break;
                case 3:
                case 1000:
                    explain = "File is not found";
                    break;
                case 4:
                case 1001:
                    explain = "Invalid protocol";
                    break;
                case 5:
                case 1002:
                    explain = "DRM failure";
                    break;
                case 6:
                case 1003:
                    explain = "Play list is empty";
                    break;
                case 7:
                case 1004:
                    explain = "Unrecognized play list";
                    break;
                case 8:
                case 1005:
                    explain = "Invalid ASX format";
                    break;
                case 9:
                case 1006:
                    explain = "Error in downloading play list";
                    break;
                case 10:
                case 1007:
                    explain = "Out of memory";
                    break;
                case 11:
                case 1008:
                    explain = "Invalid URL list format";
                    break;
                case 12:
                case 1009:
                    explain = "Not playable in play list";
                    break;
                case 1100:
                    explain = "Unidentified WM-DRM error";
                    break;
                case 1101:
                    explain = "Incorrect license in local license store";
                    break;
                case 1102:
                    explain = "Fail in receiving correct license from server";
                    break;
                case 1103:
                    explain = "Stored license is expired";
                    break;
                }

                this.error.innerHTML = "error: " + errorMessage + " " + explain;
            },
            updateMediaInfo: function (infoObj) {
                if (!this.isCreated) {
                    return;
                }
                if (typeof infoObj !== "undefined") {
                    this.mediaInfo.innerHTML = "MediaInfo:<br/>";
                    if (typeof infoObj.duration !== "undefined") {
                        this.mediaInfo.innerHTML += "duration " + infoObj.duration + "<br/>";
                    }
                    if (typeof infoObj.currentPosition !== "undefined") {
                        this.mediaInfo.innerHTML += "currentPosition " + infoObj.currentPosition + "<br/>";
                    }
                    if (typeof infoObj.bufRemain !== "undefined") {
                        this.mediaInfo.innerHTML += "bufRemain " + infoObj.bufRemain + "<br/>";
                    }
                    if (typeof infoObj.bitrateInstant !== "undefined") {
                        this.mediaInfo.innerHTML += "bitrateInstant " + infoObj.bitrateInstant + "<br/>";
                    }
                    if (typeof infoObj.bitrateTarget !== "undefined") {
                        this.mediaInfo.innerHTML += "bitrateTarget " + infoObj.bitrateTarget + "<br/>";
                    }
                }
            }
        }
    });
});
/**
 * Override XDK LgPlayer implementation
 *
 * @class tvedemo/ext/device/lg/LgPlayer
 * @extends ax/ext/device/lg/LgPlayer
 */
define("tvedemo/ext/device/lg/LgPlayer", [
    "xdk-ext-device-lg/LgPlayer",
    "xdk-base/class",
    "xdk-base/device/Media",
    "tvedemo/ext/device/shared/opif/DrmAgent",
    "xdk-base/console",
    "xdk-base/Element",
    "xdk-base/core",
    "xdk-base/util",
    "storm/helper/util",
    "tvedemo/ext/device/lg/globals",
    "tve/sServiceHolder"
], function (lgPlayer,
             klass,
             Media,
             DrmAgent,
             console,
             Element,
             core,
             util,
             stormUtil) {
    "use strict";

    function _getDeviceAPI(api) {
        var device = amd.require("xdk-base/device");
        return device[api];
    }

    function _getResolution() {
        return _getDeviceAPI("system").getDisplayResolution();
    }

    /**
     * the stopped state in LG Player
     * @constant
     */
    var LG_STATE_STOPPED = 0,
        /**
         * the playing state in LG Player
         * @constant
         */
        LG_STATE_PLAYING = 1,
        /**
         * the paused state in LG Player
         * @constant
         */
        LG_STATE_PAUSED = 2,
        /**
         * the connecting state in LG Player
         * @constant
         */
        LG_STATE_CONNECTING = 3,
        /**
         * the buffering state in LG Player
         * @constant
         */
        LG_STATE_BUFFERING = 4,
        /**
         * the finished state in LG Player
         * @constant
         */
        LG_STATE_FINISHED = 5,
        /**
         * System id used for playready license acquisition
         * @constant
         */
        SYSTEM_ID = "urn:dvb:casystemid:19219",
        /**
         * PlayReady license acquisitor for LG 2012 TV
         * @private
         * @memberof ax/ext/device/lg/LgPlayer#
         */
        playReadyLAModule,
        sMedia = Media.singleton();

    return klass.create(lgPlayer, {}, {
        /**
         * Current asset
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        _curAsset: null,
        /**
         * Current options
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        _curOpts: null,
        /**
         * Current asset's playing URL
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        _curMediaUrl: null,
        /**
         * Media type of current asset
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        _mediaType: null,
        /**
         * DRM server location
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        _DRMServer: null,

        /**
         * Playready error codes.
         * @type {Object}
         * @memberOf tvedemo/ext/device/lg/LgPlayer
         */
        _playReadyErrorTable: {

            // 2012 always throw error -2147172273, -1 = unknown.
            "-2147172273": -1,
            "-2147170812": 0x8004c604,
            "-2147170811": 0x8004c605,

            // 2014 throws error 24586 when it receives join domain error from server.
            "24586": 0x8004c605
        },

        /**
         * More human readable translations of Samsung playready error codes.
         * @type {Object}
         * @memberOf tvedemo/ext/device/lg/LgPlayer
         */
        _playReadyErrorTableReadable: {

            // 2012 Always gives the same errorCode.
            "-2147172273": "unknown_server_error",
            "-2147170812": "internal_server_error",
            "-2147170811": "join_domain",
            "24586": "join_domain"
        },

        /**
         * The audiotracks found for the current asset
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        _audioTracks: null,

        /**
         * Time to wait for a second more desriptive error message in case an error with undefined error code is received (30 seconds).
         * @type {Number}
         * @memberOf tvedemo/ext/device/lg/LgPlayer
         */
        undefinedErrorTimeout: 30000,

        init: function (devicePackage) {
            //this._setVideoDebug(true);    // TMP: Debug on during development
            this._super(devicePackage);
        },

        /**
         * To reset the plugin player when it is not currently used
         * @param {Boolean} Force reset (only reset when deinit in playReady)
         * @method reset
         * @public
         * @memberof ax/ext/device/lg/LgPlayer#
         */
        reset: function (force) {
            this._audioTracks = null;
            this._mediaType = null;
            this._curAsset = null;
            this.__infoReady = false;
            this._curOpts = null;
            this._curMediaUrl = null;

            this._super(force);
        },

        /**
         * Overriden for LgPlayer to allow for 2014 model DRM
         * @method prepare
         * @param {Object} opts options object need to prepare creating the player
         * @memberof tvedemo/ext/device/lg/LgPlayer
         * @public
         */
        prepare: function (opts) {

            var defaultVideoObject, playReadyAgent;
            if (this._prepared) {
                if (opts.drm !== this._drm) {
                    this.reset();
                } else {
                    return;
                }

            }
            this._prepared = true;

            console.log("Preparing video player (LgPlayer) 8");

            //create debug console
            if (this._videoDebugOn) {
                this.videoDebug.create();
                this.videoDebug.show();
            } else {
                this.videoDebug.hide();
            }

            //default parent node should be the body
            this._parentNode = window.document.getElementsByTagName("body")[0];

            //create div container tag
            this._playerContainer = document.createElement("div");
            this._playerContainer.id = this._CONTAINER_NAME;
            this._playerContainer.className = "playerContainer";

            this._parentNode.appendChild(this._playerContainer);
            if (opts.use3d) {
                this._type3d = "side_by_side";
                if (opts.type3d) {
                    this._type3d = opts.type3d;
                }
                if (this._support3D(opts.type3d)) {
                    this._is3d = true;
                } else {
                    this._type3d = "off";
                }
            }

            opts.bufferingTime = opts.bufferingTime || 10;

            defaultVideoObject = true;

            //create the player object
            if (opts) {
                this.videoDebug.pushMsg("Preparing for DRM using " + opts.drm);
                switch (opts.drm) {
                    case "widevine":
                    case "verimatrix":
                        this._playerContainer.innerHTML = "<object type=\"application/x-netcast-av\" drm_type =\"" + opts.drm + "\" id=\"LgPlayer\" class=\"playerObject\"" + (this._is3d ? " mode3D=\"" + this._type3d + "\"" : "") + " preBufferingTime=\"" + opts.bufferingTime + "\"></object>";
                        defaultVideoObject = false;
                        break;
                    case "playready":
                        this._playerContainer.innerHTML = "<object type=\"application/vnd.ms-sstr+xml\" id=\"LgPlayer\" class=\"playerObject\"" + (opts.audioLanguage ? " audioLanguage=\"" + opts.audioLanguage + "\"" : "") + "></object>";

                        // Set Up DRM license Agent
                        // clean up the playReady check for license sent
                        this.videoDebug.pushMsg("Create DRM Agent for playReady....");
                        try {
                            this.videoDebug.pushMsg("DrmAgent element: " + typeof(document.getElementById("drmAgent")));

                            if (!document.getElementById("drmAgent")) {
                                this.videoDebug.pushMsg("No element yet. Creating it.");
                                playReadyAgent = document.createElement("object");
                                playReadyAgent.id = "drmAgent";
                                playReadyAgent.type = "application/oipfDrmAgent";
                                playReadyAgent.style.width = 0;
                                playReadyAgent.style.height = 0;
                                this._parentNode.appendChild(playReadyAgent);
                            }
                            if (!this._playReadyAgent) {
                                this.videoDebug.pushMsg("_playReadyAgent property not set yet.");
                                this._playReadyAgent = document.getElementById("drmAgent");
                                this.videoDebug.pushMsg("Creating DrmAgent using " + this._playReadyAgent + " and " + SYSTEM_ID);
                                playReadyLAModule = new DrmAgent(this._playReadyAgent, SYSTEM_ID);
                            }
                            this.videoDebug.pushMsg("...DrmAgent created");

                        }
                        catch (err) {
                            console.error(err.message);
                        }

                        this._lastPlayReadyDrmUrl = null;
                        this._lastPlayReadyCustomData = null;

                        defaultVideoObject = false;
                        break;
                }
            }

            if (defaultVideoObject) {
                this._playerContainer.innerHTML = "<object type='application/x-netcast-av' id='LgPlayer' class='playerObject'" + (this._is3d ? "mode3D='" + this._type3d + "'" : "") + " preBufferingTime='" + opts.bufferingTime + "'></object>";
            }

            this._playerObject = this._playerContainer.firstChild;
            this.videoDebug.pushMsg("Setting player Object");
            this._playerObject.autoStart = true;
            this._playerObject.onPlayStateChange = util.bind(this._onPlayStateChange, this);
            this._playerObject.onReadyStateChange = util.bind(this._onReadyStateChange, this);
            this._playerObject.onBuffering = util.bind(this._onBuffering, this);
            this._playerObject.onError = util.bind(this._onError, this);
            this._inited = true;

            this.videoDebug.pushMsg("Player is initialized");
            return true;
        },

        /**
         * Loads media from an URL and prepares the media player before playing.
         * @param {String} mediaUrl  url string of the media
         * @param {Object} [opts] Optional - extra prarameter needed
         * @param {String} [opts.drm] DRM technology to use
         * @param {string} [opts.type] media container format to use
         * @param {String} [opts.drmUrl] (Widevine || Playready || Verimatrix) Set the DRM license url
         * @param {String} [opts.optData] (Widevine) Set the custom data
         * @param {String} [opts.portal] (Widevine) Set the portal
         * @param {String} [opts.deviceId] (Widevien) Set the device id
         * @param {String} [opts.streamId] (Widevine) Set the stream id
         * @param {String} [opts.clientIp] (Widevine) Set the client IP
         * @param {String} [opts.drmAckUrl] (Widevine) Set the drm acknowledge url
         * @param {String} [opts.heartbeatUrl] (Widevine) Set the heartbeat url
         * @param {Stinrg} [opts.heartbeatPeriod] (Widevine) Set the hearbeat period
         * @param {String{ [opts.deviceType] (Widevine) Set the widevine type
         * @param {String} [opts.authCookiesUrl] (WMDRM) Set the url to get the authentication cookies
         * @param {String} [opts.customerName] (Verimatrix) Set the customer name
         * @param {Boolean} [opts.use3d] true if to use 3D
         * @param {String} [opts.type3d] the type of 3D
         * @memberof tvedemo/ext/device/lg/LgPlayer
         */
        load: function (mediaUrl, opts) {
            var url;

            opts = opts || {};

            for (var i in opts) {
                console.log(i + ": " + opts[i]);
                if (i === "asset") {
                    stormUtil.traceObject(opts[i]._attrs, "Asset", "log", 2);
                }
            }

            if (opts.asset) {
                this._mediaType = opts.mediaType || "clip";
                this._curAsset = opts.asset;
            }

            this.joinDomainAttempts = 0;

            if (opts.serviceId) {
                this._serviceId = opts.serviceId;
                this._serviceIdFormat = opts.serviceIdFormat;
                this._denseServiceId = opts.denseServiceId;
                this._DRMServer = opts.drmUrl;
            }

            if(this._playerObject && opts.audioLanguage) {
                this._playerObject.setAttribute("audioLanguage", opts.audioLanguage);
            }

            url = this._super(mediaUrl, opts);

            console.log("Media URL: " + url);
            this._curMediaUrl = url;
            return url;
        },

        /**
         * Handling on the player when the status change
         * @function _statusChange
         * @private
         * @memberof ax/ext/device/lg/LgPlayer#
         */
        _statusChange: function (playState) {
            console.log("LgPlayer::_statusChange(" + playState + ")");
            /*case 0 : STOPPED;
             case 1 : PLAYING;
             case 2 : PAUSED;
             case 3:  CONNECTING;
             case 4:  BUFFERING;
             case 5:  FINISHED;
             case 6:  ERROR;*/

            this._super(playState);

        },
        /**
         * Start playback
         * @function playAction
         * @param { Object } opt object containing the required options
         * @param { Number } opt.sec Play the video at the specified second
         * @public
         * @memberof tvedemo/ext/device/lg/LgPlayer#
         */
        playAction: function (opts) {
            opts = opts || {};
            console.log("LgPlayer::playAction(" + opts + ")");

            this._super(opts);
        },

        /**
         * stop the playback. Overriden to be able to check for existance of stop function, which can be undefined at some moments
         * @function _stopPlayback
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayer#
         */
        _stopPlayback: function () {
            if (this._checkingProgress) {
                window.clearInterval(this._progressCheckFuncId);
                this._checkingProgress = false;
                this.videoDebug.pushMsg("Play progress checking stopped!");
            }
            if (this._playerObject && typeof(this._playerObject.stop) === "function") {
                this._playerObject.stop();
                this.videoDebug.pushMsg("PlayObject is stopped");
            }
            this._playerContainer.style.display = "none";
        },

        /**
         * Overrides LgPlayer play method
         * @method
         * @param { Object } opt object containing the required options
         * @param { Number } opt.sec Play the video at the specified second
         * @public
         * @memberof tvedemo/ext/device/lg/LgPlayer#
         */
        play: function (opts) {
            this.videoDebug.pushMsg("Using patched LgPlayer play()");

            this._curOpts = opts;

            //deprecated opts.useEvtSeek option which use old evt to skip the video
            //now it will determine the firmware year and 2011 devices will use the old evt to skip and
            //newer devices will use native seek directly

            // if pausing, juz go directly to playAction
            if (sMedia.isState(sMedia.PAUSED)) {
                this.playAction(opts);
                return;
            }

            var joinDomainCallback, licenseRequestCallback, warningMsg;
            if (this._drm === "playready") {
                if (this._playReadyDrmUrl) {

                    this.videoDebug.pushMsg("LG Player: using PlayReady: " + this.url);

                    if (this._playReadyCustomData)  this.videoDebug.pushMsg("LG Player: Custom data: " + this._playReadyCustomData);
                    if (this._DRMServer)            this.videoDebug.pushMsg("LG Player: DRMServer: " + this._DRMServer);
                    if (this._playReadyDrmUrl)      this.videoDebug.pushMsg("LG Player: DRM Url: " + this._playReadyDrmUrl);
                    if (this._denseServiceId)       this.videoDebug.pushMsg("LG Player: Service ID: " + this._denseServiceId);
                    if (this._serviceIdFormat)      this.videoDebug.pushMsg("LG Player: Service ID format: " + this._serviceIdFormat);

                    if (this._lastPlayReadyDrmUrl !== this._playReadyDrmUrl || this._lastPlayReadyCustomData !== this._playReadyCustomData) {
                        this._lastPlayReadyDrmUrl = this._playReadyDrmUrl;
                        this._lastPlayReadyCustomData = this._playReadyCustomData;

                        joinDomainCallback = util.bind(function (result) {
                            //console.log("Domain joined");
                        }, this);

                        licenseRequestCallback = util.bind(function (data) {
                            this.videoDebug.pushMsg("[LgPlayer] sendLicenseRequest result:");
                            this.videoDebug.pushMsg(data.resultMsg);

                            try {
                                this.stop();
                                this.playAction(opts);
                            }
                            catch (err) {
                                console.error(err.message);
                            }

                        }, this);

                        this.videoDebug.pushMsg("[LgPlayer] initiating DRM license request sequence");

                        // Join domain request
                        playReadyLAModule.joinDomain(this._DRMServer, this._denseServiceId, null, this._playReadyCustomData, this._serviceIdFormat).
                            then(joinDomainCallback).
                            fail(function (reason) {
                                this.videoDebug.pushMsg("[LgPlayer] joinDomain failed: " + reason);
                                // notify the upper layer through sMedia
                                sMedia._onError(0, reason);
                            }).done();

                        playReadyLAModule.sendLicenseRequest(this._playReadyDrmUrl, this._playReadyCustomData).
                            then(licenseRequestCallback).
                            fail(function (reason) {
                                this.videoDebug.pushMsg("[LgPlayer] sendLicenseRequest failed: " + reason);
                                // notify the upper layer through sMedia
                                sMedia._onError(0, reason);
                            }).done();

                    } else {
                        // license is set, play directly
                        this.playAction(opts);
                    }
                } else {
                    warningMsg = "playReady custom Param is missing! Try to play anyway";
                    this.videoDebug.pushMsg(warningMsg);
                    console.warn(warningMsg);
                    this.playAction(opts);
                }
            } else if (this._drm === "widevine") {
                // if not loaded but play widevine, juz call load first
                if (!this.__widevineLoaded) {
                    this.__lastWidevineOpts.forceReload = true;
                    sMedia.load(this.url, this.__lastWidevineOpts);
                    // the window size may distort after reload, reset it.
                    this.setWindowSize(this._currentWindowSize);
                }
                this.__widevineLoaded = false;
                this.playAction(opts);
            } else {
                this.playAction(opts);
            }
        },

        updateMediaInfo: function (infoObj) {
            // Save media info for future reference
            this.mediaInfoObj = infoObj;
            console.error("Media INFO:");
            for (var i in infoObj) {
                console.log(i + ": " + infoObj[i]);
            }
            this.__infoReady = true;
            this._super(infoObj);
        },

        deinit: function () {
            //sMedia.removeEventListener(sMedia.EVT_STATE_CHANGED, this.__stateChangeHandler);

            this._super();
        }
    });
});
/**
 * Id class to handle the device information like firmware version
 * @class tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy
 * @augments ax/device/interface/MultipleAudioTrackStgy
 */
define("tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy", ["xdk-base/class", "xdk-base/console", "xdk-base/device/interface/MultipleAudioTrackStgy", "xdk-base/promise", "xdk-base/core", "xdk-base/util", "xdk-base/exception"], function(klass, console, MultipleAudioTrackStgy, promise, core, util, exception) {
    "use strict";
    var LgMultiAudioTracks = klass.create([MultipleAudioTrackStgy], {
        LISTENER_TIMEOUT: 10
    }, {
        /**
         * player instance
         * @name __player
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        __player: null,
        /**
         * store the current audio track id
         * @name __currentAudioTrackId
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        __currentAudioTrackId: null,
        /**
         * Timeout counter for the audio ready listener
         * @name __currentAudioTrackId
         * @private
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        __audioTrackListernerCounter: 0,
        /**
         *
         * @method
         * @param {Object} player the player instance that will use this multi audio track strategy
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        init: function(player) {
            //since it need the player state and do some checking and thus linking them.
            this.__player = player;
        },
        /**
         * Get ids of Audio Tracks. It will delay 10s when the info is not ready yet.
         * Tested on Samsung 2013 devices only which support playready.
         * @method
         * @public
         * @returns {Promise.<String[]>} A list of audio track object with id
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        getAudioTracks: function() {
            console.info("[XDK LG] getting the audio track information: " + this.__player._audioTracks);
            
            if (!this.__player._audioTracks) {
                this.__audioTrackListernerCounter++;
                
                if (this.__audioTrackListernerCounter < LgMultiAudioTracks.LISTENER_TIMEOUT)
                {
                    //since the data is not ready yet, then delay 1s to check again
                    console.info("[XDK LG] Delay 1s to get the audio track info again");
                    return util.delay(1).then(util.bind(this.getAudioTracks, this));
                }
                else
                {
                    // If timeout has been reached, reject the promise
                    console.warn("Audio tracks could not be fetched before the timeout of "+LgMultiAudioTracks.LISTENER_TIMEOUT+" seconds was reached.");
                    this.__audioTrackListernerCounter = 0;
                    return promise.reject("Audio tracks could not be fetched before the timeout of "+LgMultiAudioTracks.LISTENER_TIMEOUT+" seconds was reached.");
                }
            }
            
            // Reset timer
            this.__audioTrackListernerCounter = 0;

            var noOfAudioStream, audioTracksArr, i;

            console.info("[XDK LG] Start getting the info for audio track");

            noOfAudioStream = this.__player._audioTracks.length;

            console.info("[XDK LG] " + noOfAudioStream + " audio track(s) is(are) found.");

            audioTracksArr = [];
            
            for (i = 0; i < noOfAudioStream; i++) {
                audioTracksArr.push(this.__player._audioTracks[i].id);

                console.info("[XDK LG] Audio Track " + i);
            }

            console.info("[XDK LG] Audio Tracks: " + audioTracksArr);

            return promise.resolve(audioTracksArr);

        },
        /**
         * Set audio track by id
         * @method
         * @public
         * @param {String} id The id of the audio track
         * @returns {Promise.<Boolean>} Return the result after call in a promise
         * @throws {Promise.<module:ax/exception.ILLEGAL_ARGUMENT>} wrong formated parameter.
         * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} player is not ready yet
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        setAudioTrack: function(id) {
            if (!this.__player._audioTracks) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "LG player is not ready yet."));
            }

            this.__currentAudioTrackId = id;

            var track   = this.getAudioTrackById(id);
            var player  = this.__player;
            var currentLanguage = player._playerObject.getAttribute('audioLanguage');
            var newLanguage     = "audio_"+track[MultipleAudioTrackStgy.LANGCODE];
            console.log("Current language: "+currentLanguage);
            console.info("[XDK LG] Setting stream audio to: " + newLanguage);
            if (currentLanguage != newLanguage)
            {
                var currentTime = player.getCurTime();
                console.log("Stopping playback at "+currentTime);
                player._stopPlayback();
                // Change the player audioLanguage attribute
                player._playerObject.setAttribute('audioLanguage', newLanguage);
                // Get the latest used options
                var opts = player._curOpts;
                // Add the current time
                opts.sec = currentTime;
                // Play again using the new options
                player.load(player._curMediaUrl,opts);
            }
            else
            {
                console.warn("Audio is already set to "+newLanguage);
            }
            /*
            this.__player._playerObject.pause();
            this.__player._playerObject.audioLanguage = 'audio_'+track[MultipleAudioTrackStgy.LANGCODE];
            this.__player._playerObject.play();
            */
            //this.__player._plugin.Execute("SetStreamID", 1, id);
            return promise.resolve(true);
        },
        /**
         * Set audio track by id
         * @method
         * @public
         * @param {String} id The id of the audio track
         * @param {String} attr The media audio track attribute {@link ax/device/interface/MultipleAudioTrackStgy#LANGCODE}
         * @returns {Promise.<String>} Return the result of the property
         * @throws {Promise.<module:ax/exception.ILLEGAL_ARGUMENT>} wrong formated parameter.
         * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} player is not ready yet
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        getAudioTrackAttr: function(id, attr, defaultValue) {
            console.info("Get "+attr+" from audio track "+id);
            if (!this.__player._audioTracks) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "LG player is not ready yet."));
            }

            switch (attr) {
                case MultipleAudioTrackStgy.LANGCODE:
                    //sample "eng|audio_eng"
                    //return promise.resolve(this.__player._plugin.Execute("GetStreamLanguageCode", "1", id).split("|")[0]);
                    var track = this.getAudioTrackById(id);
                    if (track)
                    {
                        console.log("Track found");
                        var language = track[attr];
                        console.log("Language: "+language);
                        return promise.resolve(language);
                    }
                    else
                    {
                        return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "Audio track with ID "+id+" not found"));
                    }
                default:
                    if (!util.isUndefined(defaultValue)) {
                        return promise.resolve(defaultValue);
                    }
            }
            //return reject if no available value for attr and no default Value
            return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "No available attribute"));
        },
        /* Get audio track object by id
         * @method getAudioTrackById
         * @public
         * @param {String} id The id of the audio track
         * @returns {Promise.<Object|null>} The id of the audio track. Some audio track is unable to obtain the current track id, it will return null.
         * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        getAudioTrackById: function (id) {
            console.info("Get audio track "+id);
            if (!this.__player._audioTracks) {
                return null;
            }
            
            var tracks = this.__player._audioTracks;
            if (isNaN(id))
            {
                for (var i=0; i<tracks.length; i++)
                {
                    if (tracks[i].id == id)
                    {
                        return tracks[i];
                    }
                }
            }
            else
            {
                // Some bug in the player sometimes calls this method using an index. This is ugly quickfix
                return tracks[id];
            }
            return null;
        },
        /* Get current audio track id
         * @method getCurrentAudioTrackId
         * @public
         * @returns {Promise.<String|null>} The id of the audio track. Some audio track is unable to obtain the current track id, it will return null.
         * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} device is not ready yet
         * @memberof tvedemo/ext/device/lg/LgPlayerMultiAudioTracksStgy#
         */
        getCurrentAudioTrackId: function() {
            return promise.resolve(this.__currentAudioTrackId);
        }
    });
    return LgMultiAudioTracks;
});
/**
 * TvKey class to handle the key, overriding the original LG TvKey handling to register smart-hub key.
 *
 * @class tvedemo/ext/device/lg/TvKey
 * @extends ax/ext/device/lg/TvKey
 */
define("tvedemo/ext/device/lg/TvKey", [
        "xdk-ext-device-lg/TvKey", 
        "xdk-base/class", 
        "xdk-base/console", 
        "xdk-base/device/vKey",
        "xdk-base/util", 
        "xdk-ext-device-lg/globals"
    ], 
    function (
        lgTvKey, 
        klass, 
        console, 
        VKey,
        util, 
        global
    ) {
    "use strict";
    return klass.create(lgTvKey, {}, {
        
        init: function () {
            this._super();
                
                
            /*
            var keyMapping = util.clone(keyMap.REMOTE, true);

            keyMapping.VKey[403] = VKey.RED; //"red";
            keyMapping.VKey[404] = VKey.GREEN; //"green";
            keyMapping.VKey[405] = VKey.YELLOW; //"yellow";
            keyMapping.VKey[406] = VKey.BLUE; //"blue";
            keyMapping.VKey[461] = VKey.BACK; //"back";
            keyMapping.VKey[415] = VKey.PLAY; //"play";
            keyMapping.VKey[19] = VKey.PAUSE; //"pause";
            keyMapping.VKey[413] = VKey.STOP; //"stop";
            keyMapping.VKey[417] = VKey.FF; //"ff";
            keyMapping.VKey[412] = VKey.RW; //"rw";
            keyMapping.VKey[118] = VKey.RED; //F7
            keyMapping.VKey[119] = VKey.GREEN; //F8
            keyMapping.VKey[120] = VKey.YELLOW; //F9
            this.initKeyMapping(keyMapping);
            */
        }
        
    });
});
define("tvedemo/ext/device/lg/TVKey", function(){});

/**
 * Detection of lg by checking the userAgent for "netcast" Return true if it is lg
 * @module xdk-ext-device-lg/detection
 */
define("xdk-ext-device-lg/detection", [], function () {
    "use strict";
    var detection = (function () {
        var agent = navigator.userAgent.toLowerCase();
        if (agent.indexOf("netcast") !== -1) {
            return true;
        }
        return false;
    })();
    return detection;
});
/**
 * Detection of playstation by checking the userAgent for "scee" Return true if it is playstation
 * @module xdk-ext-device-playstation/detection
 */
define("xdk-ext-device-playstation/detection", [],function () {
    "use strict";    
    var detection = (function () {
        var agent;
        //Mozilla/5.0 (PlayStation 3) AppleWebKit/531.3 (KHTML, like Gecko) SCEE/1.0 Nuanti/2.0
        if ( !! navigator && !! navigator.userAgent) {
            agent = navigator.userAgent.toLowerCase();
            if ((agent.indexOf("playstation") !== -1)) {
                return true;
            }
        }
        return false;
    })();
    return detection;
});
/**
 * Module to link the device PlayStation to the XDK
 * Please refer to <https://accedobroadband.jira.com/wiki/pages/viewpage.action?pageId=34635831> to have more information about the native api
 * @module xdk-ext-device-playstation/webmaf
 */
define("xdk-ext-device-playstation/webmaf", ["xdk-base/util", "xdk-base/console", "xdk-base/core"], function (util, console, core) {
    "use strict"; 
    var webmaf, _callbackList = {},
        _callbackListOnce = {};
    webmaf = {
        /**
         * send command to PlayStation
         * @public
         * @name command
         * @param {String} name the name of command
         * @param {Object} arg the arguments send to PlayStation
         * @param {Function} callback the callback when received from PlayStation
         * @param {Boolean} once To notify once or evey time when callbacks are received.
         * @memberof module:xdk-ext-device-playstation/webmaf
         */
        command: function (name, arg, callback, once) {
            var obj, p;
            //to track if there any callback
            this.addNativeEventListener(name, callback, once);

            obj = {
                "command": name
            };
            if (arg) {
                for (p in arg) {
                    obj[p] = arg[p];
                }
            }
            if (window.external && window.external.user) {
                console.info("[PlayStation]send the PlayStation command" + util.stringify(obj));
                window.external.user(util.stringify(obj));
                console.info("[PlayStation] after the send Command)");
            }
        },
        /**
         * add the listener when receiving the callback
         * @public
         * @name addNativeEventListener
         * @param {String} name the name of command
         * @param {Function} callback the callback when received from PlayStation
         * @param {Boolean} once To notify once or evey time when callbacks are received.
         * @memberof module:xdk-ext-device-playstation/webmaf
         */
        addNativeEventListener: function (name, callback, once) {
            if (!callback || !util.isFunction(callback)) {
                console.info("[PlayStation]no callback for the command" + name);
                return;
            }
            var callbackList, callbacks;
            //to distingish which callbackList
            if (once) {
                callbackList = _callbackListOnce;
            } else {
                callbackList = _callbackList;
            }

            callbacks = callbackList[name];
            //save the callback
            if (!callbacks) {
                callbacks = [];
                callbackList[name] = callbacks;
            }
            callbacks.push(callback);
        },
        /**
         * remove the listener when receiving the callback
         * @public
         * @name removeNativeEventListener
         * @param {String} name the name of command
         * @param {Function} callback the callback when received from PlayStation
         * @memberof module:xdk-ext-device-playstation/webmaf
         */
        removeNativeEventListener: function (name, callback) {
            var callbacks, i, calledOnce = false;
            callbacks = _callbackList[name];
            while (true) {
                if (callbacks && callbacks.length > 0) {
                    for (i = 0; i < callbacks.length; i++) {
                        if (callbacks[i] === callback) {
                            callbacks.splice(i, 1);
                            return;
                        }
                    }
                }
                if (calledOnce) {
                    break;
                }
                callbacks = _callbackListOnce[name];
                calledOnce = true;
            }
        },
        /**
         * To be called when there is callback from the device
         * @private
         * @name __nativeCallback
         * @param {String} data the json string received from the device
         * @memberof module:xdk-ext-device-playstation/webmaf
         */
        __nativeCallback: function (data) {
            console.info("[PlayStation]Receive command callback " + data);
            var callbacks, i, calledOnce = false;
            if (util.isString(data)) {
                data = util.parse(data);
            }
            if (data && data.command) {
                callbacks = _callbackList[data.command];
                while (true) {
                    //to find the callback in the list
                    if (callbacks && callbacks.length > 0) {
                        for (i = 0; i < callbacks.length; i++) {
                            console.info("[PlayStation] Run the callback of " + data.command);
                            callbacks[i](data);
                        }
                    }
                    if (calledOnce) {
                        //remove all the callback in the once callback list
                        delete _callbackListOnce[data.command];
                        return;
                    }
                    callbacks = _callbackListOnce[data.command];
                    calledOnce = true;
                }
                return;
            }
            console.info("[PlayStation]unknow native callback from the PlayStation");
        }
    };
    console.info("[PlayStation] Setting the accessfuntion to the nativecallback");
    //to set the callback to the webmaf when receive any data from global accessfunction
    core.root.accessfunction = webmaf.__nativeCallback;
    return webmaf;
});
/**
 * Id class to handle the device information like firmware version
 * @class xdk-ext-device-playstation/Id
 * @extends ax/device/AbstractId
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("xdk-ext-device-playstation/Id", [
    "xdk-base/class",
    "xdk-base/device/AbstractId",
    "xdk-base/console",
    "xdk-base/util",
    "xdk-ext-device-playstation/webmaf",
    "xdk-base/device/interface/Id"
], function (
    klass,
    abstrId,
    console,
    util,
    webmaf,
    IId
) {
    "use strict";

    return klass.create(abstrId, [IId], {}, {
        /**
         * To store the app version
         * @private
         * @name __appVersion
         * @memberof xdk-ext-device-playstation/Id#
         */
        __appVersion: null,
        /**
         * To store the uniqueID
         * @private
         * @name __uniqueID
         * @memberof xdk-ext-device-playstation/Id#
         */
        __uniqueID: null,
        init: function () {
            //to get the firmware at the begining
            webmaf.command("appversion", null, util.bind(function (data) {
                if (data && data.version) {
                    this.__appVersion = data.version;
                }
            }, this), true);

            //to get the firmware at the begining
            webmaf.command("hwid", null, util.bind(function (data) {
                if (data && data.hwid) {
                    this.__uniqueID = data.hwid;
                }
            }, this), true);
        },
        /**
         * To return the device type
         * @method getDeviceType
         * @public
         * @returns {String} the device type "playstation"
         * @deprecated replaced with getHardwareType
         * @memberof xdk-ext-device-playstation/Id#
         */
        getDeviceType: function () {
            return "playstation";
        },
        /**
         * To return the hardware type
         * @method getHardwareType
         * @public
         * @returns {ax/device/interface/Id.HARDWARE_TYPE} the hardware type  {@link xdk-base/device/interface/Id.HARDWARE_TYPE.CONSOLE}
         * @memberof xdk-ext-device-playstation/Id#
         */
        getHardwareType: function () {
            return IId.HARDWARE_TYPE.CONSOLE;
        },
        /**
         * To get the model of the device.
         * @method getModel
         * @public
         * @returns {String} the model numebr
         * @memberof xdk-ext-device-playstation/Id#
         */
        getModel: function () {
            var model = window.navigator.userAgent.indexOf("PlayStation 4") > -1 ? "PS4" : "PS3";
            console.info("Get Model: " + model);
            return model;
        },
        /**
         * Get the system's firmware version.
         * Return "dummyFirmware" if not available.
         *
         * @method getFirmware
         * @returns {String} firmware version
         * @memberof xdk-ext-device-playstation/Id#
         */
        getFirmware: function () {
            console.info("playstation firmware: " + this.__appVersion);
            return this.__appVersion || "dummyFirmware";
        },
        /**
         * To get the unique id
         * @method  getUniqueID
         * @returns {String} the unique id
         * @memberof xdk-ext-device-playstation/Id#
         */
        getUniqueID: function () {
            if (this.__uniqueID) {
                return this.__uniqueID;
            }
            return this._super();
        }
    });
});
/**
 * TvKey class to handle the key
 * @class xdk-ext-device-playstation/TvKey
 * @extends ax/device/AbstractTvKey
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("xdk-ext-device-playstation/TvKey", ["xdk-base/device/shared/browser/TvKey", "xdk-base/class", "xdk-base/device/vKey", "xdk-base/util", "xdk-base/device/shared/browser/keyMap", "xdk-ext-device-playstation/Id"], function (browserTvKey, klass, VKey, util, keyMap, Id) {
    "use strict"; 
    return klass.create(browserTvKey, {
        /**
         * @name R1
         * @property {String} id Virtual Key ID. "playstation:vkey:r1"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        R1: {
            id: "playstation:vkey:r1"
        },
        /**
         * @name R2
         * @property {String} id Virtual Key ID. "playstation:vkey:r2"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        R2: {
            id: "playstation:vkey:r2"
        },
        /**
         * @name R3
         * @property {String} id Virtual Key ID. "playstation:vkey:r3"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        R3: {
            id: "playstation:vkey:r3"
        },
        /**
         * @name L1
         * @property {String} id Virtual Key ID. "playstation:vkey:l1"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        L1: {
            id: "playstation:vkey:l1"
        },
        /**
         * @name L2
         * @property {String} id Virtual Key ID. "playstation:vkey:l2"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        L2: {
            id: "playstation:vkey:l2"
        },
        /**
         * @name L3
         * @property {String} id Virtual Key ID. "playstation:vkey:l3"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        L3: {
            id: "playstation:vkey:l3"
        },
        /**
         * @name TRIANGLE
         * @property {String} id Virtual Key ID. "playstation:vkey:triangle"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        TRIANGLE: {
            id: "playstation:vkey:triangle"
        },
        /**
         * @name SQUARE
         * @property {String} id Virtual Key ID. "playstation:vkey:square"
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        SQUARE: {
            id: "playstation:vkey:square"
        },
        /**
         * @name START
         * @property {String} id Virtual Key ID. "playstation:vkey:start". PS3 only
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        START: {
            id: "playstation:vkey:start"
        },
        /**
         * @name SELECT
         * @property {String} id Virtual Key ID. "playstation:vkey:select". PS3 only
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        SELECT: {
            id: "playstation:vkey:select"
        },
        /**
         * @name OPTIONS
         * @property {String} id Virtual Key ID. "playstation:vkey:options". PS4 only
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        OPTIONS: {
            id: "playstation:vkey:options"
        },
        /**
         * @name TOUCHPAD
         * @property {String} id Virtual Key ID. Touchpad click button "playstation:vkey:touchpad". PS4 only
         * @memberof xdk-ext-device-playstation/TvKey#
         */
        TOUCHPAD: {
            id: "playstation:vkey:touchpad"
        }
    }, {
        init: function () {
            var id = new Id(),
                keyMapping = util.clone(keyMap.REMOTE, true);
            keyMapping.VKey[8] = VKey.BACK; // controller O
            keyMapping.VKey[119] = this.constructor.R2; // controller R2
            keyMapping.VKey[118] = this.constructor.L2; // controller L2
            keyMapping.VKey[117] = this.constructor.R1; // controller R1
            keyMapping.VKey[116] = this.constructor.L1; // controller L1    
            keyMapping.VKey[112] = this.constructor.TRIANGLE; //Triangle
            keyMapping.VKey[32] = this.constructor.SQUARE; //Square
            keyMapping.VKey[120] = this.constructor.L3; //L3
            keyMapping.VKey[121] = this.constructor.R3; //R3

            // if it is PS4, 114 is for OPTIONS rather than START
            if (id.getModel() === "PS4") {
                keyMapping.VKey[114] = this.constructor.OPTIONS; //option
                keyMapping.VKey[135] = this.constructor.TOUCHPAD; //touchpad click button
            } else {
                keyMapping.VKey[114] = this.constructor.START; //start
                keyMapping.VKey[115] = this.constructor.SELECT; //select

                // BD Remote Number keys
                keyMapping.VKey[96] = VKey.KEY_0;
                keyMapping.VKey[97] = VKey.KEY_1;
                keyMapping.VKey[98] = VKey.KEY_2;
                keyMapping.VKey[99] = VKey.KEY_3;
                keyMapping.VKey[100] = VKey.KEY_4;
                keyMapping.VKey[101] = VKey.KEY_5;
                keyMapping.VKey[102] = VKey.KEY_6;
                keyMapping.VKey[103] = VKey.KEY_7;
                keyMapping.VKey[104] = VKey.KEY_8;
                keyMapping.VKey[105] = VKey.KEY_9;
            }


            keyMapping.VKey[127] = VKey.RW; //Scan rewind (BD Remote only)
            keyMapping.VKey[126] = VKey.FF; //Scan forward (BD Remote only)
            keyMapping.VKey[128] = VKey.PLAY; //Play (BD Remote only)
            keyMapping.VKey[122] = VKey.PREV; //Prev (BD Remote only)
            keyMapping.VKey[123] = VKey.NEXT; //Next (BD Remote only)
            keyMapping.VKey[129] = VKey.STOP; //Stop (BD Remote only)
            keyMapping.VKey[125] = VKey.RW; //Slow rewind (BD Remote only)
            keyMapping.VKey[124] = VKey.FF; //Slow forward (BD Remote only)
            keyMapping.VKey[130] = VKey.PAUSE; //Pause (BD Remote only)
            this.initKeyMapping(keyMapping);
        }
    });
});
/**
 * System class to handle the system api and connection checking
 * @class xdk-ext-device-playstation/System
 * @augments ax/device/AbstractSystem
 */
define("xdk-ext-device-playstation/System", [
    "xdk-base/class",
    "xdk-base/device/AbstractSystem",
    "xdk-base/device/shared/ConnectionPoller",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-ext-device-playstation/webmaf",
    "xdk-base/device/interface/System",
    "xdk-base/promise"
], function (
    klass,
    abstrSystem,
    ConnectionPoller,
    util,
    console,
    webmaf,
    ISystem,
    promise
) {
    "use strict";
    return klass.create(abstrSystem, {}, {
        /**
         * To store the online status
         * @private
         * @name __online
         * @memberof xdk-ext-device-playstation/System#
         */
        __online: true,
        init: function () {
            this.__visibilityHandler();
            //inherit the abstract system which will set the network checking
            this._super();
        },
        /**
         * To listen the visibility and check whether the applicaion is paused or resumed
         * @private
         * @method __visibilityHandler
         * @memberof xdk-ext-device-playstation/System#
         */
        __visibilityHandler: function () {
            //to listen to the application status change for foreground(resumed) and background(paused)
            var device = require("xdk-base/device"),
                deviceHandler = device.getDeviceHandler();

            webmaf.addNativeEventListener("applicationStatusChange", function (data) {
                if (!data) {
                    return;
                }

                console.info("[PlayStation] Received the application status change callback:" + data.applicationStatus);

                switch (data.applicationStatus) {
                case "foreground":
                    deviceHandler.onDeviceResume();
                    break;
                case "background":
                    deviceHandler.onDevicePause();
                    break;
                }
            });

        },
        /**
         * To get the display resolution
         * @public
         * @method getDisplayResolution
         * @return {Object} object {width:1280,height:720}
         * @memberof xdk-ext-device-playstation/System#
         */
        getDisplayResolution: function () {
            return {
                width: (window.innerWidth !== null ? window.innerWidth : document.body !== null ? document.body.clientWidth : null),
                height: (window.innerHeight !== null ? window.innerHeight : document.body !== null ? document.body.clientHeight : null)
            };
        },
        /**
         * Override the abstract system and return the current network status
         * @method getNetworkStatus
         * @return {Promise.<Boolean>}  Return the current network status
         * @public
         * @memberof xdk-ext-device-playstation/System#
         */
        getNetworkStatus: function () {
            return promise.resolve(this._isInternetConnected());
        },
        /**
         * To check the Internet connected or not. Relies on sytem event
         * @method _postInit
         * @return {Boolean} Return true if it is connected
         * @protected
         * @memberof xdk-ext-device-playstation/System#
         */
        _isInternetConnected: function () {
            console.info("[PlayStation] checking the internetConnected" + this.__online);
            return this.__online;
        },
        /**
         * Over the abstract system and set the current network status checking using the ajax network checking method
         * @method _postInit
         * @protected
         * @memberof xdk-ext-device-playstation/System#
         */
        _postInit: function () {
            webmaf.addNativeEventListener("networkStatusChange", util.bind(function (data) {
                if (data && data.newState) {
                    console.debug("[PlayStation] Received the network status change callback" + data.newState);
                    if (data.newState === "connected") {
                        this.__online = true;
                        this.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, this.__online);
                    } else if (data.newState === "disconnected") {
                        this.__online = false;
                        this.dispatchEvent(ISystem.EVT_NETWORK_STATUS_CHANGED, this.__online);
                    }
                }
            }, this));
        }
    });
});
/**
 *
 * DevicePack class to handle the packaging for the playstation webmaf
 *
 * 1. Use Cookies as storage
 * 2. Automatically map circle key as OK and X as back
 * 3. No exit function and handling
 * 4. Supporting PS3 and PS4. Identified by id.getModel(). Key handling has slightly different due to Sony PS hardware changes 
 *
 * ###Support Models
 *
 * * Playstation 3, 4 Webmaf
 *
 * ###Media Player
 *
 * * {@link xdk-ext-device-playstation/PSPlayer} an PlayStation Player using its own native API. And the native player is always on the bottom
 * Support multiple audio tracks
 * * {@link xdk-ext-device-playstation/Html5Player} an extended HTML5 player (Not available for production since there are some issues on html5 video)
 * Default: xdk-ext-device-playstation/PSPlayer
 *
 * ###Strategy
 * * {@link xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy} PSPlayerMultiAudioTracksStgy
 * Support only on the PSPlayer. And it allows users to switch the audio channels of the videos
 *
 * ###External Files
 * External resources are available in src/res folder
 *
 * 1. webmaf_settings.ini which indicate the app specific setting like the address
 * For the setting, please refer to wiki page
 *
 * ###Hardware Support
 *
 * 1. PlayStation controllers (PS3 supports "Start" and "Select" buttons and PS4 supports "Options" and "Touchpad" buttons)
 *
 * ###Resources
 * * <https://accedobroadband.jira.com/wiki/pages/viewpage.action?pageId=34635831>
 *
 * @class xdk-ext-device-playstation/DevicePackage
 * @extends ax/device/AbstractDevicePackage
 *
 * @author Mike Leung <mike.leung@accedo.tv>
 */
define("xdk-ext-device-playstation/DevicePackage", ["xdk-base/device/AbstractDevicePackage", "xdk-base/device/shared/CookiesStorage", "xdk-ext-device-playstation/TvKey", "xdk-ext-device-playstation/Id", "xdk-ext-device-playstation/System", "xdk-base/device/Media", "xdk-base/class", "xdk-base/util", "xdk-base/config", "xdk-base/console", "xdk-ext-device-playstation/webmaf"], function(AbsDevicePackage, CookiesStorage, TvKey, Id, System, Media, klass, util, config, console, webmaf) {
    "use strict";

    var sMedia = Media.singleton();

    return klass.create(AbsDevicePackage, {}, {
        /**
         * [Backward Compatible only] To be true when device package version >= 2.3, determine whether to run setup method in AbstractDevicePackage
         * @property {Boolean} _shouldSetup
         * @memberof xdk-ext-device-playstation/DevicePackage#
         * @protected
         */
        _shouldSetup: true,

        __callbacks: {},
        /**
         * To return platform id of this abstraction
         * @method
         * @protected
         * @returns {String} the id of the device package "playstation"
         * @memberof xdk-ext-device-playstation/DevicePackage#
         */
        getId: function() {
            return "playstation";
        },
        /**
         * setup the device package
         * @param {Function} onDeviceLoaded callback when the device is loaded.
         * @returns {xdk-ext-device-playstation/DevicePackage} abstract device package itself
         * @memberof xdk-ext-device-playstation/DevicePackage#
         */
        setup: function(onDeviceLoaded) {
            var interfaceTypes, ready;

            this._super(onDeviceLoaded);

            interfaceTypes = this.getInterfaceTypes();

            util.each(interfaceTypes, util.bind(function(pair) {
                this.addInterfaceType(pair.key, pair.value.handle, pair.value.interfaceObj);
            }, this));

            ready = util.bind(function() {
                //remove the splash screen
                webmaf.command("dismissSplash", null, util.bind(function() {
                    console.info("[PlayStation] Dismiss the Splash Screen and the apps is ready");
                    this.ready();
                }, this), true);
            }, this);

            this._preparePlayerList(ready);
        },
        /**
         * To get the default player. Default will be {@link xdk-ext-device-playstation/PSPlayer}
         * @function getDefaultPlayer
         * @returns {String[]} Array of the player list
         * @public
         * @memberof xdk-ext-device-playstation/DevicePackage#
         */
        getDefaultPlayer: function() {
            return ["xdk-ext-device-playstation/PSPlayer"];
        },
        /**
         * To init each modules like id, sMedia, system and tvkey
         * @method
         * @protected
         * @return {Object} the interfacesof tvkey, id, storage, player and system
         * @memberof xdk-ext-device-playstation/DevicePackage#
         */
        getInterfaceTypes: function() {
            var ret = {};
            ret[AbsDevicePackage.STORAGE] = {
                handle: AbsDevicePackage.STORAGE_HANDLE,
                interfaceObj: new CookiesStorage()
            };

            ret[AbsDevicePackage.MEDIA_PLAYER] = {
                handle: AbsDevicePackage.MEDIA_PLAYER_HANDLE,
                interfaceObj: sMedia
            };

            ret[AbsDevicePackage.TV_KEY] = {
                handle: AbsDevicePackage.TV_KEY_HANDLE,
                interfaceObj: new TvKey()
            };

            ret[AbsDevicePackage.ID] = {
                handle: AbsDevicePackage.ID_HANDLE,
                interfaceObj: new Id()
            };

            ret[AbsDevicePackage.SYSTEM] = {
                handle: AbsDevicePackage.SYSTEM_HANDLE,
                interfaceObj: new System()
            };

            return ret;
        }
    });
});
/**
 * HTML 5 player specifically for playstation
 * @class xdk-ext-device-playstation/Html5Player
 * @augments ax/device/shared/Html5Player
 */
define("xdk-ext-device-playstation/Html5Player", [
    "xdk-base/class",
    "xdk-base/device/shared/Html5Player",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-base/device",
    "xdk-base/device/Media"
], function (
    klass,
    Html5Player,
    util,
    console,
    device,
    Media
) {
    "use strict";

    var sMedia = Media.singleton();
    var logPrefix = "[Playstation Html5Player] ";

    return klass.create(Html5Player, {}, {
        /**
         * To seek the time
         * @method seek
         * @param {Number} sec the target time
         * @memberof xdk-ext-device-playstation/Html5Player#
         * @function
         * @public
         */
        seek: function (sec) {

            //@XDK-2830, seek do not work if set time equals length of the video. 
            //3 seconds before video length is needed by playstation. 
            var delta = -3;
            if (sec >= this.getDuration() + delta) {
                sec = this.getDuration() + delta;
            }

            //@XDK-1444 workaround for playstation if seek back to 0-1. It seems set to 0 doesn't work, so set the second time after 300ms
            if (sec >= 0 && sec <= 1) {
                this._playerObject.currentTime = sec;
                util.delay(0.3).then(util.bind(function () {
                    this._playerObject.currentTime = sec;
                }, this)).done();
            } else {
                this._playerObject.currentTime = sec;
            }
        },
        /**
         * when the video finish playing the video
         * @method
         * @memberof xdk-ext-device-playstation/Html5Player#
         * @protected
         */
        _onFinished: function () {

            console.info(logPrefix + ": finished");
            sMedia._onTimeUpdate(this.getDuration());

            //PS3, after load() video would start automatically. 
            this._playerObject.autoplay = false;

            this._stopPlayback();

            this.__hasFinished = true;
            sMedia._onFinish();

        },

        /* stop the video playback for real
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/Html5Player#
         */
        _stopPlayback: function () {

            this._playerObject.pause();

            this._playerObject.load();
            //reset the onload since it is loaded again
            this._onLoaded = false;

            this.hide();
            this._removeConnectionTimeOut();
            this._connected = false;

        },

        /**
         * resets the video player, to non-playing mode
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/Html5Player#
         */
        reset: function () {

            console.info(logPrefix + "reset: stop playback + deinit");
            this._stopPlayback();
            this.deinit();
        },

        /**
         * deinit the video player and remove the eventListener
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/Html5Player#
         */
        deinit: function () {
            console.debug(logPrefix + "deinit: removing listeners");
            this._removeVideoEventListeners(this._playerObject);
            //@XDK-2693
            //do not deinit the video tag or remove Event Listeners 
            //can't remove the dom element. webmaf webkit bug or limitation.
            //instead, just reset the src and load() on PS4. (_onFinished)

            return;
        },
        /**
         * to invoke the waiting msg
         * @method
         * @memberof xdk-base/device/playstation/Html5Player#
         * @protected
         */
        _onWaiting: function () {

            if (sMedia.isState(sMedia.CONNECTING) || this.__needBlockStateChange() || sMedia.isState(sMedia.PLAYING)) {
                return;
            }

            console.info(logPrefix + "waiting");
            sMedia._onBufferingStart();
            sMedia._onBufferingProgress();
        },
        /**
         * _onPlaying to be invoked when the player play
         * @method
         * @memberof xdk-base/device/playstation/Html5Player#
         * @protected
         */
        _onPlaying: function () {

            //ignore the state change when speeding or playing
            if (this.__needBlockStateChange() || sMedia.isState(sMedia.PLAYING)) {
                return;
            }
            console.info(logPrefix + "onplaying event");
            this._removeConnectionTimeOut();
            if (!this._pausedVideo) {
                sMedia._onPlaying();
            } else {
                sMedia._onPause();
            }
            if (sMedia.isState(sMedia.BUFFERING)) {
                sMedia._onBufferingFinish();
            }
        },

        /**
         * to update the time when the video is playing
         * @method
         * @memberof xdk-base/device/playstation/Html5Player#
         * @protected
         */
        _onTimeUpdate: function () {
            if (!this._connected) {
                return;
            }
            var curTime = this.getCurTime();
            //XDK-3018 on webmaf 1.35 it won't fire onFinished event, so manually check the current time
            if (curTime >= this.getDuration() || util.isNaN(curTime)) {
                this._onFinished();
                return;
            }
            sMedia._onTimeUpdate(curTime);
        }
    });
});
/**
 * playstation media player.
 *
 * @class xdk-ext-device-playstation/PSPlayer
 * @augments ax/device/interface/Player
 */
define("xdk-ext-device-playstation/PSPlayer", [
    "xdk-base/class",
    "xdk-base/device",
    "xdk-base/device/Media",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-base/config",
    "xdk-ext-device-playstation/webmaf",
    "xdk-base/core",
    "xdk-base/device/AbstractPlayer",
    "xdk-base/device/interface/Player",
    "require"
], function (
    klass,
    device,
    Media,
    util,
    console,
    config,
    webmaf,
    core,
    AbstractPlayer,
    IPlayer,
    require) {

    "use strict";

    var sMedia = Media.singleton(),
        resolution = null,
        getResolution = function () {
            if (resolution) {
                return resolution;
            }
            resolution = require("xdk-base/device")
                .system.getDisplayResolution();
            return resolution;
        };

    var PLAYBACK_ERRORS = IPlayer.PLAYBACK_ERRORS,
        HLS_DURATION_THRESHOLD = 5,
        DURATION_THRESHOLD = 1;

    return klass.create(AbstractPlayer, {}, {
        /**
         * the init status of the player, if it isn't true, the event Listener or player may not been attached to DOM
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _prepared: false,
        /**
         * total time of the video
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _duration: 0,
        /**
         * connection time out (in sec) when the video is fail to play
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _connectionTimeLimit: 90,
        // in sec
        /**
         * store the timeout of the connection time out
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _connectionTimeOut: null,
        /**
         * to check if it is connected
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _connected: false,
        /**
         * if the video format HLS is supported
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _supportHLS: false,
        /**
         * to check if the video format is supported
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _support: true,
        /**
         * to check if it needs to seek before play
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _seek: false,
        /**
         * to store the time which needed to be seek
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _seekTime: 0,
        /*         
         * to indicate whether playback is seeking
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _isSeeking: false,
        /*
         * Whether to enable the unblock workaround feature in seeking process with running time check.
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#   
         */
        _enableRunningTimeUnblock: true,
        /*
         * The prev elapsed time     
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#     
         */
        _prevElapsedTime: 0,
        /*
         * The prev elapsed time for paused Skip unblock workaround
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#       
         */
        _prevPausedElapsedTime: 0,
        /**
         * to store the last loaded media URL
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _url: null,
        /**
         * to store the bandwidth
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _bandwidth: null,
        /**
         * to store the current bitrate
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _currentBitrate: null,
        /**
         * to store the current available Bitrates
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _availableBitrates: [],
        /**
         * function that will get the current video stats, time, current bitrate.
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _updatePlaybackStateFn: null,
        /**
         * Time Interval, interval to trigger  _updatePlaybackStateFn
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __timeInterval: null,
        /**
         * prefix message for logs and debug
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __logPrefix: "[XDK] [PSPlayer] ",
        /**
         * Prepare the player
         * @name prepare
         * @method
         * @param {object} opts The opts parameter passed from {@link xdk-base/device/Media#load|device.media.load}
         * @param {HTMLElement} [opts.parentNode] parentNode to be append the player object.
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */

        prepare: function (opts) {
            this._mediaOpts = opts;

            if (this._prepared) {
                return;
            }

            console.info(this.__logPrefix + "Native player is not a DOM object and unable to place into another node");
            this._prepared = true;

            this._addPlaybackEventListeners();
        },
        /**
         * To perform the action (predefined seek or change into buffering state) when the media is ready
         * @method __onLoad
         * @param {Object} data the meta data of the media from the device
         * @param {Number} data.totalLength media duration
         * @private
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __onLoad: function (data) {
            this._onLoaded = true;
            this._clearConnectionTimeout();

            if (this._isVideoMetricsAvailable()) {

                console.info(this.__logPrefix + "_updatePlaybackStateFn: Using videometrics");

                this._updatePlaybackStateFn = util.bind(function () {
                    var vm = this.getVideoMetrics();
                    this.__onTimeUpdate({
                        elapsedTime: vm.elapsed / 1000
                    });
                    this._setDuration(vm.duration / 1000);
                    var bitrateObj = {
                        bitrate: vm.currentBitrate,
                        bitrates: vm.bitrates,
                        bandwidth: vm.bandwidth
                    };

                    this.__setBitrateData(bitrateObj);
                }, this);
            } else {

              this._setDuration(data.totalLength);
                this._updatePlaybackStateFn = util.bind(function () {
                    console.info(this.__logPrefix + "_updatePlaybackStateFn: Using WebMaf commands");
                    webmaf.command("getPlaybackTime");
                    webmaf.command("getBitrate", null, this.__setBitrateData);
                }, this);

            }

            //begin to getPlayback time when it is ready
            this.__enableTimeInterval(true);

            //seek time should be after setting the total time, otherwise there are conflict and condition checking error
            if (this._seek && this._seekTime > 0) {
                this.seek(this._seekTime);
                this._seek = false;
            }

            if (!this._connected) {
                return;
            }

            console.info(this.__logPrefix + "onload event");
            sMedia._onBufferingStart();
            sMedia._onBufferingProgress();
        },
        /**
         * resets the video player, to non-playing mode
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        reset: function () {
            if (!this._prepared) {
                return;
            }

            this._prepared = false;
            this._isSeeking = false;
            this._prevPausedElapsedTime = 0;
            this._prevElapsedTime = 0;

            this._removePlaybackEventListeners();
            this._stopPlayback();
            this.deinit();
        },
        /**
         * to handle when status change received from the device
         * @method
         * @private
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __onStatusChange: function (data) {
            //convert the state into the right variable
            var status = data.playerState;
            console.info(this.__logPrefix + "receive the status change " + status);
            switch (status.toLowerCase()) {
            case "buffering":
                sMedia._onBufferingStart();
                sMedia._onBufferingProgress();
                this._resetConnectionTimeout();
                break;
            case "endofstream":
                this.__onFinished();
                break;
            case "notready":
                break;
            case "opening":
                if (sMedia.isState(sMedia.STOPPED)) {
                    sMedia._onConnecting();
                }
                this._resetConnectionTimeout();
                break;
            case "paused":
                //to clear time out from buffering to paused state
                this._clearConnectionTimeout();
                this._isSeeking = false;
                sMedia._onPause();
                //XDK-3108 Update the time when paused after pop
                this._updatePlaybackStateFn();
                break;
            case "playing":
                this._clearConnectionTimeout();
                if (this.__witholdSkip) {
                    return;
                }
                if (this._seek && this._seekTime > 0) {
                    this.seek(this._seekTime);
                    this._seek = false;
                }
                this._isSeeking = false;
                if (sMedia.isState(sMedia.BUFFERING)) {
                    sMedia._onBufferingFinish();
                }
                sMedia._onPlaying();
                break;
            case "stopped":
                break;
            case "unknown":
                break;
            }
            console.log(this.__logPrefix + "update the state" + status);
        },
        /**
         * deinit the video player and remove the eventListener
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        deinit: function () {
            if (!this._prepared) {
                return;
            }
            this._prepared = false;
            console.info(this.__logPrefix + "player deinit successfull.");
            return;
        },
        /**
         * play the video item
         * @method
         * @param {Object} param object containing the required options
         * @param {Number} param.sec Play the video at the specified second
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        play: function (opts) {
            console.info(this.__logPrefix + "Play requested.");

            if (!this._support) {
                this._stopPlayback();
                sMedia._onError(PLAYBACK_ERRORS.RENDER.UNSUPPORTED, this.__logPrefix + "unsupport format in the playstation video player");
                return;
            }

            if (sMedia.isState(sMedia.STOPPED)) {
                this._onLoaded = false;

                var mediaOpts = this._mediaOpts,
                    commandArgs = {
                        contentUri: this.url
                    };

                if (mediaOpts.drm === "playready") {
                    // license uri and custom data are both optional and independent to each other

                    // if license uri is available
                    if (mediaOpts.drmUrl) {
                        commandArgs.licenseUri = mediaOpts.drmUrl;
                    }

                    // if custom data is available
                    if (mediaOpts.customData) {
                        commandArgs.customData = mediaOpts.customData;
                    }
                }

                var bitrates = {
                    bitratesFrom: 0,
                    bitratesTo: 0
                };

                if (mediaOpts.hasOwnProperty("bitratesFrom")) {
                    bitrates.bitratesFrom = mediaOpts.bitratesFrom;
                }

                if (mediaOpts.hasOwnProperty("bitratesTo")) {
                    bitrates.bitratesTo = mediaOpts.bitratesTo;
                }

                this.setFixVideoRepresentations(bitrates);

                webmaf.command("load", commandArgs);

                sMedia._onConnecting();
                this._resetConnectionTimeout();
            } else {
                //restart the time interval when from non-stop like pause to play
                this.__enableTimeInterval(true);
            }

            this._seek = false;
            if (opts && opts.sec) {
                this._seek = true;
                this._seekTime = opts.sec;
            }

            webmaf.command("play");
        },
        /**
         * To get the current time from the player
         * @method
         * @param {Boolean} bool To enable the time interval to get the current time
         * @private
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __enableTimeInterval: function (bool) {
            if (this.__timeInterval) {
                clearInterval(this.__timeInterval);
                this.__timeInterval = null;
            }
            // do it each time when set time interval to make sure the time is updated
            this._updatePlaybackStateFn();

            if (bool) {
                this.__timeInterval = setInterval(this._updatePlaybackStateFn, 500);
            }
        },
        /**
         * pause the video item
         * @method
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        pause: function () {

            if (this._isSeeking) {
                console.info(this.__logPrefix + "The playback is in seeking state, block pause action.");
                return;
            }

            console.info(this.__logPrefix + "Pausing video.");
            webmaf.command("pause");
            sMedia._onPause();
            this.__enableTimeInterval(false);
            // there may be a short delay of the state update
            // update the last time after a short delay to get the accurate state
            //XDK-3108,XDK-3109 Fail to update the time when paused, especially a delay is needed when popped.
            util.delay(0.2).done(this._updatePlaybackStateFn);
        },
        /**
         * stop the video playback
         * @method
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        stop: function () {
            console.info(this.__logPrefix + "Stopping video");
            this._stopPlayback();
            sMedia._onStopped();
        },
        /**
         * stop the video playback for real
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _stopPlayback: function () {
            this._clearConnectionTimeout();
            this.__enableTimeInterval(false);
            this._currentBitrate = null;
            this._availableBitrates = null;
            this._bandwidth = null;
            webmaf.command("stop");
        },
        /**
         * resume playing the video
         * @method
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        resume: function () {

            if (sMedia.isState(sMedia.PAUSED) && this._isSeeking) {
                console.info(this.__logPrefix + "The paused playback is in seeking state, block resume action.");
                return;
            }

            this.__enableTimeInterval(true);
            console.info(this.__logPrefix + "Resuming...");
            webmaf.command("play");
            sMedia._onPlaying();
        },
        /**
         * Skip the playback forward/backward for certain seconds
         * @method
         * @param {Number} sec number of seconds to skip (10 by default)
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        skip: function (sec) {

            if (this._isSeeking) {
                console.info(this.__logPrefix + "The playback is in seeking state, block skip action.");
                return;
            }

            var time = this.getCurTime() + sec;

            if (sMedia.isState(sMedia.PAUSED)) {
                this.__witholdSkip = true;

                this.__setCurTime(time);
                sMedia._onTimeUpdate(time);

                webmaf.command("setPlayTime", {
                    playTime: Math.floor(time)
                }, util.bind(function () {
                    this.__witholdSkip = false;
                }, this), true);

            } else {
                this.seek(time);
            }
        },
        /**
         * Seek to specifiy position of the video
         * @method
         * @param {Number} sec the position to seek to in seconds
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        seek: function (sec) {
            //XDK-1620 Tried to seek for 0 sec but it doesn't work. So it will convert into 1 sec when seeking for 0sec.
            if (sec === 0) {
                sec = 1;
            }

            //XDK-3117 Fail to seek when close to the end with type hls/aes128
            if (this._mediaOpts && (this._mediaOpts.type === "hls" || this._mediaOpts.drm === "aes128") && sec > this.getDuration() - HLS_DURATION_THRESHOLD) {
                sec = this.getDuration() - HLS_DURATION_THRESHOLD;
            } else if (sec === this.getDuration()) {
                //XDK-1475. It is unable to set the time to be duration. So we will try to minus one to seek the duraton time
                sec = this.getDuration() - DURATION_THRESHOLD;
            }
            sec = Math.max(0, sec);
            webmaf.command("setPlayTime", {
                playTime: Math.floor(sec)
            });
        },

        /**
         * get bitrate and available bitrates
         * @method
         * @return {ax/device/interface/Player~MediaBitrates}
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */

        getBitrates: function () {

            if (this._currentBitrate === null) {
                return false;
            }

            return {
                currentBitrate: this._currentBitrate,
                availableBitrates: this._availableBitrates
            };
        },

        /**
         * get bandwidth
         * @method
         * @return {String}
         * @public
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */

        getBandwidth: function () {

            if (this._bandwidth === null) {
                return false;
            }

            return this._bandwidth;
        },

        /**
         * At least one parameter is compulsory up to a total of four. Any parameters can be left as 0 and will be ignored.
         * This function must be called before the command load in order to have effect. Any load command thereafter is affected.
         * Setting all parameters to 0 will remove any restrictions for video representations.
         *
         * @method
         * @param {Object} opts The options for setting bitrate
         * @param {Number} [opts.minBitrate=0] Min bitrate representation allowed measured in b/s
         * @param {Number} [opts.maxBitrate=0] Max bitrate representation allowed measured in b/s
         * @param {Number} [opts.minLumaSample=0] Min luma sample representation allowed measured in pixels (hxw)
         * @param {Number} [opts.maxLumaSample=0] Max luma sample representation allowed measured in pixels (hxw)
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        setFixVideoRepresentations: function (opts) {

            var videoRepresentationsObj = {
                minBitrate: 0,
                maxBitrate: 0,
                minLumaSample: 0,
                maxLumaSample: 0
            };

            if (opts.minBitrate) {
                videoRepresentationsObj.minBitrate = opts.minBitrate;
            }
            if (opts.maxBitrate) {
                videoRepresentationsObj.maxBitrate = opts.maxBitrate;
            }
            if (opts.minLumaSample) {
                videoRepresentationsObj.minLumaSample = opts.minLumaSample;
            }
            if (opts.maxLumaSample) {
                videoRepresentationsObj.maxLumaSample = opts.maxLumaSample;
            }

            webmaf.command("setFixVideoRepresentations", videoRepresentationsObj);

        },

        /**
         * Get the current playback time
         * @method
         * @return {Number} the current playback time
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @public
         */
        getCurTime: function () {
            return this._currentTime;
        },
        /**
         * set the current playback time
         * @method
         * @param {Number} the current playback time
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @private
         */
        __setCurTime: function (time) {
            this._currentTime = time;
        },
        /**
         * to set the total time of the player
         * @method
         * @param {Number} time the duration time
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        _setDuration: function (time) {
            this._duration = time;
        },
        /**
         * to get the total time of the video
         * @method
         * @return {number} the total time of the video
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @public
         */
        getDuration: function () {
            return this._duration;
        },
        /**
         * Gets the player's capabilities
         * @method
         * @return {Object} object of the available capitilites of type and drms
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        getCapabilities: function () {
            var cap = {
                type: ["mp4", "hls", "dash"],
                drms: ["playready", "aes128"]
            };
            return cap;
        },
        /**
         * Loads the specified media
         * @method
         * @param {String} url the URL address of the media
         * @param {Object} [opts] the options for loading this media
         * @param {module:xdk-base/device/playerRegistry.DRM} [opts.drm] DRM to be used
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        /*jshint unused:false*/
        load: function (mediaUrl, opts) {
            this.url = mediaUrl;

            if (!this._prepared) {
                return false;
            }
            return mediaUrl;
        },
        /*jshint unused:true*/
        /**
         * Sets video window size
         * @method
         * @param {Object} param window size parameter
         * @param {Integer} param.top window top
         * @param {Integer} param.left window left
         * @param {Integer} param.width window width
         * @param {Integer} param.height window height
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        setWindowSize: function (obj) {
            var res = getResolution();
            var height = res.height / 2,
                width = res.width / 2,
                ltx = obj.left / width - 1,
                lty = -(obj.top / height - 1),
                rbx = (obj.left + obj.width) / width - 1,
                rby = -((obj.top + obj.height) / height - 1);
            webmaf.command("setVideoPortalSize", {
                ltx: ltx,
                lty: lty,
                rbx: rbx,
                rby: rby
            });

            this._currentWindowSize = obj;
            return;
        },
        /**
         * Sets video window size as full screen
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        setFullscreen: function () {
            var res = getResolution();
            this.setWindowSize({
                top: 0,
                left: 0,
                height: res.height,
                width: res.width
            });
        },
        /*globals videometrics:true*/
        /**
         * Get webmaf videometrics object.
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        getVideoMetrics: function () {
            videometrics.poll();
            return videometrics;
        },
        /**
         * Check if videometrics global exists
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _isVideoMetricsAvailable: function () {
            return !util.isUndefined(videometrics);
        },
        /*globals videometrics:false*/
        /**
         * Add the event listeners for the playback events.
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _addPlaybackEventListeners: function () {
            this.__bindedOnStatusChange = util.bind(this.__onStatusChange, this);
            webmaf.addNativeEventListener("playerStatusChange", this.__bindedOnStatusChange);

            this.__bindedOnLoad = util.bind(this.__onLoad, this);
            webmaf.addNativeEventListener("contentAvailable", this.__bindedOnLoad);

            this.__bindedOnTimeUpdate = util.bind(this.__onTimeUpdate, this);
            webmaf.addNativeEventListener("getPlaybackTime", this.__bindedOnTimeUpdate);

            this.__bindedOnSetPlayTime = util.bind(this.__onSetPlayTime, this);
            webmaf.addNativeEventListener("setPlayTime", this.__bindedOnSetPlayTime);

            this.__bindedOnPlayerMessage = util.bind(this.__onPlayerMessage, this);
            webmaf.addNativeEventListener("playerMessage", this.__bindedOnPlayerMessage);

            this.__bindedOnStreamError = util.bind(this.__onStreamingError, this);
            webmaf.addNativeEventListener("playerStreamingError", this.__bindedOnStreamError);

            this.__bindedOnError = util.bind(this.__onError, this);
            webmaf.addNativeEventListener("playerError", this.__bindedOnError);
        },
        /**
         * Remove the event listeners for the playback events.
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _removePlaybackEventListeners: function () {
            webmaf.removeNativeEventListener("playerStatusChange", this.__bindedOnStatusChange);
            webmaf.removeNativeEventListener("contentAvailable", this.__bindedOnLoad);
            webmaf.removeNativeEventListener("getPlaybackTime", this.__bindedOnTimeUpdate);
            webmaf.removeNativeEventListener("setPlayTime", this.__bindedOnSetPlayTime);
            webmaf.removeNativeEventListener("playerMessage", this.__bindedOnPlayerMessage);
            webmaf.removeNativeEventListener("playerStreamingError", this.__bindedOnStreamError);
            webmaf.removeNativeEventListener("playerError", this.__bindedOnError);
        },
        /**
         * Timeout to throw error if it is still in connecting with the connectionTimeLimit
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _onConnectionTimeout: function () {
            this._stopPlayback();
            sMedia._onError(PLAYBACK_ERRORS.NETWORK.FAILED, "Connection error");
            console.info(this.__logPrefix + "Connection error: _onConnectionTimeout");
        },
        /**
         * To remove the connection time out set when set Media url and play
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        _clearConnectionTimeout: function () {
            util.clearDelay(this._connectionTimeOut);
        },
        /**
         * Reset the connection timeout, which will timeout after `this._connectionTimeLimit` seconds.
         * Upon timeout, `this._onConnectionTimeout` will be invoked.
         * Reseting the timeout will clear any previous timeout.
         * The connection timeout can be cleared using `_clearConnectionTimeout`.
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        _resetConnectionTimeout: function () {
            this._clearConnectionTimeout();
            this._connectionTimeOut = core.getGuid();
            util.delay(this._connectionTimeLimit, this._connectionTimeOut)
                .then(util.bind(this._onConnectionTimeout, this))
                .done();
        },
        /**
         * to update the time when the video is playing
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        __onTimeUpdate: function (data) {

            var currentTime = data.elapsedTime;

            if (this._enableRunningTimeUnblock && this._isSeeking) {
                if (sMedia.isState(sMedia.PAUSED)) {
                    // workaround of unblock isSeeking for seeked under paused state.
                    if (this._prevPausedElapsedTime > 0 && currentTime !== this._prevPausedElapsedTime && currentTime !== (this._prevPausedElapsedTime + 1)) {
                        this._isSeeking = false;

                        this._prevPausedElapsedTime = 0;
                    } else {
                        this._prevPausedElapsedTime = currentTime;
                    }

                } else {
                    // workaround of unblock isSeeking for seeked.
                    if (this._prevElapsedTime > 0 && currentTime === (this._prevElapsedTime + 1)) {
                        this._isSeeking = false;
                    }
                    this._prevElapsedTime = currentTime;
                }
                //no need to update the time when isSeeking.
                return;
            }

            this.__setCurTime(currentTime);
            sMedia._onTimeUpdate(currentTime);
        },

        /*
         * to indicate setPlayTime command has started.
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __onSetPlayTime: function (data) {
            if (!data || data.status !== "ok") {
                return;
            }

            this._isSeeking = true;

            if (this._enableRunningTimeUnblock && sMedia.isState(sMedia.PAUSED)) {
                // let the getTime run to check when to unblock for the workaround.
                this.__enableTimeInterval(true);
            }
        },
        /**
         * to indicate setPlayTime command has completed.
         * @method
         * @protected
         * @memberof xdk-ext-device-playstation/PSPlayer#
         */
        __onPlayerMessage: function (data) {
            if (!data || data.msg_info !== "setPlayTimeSuccess") {
                return;
            }

            // do not use runningTimeUnblock workaround if support "setPlayTimeSuccess" (webmaf 1.31+)
            if (this._enableRunningTimeUnblock) {
                this._enableRunningTimeUnblock = false;
                //since the first setPlayTime will create an unnecessary interval since onPlayMessage is never called before.
                if (sMedia.isState(sMedia.PAUSED)) {
                    this.__enableTimeInterval(false);
                }
            }
            //update the time when successfully set the time
            this._updatePlaybackStateFn();
            this._isSeeking = false;
        },
        /**
         * to update the bitrates data
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        __setBitrateData: function (data) {

            this._availableBitrates = data.bitrates;
            this._currentBitrate = data.bitrate;
            this._bandwidth = data.bandwidth;

        },
        /**
         * when the video finish playing the video
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        __onFinished: function () {
            console.info(this.__logPrefix + "finished event");
            //since it won't update the time when finish
            this.__setCurTime(this.getDuration());
            sMedia._onTimeUpdate(this.getCurTime());

            this._stopPlayback();
            sMedia._onFinish();
        },
        /**
         * when the video has streaming error
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        __onStreamingError: function (data) {
            this.__enableTimeInterval(false);
            //to clear the connection time out when error
            this._clearConnectionTimeout();
            // to avoid throw second error when it is alreay in error state or it is already finished
            if (sMedia.isState(sMedia.STOPPED)) {
                return;
            }
            if (data.error && data.status_code) {

                switch (data.error) {

                case "http_connection":
                    //http_connection: connection cannot be stablish with the server. 
                    sMedia._onError(PLAYBACK_ERRORS.NETWORK.FAILED, {
                        code: data.status_code,
                        msg: data.error
                    }, data);
                    break;
                case "http_status_code":
                    //http_status_code, connection stablished, but status_code returned.
                    sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, {
                        code: data.status_code,
                        msg: data.error
                    }, data);
                    break;

                }

                console.error(this.__logPrefix + "onRenderError : " + data.error + "with error Code" + data.status_code);

            } else if (data.status) {

                sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, {
                    code: data.status_code,
                    msg: data.error
                }, data);

                console.error(this.__logPrefix + "onRenderError : with status " + data.status);

            } else {

                sMedia._onError(PLAYBACK_ERRORS.GENERIC.UNKNOWN, null, data);

            }
        },
        /**
         * The error object from the device. It may contain other error attributes depend on the video player or technology used.
         * @typedef {Object} Error
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @property {String} error the error type
         * @property {String} error_code the error code
         */
        /**
         * when the video has a video error
         * the error message will be the JSON stringify of error object. {@link xdk-ext-device-playstation/PSPlayer.Error}
         * @method
         * @memberof xdk-ext-device-playstation/PSPlayer#
         * @protected
         */
        __onError: function (data) {

            if (data && data.error_info && data.error_info.indexOf("sceAvPlayerJumpToTime") > 0) {
                console.info("Ignore sceAvPlayerJumpToTime error as it won't affect anything of playback.");
                return;
            }

            //stop the getPlayback time
            this.__enableTimeInterval(false);

            //to clear the connection time out when error
            this._clearConnectionTimeout();

            if (data.error && data.error_code_hexa) {

                switch (data.error) {

                case "video_error":
                    sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, {
                        code: data.error_code_hexa,
                        msg: data.error
                    }, data);
                    break;
                case "drm_error":
                    sMedia._onError(PLAYBACK_ERRORS.DRM.FAILED, {
                        code: data.error_code_hexa,
                        msg: data.error
                    }, data);
                    break;

                }

                console.error(this.__logPrefix + "onRenderError : " + data.error + "with error code: " + data.error_code_hexa);


            } else if (data.status) {

                sMedia._onError(PLAYBACK_ERRORS.RENDER.FAILED, {
                    code: data.status_code,
                    error: data.error
                }, data);

                console.error(this.__logPrefix + "onRenderError : with status " + data.status);

            } else {

                sMedia._onError(PLAYBACK_ERRORS.GENERIC.UNKNOWN, {
                    code: data.status_code,
                    error: data.error
                }, data);

                console.error(this.__logPrefix + "onRenderError : unknown ");

            }


        }
    });
});
/**
 * PSPlayer Multi audio track support strategy
 * @class xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy
 * @augments ax/device/interface/MultipleAudioTrackStgy
 */
define("xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy", ["xdk-base/class", "xdk-base/console", "xdk-base/device/interface/MultipleAudioTrackStgy", "xdk-base/promise", "xdk-base/core", "xdk-base/exception", "xdk-base/util", "xdk-ext-device-playstation/webmaf", "xdk-base/device/Media"], function(klass, console, MultipleAudioTrackStgy, promise, core, exception, util, webmaf, Media) {
    "use strict";
    var PSPlayerMultiAudioTracksStgy,
        sMedia = Media.singleton();

    PSPlayerMultiAudioTracksStgy = klass.create([MultipleAudioTrackStgy], {}, {
        /**
         * player instance
         * @name __player
         * @private
         * @memberof xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy#
         */
        __player: null,
        /**
         *
         * @method
         * @param {Object} player the player instance that will use this multi audio track strategy
         * @memberof xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy#
         */
        init: function(player) {
            //since it need the player state and do some checking and thus linking them.
            this.__player = player;
        },
        /**
         * Get ids of Audio Tracks
         * @method
         * @protected
         * @returns {Promise.<String[]>} A list of audio track object with id.
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} player is stopped
         * @memberof xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy#
         */
        getAudioTracks: function() {
            //stop the loop when the player is changed into stopped state, directly return rejected promise in order to avoid error case
            if (sMedia.isState(sMedia.STOPPED)) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Unable to get the audio track when the player is stopped."));
            }

            if (!this.__player._onLoaded) {
                //since the data is not ready yet, then delay 10s to check again
                console.info("[XDK playstation] Delay 10s to get the audio track info again");
                return util.delay(10).then(util.bind(this.getAudioTracks, this));

            }
            var i, audioTracksArr = [],
                audioTracksObjsArr = [],
                deferred = promise.defer();

            webmaf.command("getAudioTracks", {}, function(data) {
                console.info("[XDK playstation]Audio Tracks: " + data);
                if (data.audioTracks) {
                    audioTracksArr = data.audioTracks.split(",");
                    //convert the audio Tracks from string array into audioTrackObj array
                    for (i = 0; i < audioTracksArr.length; i++) {
                        audioTracksObjsArr.push(audioTracksArr[i]);
                        console.info("[XDK playstation] Available audio track is " + audioTracksArr[i]);
                    }
                }

                deferred.resolve(audioTracksObjsArr);
            }, true);

            return deferred.promise;
        },

        /**
         * Set audio track by id
         * @method
         * @protected
         * @param {String} id The id of the audio track
         * @returns {Boolean} Return the result after call in a promise
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} player is not ready yet
         * @memberof xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy#
         */
        setAudioTrack: function(id) {
            if (!this.__player._onLoaded) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "PSPlayer is not ready yet."));
            }

            console.info("[XDK playstation]Set stream ID to: " + id);

            webmaf.command("setAudioTrack", {
                audioTrack: id
            });

            return promise.resolve(true);
        },
        /**
         * Set audio track by id
         * @method
         * @public
         * @param {Number} id The id of the audio track
         * @param {String} attr The media audio track attribute like {@link xdk-base/device/interface/MultipleAudioTrackStgy#LANGCODE}
         * @returns {Promise.<Mixed>} Return the result of the property
         * @throws {Promise.<module:xdk-base/exception.UNSUPPORTED_OPERATION>} player is not ready yet
         * @memberof xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy#
         */
        getAudioTrackAttr: function(id, attr, defaultValue) {
            if (!this.__player._onLoaded) {
                return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "PSPlayer is not ready yet."));
            }

            switch (attr) {
                case MultipleAudioTrackStgy.LANGCODE:
                    return promise.resolve(id);
                default:
                    if (!util.isUndefined(defaultValue)) {
                        return promise.resolve(defaultValue);
                    }
            }

            //return reject if no available value for attr and no default Value
            return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "No valid argument and unable to obtain the audio track attritbue."));
        },

        /* Get current audio track id
         * @method getCurrentAudioTrackId
         * @public
         * @returns {Promise.<String>} The id of the audio track
         * @memberof xdk-ext-device-playstation/PSPlayerMultiAudioTracksStgy#
         */
        getCurrentAudioTrackId: function() {
            if (!this.__player._onLoaded) {
                //since the data is not ready yet, then delay 10s to check again
                console.info("[XDK playstation] Delay 10s to get the audio track info again");
                return util.delay(10).then(util.bind(this.getAudioTracks, this));

            }
            var deferred = promise.defer(),
                currentTrackId = null;

            webmaf.command("getAudioTracks", {}, function(data) {
                console.info("[XDK playstation]Audio Tracks: " + data);
                if (data.currentAudioTrack) {
                    currentTrackId = data.currentAudioTrack;
                }

                deferred.resolve(currentTrackId);

            }, true);

            return deferred.promise;
        }
    });
    return PSPlayerMultiAudioTracksStgy;
});
/**
 * playstation media player, extended from ax/ext/device/playstation/PSPlayer.
 *
 * @class tvedemo/ext/device/playstation/PSPlayer
 */
define("tvedemo/ext/device/playstation/PSPlayer", [
    "xdk-base/class",
    "xdk-base/device",
    "xdk-base/device/Media",
    "xdk-base/util",
    "xdk-base/console",
    "xdk-ext-device-playstation/webmaf",
    "xdk-ext-device-playstation/PSPlayer",
    "require",
    "tvedemo/wgt/vLoading"
], function (
    klass,
    device,
    Media,
    util,
    console,
    webmaf,
    PSPlayer,
    require,
    vLoading) {

    "use strict";

    var sMedia = Media.singleton();

    return klass.create(PSPlayer, {}, {

        /*
         * Indicator of playback seeking state        
         */
        _isSeeking: false,
        /*
         * Whether to enable the unblock workaround feature in seeking process with running time check.   
         */
        _enableRunningTimeUnblock: true,
        /*
         * The prev elapsed time        
         */
        _prevElapsedTime: 0,
        /*
         * The prev elapsed time for paused Skip unblock workaround       
         */
        _prevPausedElapsedTime: 0,
        /**
         * To get the current time from the player
         * @method
         * @param {Boolean} bool To enable the time interval to get the current time
         * @overrided
         * @private
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        __enableTimeInterval: function (bool) {
            if (this.__timeInterval) {
                clearInterval(this.__timeInterval);
                this.__timeInterval = null;
            }

            if (bool) {
                this.__timeInterval = setInterval(util.bind(function () {
                    if (this._enableRunningTimeUnblock && this._isSeeking) {
                        webmaf.command("getPlaybackTime", null, this.__bindedOnTimeUpdate);
                    } else {
                        webmaf.command("getPlaybackTime");
                    }
                }, this), 1000);
            }
        },
        /**
         * play the video item
         * @method
         * @param {Object} param object containing the required options
         * @param {Number} param.sec Play the video at the specified second
         * @public
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        play: function(opts) {
            // Reset isSeeking to avoid getting stuck in a isSeeking state.
            this._isSeeking = false;
            vLoading.close();

            this._super(opts);
        },

        /**
         * pause the video item
         * @method
         * @overrided
         * @public
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        pause: function () {
            if (this._isSeeking) {
                console.warn("The playback is in seeking state, block pause action.");
                return;
            }

            //console.info("[XDK playstation] Pausing video.");
            this.__enableTimeInterval(false);
            webmaf.command("pause");
            sMedia._onPause();
        },
        
        /**
         * Override the Skip function of xdk PSPlayer with isSeeking blocking.
         * @method
         * @overrided
         * @param {Number} sec number of seconds to skip (10 by default)
         * @public
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        skip: function (sec) {
            if (this._isSeeking) {
                console.warn("The playback is in seeking state, block skip action.");
                return;
            }

            this._super(sec);
        },

        /**
         * Add the event listeners for the playback events.
         * @method
         * @overrided
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        _addPlaybackEventListeners: function () {
            this.__bindedOnStatusChange = util.bind(this.__onStatusChange, this);
            webmaf.addNativeEventListener("playerStatusChange", this.__bindedOnStatusChange);

            this.__bindedOnLoad = util.bind(this.__onLoad, this);
            webmaf.addNativeEventListener("contentAvailable", this.__bindedOnLoad);

            this.__bindedOnTimeUpdate = util.bind(this.__onTimeUpdate, this);
            webmaf.addNativeEventListener("getPlaybackTime", this.__bindedOnTimeUpdate);

            this.__bindedOnStreamError = util.bind(this.__onStreamingError, this);
            webmaf.addNativeEventListener("playerStreamingError", this.__bindedOnStreamError);

            this.__bindedOnError = util.bind(this.__onError, this);
            webmaf.addNativeEventListener("playerError", this.__bindedOnError);

            if(device.id.getModel() === "PS4"){
                // two extra listeners been added for accurate skip/play state change events.
                this.__bindedOnPlayerMessage = util.bind(this.__onPlayerMessage, this);
                webmaf.addNativeEventListener("playerMessage", this.__bindedOnPlayerMessage);

                this.__bindedOnSetPlayTime = util.bind(this.__onSetPlayTime, this);
                webmaf.addNativeEventListener("setPlayTime", this.__bindedOnSetPlayTime);
            }
        },
        /**
         * Remove the event listeners for the playback events.
         * @method
         * @overrided
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        _removePlaybackEventListeners: function () {
            webmaf.removeNativeEventListener("playerStatusChange", this.__bindedOnStatusChange);
            webmaf.removeNativeEventListener("contentAvailable", this.__bindedOnLoad);
            webmaf.removeNativeEventListener("getPlaybackTime", this.__bindedOnTimeUpdate);
            webmaf.removeNativeEventListener("playerStreamingError", this.__bindedOnStreamError);
            webmaf.removeNativeEventListener("playerError", this.__bindedOnError);
            
            if(device.id.getModel() === "PS4"){
                webmaf.removeNativeEventListener("playerMessage", this.__bindedOnPlayerMessage);
                webmaf.removeNativeEventListener("setPlayTime", this.__bindedOnSetPlayTime);
            }

            this._prevPausedElapsedTime = 0;
            this._prevElapsedTime = 0;
            this._isSeeking = false;
            vLoading.close();
        },
        /**
         * to update the time when the video is playing
         * @method
         * @overrided
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        __onTimeUpdate: function (data) {
            //ignore the time update received after the stopped
            if (sMedia.isState(sMedia.STOPPED)) {
                return;
            }
            
            var currentTime = data.elapsedTime;

            if (this._enableRunningTimeUnblock && this._isSeeking) {
                if(sMedia.isState(sMedia.PAUSED)) {
                    if (this._prevPausedElapsedTime > 0 && currentTime !== this._prevPausedElapsedTime && currentTime !== (this._prevPausedElapsedTime + 1)){
                        console.warn("Time skipped, paused seek should be done. So unblock seeking process.");

                        this._isSeeking = false;
                        vLoading.close();

                        this._prevPausedElapsedTime = 0;
                    } else {
                        this._prevPausedElapsedTime = currentTime;
                    }

                } else {
                    if (this._prevElapsedTime > 0 && currentTime === (this._prevElapsedTime + 1)){
                        console.warn("Time is running again, seek should be completed. So unblock seeking process.");

                        this._isSeeking = false;
                        vLoading.close();
                    }

                    this._prevElapsedTime = currentTime;
                }
            }

            this.__setCurTime(currentTime);
            sMedia._onTimeUpdate(this.getCurTime());
        },
        /**
         * when the video finish playing the video
         * @method
         * @overrided
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        __onFinished: function () {
            this._isSeeking = false;
            vLoading.close();

            this._super();
        },
        /**
         * Event handler for the setPlayTime callback event of playstation.
         * @method
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        __onSetPlayTime: function (data) {
            if (data && data.status === "ok") {
                console.warn("The playback state changes to seeking.");

                // unblock check for paused -> skip condition.
                if (this._enableRunningTimeUnblock && sMedia.isState(sMedia.PAUSED)) {
                    // let the time check run again and check when to unblock.
                    this.__enableTimeInterval(true);
                }

                this._isSeeking = true;
                vLoading.open();
            }
        },
        /**
         * Event handler for the playerMessage callback event of playstation.
         * @method
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        __onPlayerMessage: function (data) {
            if (data && data.msg_info === "setPlayTimeSuccess") {
                // not to use runningTime workaround if support "setPlayTimeSuccess" API.
                if (this._enableRunningTimeUnblock) {
                    this._enableRunningTimeUnblock = false;
                };
                console.warn("The playback finishes seeking.");

                this._isSeeking = false;
                vLoading.close();
            }
            return;
        },

        /**
         * The error object from the device. It may contain other error attributes depend on the video player or technology used.
         * @typedef {Object} Error
         * @property {String} error the error type
         * @property {String} error_code the error code
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        /**
         * when the video has a video error
         * the error message will be the JSON stringify of error object. {@link ax/ext/device/playstation/PSPlayer.Error}
         * @method
         * @overrided
         * @protected
         * @memberof tvedemo/ext/device/playstation/PSPlayer#
         */
        __onError: function (data) {
            if (data && data.error_info && data.error_info.indexOf("sceAvPlayerJumpToTime") > 0) {
                console.warn("Suppress and ignore sceAvPlayerJumpToTime error as it won't affect the playback.");
                return;
            }

            //stop the getPlayback time
            this.__enableTimeInterval(false);

            //to clear the connection time out when error
            this._clearConnectionTimeout();

            sMedia._onError("onRenderError", util.stringify(data));
            console.error("[XDK playstation] onRenderError : " + data.error + "with error Code" + data.error_code);
        }
    });
});
/**
 * PSPlayer Multi audio track support strategy
 * @class ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy
 * @augments ax/device/interface/MultipleAudioTrackStgy
 */
define("tvedemo/ext/device/playstation/PSPlayerMultiAudioTracksStgy",
    [
        "xdk-base/class",
        "xdk-base/console",
        "xdk-base/device/interface/MultipleAudioTrackStgy",
        "xdk-base/promise",
        "xdk-base/core",
        "xdk-base/exception",
        "xdk-base/util",
        "xdk-ext-device-playstation/webmaf",
        "xdk-base/device/Media"
    ],
    function(
        klass,
        console,
        MultipleAudioTrackStgy,
        promise,
        core,
        exception,
        util,
        webmaf,
        Media
    ) {
        "use strict";
        var PSPlayerMultiAudioTracksStgy,
            sMedia = Media.singleton(),
            audioTracksTimestamp,
            previousAudioChange;

        PSPlayerMultiAudioTracksStgy = klass.create([MultipleAudioTrackStgy], {}, {
            /**
             * player instance
             * @name __player
             * @private
             * @memberof ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy#
             */
            __player: null,

            __setAudioDelayId: 'psAudioTrackDelay',

            /**
             *
             * @method
             * @param {Object} player the player instance that will use this multi audio track strategy
             * @memberof ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy#
             */
            init: function(player) {
                //since it need the player state and do some checking and thus linking them.
                this.__player = player;
            },
            /**
             * Get ids of Audio Tracks
             * @method
             * @protected
             * @returns {Promise.<String[]>} A list of audio track object with id.
             * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} player is stopped
             * @memberof ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy#
             */
            getAudioTracks: function() {
                //stop the loop when the player is changed into stopped state, directly return rejected promise in order to avoid error case
                if (sMedia.isState(sMedia.STOPPED)) {
                    return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Unable to get the audio track when the player is stopped."));
                }

                if (!this.__player._onLoaded) {
                    //since the data is not ready yet, then delay 10s to check again
                    console.info("[XDK playstation] Delay 10s to get the audio track info again");
                    return util.delay(10).then(util.bind(this.getAudioTracks, this));

                }
                var i, audioTracksArr = [],
                    audioTracksObjsArr = [],
                    deferred = promise.defer();

                webmaf.command("getAudioTracks", {}, function(data) {
                    console.info("[XDK playstation]Audio Tracks: " + data);
                    audioTracksTimestamp = Date.now();
                    previousAudioChange = 0;

                    if (data.audioTracks) {
                        audioTracksArr = data.audioTracks.split(",");
                        //convert the audio Tracks from string array into audioTrackObj array
                        for (i = 0; i < audioTracksArr.length; i++) {
                            audioTracksObjsArr.push(audioTracksArr[i]);
                            console.info("[XDK playstation] Available audio track is " + audioTracksArr[i]);
                        }
                    }

                    deferred.resolve(audioTracksObjsArr);
                }, true);

                return deferred.promise;
            },

            /**
             * Set audio track by id
             * @method
             * @protected
             * @param {String} id The id of the audio track
             * @returns {Boolean} Return the result after call in a promise
             * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} player is not ready yet
             * @memberof ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy#
             */
            setAudioTrack: function(id) {
                if (!this.__player._onLoaded) {
                    return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "PSPlayer is not ready yet."));
                }

                var dateNow = Date.now();

                if (previousAudioChange && (dateNow - previousAudioChange < 2000)) {
                    console.warn('[XDK playstation] setAudioTrack was done too soon since last operation');
                    return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Too early since last setAudioTrack operation"));
                }

                if (sMedia._isSeeking === true) {
                    console.warn("[XDK playstation] setAudioTrack can't be done during seek operation");
                    return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "Can't change audio during seek"));
                }

                // Be sure we're playing the content and that it has elapsed at least 5 seconds before we allow the seek trick.
                // Crashes as been noted if this is done too early.
                var useSeekTrick = (dateNow - audioTracksTimestamp > 5000),
                    deferred = promise.defer();
                    
                previousAudioChange = dateNow;

                // This delay is needed, otherwise the browser will randomly get spammed with the triangle key event.

                util.clearDelay(this.__setAudioDelayId);
                util.delay(0.5, this.__setAudioDelayId).then(function() {

                    webmaf.command("setAudioTrack", {
                        audioTrack: id
                    });

                    if (useSeekTrick) {
                        sMedia.skip(-1);
                    }

                    deferred.resolve(true);
                });

                return deferred.promise;
            },
            /**
             * Set audio track by id
             * @method
             * @public
             * @param {Number} id The id of the audio track
             * @param {String} attr The media audio track attribute like {@link ax/device/interface/MultipleAudioTrackStgy#LANGCODE}
             * @returns {Promise.<Mixed>} Return the result of the property
             * @throws {Promise.<module:ax/exception.UNSUPPORTED_OPERATION>} player is not ready yet
             * @memberof ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy#
             */
            getAudioTrackAttr: function(id, attr, defaultValue) {
                if (!this.__player._onLoaded) {
                    return promise.reject(core.createException(exception.UNSUPPORTED_OPERATION, "PSPlayer is not ready yet."));
                }

                switch (attr) {
                    case MultipleAudioTrackStgy.LANGCODE:
                        return promise.resolve(id);
                    default:
                        if (!util.isUndefined(defaultValue)) {
                            return promise.resolve(defaultValue);
                        }
                }

                //return reject if no available value for attr and no default Value
                return promise.reject(core.createException(exception.ILLEGAL_ARGUMENT, "No valid argument and unable to obtain the audio track attritbue."));
            },

            /* Get current audio track id
             * @method getCurrentAudioTrackId
             * @public
             * @returns {Promise.<String>} The id of the audio track
             * @memberof ax/ext/device/playstation/PSPlayerMultiAudioTracksStgy#
             */
            getCurrentAudioTrackId: function() {
                if (!this.__player._onLoaded) {
                    //since the data is not ready yet, then delay 10s to check again
                    console.info("[XDK playstation] Delay 10s to get the audio track info again");
                    return util.delay(10).then(util.bind(this.getAudioTracks, this));

                }
                var deferred = promise.defer(),
                    currentTrackId = null;

                webmaf.command("getAudioTracks", {}, function(data) {
                    console.info("[XDK playstation]Audio Tracks: " + data);
                    if (data.currentAudioTrack) {
                        currentTrackId = data.currentAudioTrack;
                    }

                    deferred.resolve(currentTrackId);

                }, true);

                return deferred.promise;
            }
        });

        return PSPlayerMultiAudioTracksStgy;
    }
);
